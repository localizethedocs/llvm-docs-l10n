# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../GarbageCollection.rst:3
msgid "Garbage Collection with LLVM"
msgstr ""

#: ../../../GarbageCollection.rst:9
msgid "Abstract"
msgstr ""

#: ../../../GarbageCollection.rst:11
msgid ""
"This document covers how to integrate LLVM into a compiler for a language "
"which supports garbage collection.  **Note that LLVM itself does not provide "
"a garbage collector.**  You must provide your own."
msgstr ""

#: ../../../GarbageCollection.rst:16
msgid "Quick Start"
msgstr ""

#: ../../../GarbageCollection.rst:18
msgid ""
"First, you should pick a collector strategy.  LLVM includes a number of "
"built in ones, but you can also implement a loadable plugin with a custom "
"definition. Note that the collector strategy is a description of how LLVM "
"should generate code such that it interacts with your collector and runtime, "
"not a description of the collector itself."
msgstr ""

#: ../../../GarbageCollection.rst:24
msgid ""
"Next, mark your generated functions as using your chosen collector strategy. "
"From c++, you can call:"
msgstr ""

#: ../../../GarbageCollection.rst:32
msgid "This will produce IR like the following fragment:"
msgstr ""

#: ../../../GarbageCollection.rst:39
msgid "When generating LLVM IR for your functions, you will need to:"
msgstr ""

#: ../../../GarbageCollection.rst:41
msgid ""
"Use ``@llvm.gcread`` and/or ``@llvm.gcwrite`` in place of standard load and "
"store instructions.  These intrinsics are used to represent load and store "
"barriers.  If you collector does not require such barriers, you can skip "
"this step."
msgstr ""

#: ../../../GarbageCollection.rst:46
msgid ""
"Use the memory allocation routines provided by your garbage collector's "
"runtime library."
msgstr ""

#: ../../../GarbageCollection.rst:49
msgid ""
"If your collector requires them, generate type maps according to your "
"runtime's binary interface.  LLVM is not involved in the process.  In "
"particular, the LLVM type system is not suitable for conveying such "
"information though the compiler."
msgstr ""

#: ../../../GarbageCollection.rst:54
msgid ""
"Insert any coordination code required for interacting with your collector. "
"Many collectors require running application code to periodically check a "
"flag and conditionally call a runtime function.  This is often referred to "
"as a safepoint poll."
msgstr ""

#: ../../../GarbageCollection.rst:59
msgid ""
"You will need to identify roots (i.e. references to heap objects your "
"collector needs to know about) in your generated IR, so that LLVM can encode "
"them into your final stack maps.  Depending on the collector strategy "
"chosen, this is accomplished by using either the ``@llvm.gcroot`` intrinsics "
"or an ``gc.statepoint`` relocation sequence."
msgstr ""

#: ../../../GarbageCollection.rst:65
msgid ""
"Don't forget to create a root for each intermediate value that is generated "
"when evaluating an expression.  In ``h(f(), g())``, the result of ``f()`` "
"could easily be collected if evaluating ``g()`` triggers a collection."
msgstr ""

#: ../../../GarbageCollection.rst:69
msgid ""
"Finally, you need to link your runtime library with the generated program "
"executable (for a static compiler) or ensure the appropriate symbols are "
"available for the runtime linker (for a JIT compiler)."
msgstr ""

#: ../../../GarbageCollection.rst:75
msgid "Introduction"
msgstr "簡介"

#: ../../../GarbageCollection.rst:78
msgid "What is Garbage Collection?"
msgstr ""

#: ../../../GarbageCollection.rst:80
msgid ""
"Garbage collection is a widely used technique that frees the programmer from "
"having to know the lifetimes of heap objects, making software easier to "
"produce and maintain.  Many programming languages rely on garbage collection "
"for automatic memory management.  There are two primary forms of garbage "
"collection: conservative and accurate."
msgstr ""

#: ../../../GarbageCollection.rst:86
msgid ""
"Conservative garbage collection often does not require any special support "
"from either the language or the compiler: it can handle non-type-safe "
"programming languages (such as C/C++) and does not require any special "
"information from the compiler.  The `Boehm collector <http://www.hpl.hp.com/"
"personal/Hans_Boehm/gc/>`__ is an example of a state-of-the-art conservative "
"collector."
msgstr ""

#: ../../../GarbageCollection.rst:93
msgid ""
"Accurate garbage collection requires the ability to identify all pointers in "
"the program at run-time (which requires that the source-language be type-"
"safe in most cases).  Identifying pointers at run-time requires compiler "
"support to locate all places that hold live pointer variables at run-time, "
"including the :ref:`processor stack and registers <gcroot>`."
msgstr ""

#: ../../../GarbageCollection.rst:99
msgid ""
"Conservative garbage collection is attractive because it does not require "
"any special compiler support, but it does have problems.  In particular, "
"because the conservative garbage collector cannot *know* that a particular "
"word in the machine is a pointer, it cannot move live objects in the heap "
"(preventing the use of compacting and generational GC algorithms) and it can "
"occasionally suffer from memory leaks due to integer values that happen to "
"point to objects in the program.  In addition, some aggressive compiler "
"transformations can break conservative garbage collectors (though these seem "
"rare in practice)."
msgstr ""

#: ../../../GarbageCollection.rst:108
msgid ""
"Accurate garbage collectors do not suffer from any of these problems, but "
"they can suffer from degraded scalar optimization of the program.  In "
"particular, because the runtime must be able to identify and update all "
"pointers active in the program, some optimizations are less effective.  In "
"practice, however, the locality and performance benefits of using aggressive "
"garbage collection techniques dominates any low-level losses."
msgstr ""

#: ../../../GarbageCollection.rst:115
msgid ""
"This document describes the mechanisms and interfaces provided by LLVM to "
"support accurate garbage collection."
msgstr ""

#: ../../../GarbageCollection.rst:119
msgid "Goals and non-goals"
msgstr ""

#: ../../../GarbageCollection.rst:121
msgid ""
"LLVM's intermediate representation provides :ref:`garbage collection "
"intrinsics <gc_intrinsics>` that offer support for a broad class of "
"collector models.  For instance, the intrinsics permit:"
msgstr ""

#: ../../../GarbageCollection.rst:125
msgid "semi-space collectors"
msgstr ""

#: ../../../GarbageCollection.rst:127
msgid "mark-sweep collectors"
msgstr ""

#: ../../../GarbageCollection.rst:129
msgid "generational collectors"
msgstr ""

#: ../../../GarbageCollection.rst:131
msgid "incremental collectors"
msgstr ""

#: ../../../GarbageCollection.rst:133
msgid "concurrent collectors"
msgstr ""

#: ../../../GarbageCollection.rst:135
msgid "cooperative collectors"
msgstr ""

#: ../../../GarbageCollection.rst:137
msgid "reference counting"
msgstr ""

#: ../../../GarbageCollection.rst:139
msgid ""
"We hope that the support built into the LLVM IR is sufficient to support a "
"broad class of garbage collected languages including Scheme, ML, Java, C#, "
"Perl, Python, Lua, Ruby, other scripting languages, and more."
msgstr ""

#: ../../../GarbageCollection.rst:143
msgid ""
"Note that LLVM **does not itself provide a garbage collector** --- this "
"should be part of your language's runtime library.  LLVM provides a "
"framework for describing the garbage collectors requirements to the "
"compiler.  In particular, LLVM provides support for generating stack maps at "
"call sites, polling for a safepoint, and emitting load and store barriers.  "
"You can also extend LLVM - possibly through a loadable :ref:`code generation "
"plugins <plugin>` - to generate code and data structures which conforms to "
"the *binary interface* specified by the *runtime library*.  This is similar "
"to the relationship between LLVM and DWARF debugging info, for example.  The "
"difference primarily lies in the lack of an established standard in the "
"domain of garbage collection --- thus the need for a flexible extension "
"mechanism."
msgstr ""

#: ../../../GarbageCollection.rst:155
msgid ""
"The aspects of the binary interface with which LLVM's GC support is "
"concerned are:"
msgstr ""

#: ../../../GarbageCollection.rst:158
msgid ""
"Creation of GC safepoints within code where collection is allowed to execute "
"safely."
msgstr ""

#: ../../../GarbageCollection.rst:161
msgid ""
"Computation of the stack map.  For each safe point in the code, object "
"references within the stack frame must be identified so that the collector "
"may traverse and perhaps update them."
msgstr ""

#: ../../../GarbageCollection.rst:165
msgid ""
"Write barriers when storing object references to the heap.  These are "
"commonly used to optimize incremental scans in generational collectors."
msgstr ""

#: ../../../GarbageCollection.rst:168
msgid ""
"Emission of read barriers when loading object references.  These are useful "
"for interoperating with concurrent collectors."
msgstr ""

#: ../../../GarbageCollection.rst:171
msgid "There are additional areas that LLVM does not directly address:"
msgstr ""

#: ../../../GarbageCollection.rst:173
msgid "Registration of global roots with the runtime."
msgstr ""

#: ../../../GarbageCollection.rst:175
msgid "Registration of stack map entries with the runtime."
msgstr ""

#: ../../../GarbageCollection.rst:177
msgid ""
"The functions used by the program to allocate memory, trigger a collection, "
"etc."
msgstr ""

#: ../../../GarbageCollection.rst:180
msgid ""
"Computation or compilation of type maps, or registration of them with the "
"runtime.  These are used to crawl the heap for object references."
msgstr ""

#: ../../../GarbageCollection.rst:183
msgid ""
"In general, LLVM's support for GC does not include features which can be "
"adequately addressed with other features of the IR and does not specify a "
"particular binary interface.  On the plus side, this means that you should "
"be able to integrate LLVM with an existing runtime.  On the other hand, it "
"can have the effect of leaving a lot of work for the developer of a novel "
"language.  We try to mitigate this by providing built in collector strategy "
"descriptions that can work with many common collector designs and easy "
"extension points.  If you don't already have a specific binary interface you "
"need to support, we recommend trying to use one of these built in collector "
"strategies."
msgstr ""

#: ../../../GarbageCollection.rst:197
msgid "LLVM IR Features"
msgstr ""

#: ../../../GarbageCollection.rst:199
msgid ""
"This section describes the garbage collection facilities provided by the :"
"doc:`LLVM intermediate representation <LangRef>`.  The exact behavior of "
"these IR features is specified by the selected :ref:`GC strategy description "
"<plugin>`."
msgstr ""

#: ../../../GarbageCollection.rst:205
msgid "Specifying GC code generation: ``gc \"...\"``"
msgstr ""

#: ../../../GarbageCollection.rst:211
msgid ""
"The ``gc`` function attribute is used to specify the desired GC strategy to "
"the compiler.  Its programmatic equivalent is the ``setGC`` method of "
"``Function``."
msgstr ""

#: ../../../GarbageCollection.rst:214
msgid ""
"Setting ``gc \"name\"`` on a function triggers a search for a matching "
"subclass of GCStrategy.  Some collector strategies are built in.  You can "
"add others using either the loadable plugin mechanism, or by patching your "
"copy of LLVM. It is the selected GC strategy which defines the exact nature "
"of the code generated to support GC.  If none is found, the compiler will "
"raise an error."
msgstr ""

#: ../../../GarbageCollection.rst:220
msgid ""
"Specifying the GC style on a per-function basis allows LLVM to link together "
"programs that use different garbage collection algorithms (or none at all)."
msgstr ""

#: ../../../GarbageCollection.rst:226
msgid "Identifying GC roots on the stack"
msgstr ""

#: ../../../GarbageCollection.rst:228
msgid ""
"LLVM currently supports two different mechanisms for describing references "
"in compiled code at safepoints.  ``llvm.gcroot`` is the older mechanism; "
"``gc.statepoint`` has been added more recently.  At the moment, you can "
"choose either implementation (on a per :ref:`GC strategy <plugin>` basis).  "
"Longer term, we will probably either migrate away from ``llvm.gcroot`` "
"entirely, or substantially merge their implementations. Note that most new "
"development work is focused on ``gc.statepoint``."
msgstr ""

#: ../../../GarbageCollection.rst:237
msgid "Using ``gc.statepoint``"
msgstr "使用 ``gc.statepoint``"

#: ../../../GarbageCollection.rst:238
msgid ""
":doc:`This page <Statepoints>` contains detailed documentation for ``gc."
"statepoint``."
msgstr ""

#: ../../../GarbageCollection.rst:242
msgid "Using ``llvm.gcwrite``"
msgstr "使用 ``llvm.gcwrite``"

#: ../../../GarbageCollection.rst:248
msgid ""
"The ``llvm.gcroot`` intrinsic is used to inform LLVM that a stack variable "
"references an object on the heap and is to be tracked for garbage "
"collection. The exact impact on generated code is specified by the "
"Function's selected :ref:`GC strategy <plugin>`.  All calls to ``llvm."
"gcroot`` **must** reside inside the first basic block."
msgstr ""

#: ../../../GarbageCollection.rst:254
msgid ""
"The first argument **must** be a value referring to an alloca instruction or "
"a bitcast of an alloca.  The second contains a pointer to metadata that "
"should be associated with the pointer, and **must** be a constant or global "
"value address.  If your target collector uses tags, use a null pointer for "
"metadata."
msgstr ""

#: ../../../GarbageCollection.rst:259
msgid ""
"A compiler which performs manual SSA construction **must** ensure that SSA "
"values representing GC references are stored in to the alloca passed to the "
"respective ``gcroot`` before every call site and reloaded after every call. "
"A compiler which uses mem2reg to raise imperative code using ``alloca`` into "
"SSA form need only add a call to ``@llvm.gcroot`` for those variables which "
"are pointers into the GC heap."
msgstr ""

#: ../../../GarbageCollection.rst:266
msgid ""
"It is also important to mark intermediate values with ``llvm.gcroot``.  For "
"example, consider ``h(f(), g())``.  Beware leaking the result of ``f()`` in "
"the case that ``g()`` triggers a collection.  Note, that stack variables "
"must be initialized and marked with ``llvm.gcroot`` in function's prologue."
msgstr ""

#: ../../../GarbageCollection.rst:271
msgid ""
"The ``%metadata`` argument can be used to avoid requiring heap objects to "
"have 'isa' pointers or tag bits. [Appel89_, Goldberg91_, Tolmach94_] If "
"specified, its value will be tracked along with the location of the pointer "
"in the stack frame."
msgstr ""

#: ../../../GarbageCollection.rst:276
msgid "Consider the following fragment of Java code:"
msgstr ""

#: ../../../GarbageCollection.rst:285
msgid ""
"This block (which may be located in the middle of a function or in a loop "
"nest), could be compiled to this LLVM code:"
msgstr ""

#: ../../../GarbageCollection.rst:315
msgid "Reading and writing references in the heap"
msgstr ""

#: ../../../GarbageCollection.rst:317
msgid ""
"Some collectors need to be informed when the mutator (the program that needs "
"garbage collection) either reads a pointer from or writes a pointer to a "
"field of a heap object.  The code fragments inserted at these points are "
"called *read barriers* and *write barriers*, respectively.  The amount of "
"code that needs to be executed is usually quite small and not on the "
"critical path of any computation, so the overall performance impact of the "
"barrier is tolerable."
msgstr ""

#: ../../../GarbageCollection.rst:324
msgid ""
"Barriers often require access to the *object pointer* rather than the "
"*derived pointer* (which is a pointer to the field within the object).  "
"Accordingly, these intrinsics take both pointers as separate arguments for "
"completeness.  In this snippet, ``%object`` is the object pointer, and "
"``%derived`` is the derived pointer:"
msgstr ""

#: ../../../GarbageCollection.rst:342
msgid ""
"LLVM does not enforce this relationship between the object and derived "
"pointer (although a particular :ref:`collector strategy <plugin>` might).  "
"However, it would be an unusual collector that violated it."
msgstr ""

#: ../../../GarbageCollection.rst:346
msgid ""
"The use of these intrinsics is naturally optional if the target GC does not "
"require the corresponding barrier.  The GC strategy used with such a "
"collector should replace the intrinsic calls with the corresponding ``load`` "
"or ``store`` instruction if they are used."
msgstr ""

#: ../../../GarbageCollection.rst:351
msgid ""
"One known deficiency with the current design is that the barrier intrinsics "
"do not include the size or alignment of the underlying operation performed.  "
"It is currently assumed that the operation is of pointer size and the "
"alignment is assumed to be the target machine's default alignment."
msgstr ""

#: ../../../GarbageCollection.rst:357
msgid "Write barrier: ``llvm.gcwrite``"
msgstr ""

#: ../../../GarbageCollection.rst:363
msgid ""
"For write barriers, LLVM provides the ``llvm.gcwrite`` intrinsic function.  "
"It has exactly the same semantics as a non-volatile ``store`` to the derived "
"pointer (the third argument).  The exact code generated is specified by the "
"Function's selected :ref:`GC strategy <plugin>`."
msgstr ""

#: ../../../GarbageCollection.rst:368
msgid ""
"Many important algorithms require write barriers, including generational and "
"concurrent collectors.  Additionally, write barriers could be used to "
"implement reference counting."
msgstr ""

#: ../../../GarbageCollection.rst:373
msgid "Read barrier: ``llvm.gcread``"
msgstr ""

#: ../../../GarbageCollection.rst:379
msgid ""
"For read barriers, LLVM provides the ``llvm.gcread`` intrinsic function.  It "
"has exactly the same semantics as a non-volatile ``load`` from the derived "
"pointer (the second argument).  The exact code generated is specified by the "
"Function's selected :ref:`GC strategy <plugin>`."
msgstr ""

#: ../../../GarbageCollection.rst:384
msgid ""
"Read barriers are needed by fewer algorithms than write barriers, and may "
"have a greater performance impact since pointer reads are more frequent than "
"writes."
msgstr ""

#: ../../../GarbageCollection.rst:392
msgid "Built In GC Strategies"
msgstr ""

#: ../../../GarbageCollection.rst:394
msgid ""
"LLVM includes built in support for several varieties of garbage collectors."
msgstr ""

#: ../../../GarbageCollection.rst:397
msgid "The Shadow Stack GC"
msgstr ""

#: ../../../GarbageCollection.rst:399
msgid "To use this collector strategy, mark your functions with:"
msgstr ""

#: ../../../GarbageCollection.rst:405
msgid ""
"Unlike many GC algorithms which rely on a cooperative code generator to "
"compile stack maps, this algorithm carefully maintains a linked list of "
"stack roots [:ref:`Henderson2002 <henderson02>`].  This so-called \"shadow "
"stack\" mirrors the machine stack.  Maintaining this data structure is "
"slower than using a stack map compiled into the executable as constant data, "
"but has a significant portability advantage because it requires no special "
"support from the target code generator, and does not require tricky platform-"
"specific code to crawl the machine stack."
msgstr ""

#: ../../../GarbageCollection.rst:413
msgid "The tradeoff for this simplicity and portability is:"
msgstr ""

#: ../../../GarbageCollection.rst:415
msgid "High overhead per function call."
msgstr ""

#: ../../../GarbageCollection.rst:417
msgid "Not thread-safe."
msgstr ""

#: ../../../GarbageCollection.rst:419
msgid ""
"Still, it's an easy way to get started.  After your compiler and runtime are "
"up and running, writing a :ref:`plugin <plugin>` will allow you to take "
"advantage of :ref:`more advanced GC features <collector-algos>` of LLVM in "
"order to improve performance."
msgstr ""

#: ../../../GarbageCollection.rst:425
msgid ""
"The shadow stack doesn't imply a memory allocation algorithm.  A semispace "
"collector or building atop ``malloc`` are great places to start, and can be "
"implemented with very little code."
msgstr ""

#: ../../../GarbageCollection.rst:429
msgid ""
"When it comes time to collect, however, your runtime needs to traverse the "
"stack roots, and for this it needs to integrate with the shadow stack.  "
"Luckily, doing so is very simple. (This code is heavily commented to help "
"you understand the data structure, but there are only 20 lines of meaningful "
"code.)"
msgstr ""

#: ../../../GarbageCollection.rst:485
msgid "The 'Erlang' and 'Ocaml' GCs"
msgstr ""

#: ../../../GarbageCollection.rst:487
msgid ""
"LLVM ships with two example collectors which leverage the ``gcroot`` "
"mechanisms.  To our knowledge, these are not actually used by any language "
"runtime, but they do provide a reasonable starting point for someone "
"interested in writing an ``gcroot`` compatible GC plugin.  In particular, "
"these are the only in tree examples of how to produce a custom binary stack "
"map format using a ``gcroot`` strategy."
msgstr ""

#: ../../../GarbageCollection.rst:494
msgid ""
"As there names imply, the binary format produced is intended to model that "
"used by the Erlang and OCaml compilers respectively."
msgstr ""

#: ../../../GarbageCollection.rst:500
msgid "The Statepoint Example GC"
msgstr ""

#: ../../../GarbageCollection.rst:506
msgid ""
"This GC provides an example of how one might use the infrastructure provided "
"by ``gc.statepoint``. This example GC is compatible with the :ref:"
"`PlaceSafepoints` and :ref:`RewriteStatepointsForGC` utility passes which "
"simplify ``gc.statepoint`` sequence insertion. If you need to build a custom "
"GC strategy around the ``gc.statepoints`` mechanisms, it is recommended that "
"you use this one as a starting point."
msgstr ""

#: ../../../GarbageCollection.rst:513
msgid ""
"This GC strategy does not support read or write barriers.  As a result, "
"these intrinsics are lowered to normal loads and stores."
msgstr ""

#: ../../../GarbageCollection.rst:516
msgid ""
"The stack map format generated by this GC strategy can be found in the :ref:"
"`stackmap-section` using a format documented :ref:`here <statepoint-stackmap-"
"format>`. This format is intended to be the standard format supported by "
"LLVM going forward."
msgstr ""

#: ../../../GarbageCollection.rst:522
msgid "The CoreCLR GC"
msgstr ""

#: ../../../GarbageCollection.rst:528
msgid ""
"This GC leverages the ``gc.statepoint`` mechanism to support the `CoreCLR "
"<https://github.com/dotnet/coreclr>`__ runtime."
msgstr ""

#: ../../../GarbageCollection.rst:531
msgid ""
"Support for this GC strategy is a work in progress. This strategy will "
"differ from :ref:`statepoint-example GC<statepoint_example_gc>` strategy in "
"certain aspects like:"
msgstr ""

#: ../../../GarbageCollection.rst:536
msgid ""
"Base-pointers of interior pointers are not explicitly tracked and reported."
msgstr ""

#: ../../../GarbageCollection.rst:539
msgid "A different format is used for encoding stack maps."
msgstr ""

#: ../../../GarbageCollection.rst:541
msgid ""
"Safe-point polls are only needed before loop-back edges and before tail-"
"calls (not needed at function-entry)."
msgstr ""

#: ../../../GarbageCollection.rst:545
msgid "Custom GC Strategies"
msgstr ""

#: ../../../GarbageCollection.rst:547
msgid ""
"If none of the built in GC strategy descriptions met your needs above, you "
"will need to define a custom GCStrategy and possibly, a custom LLVM pass to "
"perform lowering.  Your best example of where to start defining a custom "
"GCStrategy would be to look at one of the built in strategies."
msgstr ""

#: ../../../GarbageCollection.rst:552
msgid ""
"You may be able to structure this additional code as a loadable plugin "
"library. Loadable plugins are sufficient if all you need is to enable a "
"different combination of built in functionality, but if you need to provide "
"a custom lowering pass, you will need to build a patched version of LLVM.  "
"If you think you need a patched build, please ask for advice on llvm-dev.  "
"There may be an easy way we can extend the support to make it work for your "
"use case without requiring a custom build."
msgstr ""

#: ../../../GarbageCollection.rst:561
msgid "Collector Requirements"
msgstr ""

#: ../../../GarbageCollection.rst:563
msgid ""
"You should be able to leverage any existing collector library that includes "
"the following elements:"
msgstr ""

#: ../../../GarbageCollection.rst:565
msgid ""
"A memory allocator which exposes an allocation function your compiled code "
"can call."
msgstr ""

#: ../../../GarbageCollection.rst:568
msgid ""
"A binary format for the stack map.  A stack map describes the location of "
"references at a safepoint and is used by precise collectors to identify "
"references within a stack frame on the machine stack. Note that collectors "
"which conservatively scan the stack don't require such a structure."
msgstr ""

#: ../../../GarbageCollection.rst:573
msgid ""
"A stack crawler to discover functions on the call stack, and enumerate the "
"references listed in the stack map for each call site."
msgstr ""

#: ../../../GarbageCollection.rst:576
msgid ""
"A mechanism for identifying references in global locations (e.g. global "
"variables)."
msgstr ""

#: ../../../GarbageCollection.rst:579
msgid ""
"If you collector requires them, an LLVM IR implementation of your collectors "
"load and store barriers.  Note that since many collectors don't require "
"barriers at all, LLVM defaults to lowering such barriers to normal loads and "
"stores unless you arrange otherwise."
msgstr ""

#: ../../../GarbageCollection.rst:586
msgid "Implementing a collector plugin"
msgstr ""

#: ../../../GarbageCollection.rst:588
msgid ""
"User code specifies which GC code generation to use with the ``gc`` function "
"attribute or, equivalently, with the ``setGC`` method of ``Function``."
msgstr ""

#: ../../../GarbageCollection.rst:591
msgid ""
"To implement a GC plugin, it is necessary to subclass ``llvm::GCStrategy``, "
"which can be accomplished in a few lines of boilerplate code.  LLVM's "
"infrastructure provides access to several important algorithms.  For an "
"uncontroversial collector, all that remains may be to compile LLVM's "
"computed stack map to assembly code (using the binary representation "
"expected by the runtime library).  This can be accomplished in about 100 "
"lines of code."
msgstr ""

#: ../../../GarbageCollection.rst:598
msgid ""
"This is not the appropriate place to implement a garbage collected heap or a "
"garbage collector itself.  That code should exist in the language's runtime "
"library.  The compiler plugin is responsible for generating code which "
"conforms to the binary interface defined by library, most essentially the :"
"ref:`stack map <stack-map>`."
msgstr ""

#: ../../../GarbageCollection.rst:604
msgid "To subclass ``llvm::GCStrategy`` and register it with the compiler:"
msgstr ""

#: ../../../GarbageCollection.rst:626
msgid "This boilerplate collector does nothing.  More specifically:"
msgstr ""

#: ../../../GarbageCollection.rst:628
msgid ""
"``llvm.gcread`` calls are replaced with the corresponding ``load`` "
"instruction."
msgstr ""

#: ../../../GarbageCollection.rst:631
msgid ""
"``llvm.gcwrite`` calls are replaced with the corresponding ``store`` "
"instruction."
msgstr ""

#: ../../../GarbageCollection.rst:634
msgid "No safe points are added to the code."
msgstr ""

#: ../../../GarbageCollection.rst:636
msgid "The stack map is not compiled into the executable."
msgstr ""

#: ../../../GarbageCollection.rst:638
msgid ""
"Using the LLVM makefiles, this code can be compiled as a plugin using a "
"simple makefile:"
msgstr ""

#: ../../../GarbageCollection.rst:651
msgid ""
"Once the plugin is compiled, code using it may be compiled using ``llc -"
"load=MyGC.so`` (though MyGC.so may have some other platform-specific "
"extension):"
msgstr ""

#: ../../../GarbageCollection.rst:664
msgid ""
"It is also possible to statically link the collector plugin into tools, such "
"as a language-specific compiler front-end."
msgstr ""

#: ../../../GarbageCollection.rst:670
msgid "Overview of available features"
msgstr ""

#: ../../../GarbageCollection.rst:672
msgid ""
"``GCStrategy`` provides a range of features through which a plugin may do "
"useful work.  Some of these are callbacks, some are algorithms that can be "
"enabled, disabled, or customized.  This matrix summarizes the supported (and "
"planned) features and correlates them with the collection techniques which "
"typically require them."
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "Algorithm"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "Done"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "Shadow stack"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "refcount"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "mark- sweep"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "copying"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "incremental"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "threaded"
msgstr ""

#: ../../../GarbageCollection.rst:685
msgid "concurrent"
msgstr ""

#: ../../../GarbageCollection.rst:688
msgid "stack map"
msgstr ""

#: ../../../GarbageCollection.rst:688 ../../../GarbageCollection.rst:690
#: ../../../GarbageCollection.rst:696 ../../../GarbageCollection.rst:699
#: ../../../GarbageCollection.rst:701 ../../../GarbageCollection.rst:703
#: ../../../GarbageCollection.rst:708 ../../../GarbageCollection.rst:711
#: ../../../GarbageCollection.rst:717 ../../../GarbageCollection.rst:726
msgid "|v|"
msgstr ""

#: ../../../GarbageCollection.rst:688 ../../../GarbageCollection.rst:690
#: ../../../GarbageCollection.rst:699 ../../../GarbageCollection.rst:701
#: ../../../GarbageCollection.rst:703 ../../../GarbageCollection.rst:708
#: ../../../GarbageCollection.rst:711 ../../../GarbageCollection.rst:717
#: ../../../GarbageCollection.rst:726
msgid "|x|"
msgstr ""

#: ../../../GarbageCollection.rst:690
msgid "initialize roots"
msgstr ""

#: ../../../GarbageCollection.rst:693
msgid "derived pointers"
msgstr ""

#: ../../../GarbageCollection.rst:693 ../../../GarbageCollection.rst:714
#: ../../../GarbageCollection.rst:720 ../../../GarbageCollection.rst:728
#: ../../../GarbageCollection.rst:730 ../../../GarbageCollection.rst:732
#: ../../../GarbageCollection.rst:735
msgid "NO"
msgstr ""

#: ../../../GarbageCollection.rst:693
msgid "**N**\\*"
msgstr ""

#: ../../../GarbageCollection.rst:696
msgid "**custom lowering**"
msgstr ""

#: ../../../GarbageCollection.rst:699
msgid "*gcroot*"
msgstr ""

#: ../../../GarbageCollection.rst:701
msgid "*gcwrite*"
msgstr ""

#: ../../../GarbageCollection.rst:703
msgid "*gcread*"
msgstr ""

#: ../../../GarbageCollection.rst:705
msgid "**safe points**"
msgstr ""

#: ../../../GarbageCollection.rst:708
msgid "*in calls*"
msgstr ""

#: ../../../GarbageCollection.rst:711
msgid "*before calls*"
msgstr ""

#: ../../../GarbageCollection.rst:714
msgid "*for loops*"
msgstr ""

#: ../../../GarbageCollection.rst:714 ../../../GarbageCollection.rst:720
msgid "**N**"
msgstr ""

#: ../../../GarbageCollection.rst:717
msgid "*before escape*"
msgstr ""

#: ../../../GarbageCollection.rst:720
msgid "emit code at safe points"
msgstr ""

#: ../../../GarbageCollection.rst:724
msgid "**output**"
msgstr ""

#: ../../../GarbageCollection.rst:726
msgid "*assembly*"
msgstr ""

#: ../../../GarbageCollection.rst:728
msgid "*JIT*"
msgstr ""

#: ../../../GarbageCollection.rst:728 ../../../GarbageCollection.rst:730
#: ../../../GarbageCollection.rst:732 ../../../GarbageCollection.rst:735
msgid "**?**"
msgstr ""

#: ../../../GarbageCollection.rst:730
msgid "*obj*"
msgstr ""

#: ../../../GarbageCollection.rst:732
msgid "live analysis"
msgstr ""

#: ../../../GarbageCollection.rst:735
msgid "register map"
msgstr ""

#: ../../../GarbageCollection.rst:738
msgid "\\* Derived pointers only pose a hasard to copying collections."
msgstr ""

#: ../../../GarbageCollection.rst:740
msgid "**?** denotes a feature which could be utilized if available."
msgstr ""

#: ../../../GarbageCollection.rst:743
msgid "To be clear, the collection techniques above are defined as:"
msgstr ""

#: ../../../GarbageCollection.rst:746
msgid "Shadow Stack"
msgstr ""

#: ../../../GarbageCollection.rst:746
msgid "The mutator carefully maintains a linked list of stack roots."
msgstr ""

#: ../../../GarbageCollection.rst:750
msgid "Reference Counting"
msgstr ""

#: ../../../GarbageCollection.rst:749
msgid ""
"The mutator maintains a reference count for each object and frees an object "
"when its count falls to zero."
msgstr ""

#: ../../../GarbageCollection.rst:754
msgid "Mark-Sweep"
msgstr ""

#: ../../../GarbageCollection.rst:753
msgid ""
"When the heap is exhausted, the collector marks reachable objects starting "
"from the roots, then deallocates unreachable objects in a sweep phase."
msgstr ""

#: ../../../GarbageCollection.rst:760
msgid "Copying"
msgstr ""

#: ../../../GarbageCollection.rst:757
msgid ""
"As reachability analysis proceeds, the collector copies objects from one "
"heap area to another, compacting them in the process.  Copying collectors "
"enable highly efficient \"bump pointer\" allocation and can improve locality "
"of reference."
msgstr ""

#: ../../../GarbageCollection.rst:765
msgid "Incremental"
msgstr ""

#: ../../../GarbageCollection.rst:763
msgid ""
"(Including generational collectors.) Incremental collectors generally have "
"all the properties of a copying collector (regardless of whether the mature "
"heap is compacting), but bring the added complexity of requiring write "
"barriers."
msgstr ""

#: ../../../GarbageCollection.rst:772
msgid "Threaded"
msgstr ""

#: ../../../GarbageCollection.rst:768
msgid ""
"Denotes a multithreaded mutator; the collector must still stop the mutator "
"(\"stop the world\") before beginning reachability analysis.  Stopping a "
"multithreaded mutator is a complicated problem.  It generally requires "
"highly platform-specific code in the runtime, and the production of "
"carefully designed machine code at safe points."
msgstr ""

#: ../../../GarbageCollection.rst:780
msgid "Concurrent"
msgstr ""

#: ../../../GarbageCollection.rst:775
msgid ""
"In this technique, the mutator and the collector run concurrently, with the "
"goal of eliminating pause times.  In a *cooperative* collector, the mutator "
"further aids with collection should a pause occur, allowing collection to "
"take advantage of multiprocessor hosts.  The \"stop the world\" problem of "
"threaded collectors is generally still present to a limited extent.  "
"Sophisticated marking algorithms are necessary.  Read barriers may be "
"necessary."
msgstr ""

#: ../../../GarbageCollection.rst:782
msgid ""
"As the matrix indicates, LLVM's garbage collection infrastructure is already "
"suitable for a wide variety of collectors, but does not currently extend to "
"multithreaded programs.  This will be added in the future as there is "
"interest."
msgstr ""

#: ../../../GarbageCollection.rst:790
msgid "Computing stack maps"
msgstr ""

#: ../../../GarbageCollection.rst:792
msgid ""
"LLVM automatically computes a stack map.  One of the most important features "
"of a ``GCStrategy`` is to compile this information into the executable in "
"the binary representation expected by the runtime library."
msgstr ""

#: ../../../GarbageCollection.rst:796
msgid ""
"The stack map consists of the location and identity of each GC root in the "
"each function in the module.  For each root:"
msgstr ""

#: ../../../GarbageCollection.rst:799
msgid "``RootNum``: The index of the root."
msgstr ""

#: ../../../GarbageCollection.rst:801
msgid ""
"``StackOffset``: The offset of the object relative to the frame pointer."
msgstr ""

#: ../../../GarbageCollection.rst:803
msgid ""
"``RootMetadata``: The value passed as the ``%metadata`` parameter to the "
"``@llvm.gcroot`` intrinsic."
msgstr ""

#: ../../../GarbageCollection.rst:806
msgid "Also, for the function as a whole:"
msgstr ""

#: ../../../GarbageCollection.rst:809
msgid ""
"``getFrameSize()``: The overall size of the function's initial stack frame,"
msgstr ""

#: ../../../GarbageCollection.rst:809
msgid "not accounting for any dynamic allocation."
msgstr ""

#: ../../../GarbageCollection.rst:811
msgid "``roots_size()``: The count of roots in the function."
msgstr ""

#: ../../../GarbageCollection.rst:813
msgid ""
"To access the stack map, use ``GCFunctionMetadata::roots_begin()`` and -"
"``end()`` from the :ref:`GCMetadataPrinter <assembly>`:"
msgstr ""

#: ../../../GarbageCollection.rst:832
msgid ""
"If the ``llvm.gcroot`` intrinsic is eliminated before code generation by a "
"custom lowering pass, LLVM will compute an empty stack map.  This may be "
"useful for collector plugins which implement reference counting or a shadow "
"stack."
msgstr ""

#: ../../../GarbageCollection.rst:839
msgid "Initializing roots to null: ``InitRoots``"
msgstr ""

#: ../../../GarbageCollection.rst:847
msgid ""
"When set, LLVM will automatically initialize each root to ``null`` upon "
"entry to the function.  This prevents the GC's sweep phase from visiting "
"uninitialized pointers, which will almost certainly cause it to crash.  This "
"initialization occurs before custom lowering, so the two may be used "
"together."
msgstr ""

#: ../../../GarbageCollection.rst:852
msgid ""
"Since LLVM does not yet compute liveness information, there is no means of "
"distinguishing an uninitialized stack root from an initialized one.  "
"Therefore, this feature should be used by all GC plugins.  It is enabled by "
"default."
msgstr ""

#: ../../../GarbageCollection.rst:857
msgid ""
"Custom lowering of intrinsics: ``CustomRoots``, ``CustomReadBarriers``, and "
"``CustomWriteBarriers``"
msgstr ""

#: ../../../GarbageCollection.rst:859
msgid ""
"For GCs which use barriers or unusual treatment of stack roots, these flags "
"allow the collector to perform arbitrary transformations of the LLVM IR:"
msgstr ""

#: ../../../GarbageCollection.rst:874
msgid ""
"If any of these flags are set, LLVM suppresses its default lowering for the "
"corresponding intrinsics.  Instead, you must provide a custom Pass which "
"lowers the intrinsics as desired.  If you have opted in to custom lowering "
"of a particular intrinsic your pass **must** eliminate all instances of the "
"corresponding intrinsic in functions which opt in to your GC.  The best "
"example of such a pass is the ShadowStackGC and it's ShadowStackGCLowering "
"pass."
msgstr ""

#: ../../../GarbageCollection.rst:882
msgid ""
"There is currently no way to register such a custom lowering pass without "
"building a custom copy of LLVM."
msgstr ""

#: ../../../GarbageCollection.rst:888
msgid "Generating safe points: ``NeededSafePoints``"
msgstr ""

#: ../../../GarbageCollection.rst:890
msgid "LLVM can compute four kinds of safe points:"
msgstr ""

#: ../../../GarbageCollection.rst:905
msgid ""
"A collector can request any combination of the four by setting the "
"``NeededSafePoints`` mask:"
msgstr ""

#: ../../../GarbageCollection.rst:917
msgid "It can then use the following routines to access safe points."
msgstr ""

#: ../../../GarbageCollection.rst:932
msgid ""
"Almost every collector requires ``PostCall`` safe points, since these "
"correspond to the moments when the function is suspended during a call to a "
"subroutine."
msgstr ""

#: ../../../GarbageCollection.rst:935
msgid ""
"Threaded programs generally require ``Loop`` safe points to guarantee that "
"the application will reach a safe point within a bounded amount of time, "
"even if it is executing a long-running loop which contains no function calls."
msgstr ""

#: ../../../GarbageCollection.rst:939
msgid ""
"Threaded collectors may also require ``Return`` and ``PreCall`` safe points "
"to implement \"stop the world\" techniques using self-modifying code, where "
"it is important that the program not exit the function without reaching a "
"safe point (because only the topmost function has been patched)."
msgstr ""

#: ../../../GarbageCollection.rst:947
msgid "Emitting assembly code: ``GCMetadataPrinter``"
msgstr ""

#: ../../../GarbageCollection.rst:949
msgid ""
"LLVM allows a plugin to print arbitrary assembly code before and after the "
"rest of a module's assembly code.  At the end of the module, the GC can "
"compile the LLVM stack map into assembly code. (At the beginning, this "
"information is not yet computed.)"
msgstr ""

#: ../../../GarbageCollection.rst:954
msgid ""
"Since AsmWriter and CodeGen are separate components of LLVM, a separate "
"abstract base class and registry is provided for printing assembly code, the "
"``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``.  The AsmWriter will "
"look for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:"
msgstr ""

#: ../../../GarbageCollection.rst:965
msgid "This separation allows JIT-only clients to be smaller."
msgstr ""

#: ../../../GarbageCollection.rst:967
msgid ""
"Note that LLVM does not currently have analogous APIs to support code "
"generation in the JIT, nor using the object writers."
msgstr ""

#: ../../../GarbageCollection.rst:991
msgid ""
"The collector should use ``AsmPrinter`` to print portable assembly code.  "
"The collector itself contains the stack map for the entire module, and may "
"access the ``GCFunctionInfo`` using its own ``begin()`` and ``end()`` "
"methods.  Here's a realistic example:"
msgstr ""

#: ../../../GarbageCollection.rst:1077
msgid "References"
msgstr ""

#: ../../../GarbageCollection.rst:1081
msgid ""
"[Appel89] Runtime Tags Aren't Necessary. Andrew W. Appel. Lisp and Symbolic "
"Computation 19(7):703-705, July 1989."
msgstr ""

#: ../../../GarbageCollection.rst:1086
msgid ""
"[Goldberg91] Tag-free garbage collection for strongly typed programming "
"languages. Benjamin Goldberg. ACM SIGPLAN PLDI'91."
msgstr ""

#: ../../../GarbageCollection.rst:1091
msgid ""
"[Tolmach94] Tag-free garbage collection using explicit type parameters. "
"Andrew Tolmach. Proceedings of the 1994 ACM conference on LISP and "
"functional programming."
msgstr ""

#: ../../../GarbageCollection.rst:1097
msgid ""
"[Henderson2002] `Accurate Garbage Collection in an Uncooperative Environment "
"<http://citeseer.ist.psu.edu/henderson02accurate.html>`__"
msgstr ""
