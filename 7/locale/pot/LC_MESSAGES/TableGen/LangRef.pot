# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TableGen/LangRef.rst:3
msgid "TableGen Language Reference"
msgstr ""

#: ../../../TableGen/LangRef.rst:9
msgid ""
"This document is extremely rough. If you find something lacking, please fix "
"it, file a documentation bug, or ask about it on llvm-dev."
msgstr ""

#: ../../../TableGen/LangRef.rst:13
msgid "Introduction"
msgstr ""

#: ../../../TableGen/LangRef.rst:15
msgid ""
"This document is meant to be a normative spec about the TableGen language in "
"and of itself (i.e. how to understand a given construct in terms of how it "
"affects the final set of records represented by the TableGen file). If you "
"are unsure if this document is really what you are looking for, please read "
"the :doc:`introduction to TableGen <index>` first."
msgstr ""

#: ../../../TableGen/LangRef.rst:22
msgid "Notation"
msgstr ""

#: ../../../TableGen/LangRef.rst:24
msgid ""
"The lexical and syntax notation used here is intended to imitate "
"`Python's`_. In particular, for lexical definitions, the productions operate "
"at the character level and there is no implied whitespace between elements. "
"The syntax definitions operate at the token level, so there is implied "
"whitespace between tokens."
msgstr ""

#: ../../../TableGen/LangRef.rst:33
msgid "Lexical Analysis"
msgstr ""

#: ../../../TableGen/LangRef.rst:35
msgid ""
"TableGen supports BCPL (``// ...``) and nestable C-style (``/* ... */``) "
"comments."
msgstr ""

#: ../../../TableGen/LangRef.rst:38
msgid "The following is a listing of the basic punctuation tokens::"
msgstr ""

#: ../../../TableGen/LangRef.rst:42
msgid "Numeric literals take one of the following forms:"
msgstr ""

#: ../../../TableGen/LangRef.rst:54
msgid ""
"One aspect to note is that the :token:`DecimalInteger` token *includes* the "
"``+`` or ``-``, as opposed to having ``+`` and ``-`` be unary operators as "
"most languages do."
msgstr ""

#: ../../../TableGen/LangRef.rst:58
msgid ""
"Also note that :token:`BinInteger` creates a value of type ``bits<n>`` "
"(where ``n`` is the number of bits).  This will implicitly convert to "
"integers when needed."
msgstr ""

#: ../../../TableGen/LangRef.rst:62
msgid "TableGen has identifier-like tokens:"
msgstr ""

#: ../../../TableGen/LangRef.rst:69
msgid ""
"Note that unlike most languages, TableGen allows :token:`TokIdentifier` to "
"begin with a number. In case of ambiguity, a token will be interpreted as a "
"numeric literal rather than an identifier."
msgstr ""

#: ../../../TableGen/LangRef.rst:73
msgid "TableGen also has two string-like literals:"
msgstr ""

#: ../../../TableGen/LangRef.rst:79
msgid ""
":token:`TokCodeFragment` is essentially a multiline string literal delimited "
"by ``[{`` and ``}]``."
msgstr ""

#: ../../../TableGen/LangRef.rst:83
msgid "The current implementation accepts the following C-like escapes::"
msgstr ""

#: ../../../TableGen/LangRef.rst:87
msgid "TableGen also has the following keywords::"
msgstr ""

#: ../../../TableGen/LangRef.rst:93
msgid ""
"TableGen also has \"bang operators\" which have a wide variety of meanings:"
msgstr ""

#: ../../../TableGen/LangRef.rst:107
msgid "Syntax"
msgstr ""

#: ../../../TableGen/LangRef.rst:109
msgid ""
"TableGen has an ``include`` mechanism. It does not play a role in the syntax "
"per se, since it is lexically replaced with the contents of the included "
"file."
msgstr ""

#: ../../../TableGen/LangRef.rst:116
msgid "TableGen's top-level production consists of \"objects\"."
msgstr ""

#: ../../../TableGen/LangRef.rst:124
msgid "``class``\\es"
msgstr ""

#: ../../../TableGen/LangRef.rst:130
msgid ""
"A ``class`` declaration creates a record which other records can inherit "
"from. A class can be parametrized by a list of \"template arguments\", whose "
"values can be used in the class body."
msgstr ""

#: ../../../TableGen/LangRef.rst:134
msgid ""
"A given class can only be defined once. A ``class`` declaration is "
"considered to define the class if any of the following is true:"
msgstr ""

#: ../../../TableGen/LangRef.rst:139
msgid "The :token:`TemplateArgList` is present."
msgstr ""

#: ../../../TableGen/LangRef.rst:140
msgid ""
"The :token:`Body` in the :token:`ObjectBody` is present and is not empty."
msgstr ""

#: ../../../TableGen/LangRef.rst:141
msgid "The :token:`BaseClassList` in the :token:`ObjectBody` is present."
msgstr ""

#: ../../../TableGen/LangRef.rst:143
msgid ""
"You can declare an empty class by giving and empty :token:`TemplateArgList` "
"and an empty :token:`ObjectBody`. This can serve as a restricted form of "
"forward declaration: note that records deriving from the forward-declared "
"class will inherit no fields from it since the record expansion is done when "
"the record is parsed."
msgstr ""

#: ../../../TableGen/LangRef.rst:149
msgid ""
"Every class has an implicit template argument called ``NAME``, which is set "
"to the name of the instantiating ``def`` or ``defm``. The result is "
"undefined if the class is instantiated by an anonymous record."
msgstr ""

#: ../../../TableGen/LangRef.rst:154
msgid "Declarations"
msgstr ""

#: ../../../TableGen/LangRef.rst:158
msgid ""
"The declaration syntax is pretty much what you would expect as a C++ "
"programmer."
msgstr ""

#: ../../../TableGen/LangRef.rst:164
msgid "It assigns the value to the identifier."
msgstr ""

#: ../../../TableGen/LangRef.rst:167
msgid "Types"
msgstr ""

#: ../../../TableGen/LangRef.rst:176
msgid ""
"Both ``string`` and ``code`` correspond to the string type; the difference "
"is purely to indicate programmer intention."
msgstr ""

#: ../../../TableGen/LangRef.rst:179
msgid ""
"The :token:`ClassID` must identify a class that has been previously declared "
"or defined."
msgstr ""

#: ../../../TableGen/LangRef.rst:183
msgid "Values"
msgstr ""

#: ../../../TableGen/LangRef.rst:195
msgid ""
"The peculiar last form of :token:`RangePiece` is due to the fact that the "
"\"``-``\" is included in the :token:`TokInteger`, hence ``1-5`` gets lexed "
"as two consecutive :token:`TokInteger`'s, with values ``1`` and ``-5``, "
"instead of \"1\", \"-\", and \"5\". The :token:`RangeList` can be thought of "
"as specifying \"list slice\" in some contexts."
msgstr ""

#: ../../../TableGen/LangRef.rst:203
msgid ":token:`SimpleValue` has a number of forms:"
msgstr ""

#: ../../../TableGen/LangRef.rst:209
msgid ""
"The value will be the variable referenced by the identifier. It can be one "
"of:"
msgstr ""

#: ../../../TableGen/LangRef.rst:215
msgid "name of a ``def``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:225
msgid "value local to a ``def``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:232
msgid "Values defined in superclasses can be accessed the same way."
msgstr ""

#: ../../../TableGen/LangRef.rst:234
msgid "a template arg of a ``class``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:240
msgid "value local to a ``class``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:247
msgid "a template arg to a ``multiclass``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:253
msgid "the iteration variable of a ``foreach``, such as the use of ``i`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:258
msgid "a variable defined by ``defset``"
msgstr ""

#: ../../../TableGen/LangRef.rst:260
msgid ""
"the implicit template argument ``NAME`` in a ``class`` or ``multiclass``"
msgstr ""

#: ../../../TableGen/LangRef.rst:265
msgid "This represents the numeric value of the integer."
msgstr ""

#: ../../../TableGen/LangRef.rst:270
msgid ""
"Multiple adjacent string literals are concatenated like in C/C++. The value "
"is the concatenation of the strings."
msgstr ""

#: ../../../TableGen/LangRef.rst:276
msgid "The value is the string value of the code fragment."
msgstr ""

#: ../../../TableGen/LangRef.rst:281
msgid "``?`` represents an \"unset\" initializer."
msgstr ""

#: ../../../TableGen/LangRef.rst:288
msgid ""
"This represents a sequence of bits, as would be used to initialize a "
"``bits<n>`` field (where ``n`` is the number of bits)."
msgstr ""

#: ../../../TableGen/LangRef.rst:294
msgid ""
"This generates a new anonymous record definition (as would be created by an "
"unnamed ``def`` inheriting from the given class with the given template "
"arguments) and the value is the value of that record definition."
msgstr ""

#: ../../../TableGen/LangRef.rst:301
msgid ""
"A list initializer. The optional :token:`Type` can be used to indicate a "
"specific element type, otherwise the element type will be deduced from the "
"given values."
msgstr ""

#: ../../../TableGen/LangRef.rst:314
msgid "The initial :token:`DagArg` is called the \"operator\" of the dag."
msgstr ""

#: ../../../TableGen/LangRef.rst:320
msgid "Bodies"
msgstr ""

#: ../../../TableGen/LangRef.rst:329
msgid ""
"The version with the :token:`MultiClassID` is only valid in the :token:"
"`BaseClassList` of a ``defm``. The :token:`MultiClassID` should be the name "
"of a ``multiclass``."
msgstr ""

#: ../../../TableGen/LangRef.rst:335
msgid ""
"It is after parsing the base class list that the \"let stack\" is applied."
msgstr ""

#: ../../../TableGen/LangRef.rst:343
msgid "The ``let`` form allows overriding the value of an inherited field."
msgstr ""

#: ../../../TableGen/LangRef.rst:346
msgid "``def``"
msgstr ""

#: ../../../TableGen/LangRef.rst:351
msgid ""
"Defines a record whose name is given by the optional :token:`Value`. The "
"value is parsed in a special mode where global identifiers (records and "
"variables defined by ``defset``) are not recognized, and all unrecognized "
"identifiers are interpreted as strings."
msgstr ""

#: ../../../TableGen/LangRef.rst:356
msgid ""
"If no name is given, the record is anonymous. The final name of anonymous "
"records is undefined, but globally unique."
msgstr ""

#: ../../../TableGen/LangRef.rst:359
msgid ""
"Special handling occurs if this ``def`` appears inside a ``multiclass`` or a "
"``foreach``."
msgstr ""

#: ../../../TableGen/LangRef.rst:362
msgid ""
"When a non-anonymous record is defined in a multiclass and the given name "
"does not contain a reference to the implicit template argument ``NAME``, "
"such a reference will automatically be prepended. That is, the following are "
"equivalent inside a multiclass::"
msgstr ""

#: ../../../TableGen/LangRef.rst:371
msgid "``defm``"
msgstr ""

#: ../../../TableGen/LangRef.rst:376
msgid ""
"The :token:`BaseClassList` is a list of at least one ``multiclass`` and any "
"number of ``class``'s. The ``multiclass``'s must occur before any "
"``class``'s."
msgstr ""

#: ../../../TableGen/LangRef.rst:379
msgid ""
"Instantiates all records defined in all given ``multiclass``'s and adds the "
"given ``class``'s as superclasses."
msgstr ""

#: ../../../TableGen/LangRef.rst:382
msgid ""
"The name is parsed in the same special mode used by ``def``. If the name is "
"missing, a globally unique string is used instead (but instantiated records "
"are not considered to be anonymous, unless they were originally defined by "
"an anonymous ``def``) That is, the following have different semantics::"
msgstr ""

#: ../../../TableGen/LangRef.rst:390
msgid ""
"When it occurs inside a multiclass, the second variant is equivalent to "
"``defm NAME : ...``. More generally, when ``defm`` occurs in a multiclass "
"and its name does not contain a reference to the implicit template argument "
"``NAME``, such a reference will automatically be prepended. That is, the "
"following are equivalent inside a multiclass::"
msgstr ""

#: ../../../TableGen/LangRef.rst:400
msgid "``defset``"
msgstr ""

#: ../../../TableGen/LangRef.rst:404
msgid ""
"All records defined inside the braces via ``def`` and ``defm`` are collected "
"in a globally accessible list of the given name (in addition to being added "
"to the global collection of records as usual). Anonymous records created "
"inside initializier expressions using the ``Class<args...>`` syntax are "
"never collected in a defset."
msgstr ""

#: ../../../TableGen/LangRef.rst:410
msgid ""
"The given type must be ``list<A>``, where ``A`` is some class. It is an "
"error to define a record (via ``def`` or ``defm``) inside the braces which "
"doesn't derive from ``A``."
msgstr ""

#: ../../../TableGen/LangRef.rst:415
msgid "``foreach``"
msgstr ""

#: ../../../TableGen/LangRef.rst:422
msgid ""
"The value assigned to the variable in the declaration is iterated over and "
"the object or object list is reevaluated with the variable set at each "
"iterated value."
msgstr ""

#: ../../../TableGen/LangRef.rst:426
msgid ""
"Note that the productions involving RangeList and RangePiece have precedence "
"over the more generic value parsing based on the first token."
msgstr ""

#: ../../../TableGen/LangRef.rst:430
msgid "Top-Level ``let``"
msgstr ""

#: ../../../TableGen/LangRef.rst:438
msgid ""
"This is effectively equivalent to ``let`` inside the body of a record except "
"that it applies to multiple records at a time. The bindings are applied at "
"the end of parsing the base classes of a record."
msgstr ""

#: ../../../TableGen/LangRef.rst:443
msgid "``multiclass``"
msgstr ""
