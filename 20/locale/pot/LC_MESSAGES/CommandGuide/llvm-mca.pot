# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CommandGuide/llvm-mca.rst:2
msgid "llvm-mca - LLVM Machine Code Analyzer"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:7
msgid "SYNOPSIS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:9
msgid ":program:`llvm-mca` [*options*] [input]"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:12
msgid "DESCRIPTION"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:14
msgid ""
":program:`llvm-mca` is a performance analysis tool that uses information "
"available in LLVM (e.g. scheduling models) to statically measure the "
"performance of machine code in a specific CPU."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:18
msgid ""
"Performance is measured in terms of throughput as well as processor resource "
"consumption. The tool currently works for processors with a backend for "
"which there is a scheduling model available in LLVM."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:22
msgid ""
"The main goal of this tool is not just to predict the performance of the "
"code when run on the target, but also help with diagnosing potential "
"performance issues."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:26
msgid ""
"Given an assembly code sequence, :program:`llvm-mca` estimates the "
"Instructions Per Cycle (IPC), as well as hardware resource pressure. The "
"analysis and reporting style were inspired by the IACA tool from Intel."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:30
msgid ""
"For example, you can compile code with clang, output assembly, and pipe it "
"directly into :program:`llvm-mca` for analysis:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:37
msgid "Or for Intel syntax:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:43
msgid ""
"(:program:`llvm-mca` detects Intel syntax by the presence of an `."
"intel_syntax` directive at the beginning of the input.  By default its "
"output syntax matches that of its input.)"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:47
msgid ""
"Scheduling models are not just used to compute instruction latencies and "
"throughput, but also to understand what processor resources are available "
"and how to simulate them."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:51
msgid ""
"By design, the quality of the analysis conducted by :program:`llvm-mca` is "
"inevitably affected by the quality of the scheduling models in LLVM."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:54
msgid ""
"If you see that the performance report is not accurate for a processor, "
"please `file a bug <https://github.com/llvm/llvm-project/issues>`_ against "
"the appropriate backend."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:59
msgid "OPTIONS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:61
msgid ""
"If ``input`` is \"``-``\" or omitted, :program:`llvm-mca` reads from "
"standard input. Otherwise, it will read from the specified filename."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:64
msgid ""
"If the :option:`-o` option is omitted, then :program:`llvm-mca` will send "
"its output to standard output if the input is from standard input.  If the :"
"option:`-o` option specifies \"``-``\", then the output will also be sent to "
"standard output."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:71
msgid "Print a summary of command line options."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:75
msgid ""
"Use ``<filename>`` as the output filename. See the summary above for more "
"details."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:80
msgid "Specify a target triple string."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:84
msgid ""
"Specify the architecture for which to analyze the code. It defaults to the "
"host default target."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:89
msgid ""
"Specify the processor for which to analyze the code.  By default, the cpu "
"name is autodetected from the host."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:94
msgid ""
"Specify the output assembly variant for the report generated by the tool. On "
"x86, possible values are [0, 1]. A value of 0 (vic. 1) for this flag enables "
"the AT&T (vic. Intel) assembly format for the code printed out by the tool "
"in the analysis report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:101
msgid ""
"Prefer hex format for numeric literals in the output assembly printed as "
"part of the report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:106
msgid ""
"Specify a different dispatch width for the processor. The dispatch width "
"defaults to field 'IssueWidth' in the processor scheduling model.  If width "
"is zero, then the default dispatch width is used."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:112
msgid ""
"Specify the size of the register file. When specified, this flag limits how "
"many physical registers are available for register renaming purposes. A "
"value of zero for this flag means \"unlimited number of physical registers\"."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:118
msgid ""
"Specify the number of iterations to run. If this flag is set to 0, then the "
"tool sets the number of iterations to a default value (i.e. 100)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:123
msgid ""
"If set, the tool assumes that loads and stores don't alias. This is the "
"default behavior."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:128
msgid ""
"Specify the size of the load queue in the load/store unit emulated by the "
"tool. By default, the tool assumes an unbound number of entries in the load "
"queue. A value of zero for this flag is ignored, and the default load queue "
"size is used instead."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:135
msgid ""
"Specify the size of the store queue in the load/store unit emulated by the "
"tool. By default, the tool assumes an unbound number of entries in the store "
"queue. A value of zero for this flag is ignored, and the default store queue "
"size is used instead."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:142
msgid "Enable the timeline view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:146
msgid ""
"Limit the number of iterations to print in the timeline view. By default, "
"the timeline view prints information for up to 10 iterations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:151
msgid ""
"Limit the number of cycles in the timeline view, or use 0 for no limit. By "
"default, the number of cycles is set to 80."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:156
msgid "Enable the resource pressure view. This is enabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:160
msgid "Enable register file usage statistics."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:164
msgid ""
"Enable extra dispatch statistics. This view collects and analyzes "
"instruction dispatch events, as well as static/dynamic dispatch stall "
"events. This view is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:170
msgid ""
"Enable extra scheduler statistics. This view collects and analyzes "
"instruction issue events. This view is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:175
msgid ""
"Enable extra retire control unit statistics. This view is disabled by "
"default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:179
msgid "Enable the instruction info view. This is enabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:183
msgid ""
"Enable the printing of instruction encodings within the instruction info "
"view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:187
msgid ""
"Enable the printing of LoadBarrier and StoreBarrier flags within the "
"instruction info view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:192
msgid ""
"Print all hardware statistics. This enables extra statistics related to the "
"dispatch logic, the hardware schedulers, the register file(s), and the "
"retire control unit. This option is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:198
msgid "Enable all the view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:202
msgid ""
"Prints resource pressure information based on the static information "
"available from the processor model. This differs from the resource pressure "
"view because it doesn't require that the code is simulated. It instead "
"prints the theoretical uniform distribution of resource pressure for every "
"instruction in sequence."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:210
msgid ""
"Print information about bottlenecks that affect the throughput. This "
"analysis can be expensive, and it is disabled by default. Bottlenecks are "
"highlighted in the summary view. Bottleneck analysis is currently not "
"supported for processors with an in-order backend."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:217
msgid ""
"Print the requested views in valid JSON format. The instructions and the "
"processor resources are printed as members of special top level JSON "
"objects. The individual views refer to them by index. However, not all views "
"are currently supported. For example, the report from the bottleneck "
"analysis is not printed out in JSON. All the default views are currently "
"supported."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:225
msgid ""
"Force usage of the generic CustomBehaviour and InstrPostProcess classes "
"rather than using the target specific implementation. The generic classes "
"never detect any custom hazards or make any post processing modifications to "
"instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:232
msgid ""
"Force usage of the generic InstrumentManager rather than using the target "
"specific implementation. The generic class creates Instruments that provide "
"no extra information, and InstrumentManager never overrides the default "
"schedule class for a given instruction."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:239
msgid ""
"Force :program:`llvm-mca` to continue in the presence of instructions which "
"do not parse or lack key scheduling information. Note that the resulting "
"analysis is impacted since those unsupported instructions are ignored as-if "
"they are not supplied as a part of the input."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:244
msgid ""
"The choice of `<reason>` controls the when mca will report an error. "
"`<reason>` may be `none` (default), `lack-sched`, `parse-failure`, `any`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:248
msgid "EXIT STATUS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:250
msgid ""
":program:`llvm-mca` returns 0 on success. Otherwise, an error message is "
"printed to standard error, and the tool returns 1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:254
msgid "USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:255
msgid ""
":program:`llvm-mca` allows for the optional usage of special code comments "
"to mark regions of the assembly code to be analyzed.  A comment starting "
"with substring ``LLVM-MCA-BEGIN`` marks the beginning of an analysis region. "
"A comment starting with substring ``LLVM-MCA-END`` marks the end of a "
"region. For example:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:267
msgid ""
"If no user-defined region is specified, then :program:`llvm-mca` assumes a "
"default region which contains every instruction in the input file.  Every "
"region is analyzed in isolation, and the final performance report is the "
"union of all the reports generated for every analysis region."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:272
msgid "Analysis regions can have names. For example:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:280
msgid ""
"The code from the example above defines a region named \"A simple example\" "
"with a single instruction in it. Note how the region name doesn't have to be "
"repeated in the ``LLVM-MCA-END`` directive. In the absence of overlapping "
"regions, an anonymous ``LLVM-MCA-END`` directive always ends the currently "
"active user defined region."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:286
msgid "Example of nesting regions:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:297
msgid "Example of overlapping regions:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:309
msgid ""
"Note that multiple anonymous regions cannot overlap. Also, overlapping "
"regions cannot have the same name."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:312
msgid ""
"There is no support for marking regions from high-level source code, like C "
"or C++. As a workaround, inline assembly directives may be used:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:325
msgid ""
"However, this interferes with optimizations like loop vectorization and may "
"have an impact on the code generated. This is because the ``__asm`` "
"statements are seen as real code having important side effects, which limits "
"how the code around them can be transformed. If users want to make use of "
"inline assembly to emit markers, then the recommendation is to always verify "
"that the output assembly is equivalent to the assembly generated in the "
"absence of markers. The `Clang options to emit optimization reports <https://"
"clang.llvm.org/docs/UsersManual.html#options-to-emit-optimization-reports>`_ "
"can also help in detecting missed optimizations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:335
msgid "INSTRUMENT REGIONS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:337
msgid ""
"An InstrumentRegion describes a region of assembly code guarded by special "
"LLVM-MCA comment directives."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:345
msgid ""
"where `INSTRUMENT_TYPE` is a type defined by the target and expects to use "
"`data`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:348
msgid ""
"A comment starting with substring `LLVM-MCA-<INSTRUMENT_TYPE>` brings data "
"into scope for llvm-mca to use in its analysis for all following "
"instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:352
msgid ""
"If a comment with the same `INSTRUMENT_TYPE` is found later in the "
"instruction list, then the original InstrumentRegion will be automatically "
"ended, and a new InstrumentRegion will begin."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:356
msgid ""
"If there are comments containing the different `INSTRUMENT_TYPE`, then both "
"data sets remain available. In contrast with an AnalysisRegion, an "
"InstrumentRegion does not need a comment to end the region."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:360
msgid ""
"Comments that are prefixed with `LLVM-MCA-` but do not correspond to a valid "
"`INSTRUMENT_TYPE` for the target cause an error, except for `BEGIN` and "
"`END`, since those correspond to AnalysisRegions. Comments that do not start "
"with `LLVM-MCA-` are ignored by :program:`llvm-mca`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:365
msgid ""
"An instruction (a MCInst) is added to an InstrumentRegion R only if its "
"location is in range [R.RangeStart, R.RangeEnd]."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:368
msgid ""
"On RISCV targets, vector instructions have different behaviour depending on "
"the LMUL. Code can be instrumented with a comment that takes the following "
"form:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:376
msgid ""
"The RISCV InstrumentManager will override the schedule class for vector "
"instructions to use the scheduling behaviour of its pseudo-instruction which "
"is LMUL dependent. It makes sense to place RISCV instrument comments "
"directly after `vset{i}vl{i}` instructions, although they can be placed "
"anywhere in the program."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:382
msgid "Example of program with no call to `vset{i}vl{i}`:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:389
msgid "Example of program with call to `vset{i}vl{i}`:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:397
msgid "Example of program with multiple calls to `vset{i}vl{i}`:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:408
msgid "Example of program with call to `vsetvl`:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:420
msgid "HOW LLVM-MCA WORKS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:422
msgid ""
":program:`llvm-mca` takes assembly code as input. The assembly code is "
"parsed into a sequence of MCInst with the help of the existing LLVM target "
"assembly parsers. The parsed sequence of MCInst is then analyzed by a "
"``Pipeline`` module to generate a performance report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:427
msgid ""
"The Pipeline module simulates the execution of the machine code sequence in "
"a loop of iterations (default is 100). During this process, the pipeline "
"collects a number of execution related statistics. At the end of this "
"process, the pipeline generates and prints a report from the collected "
"statistics."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:432
msgid ""
"Here is an example of a performance report generated by the tool for a dot-"
"product of two packed float vectors of four elements. The analysis is "
"conducted for target x86, cpu btver2.  The following result can be produced "
"via the following command using the example located at ``test/tools/llvm-mca/"
"X86/BtVer2/dot-product.s``:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:496
msgid ""
"According to this report, the dot-product kernel has been executed 300 "
"times, for a total of 900 simulated instructions. The total number of "
"simulated micro opcodes (uOps) is also 900."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:500
msgid ""
"The report is structured in three main sections.  The first section collects "
"a few performance numbers; the goal of this section is to give a very quick "
"overview of the performance throughput. Important performance indicators are "
"**IPC**, **uOps Per Cycle**, and  **Block RThroughput** (Block Reciprocal "
"Throughput)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:506
msgid ""
"Field *DispatchWidth* is the maximum number of micro opcodes that are "
"dispatched to the out-of-order backend every simulated cycle. For processors "
"with an in-order backend, *DispatchWidth* is the maximum number of micro "
"opcodes issued to the backend every simulated cycle."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:511
msgid ""
"IPC is computed dividing the total number of simulated instructions by the "
"total number of cycles."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:514
msgid ""
"Field *Block RThroughput* is the reciprocal of the block throughput. Block "
"throughput is a theoretical quantity computed as the maximum number of "
"blocks (i.e. iterations) that can be executed per simulated clock cycle in "
"the absence of loop carried dependencies. Block throughput is superiorly "
"limited by the dispatch rate, and the availability of hardware resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:520
msgid ""
"In the absence of loop-carried data dependencies, the observed IPC tends to "
"a theoretical maximum which can be computed by dividing the number of "
"instructions of a single iteration by the `Block RThroughput`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:524
msgid ""
"Field 'uOps Per Cycle' is computed dividing the total number of simulated "
"micro opcodes by the total number of cycles. A delta between Dispatch Width "
"and this field is an indicator of a performance issue. In the absence of "
"loop-carried data dependencies, the observed 'uOps Per Cycle' should tend to "
"a theoretical maximum throughput which can be computed by dividing the "
"number of uOps of a single iteration by the `Block RThroughput`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:531
msgid ""
"Field *uOps Per Cycle* is bounded from above by the dispatch width. That is "
"because the dispatch width limits the maximum size of a dispatch group. Both "
"IPC and 'uOps Per Cycle' are limited by the amount of hardware parallelism. "
"The availability of hardware resources affects the resource pressure "
"distribution, and it limits the number of instructions that can be executed "
"in parallel every cycle.  A delta between Dispatch Width and the theoretical "
"maximum uOps per Cycle (computed by dividing the number of uOps of a single "
"iteration by the `Block RThroughput`) is an indicator of a performance "
"bottleneck caused by the lack of hardware resources. In general, the lower "
"the Block RThroughput, the better."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:542
msgid ""
"In this example, ``uOps per iteration/Block RThroughput`` is 1.50. Since "
"there are no loop-carried dependencies, the observed `uOps Per Cycle` is "
"expected to approach 1.50 when the number of iterations tends to infinity. "
"The delta between the Dispatch Width (2.00), and the theoretical maximum uOp "
"throughput (1.50) is an indicator of a performance bottleneck caused by the "
"lack of hardware resources, and the *Resource pressure view* can help to "
"identify the problematic resource usage."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:550
msgid ""
"The second section of the report is the `instruction info view`. It shows "
"the latency and reciprocal throughput of every instruction in the sequence. "
"It also reports extra information related to the number of micro opcodes, "
"and opcode properties (i.e., 'MayLoad', 'MayStore', and 'HasSideEffects')."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:555
msgid ""
"Field *RThroughput* is the reciprocal of the instruction throughput. "
"Throughput is computed as the maximum number of instructions of a same type "
"that can be executed per clock cycle in the absence of operand dependencies. "
"In this example, the reciprocal throughput of a vector float multiply is 1 "
"cycles/instruction.  That is because the FP multiplier JFPM is only "
"available from pipeline JFPU1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:562
msgid ""
"Instruction encodings are displayed within the instruction info view when "
"flag `-show-encoding` is specified."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:565
msgid ""
"Below is an example of `-show-encoding` output for the dot-product kernel:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:583
msgid ""
"The `Encoding Size` column shows the size in bytes of instructions.  The "
"`Encodings` column shows the actual instruction encodings (byte sequences in "
"hex)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:587
msgid ""
"The third section is the *Resource pressure view*.  This view reports the "
"average number of resource cycles consumed every iteration by instructions "
"for every processor resource unit available on the target.  Information is "
"structured in two tables. The first table reports the number of resource "
"cycles spent on average every iteration. The second table correlates the "
"resource cycles to the machine instruction in the sequence. For example, "
"every iteration of the instruction vmulps always executes on resource unit "
"[6] (JFPU1 - floating point pipeline #1), consuming an average of 1 resource "
"cycle per iteration.  Note that on AMD Jaguar, vector floating-point "
"multiply can only be issued to pipeline JFPU1, while horizontal floating-"
"point additions can only be issued to pipeline JFPU0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:599
msgid ""
"The resource pressure view helps with identifying bottlenecks caused by high "
"usage of specific hardware resources.  Situations with resource pressure "
"mainly concentrated on a few resources should, in general, be avoided.  "
"Ideally, pressure should be uniformly distributed between multiple resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:605
msgid "Timeline View"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:606
msgid ""
"The timeline view produces a detailed report of each instruction's state "
"transitions through an instruction pipeline.  This view is enabled by the "
"command line option ``-timeline``.  As instructions transition through the "
"various stages of the pipeline, their states are depicted in the view "
"report. These states are represented by the following characters:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:612
msgid "D : Instruction dispatched."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:613
msgid "e : Instruction executing."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:614
msgid "E : Instruction executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:615
msgid "R : Instruction retired."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:616
msgid "= : Instruction already dispatched, waiting to be executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:617
msgid "\\- : Instruction executed, waiting to be retired."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:619
msgid ""
"Below is the timeline view for a subset of the dot-product example located "
"in ``test/tools/llvm-mca/X86/BtVer2/dot-product.s`` and processed by :"
"program:`llvm-mca` using the following command:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:656
msgid ""
"The timeline view is interesting because it shows instruction state changes "
"during execution.  It also gives an idea of how the tool processes "
"instructions executed on the target, and how their timing information might "
"be calculated."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:660
msgid ""
"The timeline view is structured in two tables.  The first table shows "
"instructions changing state over time (measured in cycles); the second table "
"(named *Average Wait times*) reports useful timing statistics, which should "
"help diagnose performance bottlenecks caused by long data dependencies and "
"sub-optimal usage of hardware resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:666
msgid ""
"An instruction in the timeline view is identified by a pair of indices, "
"where the first index identifies an iteration, and the second index is the "
"instruction index (i.e., where it appears in the code sequence).  Since this "
"example was generated using 3 iterations: ``-iterations=3``, the iteration "
"indices range from 0-2 inclusively."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:672
msgid ""
"Excluding the first and last column, the remaining columns are in cycles. "
"Cycles are numbered sequentially starting from 0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:675
msgid "From the example output above, we know the following:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:677
msgid "Instruction [1,0] was dispatched at cycle 1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:678
msgid "Instruction [1,0] started executing at cycle 2."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:679
msgid "Instruction [1,0] reached the write back stage at cycle 4."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:680
msgid "Instruction [1,0] was retired at cycle 10."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:682
msgid ""
"Instruction [1,0] (i.e., vmulps from iteration #1) does not have to wait in "
"the scheduler's queue for the operands to become available. By the time "
"vmulps is dispatched, operands are already available, and pipeline JFPU1 is "
"ready to serve another instruction.  So the instruction can be immediately "
"issued on the JFPU1 pipeline. That is demonstrated by the fact that the "
"instruction only spent 1cy in the scheduler's queue."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:689
msgid ""
"There is a gap of 5 cycles between the write-back stage and the retire "
"event. That is because instructions must retire in program order, so [1,0] "
"has to wait for [0,2] to be retired first (i.e., it has to wait until cycle "
"10)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:693
msgid ""
"In the example, all instructions are in a RAW (Read After Write) dependency "
"chain.  Register %xmm2 written by vmulps is immediately used by the first "
"vhaddps, and register %xmm3 written by the first vhaddps is used by the "
"second vhaddps.  Long data dependencies negatively impact the ILP "
"(Instruction Level Parallelism)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:699
msgid ""
"In the dot-product example, there are anti-dependencies introduced by "
"instructions from different iterations.  However, those dependencies can be "
"removed at register renaming stage (at the cost of allocating register "
"aliases, and therefore consuming physical registers)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:704
msgid ""
"Table *Average Wait times* helps diagnose performance issues that are caused "
"by the presence of long latency instructions and potentially long data "
"dependencies which may limit the ILP. Last row, ``<total>``, shows a global "
"average over all instructions measured. Note that :program:`llvm-mca`, by "
"default, assumes at least 1cy between the dispatch event and the issue event."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:710
msgid ""
"When the performance is limited by data dependencies and/or long latency "
"instructions, the number of cycles spent while in the *ready* state is "
"expected to be very small when compared with the total number of cycles "
"spent in the scheduler's queue.  The difference between the two counters is "
"a good indicator of how large of an impact data dependencies had on the "
"execution of the instructions.  When performance is mostly limited by the "
"lack of hardware resources, the delta between the two counters is small.  "
"However, the number of cycles spent in the queue tends to be larger (i.e., "
"more than 1-3cy), especially when compared to other low latency instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:721
msgid "Bottleneck Analysis"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:722
msgid ""
"The ``-bottleneck-analysis`` command line option enables the analysis of "
"performance bottlenecks."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:725
msgid ""
"This analysis is potentially expensive. It attempts to correlate increases "
"in backend pressure (caused by pipeline resource pressure and data "
"dependencies) to dynamic dispatch stalls."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:729
msgid ""
"Below is an example of ``-bottleneck-analysis`` output generated by :program:"
"`llvm-mca` for 500 iterations of the dot-product example on btver2."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:760
msgid ""
"According to the analysis, throughput is limited by resource pressure and "
"not by data dependencies.  The analysis observed increases in backend "
"pressure during 48.07% of the simulated run. Almost all those pressure "
"increase events were caused by contention on processor resources JFPA/JFPU0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:765
msgid ""
"The `critical sequence` is the most expensive sequence of instructions "
"according to the simulation. It is annotated to provide extra information "
"about critical register dependencies and resource interferences between "
"instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:769
msgid ""
"Instructions from the critical sequence are expected to significantly impact "
"performance. By construction, the accuracy of this analysis is strongly "
"dependent on the simulation and (as always) by the quality of the processor "
"model in llvm."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:774
msgid ""
"Bottleneck analysis is currently not supported for processors with an in-"
"order backend."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:778
msgid "Extra Statistics to Further Diagnose Performance Issues"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:779
msgid ""
"The ``-all-stats`` command line option enables extra statistics and "
"performance counters for the dispatch logic, the reorder buffer, the retire "
"control unit, and the register file."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:783
msgid ""
"Below is an example of ``-all-stats`` output generated by  :program:`llvm-"
"mca` for 300 iterations of the dot-product example discussed in the previous "
"sections."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:848
msgid ""
"If we look at the *Dynamic Dispatch Stall Cycles* table, we see the counter "
"for SCHEDQ reports 272 cycles.  This counter is incremented every time the "
"dispatch logic is unable to dispatch a full group because the scheduler's "
"queue is full."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:852
msgid ""
"Looking at the *Dispatch Logic* table, we see that the pipeline was only "
"able to dispatch two micro opcodes 51.5% of the time.  The dispatch group "
"was limited to one micro opcode 44.6% of the cycles, which corresponds to "
"272 cycles.  The dispatch statistics are displayed by either using the "
"command option ``-all-stats`` or ``-dispatch-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:858
msgid ""
"The next table, *Schedulers*, presents a histogram displaying a count, "
"representing the number of micro opcodes issued on some number of cycles. In "
"this case, of the 610 simulated cycles, single opcodes were issued 306 times "
"(50.2%) and there were 7 cycles where no opcodes were issued."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:863
msgid ""
"The *Scheduler's queue usage* table shows that the average and maximum "
"number of buffer entries (i.e., scheduler queue entries) used at runtime.  "
"Resource JFPU01 reached its maximum (18 of 18 queue entries). Note that AMD "
"Jaguar implements three schedulers:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:868
msgid "JALU01 - A scheduler for ALU instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:869
msgid "JFPU01 - A scheduler floating point operations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:870
msgid "JLSAGU - A scheduler for address generation."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:872
msgid ""
"The dot-product is a kernel of three floating point instructions (a vector "
"multiply followed by two horizontal adds).  That explains why only the "
"floating point scheduler appears to be used."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:876
msgid ""
"A full scheduler queue is either caused by data dependency chains or by a "
"sub-optimal usage of hardware resources.  Sometimes, resource pressure can "
"be mitigated by rewriting the kernel using different instructions that "
"consume different scheduler resources.  Schedulers with a small queue are "
"less resilient to bottlenecks caused by the presence of long data "
"dependencies.  The scheduler statistics are displayed by using the command "
"option ``-all-stats`` or ``-scheduler-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:884
msgid ""
"The next table, *Retire Control Unit*, presents a histogram displaying a "
"count, representing the number of instructions retired on some number of "
"cycles.  In this case, of the 610 simulated cycles, two instructions were "
"retired during the same cycle 399 times (65.4%) and there were 109 cycles "
"where no instructions were retired.  The retire statistics are displayed by "
"using the command option ``-all-stats`` or ``-retire-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:891
msgid ""
"The last table presented is *Register File statistics*.  Each physical "
"register file (PRF) used by the pipeline is presented in this table.  In the "
"case of AMD Jaguar, there are two register files, one for floating-point "
"registers (JFpuPRF) and one for integer registers (JIntegerPRF).  The table "
"shows that of the 900 instructions processed, there were 900 mappings "
"created.  Since this dot-product example utilized only floating point "
"registers, the JFPuPRF was responsible for creating the 900 mappings.  "
"However, we see that the pipeline only used a maximum of 35 of 72 available "
"register slots at any given time. We can conclude that the floating point "
"PRF was the only register file used for the example, and that it was never "
"resource constrained.  The register file statistics are displayed by using "
"the command option ``-all-stats`` or ``-register-file-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:904
msgid ""
"In this example, we can conclude that the IPC is mostly limited by data "
"dependencies, and not by resource pressure."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:908
msgid "Instruction Flow"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:909
msgid ""
"This section describes the instruction flow through the default pipeline of :"
"program:`llvm-mca`, as well as the functional units involved in the process."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:912
msgid ""
"The default pipeline implements the following sequence of stages used to "
"process instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:915
msgid "Dispatch (Instruction is dispatched to the schedulers)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:916
msgid "Issue (Instruction is issued to the processor pipelines)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:917
msgid "Write Back (Instruction is executed, and results are written back)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:918
#: ../../../CommandGuide/llvm-mca.rst:923
msgid "Retire (Instruction is retired; writes are architecturally committed)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:920
msgid "The in-order pipeline implements the following sequence of stages:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:922
msgid "InOrderIssue (Instruction is issued to the processor pipelines)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:925
msgid ""
":program:`llvm-mca` assumes that instructions have all been decoded and "
"placed into a queue before the simulation start. Therefore, the instruction "
"fetch and decode stages are not modeled. Performance bottlenecks in the "
"frontend are not diagnosed. Also, :program:`llvm-mca` does not model branch "
"prediction."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:931
msgid "Instruction Dispatch"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:932
msgid ""
"During the dispatch stage, instructions are picked in program order from a "
"queue of already decoded instructions, and dispatched in groups to the "
"simulated hardware schedulers."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:936
msgid ""
"The size of a dispatch group depends on the availability of the simulated "
"hardware resources.  The processor dispatch width defaults to the value of "
"the ``IssueWidth`` in LLVM's scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:940
msgid "An instruction can be dispatched if:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:942
msgid ""
"The size of the dispatch group is smaller than processor's dispatch width."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:943
msgid "There are enough entries in the reorder buffer."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:944
msgid "There are enough physical registers to do register renaming."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:945
msgid "The schedulers are not full."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:947
msgid ""
"Scheduling models can optionally specify which register files are available "
"on the processor. :program:`llvm-mca` uses that information to initialize "
"register file descriptors.  Users can limit the number of physical registers "
"that are globally available for register renaming by using the command "
"option ``-register-file-size``.  A value of zero for this option means "
"*unbounded*. By knowing how many registers are available for renaming, the "
"tool can predict dispatch stalls caused by the lack of physical registers."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:955
msgid ""
"The number of reorder buffer entries consumed by an instruction depends on "
"the number of micro-opcodes specified for that instruction by the target "
"scheduling model.  The reorder buffer is responsible for tracking the "
"progress of instructions that are \"in-flight\", and retiring them in "
"program order.  The number of entries in the reorder buffer defaults to the "
"value specified by field `MicroOpBufferSize` in the target scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:962
msgid ""
"Instructions that are dispatched to the schedulers consume scheduler buffer "
"entries. :program:`llvm-mca` queries the scheduling model to determine the "
"set of buffered resources consumed by an instruction.  Buffered resources "
"are treated like scheduler resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:968
msgid "Instruction Issue"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:969
msgid ""
"Each processor scheduler implements a buffer of instructions.  An "
"instruction has to wait in the scheduler's buffer until input register "
"operands become available.  Only at that point, does the instruction becomes "
"eligible for execution and may be issued (potentially out-of-order) for "
"execution. Instruction latencies are computed by :program:`llvm-mca` with "
"the help of the scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:976
msgid ""
":program:`llvm-mca`'s scheduler is designed to simulate multiple processor "
"schedulers.  The scheduler is responsible for tracking data dependencies, "
"and dynamically selecting which processor resources are consumed by "
"instructions. It delegates the management of processor resource units and "
"resource groups to a resource manager.  The resource manager is responsible "
"for selecting resource units that are consumed by instructions.  For "
"example, if an instruction consumes 1cy of a resource group, the resource "
"manager selects one of the available units from the group; by default, the "
"resource manager uses a round-robin selector to guarantee that resource "
"usage is uniformly distributed between all units of a group."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:987
msgid ""
":program:`llvm-mca`'s scheduler internally groups instructions into three "
"sets:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:989
msgid "WaitSet: a set of instructions whose operands are not ready."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:990
msgid "ReadySet: a set of instructions ready to execute."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:991
msgid "IssuedSet: a set of instructions executing."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:993
msgid ""
"Depending on the operands availability, instructions that are dispatched to "
"the scheduler are either placed into the WaitSet or into the ReadySet."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:996
msgid ""
"Every cycle, the scheduler checks if instructions can be moved from the "
"WaitSet to the ReadySet, and if instructions from the ReadySet can be issued "
"to the underlying pipelines. The algorithm prioritizes older instructions "
"over younger instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1002
msgid "Write-Back and Retire Stage"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1003
msgid ""
"Issued instructions are moved from the ReadySet to the IssuedSet.  There, "
"instructions wait until they reach the write-back stage.  At that point, "
"they get removed from the queue and the retire control unit is notified."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1007
msgid ""
"When instructions are executed, the retire control unit flags the "
"instruction as \"ready to retire.\""
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1010
msgid ""
"Instructions are retired in program order.  The register file is notified of "
"the retirement so that it can free the physical registers that were "
"allocated for the instruction during the register renaming stage."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1015
msgid "Load/Store Unit and Memory Consistency Model"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1016
msgid ""
"To simulate an out-of-order execution of memory operations, :program:`llvm-"
"mca` utilizes a simulated load/store unit (LSUnit) to simulate the "
"speculative execution of loads and stores."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1020
msgid ""
"Each load (or store) consumes an entry in the load (or store) queue. Users "
"can specify flags ``-lqueue`` and ``-squeue`` to limit the number of entries "
"in the load and store queues respectively. The queues are unbounded by "
"default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1024
msgid ""
"The LSUnit implements a relaxed consistency model for memory loads and "
"stores. The rules are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1027
msgid ""
"A younger load is allowed to pass an older load only if there are no "
"intervening stores or barriers between the two loads."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1029
msgid ""
"A younger load is allowed to pass an older store provided that the load does "
"not alias with the store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1031
msgid "A younger store is not allowed to pass an older store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1032
msgid "A younger store is not allowed to pass an older load."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1034
msgid ""
"By default, the LSUnit optimistically assumes that loads do not alias (`-"
"noalias=true`) store operations.  Under this assumption, younger loads are "
"always allowed to pass older stores.  Essentially, the LSUnit does not "
"attempt to run any alias analysis to predict when loads and stores do not "
"alias with each other."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1040
msgid ""
"Note that, in the case of write-combining memory, rule 3 could be relaxed to "
"allow reordering of non-aliasing store operations.  That being said, at the "
"moment, there is no way to further relax the memory model (``-noalias`` is "
"the only option).  Essentially, there is no option to specify a different "
"memory type (e.g., write-back, write-combining, write-through; etc.) and "
"consequently to weaken, or strengthen, the memory model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1047
msgid "Other limitations are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1049
msgid "The LSUnit does not know when store-to-load forwarding may occur."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1050
msgid ""
"The LSUnit does not know anything about cache hierarchy and memory types."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1051
msgid ""
"The LSUnit does not know how to identify serializing operations and memory "
"fences."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1054
msgid ""
"The LSUnit does not attempt to predict if a load or store hits or misses the "
"L1 cache.  It only knows if an instruction \"MayLoad\" and/or \"MayStore.\"  "
"For loads, the scheduling model provides an \"optimistic\" load-to-use "
"latency (which usually matches the load-to-use latency for when there is a "
"hit in the L1D)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1059
msgid ""
":program:`llvm-mca` does not (on its own) know about serializing operations "
"or memory-barrier like instructions.  The LSUnit used to conservatively use "
"an instruction's \"MayLoad\", \"MayStore\", and unmodeled side effects flags "
"to determine whether an instruction should be treated as a memory-barrier. "
"This was inaccurate in general and was changed so that now each instruction "
"has an IsAStoreBarrier and IsALoadBarrier flag. These flags are mca specific "
"and default to false for every instruction. If any instruction should have "
"either of these flags set, it should be done within the target's "
"InstrPostProcess class. For an example, look at the `X86InstrPostProcess::"
"postProcessInstruction` method within `llvm/lib/Target/X86/MCA/"
"X86CustomBehaviour.cpp`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1070
msgid ""
"A load/store barrier consumes one entry of the load/store queue.  A load/"
"store barrier enforces ordering of loads/stores.  A younger load cannot pass "
"a load barrier.  Also, a younger store cannot pass a store barrier.  A "
"younger load has to wait for the memory/load barrier to execute.  A load/"
"store barrier is \"executed\" when it becomes the oldest entry in the load/"
"store queue(s). That also means, by construction, all of the older loads/"
"stores have been executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1077
msgid "In conclusion, the full set of load/store consistency rules are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1079
msgid "A store may not pass a previous store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1080
msgid "A store may not pass a previous load (regardless of ``-noalias``)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1081
msgid "A store has to wait until an older store barrier is fully executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1082
msgid "A load may pass a previous load."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1083
msgid "A load may not pass a previous store unless ``-noalias`` is set."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1084
msgid "A load has to wait until an older load barrier is fully executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1087
msgid "In-order Issue and Execute"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1088
msgid ""
"In-order processors are modelled as a single ``InOrderIssueStage`` stage. It "
"bypasses Dispatch, Scheduler and Load/Store unit. Instructions are issued as "
"soon as their operand registers are available and resource requirements are "
"met. Multiple instructions can be issued in one cycle according to the value "
"of the ``IssueWidth`` parameter in LLVM's scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1094
msgid ""
"Once issued, an instruction is moved to ``IssuedInst`` set until it is ready "
"to retire. :program:`llvm-mca` ensures that writes are committed in-order. "
"However, an instruction is allowed to commit writes and retire out-of-order "
"if ``RetireOOO`` property is true for at least one of its writes."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1100
msgid "Custom Behaviour"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1101
msgid ""
"Due to certain instructions not being expressed perfectly within their "
"scheduling model, :program:`llvm-mca` isn't always able to simulate them "
"perfectly. Modifying the scheduling model isn't always a viable option "
"though (maybe because the instruction is modeled incorrectly on purpose or "
"the instruction's behaviour is quite complex). The CustomBehaviour class can "
"be used in these cases to enforce proper instruction modeling (often by "
"customizing data dependencies and detecting hazards that :program:`llvm-mca` "
"has no way of knowing about)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1110
msgid ""
":program:`llvm-mca` comes with one generic and multiple target specific "
"CustomBehaviour classes. The generic class will be used if the ``-disable-"
"cb`` flag is used or if a target specific CustomBehaviour class doesn't "
"exist for that target. (The generic class does nothing.) Currently, the "
"CustomBehaviour class is only a part of the in-order pipeline, but there are "
"plans to add it to the out-of-order pipeline in the future."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1117
msgid ""
"CustomBehaviour's main method is `checkCustomHazard()` which uses the "
"current instruction and a list of all instructions still executing within "
"the pipeline to determine if the current instruction should be dispatched. "
"As output, the method returns an integer representing the number of cycles "
"that the current instruction must stall for (this can be an underestimate if "
"you don't know the exact number and a value of 0 represents no stall)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1124
msgid ""
"If you'd like to add a CustomBehaviour class for a target that doesn't "
"already have one, refer to an existing implementation to see how to set it "
"up. The classes are implemented within the target specific backend (for "
"example `/llvm/lib/Target/AMDGPU/MCA/`) so that they can access backend "
"symbols."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1130
msgid "Instrument Manager"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1131
msgid ""
"On certain architectures, scheduling information for certain instructions do "
"not contain all of the information required to identify the most precise "
"schedule class. For example, data that can have an impact on scheduling can "
"be stored in CSR registers."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1136
msgid ""
"One example of this is on RISCV, where values in registers such as `vtype` "
"and `vl` change the scheduling behaviour of vector instructions. Since MCA "
"does not keep track of the values in registers, instrument comments can be "
"used to specify these values."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1141
msgid ""
"InstrumentManager's main function is `getSchedClassID()` which has access to "
"the MCInst and all of the instruments that are active for that MCInst. This "
"function can use the instruments to override the schedule class of the "
"MCInst."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1146
msgid ""
"On RISCV, instrument comments containing LMUL information are used by "
"`getSchedClassID()` to map a vector instruction and the active LMUL to the "
"scheduling class of the pseudo-instruction that describes that base "
"instruction and the active LMUL."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1152
msgid "Custom Views"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1153
msgid ""
":program:`llvm-mca` comes with several Views such as the Timeline View and "
"Summary View. These Views are generic and can work with most (if not all) "
"targets. If you wish to add a new View to :program:`llvm-mca` and it does "
"not require any backend functionality that is not already exposed through MC "
"layer classes (MCSubtargetInfo, MCInstrInfo, etc.), please add it to the `/"
"tools/llvm-mca/View/` directory. However, if your new View is target "
"specific AND requires unexposed backend symbols or functionality, you can "
"define it in the `/lib/Target/<TargetName>/MCA/` directory."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1162
msgid ""
"To enable this target specific View, you will have to use this target's "
"CustomBehaviour class to override the `CustomBehaviour::getViews()` methods. "
"There are 3 variations of these methods based on where you want your View to "
"appear in the output: `getStartViews()`, `getPostInstrInfoViews()`, and "
"`getEndViews()`. These methods returns a vector of Views so you will want to "
"return a vector containing all of the target specific Views for the target "
"in question."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1170
msgid ""
"Because these target specific (and backend dependent) Views require the "
"`CustomBehaviour::getViews()` variants, these Views will not be enabled if "
"the `-disable-cb` flag is used."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:1174
msgid ""
"Enabling these custom Views does not affect the non-custom (generic) Views. "
"Continue to use the usual command line arguments to enable / disable those "
"Views."
msgstr ""
