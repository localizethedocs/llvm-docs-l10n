# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../AArch64SME.rst:3
msgid "Support for AArch64 Scalable Matrix Extension in LLVM"
msgstr ""

#: ../../../AArch64SME.rst:9
msgid "1. Introduction"
msgstr ""

#: ../../../AArch64SME.rst:11
msgid ""
"The :ref:`AArch64 SME ACLE <aarch64_sme_acle>` provides a number of "
"attributes for users to control PSTATE.SM and PSTATE.ZA. The :ref:`AArch64 "
"SME ABI<aarch64_sme_abi>` describes the requirements for calls between "
"functions when at least one of those functions uses PSTATE.SM or PSTATE.ZA."
msgstr ""

#: ../../../AArch64SME.rst:17
msgid ""
"This document describes how the SME ACLE attributes map to LLVM IR "
"attributes and how LLVM lowers these attributes to implement the rules and "
"requirements of the ABI."
msgstr ""

#: ../../../AArch64SME.rst:21
msgid ""
"Below we describe the LLVM IR attributes and their relation to the C/C++ "
"level ACLE attributes:"
msgstr ""

#: ../../../AArch64SME.rst:25
msgid "``aarch64_pstate_sm_enabled``"
msgstr ""

#: ../../../AArch64SME.rst:25
msgid "is used for functions with ``__arm_streaming``"
msgstr ""

#: ../../../AArch64SME.rst:28
msgid "``aarch64_pstate_sm_compatible``"
msgstr ""

#: ../../../AArch64SME.rst:28
msgid "is used for functions with ``__arm_streaming_compatible``"
msgstr ""

#: ../../../AArch64SME.rst:32
msgid "``aarch64_pstate_sm_body``"
msgstr ""

#: ../../../AArch64SME.rst:31
msgid ""
"is used for functions with ``__arm_locally_streaming`` and is only valid on "
"function definitions (not declarations)"
msgstr ""

#: ../../../AArch64SME.rst:35
msgid "``aarch64_new_za``"
msgstr ""

#: ../../../AArch64SME.rst:35
msgid "is used for functions with ``__arm_new(\"za\")``"
msgstr ""

#: ../../../AArch64SME.rst:38
msgid "``aarch64_in_za``"
msgstr ""

#: ../../../AArch64SME.rst:38
msgid "is used for functions with ``__arm_in(\"za\")``"
msgstr ""

#: ../../../AArch64SME.rst:41
msgid "``aarch64_out_za``"
msgstr ""

#: ../../../AArch64SME.rst:41
msgid "is used for functions with ``__arm_out(\"za\")``"
msgstr ""

#: ../../../AArch64SME.rst:44
msgid "``aarch64_inout_za``"
msgstr ""

#: ../../../AArch64SME.rst:44
msgid "is used for functions with ``__arm_inout(\"za\")``"
msgstr ""

#: ../../../AArch64SME.rst:47
msgid "``aarch64_preserves_za``"
msgstr ""

#: ../../../AArch64SME.rst:47
msgid "is used for functions with ``__arm_preserves(\"za\")``"
msgstr ""

#: ../../../AArch64SME.rst:50
msgid "``aarch64_expanded_pstate_za``"
msgstr ""

#: ../../../AArch64SME.rst:50
msgid "is used for functions with ``__arm_new_za``"
msgstr ""

#: ../../../AArch64SME.rst:52
msgid ""
"Clang must ensure that the above attributes are added both to the function's "
"declaration/definition as well as to their call-sites. This is important for "
"calls to attributed function pointers, where there is no definition or "
"declaration available."
msgstr ""

#: ../../../AArch64SME.rst:59
msgid "2. Handling PSTATE.SM"
msgstr ""

#: ../../../AArch64SME.rst:61
msgid ""
"When changing PSTATE.SM the execution of FP/vector operations may be "
"transferred to another processing element. This has three important "
"implications:"
msgstr ""

#: ../../../AArch64SME.rst:64
msgid "The runtime SVE vector length may change."
msgstr ""

#: ../../../AArch64SME.rst:66
msgid "The contents of FP/AdvSIMD/SVE registers are zeroed."
msgstr ""

#: ../../../AArch64SME.rst:68
msgid "The set of allowable instructions changes."
msgstr ""

#: ../../../AArch64SME.rst:70
msgid ""
"This leads to certain restrictions on IR and optimizations. For example, it "
"is undefined behaviour to share vector-length dependent state between "
"functions that may operate with different values for PSTATE.SM. Front-ends "
"must honour these restrictions when generating LLVM IR."
msgstr ""

#: ../../../AArch64SME.rst:75
msgid ""
"Even though the runtime SVE vector length may change, for the purpose of "
"LLVM IR and almost all parts of CodeGen we can assume that the runtime value "
"for ``vscale`` does not. If we let the compiler insert the appropriate "
"``smstart`` and ``smstop`` instructions around call boundaries, then the "
"effects on SVE state can be mitigated. By limiting the state changes to a "
"very brief window around the call we can control how the operations are "
"scheduled and how live values remain preserved between state transitions."
msgstr ""

#: ../../../AArch64SME.rst:83
msgid ""
"In order to control PSTATE.SM at this level of granularity, we use function "
"and callsite attributes rather than intrinsics."
msgstr ""

#: ../../../AArch64SME.rst:88
msgid "Restrictions on attributes"
msgstr ""

#: ../../../AArch64SME.rst:90
msgid ""
"It is undefined behaviour to pass or return (pointers to) scalable vector "
"objects to/from functions which may use a different SVE vector length. This "
"includes functions with a non-streaming interface, but marked with "
"``aarch64_pstate_sm_body``."
msgstr ""

#: ../../../AArch64SME.rst:95
msgid ""
"It is not allowed for a function to be decorated with both "
"``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``."
msgstr ""

#: ../../../AArch64SME.rst:98
msgid ""
"It is not allowed for a function to be decorated with more than one of the "
"following attributes: ``aarch64_new_za``, ``aarch64_in_za``, "
"``aarch64_out_za``, ``aarch64_inout_za``, ``aarch64_preserves_za``."
msgstr ""

#: ../../../AArch64SME.rst:103
msgid ""
"These restrictions also apply in the higher level SME ACLE, which means we "
"can emit diagnostics in Clang to signal users about incorrect behaviour."
msgstr ""

#: ../../../AArch64SME.rst:108
msgid "Compiler inserted streaming-mode changes"
msgstr ""

#: ../../../AArch64SME.rst:110
msgid ""
"The table below describes the transitions in PSTATE.SM the compiler has to "
"account for when doing calls between functions with different attributes. In "
"this table, we use the following abbreviations:"
msgstr ""

#: ../../../AArch64SME.rst:116
msgid "``N``"
msgstr ""

#: ../../../AArch64SME.rst:115
msgid ""
"functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on "
"return)"
msgstr ""

#: ../../../AArch64SME.rst:120
msgid "``S``"
msgstr ""

#: ../../../AArch64SME.rst:119
msgid ""
"functions with a Streaming interface (PSTATE.SM=1 on entry, PSTATE.SM=1 on "
"return)"
msgstr ""

#: ../../../AArch64SME.rst:124
msgid "``SC``"
msgstr ""

#: ../../../AArch64SME.rst:123
msgid ""
"functions with a Streaming-Compatible interface (PSTATE.SM can be either 0 "
"or 1 on entry, and is unchanged on return)."
msgstr ""

#: ../../../AArch64SME.rst:126
msgid ""
"Functions with ``__attribute__((arm_locally_streaming))`` are excluded from "
"this table because for the caller the attribute is synonymous to "
"'streaming', and for the callee it is merely an implementation detail that "
"is explicitly not exposed to the caller."
msgstr ""

#: ../../../AArch64SME.rst:131
msgid "Combinations of calls for functions with different attributes"
msgstr ""

#: ../../../AArch64SME.rst:134
msgid "From"
msgstr ""

#: ../../../AArch64SME.rst:134
msgid "To"
msgstr ""

#: ../../../AArch64SME.rst:134
msgid "Before call"
msgstr ""

#: ../../../AArch64SME.rst:134
msgid "After call"
msgstr ""

#: ../../../AArch64SME.rst:134
msgid "After exception"
msgstr ""

#: ../../../AArch64SME.rst:136 ../../../AArch64SME.rst:137
#: ../../../AArch64SME.rst:138 ../../../AArch64SME.rst:139
#: ../../../AArch64SME.rst:142
msgid "N"
msgstr ""

#: ../../../AArch64SME.rst:137 ../../../AArch64SME.rst:139
#: ../../../AArch64SME.rst:140 ../../../AArch64SME.rst:141
#: ../../../AArch64SME.rst:144
msgid "S"
msgstr ""

#: ../../../AArch64SME.rst:137 ../../../AArch64SME.rst:139
#: ../../../AArch64SME.rst:140 ../../../AArch64SME.rst:141
msgid "SMSTART"
msgstr ""

#: ../../../AArch64SME.rst:137 ../../../AArch64SME.rst:139
msgid "SMSTOP"
msgstr ""

#: ../../../AArch64SME.rst:138 ../../../AArch64SME.rst:141
#: ../../../AArch64SME.rst:142 ../../../AArch64SME.rst:144
#: ../../../AArch64SME.rst:146
msgid "SC"
msgstr ""

#: ../../../AArch64SME.rst:142
msgid "If PSTATE.SM before call is 1, then SMSTOP"
msgstr ""

#: ../../../AArch64SME.rst:142 ../../../AArch64SME.rst:144
#: ../../../AArch64SME.rst:146
msgid "If PSTATE.SM before call is 1, then SMSTART"
msgstr ""

#: ../../../AArch64SME.rst:144
msgid "If PSTATE.SM before call is 0, then SMSTART"
msgstr ""

#: ../../../AArch64SME.rst:144
msgid "If PSTATE.SM before call is 0, then SMSTOP"
msgstr ""

#: ../../../AArch64SME.rst:151
msgid ""
"Because changing PSTATE.SM zeroes the FP/vector registers, it is best to "
"emit the ``smstart`` and ``smstop`` instructions before register allocation, "
"so that the register allocator can spill/reload registers around the mode "
"change."
msgstr ""

#: ../../../AArch64SME.rst:155
msgid ""
"The compiler should also have sufficient information on which operations are "
"part of the call/function's arguments/result and which operations are part "
"of the function's body, so that it can place the mode changes in exactly the "
"right position. The suitable place to do this seems to be SelectionDAG, "
"where it lowers the call's arguments/return values to implement the "
"specified calling convention. SelectionDAG provides Chains and Glue to "
"specify the order of operations and give preliminary control over the "
"instruction's scheduling."
msgstr ""

#: ../../../AArch64SME.rst:165
msgid "Example of preserving state"
msgstr ""

#: ../../../AArch64SME.rst:167
msgid ""
"When passing and returning a ``float`` value to/from a function that has a "
"streaming interface from a function that has a normal interface, the call-"
"site will need to ensure that the argument/result registers are preserved "
"and that no other code is scheduled in between the ``smstart/smstop`` and "
"the call."
msgstr ""

#: ../../../AArch64SME.rst:181
msgid ""
"The program needs to preserve the value of the floating point argument and "
"return value in register ``s0``:"
msgstr ""

#: ../../../AArch64SME.rst:207
msgid ""
"Setting the correct register masks on the ISD nodes and inserting the "
"``smstart/smstop`` in the right places should ensure this is done correctly."
msgstr ""

#: ../../../AArch64SME.rst:212
msgid "Instruction Selection Nodes"
msgstr ""

#: ../../../AArch64SME.rst:219
msgid ""
"The ``SMSTART/SMSTOP`` nodes take ``CurrentState`` and ``ExpectedState`` "
"operand for the case of a conditional SMSTART/SMSTOP. The instruction will "
"only be executed if CurrentState != ExpectedState."
msgstr ""

#: ../../../AArch64SME.rst:223
msgid ""
"When ``CurrentState`` and ``ExpectedState`` can be evaluated at compile-time "
"(i.e. they are both constants) then an unconditional ``smstart/smstop`` "
"instruction is emitted. Otherwise the node is matched to a Pseudo "
"instruction which expands to a compare/branch and a ``smstart/smstop``. This "
"is necessary to implement transitions from ``SC -> N`` and ``SC -> S``."
msgstr ""

#: ../../../AArch64SME.rst:231
msgid "Unchained Function calls"
msgstr ""

#: ../../../AArch64SME.rst:232
msgid ""
"When a function with \"``aarch64_pstate_sm_enabled``\" calls a function that "
"is not streaming compatible, the compiler has to insert a SMSTOP before the "
"call and insert a SMSTOP after the call."
msgstr ""

#: ../../../AArch64SME.rst:236
msgid ""
"If the function that is called is an intrinsic with no side-effects which in "
"turn is lowered to a function call (e.g. ``@llvm.cos()``), then the call to "
"``@llvm.cos()`` is not part of any Chain; it can be scheduled freely."
msgstr ""

#: ../../../AArch64SME.rst:240
msgid "Lowering of a Callsite creates a small chain of nodes which:"
msgstr ""

#: ../../../AArch64SME.rst:242
msgid "starts a call sequence"
msgstr ""

#: ../../../AArch64SME.rst:244
msgid ""
"copies input values from virtual registers to physical registers specified "
"by the ABI"
msgstr ""

#: ../../../AArch64SME.rst:247
msgid "executes a branch-and-link"
msgstr ""

#: ../../../AArch64SME.rst:249
msgid "stops the call sequence"
msgstr ""

#: ../../../AArch64SME.rst:251
msgid ""
"copies the output values from their physical registers to virtual registers"
msgstr ""

#: ../../../AArch64SME.rst:253
msgid ""
"When the callsite's Chain is not used, only the result value from the "
"chained sequence is used, but the Chain itself is discarded."
msgstr ""

#: ../../../AArch64SME.rst:256
msgid ""
"The ``SMSTART`` and ``SMSTOP`` ISD nodes return a Chain, but no real values, "
"so when the ``SMSTART/SMSTOP`` nodes are part of a Chain that isn't used, "
"these nodes are not considered for scheduling and are removed from the DAG.  "
"In order to prevent these nodes from being removed, we need a way to ensure "
"the results from the ``CopyFromReg`` can only be **used after** the "
"``SMSTART/SMSTOP`` has been executed."
msgstr ""

#: ../../../AArch64SME.rst:264
msgid ""
"We can use a CopyToReg -> CopyFromReg sequence for this, which moves the "
"value to/from a virtual register and chains these nodes with the SMSTART/"
"SMSTOP to make them part of the expression that calculates the result value. "
"The resulting COPY nodes are removed by the register allocator."
msgstr ""

#: ../../../AArch64SME.rst:270
msgid ""
"The example below shows how this is used in a DAG that does not link "
"together the result by a Chain, but rather by a value:"
msgstr ""

#: ../../../AArch64SME.rst:283
msgid ""
"We also need this for locally streaming functions, where an ``SMSTART`` "
"needs to be inserted into the DAG at the start of the function."
msgstr ""

#: ../../../AArch64SME.rst:287
msgid "Functions with __attribute__((arm_locally_streaming))"
msgstr ""

#: ../../../AArch64SME.rst:289
msgid ""
"If a function is marked as ``arm_locally_streaming``, then the runtime SVE "
"vector length in the prologue/epilogue may be different from the vector "
"length in the function's body. This happens because we invoke smstart after "
"setting up the stack-frame and similarly invoke smstop before deallocating "
"the stack-frame."
msgstr ""

#: ../../../AArch64SME.rst:294
msgid ""
"To ensure we use the correct SVE vector length to allocate the locals with, "
"we can use the streaming vector-length to allocate the stack-slots through "
"the ``ADDSVL`` instruction, even when the CPU is not yet in streaming mode."
msgstr ""

#: ../../../AArch64SME.rst:298
msgid ""
"This only works for locals and not callee-save slots, since LLVM doesn't "
"support mixing two different scalable vector lengths in one stack frame. "
"That means that the case where a function is marked "
"``arm_locally_streaming`` and needs to spill SVE callee-saves in the "
"prologue is currently unsupported.  However, it is unlikely for this to "
"happen without user intervention, because ``arm_locally_streaming`` "
"functions cannot take or return vector-length-dependent values. This would "
"otherwise require forcing both the SVE PCS using '``aarch64_sve_pcs``' "
"combined with using ``arm_locally_streaming`` in order to encounter this "
"problem. This combination can be prevented in Clang through emitting a "
"diagnostic."
msgstr ""

#: ../../../AArch64SME.rst:309
msgid ""
"An example of how the prologue/epilogue would look for a function that is "
"attributed with ``arm_locally_streaming``:"
msgstr ""

#: ../../../AArch64SME.rst:331
msgid ""
"should use ADDSVL for allocating the stack space and should avoid clobbering "
"the return/argument values."
msgstr ""

#: ../../../AArch64SME.rst:374
msgid "Preventing the use of illegal instructions in Streaming Mode"
msgstr ""

#: ../../../AArch64SME.rst:376
msgid ""
"When executing a program in streaming-mode (PSTATE.SM=1) a subset of SVE/"
"SVE2 instructions and most AdvSIMD/NEON instructions are invalid."
msgstr ""

#: ../../../AArch64SME.rst:379
msgid ""
"When executing a program in normal mode (PSTATE.SM=0), a subset of SME "
"instructions are invalid."
msgstr ""

#: ../../../AArch64SME.rst:382
msgid ""
"Streaming-compatible functions must only use instructions that are valid "
"when either PSTATE.SM=0 or PSTATE.SM=1."
msgstr ""

#: ../../../AArch64SME.rst:385
msgid ""
"The value of PSTATE.SM is not controlled by the feature flags, but rather by "
"the function attributes. This means that we can compile for '``+sme``' and "
"the compiler will code-generate any instructions, even if they are not legal "
"under the requested streaming mode. The compiler needs to use the function "
"attributes to ensure the compiler doesn't do transformations under the "
"assumption that certain operations are available at runtime."
msgstr ""

#: ../../../AArch64SME.rst:392
msgid ""
"We made a conscious choice not to model this with feature flags, because we "
"still want to support inline-asm in either mode (with the user placing "
"smstart/smstop manually), and this became rather complicated to implement at "
"the individual instruction level (see `D120261 <https://reviews.llvm.org/"
"D120261>`_ and `D121208 <https://reviews.llvm.org/D121208>`_) because of "
"limitations in TableGen."
msgstr ""

#: ../../../AArch64SME.rst:399
msgid ""
"As a first step, this means we'll disable vectorization (LoopVectorize/SLP) "
"entirely when the a function has either of the "
"``aarch64_pstate_sm_enabled``, ``aarch64_pstate_sm_body`` or "
"``aarch64_pstate_sm_compatible`` attributes, in order to avoid the use of "
"vector instructions."
msgstr ""

#: ../../../AArch64SME.rst:404
msgid ""
"Later on we'll aim to relax these restrictions to enable scalable auto-"
"vectorization with a subset of streaming-compatible instructions, but that "
"requires changes to the CostModel, Legalization and SelectionDAG lowering."
msgstr ""

#: ../../../AArch64SME.rst:408
msgid ""
"We will also emit diagnostics in Clang to prevent the use of non-streaming(-"
"compatible) operations, e.g. through ACLE intrinsics, when a function is "
"decorated with the streaming mode attributes."
msgstr ""

#: ../../../AArch64SME.rst:414
msgid "Other things to consider"
msgstr ""

#: ../../../AArch64SME.rst:416
msgid ""
"Inlining must be disabled when the call-site needs to toggle PSTATE.SM or "
"when the callee's function body is executed in a different streaming mode "
"than its caller. This is needed because function calls are the boundaries "
"for streaming mode changes."
msgstr ""

#: ../../../AArch64SME.rst:421
msgid ""
"Tail call optimization must be disabled when the call-site needs to toggle "
"PSTATE.SM, such that the caller can restore the original value of PSTATE.SM."
msgstr ""

#: ../../../AArch64SME.rst:426
msgid "3. Handling PSTATE.ZA"
msgstr ""

#: ../../../AArch64SME.rst:428
msgid ""
"In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector "
"length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is "
"safe to toggle PSTATE.ZA using intrinsics. This also makes it simpler to "
"setup a lazy-save mechanism for calls to private-ZA functions (i.e. "
"functions that may either directly or indirectly clobber ZA state)."
msgstr ""

#: ../../../AArch64SME.rst:434
msgid ""
"For the purpose of handling functions marked with ``aarch64_new_za``, we "
"have introduced a new LLVM IR pass (SMEABIPass) that is run just before "
"SelectionDAG. Any such functions dealt with by this pass are marked with "
"``aarch64_expanded_pstate_za``."
msgstr ""

#: ../../../AArch64SME.rst:440
msgid "Setting up a lazy-save"
msgstr ""

#: ../../../AArch64SME.rst:443
msgid "Committing a lazy-save"
msgstr ""

#: ../../../AArch64SME.rst:446
msgid "Exception handling and ZA"
msgstr ""

#: ../../../AArch64SME.rst:449
msgid "4. Types"
msgstr ""

#: ../../../AArch64SME.rst:452
msgid "AArch64 Predicate-as-Counter Type"
msgstr ""

#: ../../../AArch64SME.rst:0
msgid "Overview"
msgstr "概覽"

#: ../../../AArch64SME.rst:456
msgid ""
"The predicate-as-counter type represents the type of a predicate-as-counter "
"value held in a AArch64 SVE predicate register. Such a value contains "
"information about the number of active lanes, the element width and a bit "
"that tells whether the generated mask should be inverted. ACLE intrinsics "
"should be used to move the predicate-as-counter value to/from a predicate "
"vector."
msgstr ""

#: ../../../AArch64SME.rst:462
msgid "There are certain limitations on the type:"
msgstr ""

#: ../../../AArch64SME.rst:464
msgid "The type can be used for function parameters and return values."
msgstr ""

#: ../../../AArch64SME.rst:466
msgid ""
"The supported LLVM operations on this type are limited to ``load``, "
"``store``, ``phi``, ``select`` and ``alloca`` instructions."
msgstr ""

#: ../../../AArch64SME.rst:469
msgid "The predicate-as-counter type is a scalable type."
msgstr ""

#: ../../../AArch64SME.rst:0
msgid "Syntax"
msgstr ""

#: ../../../AArch64SME.rst:480
msgid "5. References"
msgstr ""

#: ../../../AArch64SME.rst:484
msgid ""
"`SME ACLE Pull-request <https://github.com/ARM-software/acle/pull/188>`__"
msgstr ""

#: ../../../AArch64SME.rst:488
msgid ""
"`SME ABI Pull-request <https://github.com/ARM-software/abi-aa/pull/123>`__"
msgstr ""
