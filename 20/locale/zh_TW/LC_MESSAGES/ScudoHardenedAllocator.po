# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ScudoHardenedAllocator.rst:3
msgid "Scudo Hardened Allocator"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:10
msgid "Introduction"
msgstr "簡介"

#: ../../../ScudoHardenedAllocator.rst:12
msgid ""
"The Scudo Hardened Allocator is a user-mode allocator, originally based on "
"LLVM Sanitizers' `CombinedAllocator <https://github.com/llvm/llvm-project/"
"blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined."
"h>`_. It aims at providing additional mitigation against heap based "
"vulnerabilities, while maintaining good performance. Scudo is currently the "
"default allocator in `Fuchsia <https://fuchsia.dev/>`_, and in `Android "
"<https://www.android.com/>`_ since Android 11."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:20
msgid ""
"The name \"Scudo\" comes from the Italian word for `shield <https://www."
"collinsdictionary.com/dictionary/italian-english/scudo>`_ (and Escudo in "
"Spanish)."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:25
msgid "Design"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:28
msgid "Allocator"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:29
msgid ""
"Scudo was designed with security in mind, but aims at striking a good "
"balance between security and performance. It was designed to be highly "
"tunable and configurable, and while we provide some default configurations, "
"we encourage consumers to come up with the parameters that will work best "
"for their use cases."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:35
msgid "The allocator combines several components that serve distinct purposes:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:37
msgid ""
"the Primary allocator: fast and efficient, it services smaller allocation "
"sizes by carving reserved memory regions into blocks of identical size. "
"There are currently two Primary allocators implemented, specific to 32 and "
"64 bit architectures. It is configurable via compile time options."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:42
msgid ""
"the Secondary allocator: slower, it services larger allocation sizes via the "
"memory mapping primitives of the underlying operating system. Secondary "
"backed allocations are surrounded by Guard Pages. It is also configurable "
"via compile time options."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:47
msgid ""
"the thread specific data Registry: defines how local caches operate for each "
"thread. There are currently two models implemented: the exclusive model "
"where each thread holds its own caches (using the ELF TLS); or the shared "
"model where threads share a fixed size pool of caches."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:52
msgid ""
"the Quarantine: offers a way to delay the deallocation operations, "
"preventing blocks to be immediately available for reuse. Blocks held will be "
"recycled once certain size criteria are reached. This is essentially a "
"delayed freelist which can help mitigate some use-after-free situations. "
"This feature is fairly costly in terms of performance and memory footprint, "
"is mostly controlled by runtime options and is disabled by default."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:60
msgid "Allocations Header"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:61
msgid ""
"Every chunk of heap memory returned to an application by the allocator will "
"be preceded by a header. This has two purposes:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:64
msgid ""
"being to store various information about the chunk, that can be leveraged to "
"ensure consistency of the heap operations;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:67
msgid ""
"being able to detect potential corruption. For this purpose, the header is "
"checksummed and corruption of the header will be detected when said header "
"is accessed (note that if the corrupted header is not accessed, the "
"corruption will remain undetected)."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:72
msgid "The following information is stored in the header:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:74
msgid ""
"the class ID for that chunk, which identifies the region where the chunk "
"resides for Primary backed allocations, or 0 for Secondary backed "
"allocations;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:77
msgid "the state of the chunk (available, allocated or quarantined);"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:79
msgid ""
"the allocation type (malloc, new, new[] or memalign), to detect potential "
"mismatches in the allocation APIs used;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:82
msgid ""
"the size (Primary) or unused bytes amount (Secondary) for that chunk, which "
"is necessary for reallocation or sized-deallocation operations;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:85
msgid ""
"the offset of the chunk, which is the distance in bytes from the beginning "
"of the returned chunk to the beginning of the backend allocation (the "
"\"block\");"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:88
msgid "the 16-bit checksum;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:90
msgid ""
"This header fits within 8 bytes on all platforms supported, and contributes "
"to a small overhead for each allocation."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:93
msgid ""
"The checksum is computed using a CRC32 (made faster with hardware support) "
"of the global secret, the chunk pointer itself, and the 8 bytes of header "
"with the checksum field zeroed out. It is not intended to be "
"cryptographically strong."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:98
msgid ""
"The header is atomically loaded and stored to prevent races. This is "
"important as two consecutive chunks could belong to different threads. We "
"work on local copies and use compare-exchange primitives to update the "
"headers in the heap memory, and avoid any type of double-fetching."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:104
msgid "Randomness"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:105
msgid ""
"Randomness is a critical factor to the additional security provided by the "
"allocator. The allocator trusts the memory mapping primitives of the OS to "
"provide pages at (mostly) non-predictable locations in memory, as well as "
"the binaries to be compiled with ASLR. In the event one of those assumptions "
"is incorrect, the security will be greatly reduced. Scudo further randomizes "
"how blocks are allocated in the Primary, can randomize how caches are "
"assigned to threads."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:114
msgid "Memory reclaiming"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:115
msgid ""
"Primary and Secondary allocators have different behaviors with regard to "
"reclaiming. While Secondary mapped allocations can be unmapped on "
"deallocation, it isn't the case for the Primary, which could lead to a "
"steady growth of the RSS of a process. To counteract this, if the underlying "
"OS allows it, pages that are covered by contiguous free memory blocks in the "
"Primary can be released: this generally means they won't count towards the "
"RSS of a process and be zero filled on subsequent accesses). This is done in "
"the deallocation path, and several options exist to tune this behavior."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:125
msgid "Usage"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:128
msgid "Platform"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:129
msgid ""
"If using Fuchsia or an Android version greater than 11, your memory "
"allocations are already service by Scudo (note that Android Svelte "
"configurations still use jemalloc)."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:134
msgid "Library"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:135
msgid ""
"The allocator static library can be built from the LLVM tree thanks to the "
"``scudo_standalone`` CMake rule. The associated tests can be exercised "
"thanks to the ``check-scudo_standalone`` CMake rule."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:139
msgid ""
"Linking the static library to your project can require the use of the "
"``whole-archive`` linker flag (or equivalent), depending on your linker. "
"Additional flags might also be necessary."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:143
msgid ""
"Your linked binary should now make use of the Scudo allocation and "
"deallocation functions."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:146
msgid "You may also build Scudo like this:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:156
msgid "and then use it with existing binaries as follows:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:163
msgid "Clang"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:164
msgid ""
"With a recent version of Clang (post rL317337), the \"old\" version of the "
"allocator can be linked with a binary at compilation using the ``-"
"fsanitize=scudo`` command-line argument, if the target platform is "
"supported. Currently, the only other sanitizer Scudo is compatible with is "
"UBSan (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also "
"enforce PIE for the output binary."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:171
msgid "We will transition this to the standalone Scudo version in the future."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:174
msgid "Options"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:175
msgid ""
"Several aspects of the allocator can be configured on a per process basis "
"through the following ways:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:178
msgid ""
"at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string "
"you want set by default;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:181
msgid ""
"by defining a ``__scudo_default_options`` function in one's program that "
"returns the options string to be parsed. Said function must have the "
"following prototype: ``extern \"C\" const char* "
"__scudo_default_options(void)``, with a default visibility. This will "
"override the compile time define;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:186
msgid ""
"through the environment variable SCUDO_OPTIONS, containing the options "
"string to be parsed. Options defined this way will override any definition "
"made through ``__scudo_default_options``."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:190
msgid ""
"via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/"
"mallopt.3.html>`_, using parameters that are Scudo specific."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:193
msgid ""
"When dealing with the options string, it follows a syntax similar to ASan, "
"where distinct options can be assigned in the same string, separated by "
"colons."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:196
msgid "For example, using the environment variable:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:202
msgid "Or using the function:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:211
msgid "The following \"string\" options are available:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:214
#: ../../../ScudoHardenedAllocator.rst:278
msgid "Option"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:214
msgid "Default"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:214
#: ../../../ScudoHardenedAllocator.rst:278
msgid "Description"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:216
msgid "quarantine_size_kb"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:216
#: ../../../ScudoHardenedAllocator.rst:224
#: ../../../ScudoHardenedAllocator.rst:227
msgid "0"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:216
msgid ""
"The size (in Kb) of quarantine used to delay the actual deallocation of "
"chunks. Lower value may reduce memory usage but decrease the effectiveness "
"of the mitigation; a negative value will fallback to the defaults. Setting "
"*both* this and thread_local_quarantine_size_kb to zero will disable the "
"quarantine entirely."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:224
msgid "quarantine_max_chunk_size"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:224
msgid "Size (in bytes) up to which chunks can be quarantined."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:227
msgid "thread_local_quarantine_size_kb"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:227
msgid ""
"The size (in Kb) of per-thread cache use to offload the global quarantine. "
"Lower value may reduce memory usage but might increase contention on the "
"global quarantine. Setting *both* this and quarantine_size_kb to zero will "
"disable the quarantine entirely."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:234
msgid "dealloc_type_mismatch"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:234
#: ../../../ScudoHardenedAllocator.rst:240
#: ../../../ScudoHardenedAllocator.rst:243
msgid "false"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:234
msgid ""
"Whether or not we report errors on malloc/delete, new/free, new/delete[], "
"etc."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:237
msgid "delete_size_mismatch"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:237
#: ../../../ScudoHardenedAllocator.rst:246
msgid "true"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:237
msgid ""
"Whether or not we report errors on mismatch between sizes of new and delete."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:240
msgid "zero_contents"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:240
msgid "Whether or not we zero chunk contents on allocation."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:243
msgid "pattern_fill_contents"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:243
msgid ""
"Whether or not we fill chunk contents with a byte pattern on allocation."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:246
msgid "may_return_null"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:246
msgid ""
"Whether or not a non-fatal failure can return a NULL pointer (as opposed to "
"terminating)."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:249
msgid "release_to_os_interval_ms"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:249
msgid "5000"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:249
msgid ""
"The minimum interval (in ms) at which a release can be attempted (a negative "
"value disables reclaiming)."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:253
msgid "allocation_ring_buffer_size"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:253
msgid "32768"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:253
msgid ""
"If stack trace collection is requested, how many previous allocations to "
"keep in the allocation ring buffer."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:257
msgid ""
"This buffer is used to provide allocation and deallocation stack traces for "
"MTE fault reports. The larger the buffer, the more unrelated allocations can "
"happen between (de)allocation and the fault. If your sync-mode MTE faults do "
"not have (de)allocation stack traces, try increasing the buffer size."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:266
msgid ""
"Stack trace collection can be requested using the "
"scudo_malloc_set_track_allocation_stacks function."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:271
msgid ""
"Additional flags can be specified, for example if Scudo if compiled with "
"`GWP-ASan <https://llvm.org/docs/GwpAsan.html>`_ support."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:274
msgid ""
"The following \"mallopt\" options are available (options are defined in "
"``include/scudo/interface.h``):"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:280
msgid "M_DECAY_TIME"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:280
msgid ""
"Sets the release interval option to the specified value (Android only allows "
"0 or 1 to respectively set the interval to the minimum and maximum value as "
"specified at compile time)."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:285
msgid "M_PURGE"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:285
msgid ""
"Forces immediate memory reclaiming but does not reclaim everything. For "
"smaller size classes, there is still some memory that is not reclaimed due "
"to the extra time it takes and the small amount of memory that can be "
"reclaimed. The value is ignored."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:292
msgid "M_PURGE_ALL"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:292
msgid ""
"Same as M_PURGE but will force release all possible memory regardless of how "
"long it takes. The value is ignored."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:296
msgid "M_MEMTAG_TUNING"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:296
msgid ""
"Tunes the allocator's choice of memory tags to make it more likely that a "
"certain class of memory errors will be detected. The value argument should "
"be one of the enumerators of ``scudo_memtag_tuning``."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:301
msgid "M_THREAD_DISABLE_MEM_INIT"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:301
msgid ""
"Tunes the per-thread memory initialization, 0 being the normal behavior, 1 "
"disabling the automatic heap initialization."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:305
msgid "M_CACHE_COUNT_MAX"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:305
msgid ""
"Set the maximum number of entries than can be cached in the Secondary cache."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:308
msgid "M_CACHE_SIZE_MAX"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:308
msgid ""
"Sets the maximum size of entries that can be cached in the Secondary cache."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:311
msgid "M_TSDS_COUNT_MAX"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:311
msgid ""
"Increases the maximum number of TSDs that can be used up to the limit "
"specified at compile time."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:316
msgid "Error Types"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:318
msgid ""
"The allocator will output an error message, and potentially terminate the "
"process, when an unexpected behavior is detected. The output usually starts "
"with ``\"Scudo ERROR:\"`` followed by a short summary of the problem that "
"occurred as well as the pointer(s) involved. Once again, Scudo is meant to "
"be a mitigation, and might not be the most useful of tools to help you root-"
"cause the issue, please consider `ASan <https://github.com/google/sanitizers/"
"wiki/AddressSanitizer>`_ for this purpose."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:326
msgid "Here is a list of the current error messages and their potential cause:"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:328
msgid ""
"``\"corrupted chunk header\"``: the checksum verification of the chunk "
"header has failed. This is likely due to one of two things: the header was "
"overwritten (partially or totally), or the pointer passed to the function is "
"not a chunk at all;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:333
msgid ""
"``\"race on chunk header\"``: two different threads are attempting to "
"manipulate the same header at the same time. This is usually symptomatic of "
"a race-condition or general lack of locking when performing operations on "
"that chunk;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:338
msgid ""
"``\"invalid chunk state\"``: the chunk is not in the expected state for a "
"given operation, eg: it is not allocated when trying to free it, or it's not "
"quarantined when trying to recycle it, etc. A double-free is the typical "
"reason this error would occur;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:343
msgid ""
"``\"misaligned pointer\"``: we strongly enforce basic alignment "
"requirements, 8 bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If "
"a pointer passed to our functions does not fit those, something is "
"definitely wrong."
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:347
msgid ""
"``\"allocation type mismatch\"``: when the optional deallocation type "
"mismatch check is enabled, a deallocation function called on a chunk has to "
"match the type of function that was called to allocate it. Security "
"implications of such a mismatch are not necessarily obvious but situational "
"at best;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:352
msgid ""
"``\"invalid sized delete\"``: when the C++14 sized delete operator is used, "
"and the optional check enabled, this indicates that the size passed when "
"deallocating a chunk is not congruent with the one requested when allocating "
"it. This is likely to be a `compiler issue <https://software.intel.com/en-us/"
"forums/intel-c-compiler/topic/783942>`_, as was the case with Intel C++ "
"Compiler, or some type confusion on the object being deallocated;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:359
msgid ""
"``\"RSS limit exhausted\"``: the maximum RSS optionally specified has been "
"exceeded;"
msgstr ""

#: ../../../ScudoHardenedAllocator.rst:362
msgid ""
"Several other error messages relate to parameter checking on the libc "
"allocation APIs and are fairly straightforward to understand."
msgstr ""
