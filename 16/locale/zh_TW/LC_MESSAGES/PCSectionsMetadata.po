# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../PCSectionsMetadata.rst:3
msgid "LLVM PC Sections Metadata"
msgstr ""

#: ../../../PCSectionsMetadata.rst:9
msgid "Introduction"
msgstr "簡介"

#: ../../../PCSectionsMetadata.rst:11
msgid ""
"PC Sections Metadata can be attached to instructions and functions, for "
"which addresses, viz. program counters (PCs), are to be emitted in specially "
"encoded binary sections. Metadata is assigned as an ``MDNode`` of the "
"``MD_pcsections`` (``!pcsections``) kind; the following section describes "
"the metadata format."
msgstr ""

#: ../../../PCSectionsMetadata.rst:17
msgid "Metadata Format"
msgstr ""

#: ../../../PCSectionsMetadata.rst:19
msgid ""
"An arbitrary number of interleaved ``MDString`` and constant operators can "
"be added, where a new ``MDString`` always denotes a section name, followed "
"by an arbitrary number of auxiliary constant data encoded along the PC of "
"the instruction or function. The first operator must be a ``MDString`` "
"denoting the first section."
msgstr ""

#: ../../../PCSectionsMetadata.rst:38
msgid ""
"The occurrence of ``section#1``, ``section#2``, ..., ``section#N`` in the "
"metadata causes the backend to emit the PC for the associated instruction or "
"function to all named sections. For each emitted PC in a section #N, the "
"constants ``aux-consts#N`` in the tuple ``!N`` will be emitted after the PC. "
"Multiple tuples with constant data may be provided after a section name "
"string (e.g. ``!0 = !{\"s1\", !1, !2}``), and a single constant tuple may be "
"reused for different sections (e.g. ``!0 = !{\"s1\", !1, \"s2\", !1}``)."
msgstr ""

#: ../../../PCSectionsMetadata.rst:47
msgid "Binary Encoding"
msgstr ""

#: ../../../PCSectionsMetadata.rst:49
msgid ""
"*Instructions* result in emitting a single PC, and *functions* result in "
"emission of the start of the function and a 32-bit size. This is followed by "
"the auxiliary constants that followed the respective section name in the "
"``MD_pcsections`` metadata."
msgstr ""

#: ../../../PCSectionsMetadata.rst:54
msgid ""
"To avoid relocations in the final binary, each PC address stored at "
"``entry`` is a relative relocation, computed as ``pc - entry``. To decode, a "
"user has to compute ``entry + *entry``."
msgstr ""

#: ../../../PCSectionsMetadata.rst:58
msgid ""
"The size of each entry depends on the code model. With large and medium "
"sized code models, the entry size matches pointer size. For any smaller code "
"model the entry size is just 32 bits."
msgstr ""

#: ../../../PCSectionsMetadata.rst:63
msgid "Guarantees on Code Generation"
msgstr ""

#: ../../../PCSectionsMetadata.rst:65
msgid ""
"Attaching ``!pcsections`` metadata to LLVM IR instructions *shall not* "
"affect optimizations or code generation outside the requested PC sections."
msgstr ""

#: ../../../PCSectionsMetadata.rst:68
msgid ""
"While relying on LLVM IR metadata to request PC sections makes the above "
"guarantee relatively trivial, propagation of metadata through the "
"optimization and code generation pipeline has the following guarantees."
msgstr ""

#: ../../../PCSectionsMetadata.rst:73
msgid "Metadata Propagation"
msgstr ""

#: ../../../PCSectionsMetadata.rst:75
msgid ""
"In general, LLVM *does not make any guarantees* about preserving IR metadata "
"(attached to an ``Instruction``) through IR transformations. When using PC "
"sections metadata, this guarantee is unchanged, and ``!pcsections`` metadata "
"is remains *optional* until lowering to machine IR (MIR)."
msgstr ""

#: ../../../PCSectionsMetadata.rst:81
msgid "Note for Code Generation"
msgstr ""

#: ../../../PCSectionsMetadata.rst:83
msgid ""
"As with other LLVM IR metadata, there are no requirements for LLVM IR "
"transformation passes to preserve ``!pcsections`` metadata, with the "
"following exceptions:"
msgstr ""

#: ../../../PCSectionsMetadata.rst:87
msgid ""
"The ``AtomicExpandPass`` shall preserve ``!pcsections`` metadata according "
"to the below rules 1-4."
msgstr ""

#: ../../../PCSectionsMetadata.rst:90
msgid ""
"When translating LLVM IR to MIR, the ``!pcsections`` metadata shall be "
"copied from the source ``Instruction`` to the target ``MachineInstr`` (set "
"with ``MachineInstr::setPCSections()``). The instruction selectors and MIR "
"optimization passes shall preserve PC sections metadata as follows:"
msgstr ""

#: ../../../PCSectionsMetadata.rst:95
msgid ""
"Replacements will preserve PC sections metadata of the replaced instruction."
msgstr ""

#: ../../../PCSectionsMetadata.rst:98
msgid ""
"Duplications will preserve PC sections metadata of the copied instruction."
msgstr ""

#: ../../../PCSectionsMetadata.rst:101
msgid ""
"Merging will preserve PC sections metadata of one of the two instructions "
"(no guarantee on which instruction's metadata is used)."
msgstr ""

#: ../../../PCSectionsMetadata.rst:104
msgid "Deletions will loose PC sections metadata."
msgstr ""

#: ../../../PCSectionsMetadata.rst:106
msgid ""
"This is similar to debug info, and the ``BuildMI()`` helper provides a "
"convenient way to propagate debug info and ``!pcsections`` metadata in the "
"``MIMetadata`` bundle."
msgstr ""

#: ../../../PCSectionsMetadata.rst:111
msgid "Note for Metadata Users"
msgstr ""

#: ../../../PCSectionsMetadata.rst:113
msgid ""
"Use cases for ``!pcsections`` metadata should either be fully tolerant to "
"missing metadata, or the passes inserting ``!pcsections`` metadata should "
"run *after* all LLVM IR optimization passes to preserve the metadata until "
"being translated to MIR."
msgstr ""
