# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../PDB/TpiStream.rst:3
msgid "The PDB TPI and IPI Streams"
msgstr ""

#: ../../../PDB/TpiStream.rst:11
msgid "Introduction"
msgstr ""

#: ../../../PDB/TpiStream.rst:13
msgid ""
"The PDB TPI Stream (Index 2) and IPI Stream (Index 4) contain information "
"about all types used in the program.  It is organized as a :ref:`header "
"<tpi_header>` followed by a list of :doc:`CodeView Type Records "
"<CodeViewTypes>`.  Types are referenced from various streams and records "
"throughout the PDB by their :ref:`type index <type_indices>`.  In general, "
"the sequence of type records following the :ref:`header <tpi_header>` forms "
"a topologically sorted DAG (directed acyclic graph), which means that a type "
"record B can only refer to the type A if ``A.TypeIndex < B.TypeIndex``.  "
"While there are rare cases where this property will not hold (particularly "
"when dealing with object files compiled with MASM), an implementation should "
"try very hard to make this property hold, as it means the entire type graph "
"can be constructed in a single pass."
msgstr ""

#: ../../../PDB/TpiStream.rst:27
msgid "Type records form a topologically sorted DAG (directed acyclic graph)."
msgstr ""

#: ../../../PDB/TpiStream.rst:32
msgid "TPI vs IPI Stream"
msgstr ""

#: ../../../PDB/TpiStream.rst:34
msgid ""
"Recent versions of the PDB format (aka all versions covered by this "
"document) have 2 streams with identical layout, henceforth referred to as "
"the TPI stream and IPI stream.  Subsequent contents of this document "
"describing the on-disk format apply equally whether it is for the TPI Stream "
"or the IPI Stream.  The only difference between the two is in *which* "
"CodeView records are allowed to appear in each one, summarized by the "
"following table:"
msgstr ""

#: ../../../PDB/TpiStream.rst:42
msgid "TPI Stream"
msgstr ""

#: ../../../PDB/TpiStream.rst:42
msgid "IPI Stream"
msgstr ""

#: ../../../PDB/TpiStream.rst:44
msgid "LF_POINTER"
msgstr ""

#: ../../../PDB/TpiStream.rst:44
msgid "LF_FUNC_ID"
msgstr ""

#: ../../../PDB/TpiStream.rst:46
msgid "LF_MODIFIER"
msgstr ""

#: ../../../PDB/TpiStream.rst:46
msgid "LF_MFUNC_ID"
msgstr ""

#: ../../../PDB/TpiStream.rst:48
msgid "LF_PROCEDURE"
msgstr ""

#: ../../../PDB/TpiStream.rst:48
msgid "LF_BUILDINFO"
msgstr ""

#: ../../../PDB/TpiStream.rst:50
msgid "LF_MFUNCTION"
msgstr ""

#: ../../../PDB/TpiStream.rst:50
msgid "LF_SUBSTR_LIST"
msgstr ""

#: ../../../PDB/TpiStream.rst:52
msgid "LF_LABEL"
msgstr ""

#: ../../../PDB/TpiStream.rst:52
msgid "LF_STRING_ID"
msgstr ""

#: ../../../PDB/TpiStream.rst:54
msgid "LF_ARGLIST"
msgstr ""

#: ../../../PDB/TpiStream.rst:54
msgid "LF_UDT_SRC_LINE"
msgstr ""

#: ../../../PDB/TpiStream.rst:56
msgid "LF_FIELDLIST"
msgstr ""

#: ../../../PDB/TpiStream.rst:56
msgid "LF_UDT_MOD_SRC_LINE"
msgstr ""

#: ../../../PDB/TpiStream.rst:58
msgid "LF_ARRAY"
msgstr ""

#: ../../../PDB/TpiStream.rst:60
msgid "LF_CLASS"
msgstr ""

#: ../../../PDB/TpiStream.rst:62
msgid "LF_STRUCTURE"
msgstr ""

#: ../../../PDB/TpiStream.rst:64
msgid "LF_INTERFACE"
msgstr ""

#: ../../../PDB/TpiStream.rst:66
msgid "LF_UNION"
msgstr ""

#: ../../../PDB/TpiStream.rst:68
msgid "LF_ENUM"
msgstr ""

#: ../../../PDB/TpiStream.rst:70
msgid "LF_TYPESERVER2"
msgstr ""

#: ../../../PDB/TpiStream.rst:72
msgid "LF_VFTABLE"
msgstr ""

#: ../../../PDB/TpiStream.rst:74
msgid "LF_VTSHAPE"
msgstr ""

#: ../../../PDB/TpiStream.rst:76
msgid "LF_BITFIELD"
msgstr ""

#: ../../../PDB/TpiStream.rst:78
msgid "LF_METHODLIST"
msgstr ""

#: ../../../PDB/TpiStream.rst:80
msgid "LF_PRECOMP"
msgstr ""

#: ../../../PDB/TpiStream.rst:82
msgid "LF_ENDPRECOMP"
msgstr ""

#: ../../../PDB/TpiStream.rst:85
msgid ""
"The usage of these records is described in more detail in :doc:`CodeView "
"Type Records <CodeViewTypes>`."
msgstr ""

#: ../../../PDB/TpiStream.rst:91
msgid "Type Indices"
msgstr ""

#: ../../../PDB/TpiStream.rst:93
msgid ""
"A type index is a 32-bit integer that uniquely identifies a type inside of "
"an object file's ``.debug$T`` section or a PDB file's TPI or IPI stream.  "
"The value of the type index for the first type record from the TPI stream is "
"given by the ``TypeIndexBegin`` member of the :ref:`TPI Stream Header "
"<tpi_header>` although in practice this value is always equal to 0x1000 "
"(4096)."
msgstr ""

#: ../../../PDB/TpiStream.rst:99
msgid ""
"Any type index with a high bit set is considered to come from the IPI "
"stream, although this appears to be more of a hack, and LLVM does not "
"generate type indices of this nature.  They can, however, be observed in "
"Microsoft PDBs occasionally, so one should be prepared to handle them.  Note "
"that having the high bit set is not a necessary condition to determine "
"whether a type index comes from the IPI stream, it is only sufficient."
msgstr ""

#: ../../../PDB/TpiStream.rst:106
msgid ""
"Once the high bit is cleared, any type index >= ``TypeIndexBegin`` is "
"presumed to come from the appropriate stream, and any type index less than "
"this is a bitmask which can be decomposed as follows:"
msgstr ""

#: ../../../PDB/TpiStream.rst:118
msgid "**Kind** - A value from the following enum:"
msgstr ""

#: ../../../PDB/TpiStream.rst:178
msgid "**Mode** - A value from the following enum:"
msgstr ""

#: ../../../PDB/TpiStream.rst:193
msgid ""
"Note that for pointers, the bitness is represented in the mode.  So a "
"``void*`` would have a type index with ``Mode=NearPointer32, Kind=Void`` if "
"built for 32-bits but a type index with ``Mode=NearPointer64, Kind=Void`` if "
"built for 64-bits."
msgstr ""

#: ../../../PDB/TpiStream.rst:198
msgid ""
"By convention, the type index for ``std::nullptr_t`` is constructed the same "
"way as the type index for ``void*``, but using the bitless enumeration value "
"``NearPointer``."
msgstr ""

#: ../../../PDB/TpiStream.rst:205
msgid "Stream Header"
msgstr ""

#: ../../../PDB/TpiStream.rst:206
msgid "At offset 0 of the TPI Stream is a header with the following layout:"
msgstr ""

#: ../../../PDB/TpiStream.rst:232
msgid "**Version** - A value from the following enum."
msgstr ""

#: ../../../PDB/TpiStream.rst:244
msgid ""
"Similar to the :doc:`PDB Stream <PdbStream>`, this value always appears to "
"be ``V80``, and no other values have been observed.  It is assumed that "
"should another value be observed, the layout described by this document may "
"not be accurate."
msgstr ""

#: ../../../PDB/TpiStream.rst:249
msgid "**HeaderSize** - ``sizeof(TpiStreamHeader)``"
msgstr ""

#: ../../../PDB/TpiStream.rst:251
msgid ""
"**TypeIndexBegin** - The numeric value of the type index representing the "
"first type record in the TPI stream.  This is usually the value 0x1000 as "
"type indices lower than this are reserved (see :ref:`Type Indices "
"<type_indices>` for a discussion of reserved type indices)."
msgstr ""

#: ../../../PDB/TpiStream.rst:257
msgid ""
"**TypeIndexEnd** - One greater than the numeric value of the type index "
"representing the last type record in the TPI stream.  The total number of "
"type records in the TPI stream can be computed as ``TypeIndexEnd - "
"TypeIndexBegin``."
msgstr ""

#: ../../../PDB/TpiStream.rst:262
msgid ""
"**TypeRecordBytes** - The number of bytes of type record data following the "
"header."
msgstr ""

#: ../../../PDB/TpiStream.rst:265
msgid ""
"**HashStreamIndex** - The index of a stream which contains a list of hashes "
"for every type record.  This value may be -1, indicating that hash "
"information is not present.  In practice a valid stream index is always "
"observed, so any producer implementation should be prepared to emit this "
"stream to ensure compatibility with tools which may expect it to be present."
msgstr ""

#: ../../../PDB/TpiStream.rst:271
msgid ""
"**HashAuxStreamIndex** - Presumably the index of a stream which contains a "
"separate hash table, although this has not been observed in practice and "
"it's unclear what it might be used for."
msgstr ""

#: ../../../PDB/TpiStream.rst:275
msgid "**HashKeySize** - The size of a hash value (usually 4 bytes)."
msgstr ""

#: ../../../PDB/TpiStream.rst:277
msgid ""
"**NumHashBuckets** - The number of buckets used to generate the hash values "
"in the aforementioned hash streams."
msgstr ""

#: ../../../PDB/TpiStream.rst:280
msgid ""
"**HashValueBufferOffset / HashValueBufferLength** - The offset and size "
"within the TPI Hash Stream of the list of hash values.  It should be assumed "
"that there are either 0 hash values, or a number equal to the number of type "
"records in the TPI stream (``TypeIndexEnd - TypeEndBegin``).  Thus, if "
"``HashBufferLength`` is not equal to ``(TypeIndexEnd - TypeEndBegin) * "
"HashKeySize`` we can consider the PDB malformed."
msgstr ""

#: ../../../PDB/TpiStream.rst:287
msgid ""
"**IndexOffsetBufferOffset / IndexOffsetBufferLength** - The offset and size "
"within the TPI Hash Stream of the Type Index Offsets Buffer.  This is a list "
"of pairs of uint32_t's where the first value is a :ref:`Type Index "
"<type_indices>` and the second value is the offset in the type record data "
"of the type with this index.  This can be used to do a binary search "
"followed by a linear search to get O(log n) lookup by type index."
msgstr ""

#: ../../../PDB/TpiStream.rst:294
msgid ""
"**HashAdjBufferOffset / HashAdjBufferLength** - The offset and size within "
"the TPI hash stream of a serialized hash table whose keys are the hash "
"values in the hash value buffer and whose values are type indices.  This "
"appears to be useful in incremental linking scenarios, so that if a type is "
"modified an entry can be created mapping the old hash value to the new type "
"index so that a PDB file consumer can always have the most up to date "
"version of the type without forcing the incremental linker to garbage "
"collect and update references that point to the old version to now point to "
"the new version. The layout of this hash table is described in :doc:"
"`HashTable`."
msgstr ""

#: ../../../PDB/TpiStream.rst:307
msgid "CodeView Type Record List"
msgstr ""

#: ../../../PDB/TpiStream.rst:308
msgid ""
"Following the header, there are ``TypeRecordBytes`` bytes of data that "
"represent a variable length array of :doc:`CodeView type records "
"<CodeViewTypes>`.  The number of such records (e.g. the length of the array) "
"can be determined by computing the value ``Header.TypeIndexEnd - Header."
"TypeIndexBegin``."
msgstr ""

#: ../../../PDB/TpiStream.rst:314
msgid ""
"O(log(n)) access is provided by way of the Type Index Offsets array (if "
"present) described previously."
msgstr ""
