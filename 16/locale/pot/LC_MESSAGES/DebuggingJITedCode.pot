# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../DebuggingJITedCode.rst:3
msgid "Debugging JIT-ed Code"
msgstr ""

#: ../../../DebuggingJITedCode.rst:6
msgid "Background"
msgstr ""

#: ../../../DebuggingJITedCode.rst:8
msgid ""
"Without special runtime support, debugging dynamically generated code can be "
"quite painful.  Debuggers generally read debug information from object files "
"on disk, but for JITed code there is no such file to look for."
msgstr ""

#: ../../../DebuggingJITedCode.rst:12
msgid ""
"In order to hand over the necessary debug info, `GDB established an "
"interface <https://sourceware.org/gdb/current/onlinedocs/gdb/JIT-Interface."
"html>`_ for registering JITed code with debuggers. LLDB implements it in the "
"JITLoaderGDB plugin.  On the JIT side, LLVM MCJIT does implement the "
"interface for ELF object files."
msgstr ""

#: ../../../DebuggingJITedCode.rst:18
msgid ""
"At a high level, whenever MCJIT generates new machine code, it does so in an "
"in-memory object file that contains the debug information in DWARF format. "
"MCJIT then adds this in-memory object file to a global list of dynamically "
"generated object files and calls a special function "
"``__jit_debug_register_code`` that the debugger knows about. When the "
"debugger attaches to a process, it puts a breakpoint in this function and "
"associates a special handler with it.  Once MCJIT calls the registration "
"function, the debugger catches the breakpoint signal, loads the new object "
"file from the inferior's memory and resumes execution.  This way it can "
"obtain debug information for pure in-memory object files."
msgstr ""

#: ../../../DebuggingJITedCode.rst:31
msgid "GDB Version"
msgstr ""

#: ../../../DebuggingJITedCode.rst:33
msgid ""
"In order to debug code JIT-ed by LLVM, you need GDB 7.0 or newer, which is "
"available on most modern distributions of Linux.  The version of GDB that "
"Apple ships with Xcode has been frozen at 6.3 for a while."
msgstr ""

#: ../../../DebuggingJITedCode.rst:39
msgid "LLDB Version"
msgstr ""

#: ../../../DebuggingJITedCode.rst:41
msgid ""
"Due to a regression in release 6.0, LLDB didn't support JITed code debugging "
"for a while.  The bug was fixed in mainline recently, so that debugging "
"JITed ELF objects should be possible again from the upcoming release 12.0 "
"on. On macOS the feature must be enabled explicitly using the ``plugin.jit-"
"loader.gdb.enable`` setting."
msgstr ""

#: ../../../DebuggingJITedCode.rst:49
msgid "Debugging MCJIT-ed code"
msgstr ""

#: ../../../DebuggingJITedCode.rst:51
msgid ""
"The emerging MCJIT component of LLVM allows full debugging of JIT-ed code "
"with GDB.  This is due to MCJIT's ability to use the MC emitter to provide "
"full DWARF debugging information to GDB."
msgstr ""

#: ../../../DebuggingJITedCode.rst:55
msgid ""
"Note that lli has to be passed the ``--jit-kind=mcjit`` flag to JIT the code "
"with MCJIT instead of the newer ORC JIT."
msgstr ""

#: ../../../DebuggingJITedCode.rst:59
msgid "Example"
msgstr ""

#: ../../../DebuggingJITedCode.rst:61
msgid ""
"Consider the following C code (with line numbers added to make the example "
"easier to follow):"
msgstr ""

#: ../../../DebuggingJITedCode.rst:96
msgid ""
"Here is a sample command line session that shows how to build and run this "
"code via ``lli`` inside LLDB:"
msgstr ""
