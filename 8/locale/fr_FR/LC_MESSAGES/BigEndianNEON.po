# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../BigEndianNEON.rst:3
msgid "Using ARM NEON instructions in big endian mode"
msgstr ""

#: ../../../BigEndianNEON.rst:9
msgid "Introduction"
msgstr ""

#: ../../../BigEndianNEON.rst:11
msgid ""
"Generating code for big endian ARM processors is for the most part "
"straightforward. NEON loads and stores however have some interesting "
"properties that make code generation decisions less obvious in big endian "
"mode."
msgstr ""

#: ../../../BigEndianNEON.rst:13
msgid ""
"The aim of this document is to explain the problem with NEON loads and "
"stores, and the solution that has been implemented in LLVM."
msgstr ""

#: ../../../BigEndianNEON.rst:15
msgid ""
"In this document the term \"vector\" refers to what the ARM ABI calls a "
"\"short vector\", which is a sequence of items that can fit in a NEON "
"register. This sequence can be 64 or 128 bits in length, and can constitute "
"8, 16, 32 or 64 bit items. This document refers to A64 instructions "
"throughout, but is almost applicable to the A32/ARMv7 instruction sets also. "
"The ABI format for passing vectors in A32 is sligtly different to A64. Apart "
"from that, the same concepts apply."
msgstr ""

#: ../../../BigEndianNEON.rst:18
msgid "Example: C-level intrinsics -> assembly"
msgstr ""

#: ../../../BigEndianNEON.rst:20
msgid ""
"It may be helpful first to illustrate how C-level ARM NEON intrinsics are "
"lowered to instructions."
msgstr ""

#: ../../../BigEndianNEON.rst:22
msgid ""
"This trivial C function takes a vector of four ints and sets the zero'th "
"lane to the value \"42\"::"
msgstr ""

#: ../../../BigEndianNEON.rst:29
msgid ""
"arm_neon.h intrinsics generate \"generic\" IR where possible (that is, "
"normal IR instructions not ``llvm.arm.neon.*`` intrinsic calls). The above "
"generates::"
msgstr ""

#: ../../../BigEndianNEON.rst:36
msgid "Which then becomes the following trivial assembly::"
msgstr ""

#: ../../../BigEndianNEON.rst:44
msgid "Problem"
msgstr ""

#: ../../../BigEndianNEON.rst:46
msgid ""
"The main problem is how vectors are represented in memory and in registers."
msgstr ""

#: ../../../BigEndianNEON.rst:48
msgid ""
"First, a recap. The \"endianness\" of an item affects its representation in "
"memory only. In a register, a number is just a sequence of bits - 64 bits in "
"the case of AArch64 general purpose registers. Memory, however, is a "
"sequence of addressable units of 8 bits in size. Any number greater than 8 "
"bits must therefore be split up into 8-bit chunks, and endianness describes "
"the order in which these chunks are laid out in memory."
msgstr ""

#: ../../../BigEndianNEON.rst:50
msgid ""
"A \"little endian\" layout has the least significant byte first (lowest in "
"memory address). A \"big endian\" layout has the *most* significant byte "
"first. This means that when loading an item from big endian memory, the "
"lowest 8-bits in memory must go in the most significant 8-bits, and so forth."
msgstr ""

#: ../../../BigEndianNEON.rst:53
msgid "``LDR`` and ``LD1``"
msgstr ""

#: ../../../BigEndianNEON.rst:58
msgid "Big endian vector load using ``LDR``."
msgstr ""

#: ../../../BigEndianNEON.rst:61
msgid ""
"A vector is a consecutive sequence of items that are operated on "
"simultaneously. To load a 64-bit vector, 64 bits need to be read from "
"memory. In little endian mode, we can do this by just performing a 64-bit "
"load - ``LDR q0, [foo]``. However if we try this in big endian mode, because "
"of the byte swapping the lane indices end up being swapped! The zero'th item "
"as laid out in memory becomes the n'th lane in the vector."
msgstr ""

#: ../../../BigEndianNEON.rst:66
msgid ""
"Big endian vector load using ``LD1``. Note that the lanes retain the correct "
"ordering."
msgstr ""

#: ../../../BigEndianNEON.rst:69
msgid ""
"Because of this, the instruction ``LD1`` performs a vector load but performs "
"byte swapping not on the entire 64 bits, but on the individual items within "
"the vector. This means that the register content is the same as it would "
"have been on a little endian system."
msgstr ""

#: ../../../BigEndianNEON.rst:71
msgid ""
"It may seem that ``LD1`` should suffice to peform vector loads on a big "
"endian machine. However there are pros and cons to the two approaches that "
"make it less than simple which register format to pick."
msgstr ""

#: ../../../BigEndianNEON.rst:73
msgid "There are two options:"
msgstr ""

#: ../../../BigEndianNEON.rst:75
msgid ""
"The content of a vector register is the same *as if* it had been loaded with "
"an ``LDR`` instruction."
msgstr ""

#: ../../../BigEndianNEON.rst:76
msgid ""
"The content of a vector register is the same *as if* it had been loaded with "
"an ``LD1`` instruction."
msgstr ""

#: ../../../BigEndianNEON.rst:78
msgid ""
"Because ``LD1 == LDR + REV`` and similarly ``LDR == LD1 + REV`` (on a big "
"endian system), we can simulate either type of load with the other type of "
"load plus a ``REV`` instruction. So we're not deciding which instructions to "
"use, but which format to use (which will then influence which instruction is "
"best to use)."
msgstr ""

#: ../../../BigEndianNEON.rst:84
msgid ""
"Note that throughout this section we only mention loads. Stores have exactly "
"the same problems as their associated loads, so have been skipped for "
"brevity."
msgstr ""

#: ../../../BigEndianNEON.rst:88
msgid "Considerations"
msgstr ""

#: ../../../BigEndianNEON.rst:91
msgid "LLVM IR Lane ordering"
msgstr ""

#: ../../../BigEndianNEON.rst:93
msgid ""
"LLVM IR has first class vector types. In LLVM IR, the zero'th element of a "
"vector resides at the lowest memory address. The optimizer relies on this "
"property in certain areas, for example when concatenating vectors together. "
"The intention is for arrays and vectors to have identical memory layouts - "
"``[4 x i8]`` and ``<4 x i8>`` should be represented the same in memory. "
"Without this property there would be many special cases that the optimizer "
"would have to cleverly handle."
msgstr ""

#: ../../../BigEndianNEON.rst:95
msgid ""
"Use of ``LDR`` would break this lane ordering property. This doesn't "
"preclude the use of ``LDR``, but we would have to do one of two things:"
msgstr ""

#: ../../../BigEndianNEON.rst:97
msgid ""
"Insert a ``REV`` instruction to reverse the lane order after every ``LDR``."
msgstr ""

#: ../../../BigEndianNEON.rst:98
msgid ""
"Disable all optimizations that rely on lane layout, and for every access to "
"an individual lane (``insertelement``/``extractelement``/``shufflevector``) "
"reverse the lane index."
msgstr ""

#: ../../../BigEndianNEON.rst:101 ../../../BigEndianNEON.rst:147
msgid "AAPCS"
msgstr ""

#: ../../../BigEndianNEON.rst:103
msgid ""
"The ARM procedure call standard (AAPCS) defines the ABI for passing vectors "
"between functions in registers. It states:"
msgstr ""

#: ../../../BigEndianNEON.rst:105
msgid ""
"When a short vector is transferred between registers and memory it is "
"treated as an opaque object. That is a short vector is stored in memory as "
"if it were stored with a single ``STR`` of the entire register; a short "
"vector is loaded from memory using the corresponding ``LDR`` instruction. On "
"a little-endian system this means that element 0 will always contain the "
"lowest addressed element of a short vector; on a big-endian system element 0 "
"will contain the highest-addressed element of a short vector."
msgstr ""

#: ../../../BigEndianNEON.rst:107
msgid ""
"Procedure Call Standard for the ARM 64-bit Architecture (AArch64), 4.1.2 "
"Short Vectors"
msgstr ""

#: ../../../BigEndianNEON.rst:109
msgid ""
"The use of ``LDR`` and ``STR`` as the ABI defines has at least one advantage "
"over ``LD1`` and ``ST1``. ``LDR`` and ``STR`` are oblivious to the size of "
"the individual lanes of a vector. ``LD1`` and ``ST1`` are not - the lane "
"size is encoded within them. This is important across an ABI boundary, "
"because it would become necessary to know the lane width the callee expects. "
"Consider the following code:"
msgstr ""

#: ../../../BigEndianNEON.rst:124
msgid ""
"If ``callee`` changed its signature to ``uint16x4_t``, which is equivalent "
"in register content, if we passed as ``LD1`` we'd break this code until "
"``caller`` was updated and recompiled."
msgstr ""

#: ../../../BigEndianNEON.rst:126
msgid ""
"There is an argument that if the signatures of the two functions are "
"different then the behaviour should be undefined. But there may be functions "
"that are agnostic to the lane layout of the vector, and treating the vector "
"as an opaque value (just loading it and storing it) would be impossible "
"without a common format across ABI boundaries."
msgstr ""

#: ../../../BigEndianNEON.rst:128
msgid ""
"So to preserve ABI compatibility, we need to use the ``LDR`` lane layout "
"across function calls."
msgstr ""

#: ../../../BigEndianNEON.rst:131
msgid "Alignment"
msgstr ""

#: ../../../BigEndianNEON.rst:133
msgid ""
"In strict alignment mode, ``LDR qX`` requires its address to be 128-bit "
"aligned, whereas ``LD1`` only requires it to be as aligned as the lane size. "
"If we canonicalised on using ``LDR``, we'd still need to use ``LD1`` in some "
"places to avoid alignment faults (the result of the ``LD1`` would then need "
"to be reversed with ``REV``)."
msgstr ""

#: ../../../BigEndianNEON.rst:135
msgid ""
"Most operating systems however do not run with alignment faults enabled, so "
"this is often not an issue."
msgstr ""

#: ../../../BigEndianNEON.rst:138
msgid "Summary"
msgstr ""

#: ../../../BigEndianNEON.rst:140
msgid ""
"The following table summarises the instructions that are required to be "
"emitted for each property mentioned above for each of the two solutions."
msgstr ""

#: ../../../BigEndianNEON.rst:143
msgid "``LDR`` layout"
msgstr ""

#: ../../../BigEndianNEON.rst:143
msgid "``LD1`` layout"
msgstr ""

#: ../../../BigEndianNEON.rst:145
msgid "Lane ordering"
msgstr ""

#: ../../../BigEndianNEON.rst:145
msgid "``LDR + REV``"
msgstr ""

#: ../../../BigEndianNEON.rst:145 ../../../BigEndianNEON.rst:149
msgid "``LD1``"
msgstr ""

#: ../../../BigEndianNEON.rst:147
msgid "``LDR``"
msgstr ""

#: ../../../BigEndianNEON.rst:147
msgid "``LD1 + REV``"
msgstr ""

#: ../../../BigEndianNEON.rst:149
msgid "Alignment for strict mode"
msgstr ""

#: ../../../BigEndianNEON.rst:149
msgid "``LDR`` / ``LD1 + REV``"
msgstr ""

#: ../../../BigEndianNEON.rst:152
msgid ""
"Neither approach is perfect, and choosing one boils down to choosing the "
"lesser of two evils. The issue with lane ordering, it was decided, would "
"have to change target-agnostic compiler passes and would result in a strange "
"IR in which lane indices were reversed. It was decided that this was worse "
"than the changes that would have to be made to support ``LD1``, so ``LD1`` "
"was chosen as the canonical vector load instruction (and by inference, "
"``ST1`` for vector stores)."
msgstr ""

#: ../../../BigEndianNEON.rst:155
msgid "Implementation"
msgstr ""

#: ../../../BigEndianNEON.rst:157
msgid "There are 3 parts to the implementation:"
msgstr ""

#: ../../../BigEndianNEON.rst:159
msgid ""
"Predicate ``LDR`` and ``STR`` instructions so that they are never allowed to "
"be selected to generate vector loads and stores. The exception is one-lane "
"vectors [1]_ - these by definition cannot have lane ordering problems so are "
"fine to use ``LDR``/``STR``."
msgstr ""

#: ../../../BigEndianNEON.rst:161
msgid ""
"Create code generation patterns for bitconverts that create ``REV`` "
"instructions."
msgstr ""

#: ../../../BigEndianNEON.rst:163
msgid ""
"Make sure appropriate bitconverts are created so that vector values get "
"passed over call boundaries as 1-element vectors (which is the same as if "
"they were loaded with ``LDR``)."
msgstr ""

#: ../../../BigEndianNEON.rst:166
msgid "Bitconverts"
msgstr ""

#: ../../../BigEndianNEON.rst:171
msgid ""
"The main problem with the ``LD1`` solution is dealing with bitconverts (or "
"bitcasts, or reinterpret casts). These are pseudo instructions that only "
"change the compiler's interpretation of data, not the underlying data "
"itself. A requirement is that if data is loaded and then saved again (called "
"a \"round trip\"), the memory contents should be the same after the store as "
"before the load. If a vector is loaded and is then bitconverted to a "
"different vector type before storing, the round trip will currently be "
"broken."
msgstr ""

#: ../../../BigEndianNEON.rst:173
msgid "Take for example this code sequence::"
msgstr ""

#: ../../../BigEndianNEON.rst:179
msgid ""
"This would produce a code sequence such as that in the figure on the right. "
"The mismatched ``LD1`` and ``ST1`` cause the stored data to differ from the "
"loaded data."
msgstr ""

#: ../../../BigEndianNEON.rst:183
msgid ""
"When we see a bitcast from type ``X`` to type ``Y``, what we need to do is "
"to change the in-register representation of the data to be *as if* it had "
"just been loaded by a ``LD1`` of type ``Y``."
msgstr ""

#: ../../../BigEndianNEON.rst:188
msgid ""
"Conceptually this is simple - we can insert a ``REV`` undoing the ``LD1`` of "
"type ``X`` (converting the in-register representation to the same as if it "
"had been loaded by ``LDR``) and then insert another ``REV`` to change the "
"representation to be as if it had been loaded by an ``LD1`` of type ``Y``."
msgstr ""

#: ../../../BigEndianNEON.rst:190
msgid "For the previous example, this would be::"
msgstr ""

#: ../../../BigEndianNEON.rst:202
msgid ""
"It turns out that these ``REV`` pairs can, in almost all cases, be squashed "
"together into a single ``REV``. For the example above, a ``REV128 4s`` + "
"``REV128 2d`` is actually a ``REV64 4s``, as shown in the figure on the "
"right."
msgstr ""

#: ../../../BigEndianNEON.rst:204
msgid ""
"One lane vectors may seem useless as a concept but they serve to distinguish "
"between values held in general purpose registers and values held in NEON/VFP "
"registers. For example, an ``i64`` would live in an ``x`` register, but ``<1 "
"x i64>`` would live in a ``d`` register."
msgstr ""
