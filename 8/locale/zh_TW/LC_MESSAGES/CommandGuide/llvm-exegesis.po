# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CommandGuide/llvm-exegesis.rst:2
msgid "llvm-exegesis - LLVM Machine Instruction Benchmark"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:5
msgid "SYNOPSIS"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:7
msgid ":program:`llvm-exegesis` [*options*]"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:10
msgid "DESCRIPTION"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:12
msgid ""
":program:`llvm-exegesis` is a benchmarking tool that uses information "
"available in LLVM to measure host machine instruction characteristics like "
"latency or port decomposition."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:16
msgid ""
"Given an LLVM opcode name and a benchmarking mode, :program:`llvm-exegesis` "
"generates a code snippet that makes execution as serial (resp. as parallel) "
"as possible so that we can measure the latency (resp. uop decomposition) of "
"the instruction. The code snippet is jitted and executed on the host "
"subtarget. The time taken (resp. resource usage) is measured using hardware "
"performance counters. The result is printed out as YAML to the standard "
"output."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:24
msgid ""
"The main goal of this tool is to automatically (in)validate the LLVM's "
"TableDef scheduling models. To that end, we also provide analysis of the "
"results."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:27
msgid ""
":program:`llvm-exegesis` can also benchmark arbitrary user-provided code "
"snippets."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:31
msgid "EXAMPLE 1: benchmarking instructions"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:33
msgid ""
"Assume you have an X86-64 machine. To measure the latency of a single "
"instruction, run:"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:40
msgid "Measuring the uop decomposition of an instruction works similarly:"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:46
msgid ""
"The output is a YAML document (the default is to write to stdout, but you "
"can redirect the output to a file using `-benchmarks-file`):"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:68
msgid ""
"To measure the latency of all instructions for the host architecture, run:"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:79
msgid ""
"FIXME: Provide an :program:`llvm-exegesis` option to test all instructions."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:83
msgid "EXAMPLE 2: benchmarking a custom code snippet"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:85
msgid ""
"To measure the latency/uops of a custom piece of code, you can specify the "
"`snippets-file` option (`-` reads from standard input)."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:92
msgid ""
"Real-life code snippets typically depend on registers or memory. :program:"
"`llvm-exegesis` checks the liveliness of registers (i.e. any register use "
"has a corresponding def or is a \"live in\"). If your code depends on the "
"value of some registers, you have two options:"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:97
msgid ""
"Mark the register as requiring a definition. :program:`llvm-exegesis` will "
"automatically assign a value to the register. This can be done using the "
"directive `LLVM-EXEGESIS-DEFREG <reg name> <hex_value>`, where `<hex_value>` "
"is a bit pattern used to fill `<reg_name>`. If `<hex_value>` is smaller than "
"the register width, it will be sign-extended."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:102
msgid ""
"Mark the register as a \"live in\". :program:`llvm-exegesis` will benchmark "
"using whatever value was in this registers on entry. This can be done using "
"the directive `LLVM-EXEGESIS-LIVEIN <reg name>`."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:106
msgid ""
"For example, the following code snippet depends on the values of XMM1 (which "
"will be set by the tool) and the memory buffer passed in RDI (live in)."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:119
msgid "EXAMPLE 3: analysis"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:121
msgid ""
"Assuming you have a set of benchmarked instructions (either latency or uops) "
"as YAML in file `/tmp/benchmarks.yaml`, you can analyze the results using "
"the following command:"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:132
msgid ""
"This will group the instructions into clusters with the same performance "
"characteristics. The clusters will be written out to `/tmp/clusters.csv` in "
"the following format:"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:154
msgid ""
":program:`llvm-exegesis` will also analyze the clusters to point out "
"inconsistencies in the scheduling information. The output is an html file. "
"For example, `/tmp/inconsistencies.html` will contain messages like the "
"following :"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:161
msgid ""
"Note that the scheduling class names will be resolved only when :program:"
"`llvm-exegesis` is compiled in debug mode, else only the class id will be "
"shown. This does not invalidate any of the analysis results though."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:167
msgid "OPTIONS"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:171
msgid "Print a summary of command line options."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:175
msgid ""
"Specify the opcode to measure, by index. See example 1 for details. Either "
"`opcode-index`, `opcode-name` or `snippets-file` must be set."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:180
msgid ""
"Specify the opcode to measure, by name. Several opcodes can be specified as "
"a comma-separated list. See example 1 for details. Either `opcode-index`, "
"`opcode-name` or `snippets-file` must be set."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:186
msgid ""
"Specify the custom code snippet to measure. See example 2 for details. "
"Either `opcode-index`, `opcode-name` or `snippets-file` must be set."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:191
msgid "Specify the run mode."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:195
msgid ""
"Specify the number of repetitions of the asm snippet. Higher values lead to "
"more accurate measurements but lengthen the benchmark."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:200
msgid ""
"File to read (`analysis` mode) or write (`latency`/`uops` modes) benchmark "
"results. \"-\" uses stdin/stdout."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:205
msgid ""
"If provided, write the analysis clusters as CSV to this file. \"-\" prints "
"to stdout."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:210
msgid ""
"If non-empty, write inconsistencies found during analysis to this file. `-` "
"prints to stdout."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:215
#: ../../../CommandGuide/llvm-exegesis.rst:220
msgid ""
"Specify the numPoints parameters to be used for DBSCAN clustering "
"(`analysis` mode)."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:225
msgid ""
"If set, ignore instructions that do not have a sched class (class idx = 0)."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:229
msgid ""
"If set, measure the cpu characteristics using the counters for this CPU. "
"This is useful when creating new sched models (the host CPU is unknown to "
"LLVM)."
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:233
msgid "EXIT STATUS"
msgstr ""

#: ../../../CommandGuide/llvm-exegesis.rst:235
msgid ""
":program:`llvm-exegesis` returns 0 on success. Otherwise, an error message "
"is printed to standard error, and the tool returns a non 0 value."
msgstr ""
