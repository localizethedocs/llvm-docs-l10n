# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../StackSafetyAnalysis.rst:3
msgid "Stack Safety Analysis"
msgstr ""

#: ../../../StackSafetyAnalysis.rst:7
msgid "Introduction"
msgstr ""

#: ../../../StackSafetyAnalysis.rst:9
msgid ""
"The Stack Safety Analysis determines if stack allocated variables can be "
"considered 'safe' from memory access bugs."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:12
msgid ""
"The primary purpose of the analysis is to be used by sanitizers to avoid "
"unnecessary instrumentation of 'safe' variables. SafeStack is going to be "
"the first user."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:16
msgid ""
"'safe' variables can be defined as variables that can not be used out-of-"
"scope (e.g. use-after-return) or accessed out of bounds. In the future it "
"can be extended to track other variable properties. E.g. we plan to extend "
"implementation with a check to make sure that variable is always initialized "
"before every read to optimize use-of-uninitialized-memory checks."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:23
msgid "How it works"
msgstr ""

#: ../../../StackSafetyAnalysis.rst:25
msgid "The analysis is implemented in two stages:"
msgstr ""

#: ../../../StackSafetyAnalysis.rst:27
msgid ""
"The intra-procedural, or 'local', stage performs a depth-first search inside "
"functions to collect all uses of each alloca, including loads/stores and "
"uses as arguments functions. After this stage we know which parts of the "
"alloca are used by functions itself but we don't know what happens after it "
"is passed as an argument to another function."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:33
msgid ""
"The inter-procedural, or 'global', stage, resolves what happens to allocas "
"after they are passed as function arguments. This stage performs a depth-"
"first search on function calls inside a single module and propagates allocas "
"usage through functions calls."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:38
msgid ""
"When used with ThinLTO, the global stage performs a whole program analysis "
"over the Module Summary Index."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:42
msgid "Testing"
msgstr ""

#: ../../../StackSafetyAnalysis.rst:44
msgid "The analysis is covered with lit tests."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:46
msgid ""
"We expect that users can tolerate false classification of variables as "
"'unsafe' when in-fact it's 'safe'. This may lead to inefficient code. "
"However, we can't accept false 'safe' classification which may cause "
"sanitizers to miss actual bugs in instrumented code. To avoid that we want "
"additional validation tool."
msgstr ""

#: ../../../StackSafetyAnalysis.rst:51
msgid ""
"AddressSanitizer may help with this validation. We can instrument all "
"variables as usual but additionally store stack-safe information in the "
"``ASanStackVariableDescription``. Then if AddressSanitizer detects a bug on "
"a 'safe' variable we can produce an additional report to let the user know "
"that probably Stack Safety Analysis failed and we should check for a bug in "
"the compiler."
msgstr ""
