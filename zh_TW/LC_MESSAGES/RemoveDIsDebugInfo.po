# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 19\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../RemoveDIsDebugInfo.md:1
msgid "Debug info migration: From intrinsics to records"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:3
msgid ""
"We're planning on removing debug info intrinsics from LLVM, as they're slow, "
"unwieldy and can confuse optimisation passes if they're not expecting them. "
"Instead of having a sequence of instructions that looks like this:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:13
msgid ""
"with `dbg.value` intrinsics representing debug info records, it would "
"instead be printed as:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:23
msgid ""
"The debug records are not instructions, do not appear in the instruction "
"list, and won't appear in your optimisation passes unless you go digging for "
"them deliberately."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:25
msgid "Great, what do I need to do!"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:27
msgid ""
"Very little -- we've already instrumented all of LLVM to handle these new "
"records (\"`DbgRecords`\") and behave identically to past LLVM behaviour. "
"This is currently being turned on by default, so that `DbgRecords` will be "
"used by default in memory, IR, and bitcode."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:29
msgid "API Changes"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:31
msgid ""
"There are two significant changes to be aware of. Firstly, we're adding a "
"single bit of debug relevant data to the `BasicBlock::iterator` class (it's "
"so that we can determine whether ranges intend on including debug info at "
"the beginning of a block or not). That means when writing passes that insert "
"LLVM IR instructions, you need to identify positions with `BasicBlock::"
"iterator` rather than just a bare `Instruction *`. Most of the time this "
"means that after identifying where you intend on inserting something, you "
"must also call `getIterator` on the instruction position -- however when "
"inserting at the start of a block you _must_ use `getFirstInsertionPt`, "
"`getFirstNonPHIIt` or `begin` and use that iterator to insert, rather than "
"just fetching a pointer to the first instruction."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:33
msgid ""
"The second matter is that if you transfer sequences of instructions from one "
"place to another manually, i.e. repeatedly using `moveBefore` where you "
"might have used `splice`, then you should instead use the method "
"`moveBeforePreserving`. `moveBeforePreserving` will transfer debug info "
"records with the instruction they're attached to. This is something that "
"happens automatically today -- if you use `moveBefore` on every element of "
"an instruction sequence, then debug intrinsics will be moved in the normal "
"course of your code, but we lose this behaviour with non-instruction debug "
"info."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:35
msgid ""
"For a more in-depth overview of how to update existing code to support debug "
"records, see [the guide below](#how-to-update-existing-code)."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:37
msgid "Textual IR Changes"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:39
msgid ""
"As we change from using debug intrinsics to debug records, any tools that "
"depend on parsing IR produced by LLVM will need to handle the new format. "
"For the most part, the difference between the printed form of a debug "
"intrinsic call and a debug record is trivial:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:41
msgid "An extra 2 spaces of indentation are added."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:42
msgid ""
"The text `(tail|notail|musttail)? call void @llvm.dbg.<type>` is replaced "
"with `#dbg_<type>`."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:43
msgid "The leading `metadata ` is removed from each argument to the intrinsic."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:44
msgid ""
"The DILocation changes from being an instruction attachment with the format "
"`!dbg !<Num>`, to being an ordinary argument, i.e. `!<Num>`, that is passed "
"as the final argument to the debug record."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:46
msgid ""
"Following these rules, we have this example of a debug intrinsic and the "
"equivalent debug record:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:55
msgid "Test updates"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:57
msgid ""
"Any tests downstream of the main LLVM repo that test the IR output of LLVM "
"may break as a result of the change to using records. Updating an individual "
"test to expect records instead of intrinsics should be trivial, given the "
"update rules above. Updating many tests may be burdensome however; to update "
"the lit tests in the main repository, the following steps were used:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:59
msgid ""
"Collect the list of failing lit tests into a single file, `failing-tests."
"txt`, separated by (and ending with) newlines."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:60
msgid ""
"Use the following line to split the failing tests into tests that use "
"update_test_checks and tests that don't:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:64
msgid ""
"For the tests that use update_test_checks, run the appropriate "
"update_test_checks script - for the main LLVM repo, this was achieved with:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:69
msgid ""
"The remaining tests can be manually updated, although if there is a large "
"number of tests then the following scripts may be useful; firstly, a script "
"used to extract the check-line prefixes from a file:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:87
msgid ""
"Then a second script to perform the work of actually updating the check-"
"lines in each of the failing tests, with a series of simple substitution "
"patterns:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:116
msgid ""
"Both of these scripts combined can be used on the list in `manual-tests.txt` "
"as follows:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:120
msgid ""
"These scripts dealt successfully with the vast majority of checks in `clang/"
"test` and `llvm/test`."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:121
msgid "Verify the resulting tests pass, and detect any failing tests:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:136
msgid ""
"Some tests may have failed - the update scripts are simplistic and preserve "
"no context across lines, and so there are cases that they will not handle; "
"the remaining cases must be manually updated (or handled by further scripts)."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:138
msgid "C-API changes"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:140
msgid ""
"Some new functions that have been added are temporary and will be deprecated "
"in the future. The intention is that they'll help downstream projects adapt "
"during the transition period."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:166
msgid ""
"`LLVMDIBuilderInsertDeclareRecordBefore`, "
"`LLVMDIBuilderInsertDeclareRecordAtEnd`, "
"`LLVMDIBuilderInsertDbgValueRecordBefore` and "
"`LLVMDIBuilderInsertDbgValueRecordAtEnd` are replacing the deleted "
"`LLVMDIBuilderInsertDeclareBefore-style` functions."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:168
msgid ""
"`LLVMPositionBuilderBeforeDbgRecords` and "
"`LLVMPositionBuilderBeforeInstrAndDbgRecords` behave the same as "
"`LLVMPositionBuilder` and `LLVMPositionBuilderBefore` except the insertion "
"position is set before the debug records that precede the target "
"instruction. Note that this doesn't mean that debug intrinsics before the "
"chosen instruction are skipped, only debug records (which unlike debug "
"records are not themselves instructions)."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:170
msgid ""
"If you don't know which function to call then follow this rule: If you are "
"trying to insert at the start of a block, or purposfully skip debug "
"intrinsics to determine the insertion point for any other reason, then call "
"the new functions."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:173
msgid ""
"`LLVMPositionBuilder` and `LLVMPositionBuilderBefore` are unchanged. They "
"insert before the indicated instruction but after any attached debug records."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:175
msgid "The new \"Debug Record\" model"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:177
msgid ""
"Below is a brief overview of the new representation that replaces debug "
"intrinsics; for an instructive guide on updating old code, see [here](#how-"
"to-update-existing-code)."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:179
msgid "What exactly have you replaced debug intrinsics with?"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:181
msgid ""
"We're using a dedicated C++ class called `DbgRecord` to store debug info, "
"with a one-to-one relationship between each instance of a debug intrinsic "
"and each `DbgRecord` object in any LLVM IR program; these `DbgRecord`s are "
"represented in the IR as non-instruction debug records, as described in the "
"[Source Level Debugging](project:SourceLevelDebugging.rst#Debug Records) "
"document. This class has a set of subclasses that store exactly the same "
"information as is stored in debugging intrinsics. Each one also has almost "
"entirely the same set of methods, that behave in the same way:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:183
msgid ""
"https://llvm.org/docs/doxygen/classllvm_1_1DbgRecord.html   https://llvm.org/"
"docs/doxygen/classllvm_1_1DbgVariableRecord.html   https://llvm.org/docs/"
"doxygen/classllvm_1_1DbgLabelRecord.html"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:187
msgid ""
"This allows you to treat a `DbgVariableRecord` as if it's a `dbg.value`/`dbg."
"declare`/`dbg.assign` intrinsic most of the time, for example in generic "
"(auto-param) lambdas, and the same for `DbgLabelRecord` and `dbg.label`s."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:189
msgid "How do these `DbgRecords` fit into the instruction stream?"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:191
msgid "Like so:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:213
msgid ""
"Each instruction has a pointer to a `DbgMarker` (which will become "
"optional), that contains a list of `DbgRecord` objects. No debugging records "
"appear in the instruction list at all. `DbgRecord`s have a parent pointer to "
"their owning `DbgMarker`, and each `DbgMarker` has a pointer back to it's "
"owning instruction."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:215
msgid ""
"Not shown are the links from DbgRecord to other parts of the `Value`/"
"`Metadata` hierachy: `DbgRecord` subclasses have tracking pointers to the "
"DIMetadata that they use, and `DbgVariableRecord` has references to `Value`s "
"that are stored in a `DebugValueUser` base class. This refers to a "
"`ValueAsMetadata` object referring to `Value`s, via the `TrackingMetadata` "
"facility."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:217
msgid ""
"The various kinds of debug intrinsic (value, declare, assign, label) are all "
"stored in `DbgRecord` subclasses, with a \"RecordKind\" field distinguishing "
"`DbgLabelRecord`s from `DbgVariableRecord`s, and a `LocationType` field in "
"the `DbgVariableRecord` class further disambiguating the various debug "
"variable intrinsics it can represent."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:219
msgid "How to update existing code"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:221
msgid ""
"Any existing code that interacts with debug intrinsics in some way will need "
"to be updated to interact with debug records in the same way. A few quick "
"rules to keep in mind when updating code:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:223
msgid ""
"Debug records will not be seen when iterating over instructions; to find the "
"debug records that appear immediately before an instruction, you'll need to "
"iterate over `Instruction::getDbgRecordRange()`."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:224
msgid ""
"Debug records have interfaces that are identical to those of debug "
"intrinsics, meaning that any code that operates on debug intrinsics can be "
"trivially applied to debug records as well. The exceptions for this are "
"`Instruction` or `CallInst` methods that don't logically apply to debug "
"records, and `isa`/`cast`/`dyn_cast` methods, are replaced by methods on the "
"`DbgRecord` class itself."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:225
msgid ""
"Debug records cannot appear in a module that also contains debug intrinsics; "
"the two are mutually exclusive. As debug records are the future format, "
"handling records correctly should be prioritized in new code."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:226
msgid ""
"Until support for intrinsics is no longer present, a valid hotfix for code "
"that only handles debug intrinsics and is non-trivial to update is to "
"convert the module to the intrinsic format using `Module::"
"setIsNewDbgInfoFormat`, and convert it back afterwards."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:227
msgid ""
"This can also be performed within a lexical scope for a module or an "
"individual function using the class `ScopedDbgInfoFormatSetter`:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:238
msgid ""
"Below is a rough guide on how existing code that currently supports debug "
"intrinsics can be updated to support debug records."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:240
msgid "Creating debug records"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:242
msgid ""
"Debug records will automatically be created by the `DIBuilder` class when "
"the new format is enabled. As with instructions, it is also possible to call "
"`DbgRecord::clone` to create an unattached copy of an existing record."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:244
msgid ""
"Skipping debug records, ignoring debug-uses of `Values`, stably counting "
"instructions, etc."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:246
msgid "This will all happen transparently without needing to think about it!"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:258
msgid "Finding debug records"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:260
msgid ""
"Utilities such as `findDbgUsers` and the like now have an optional argument "
"that will return the set of `DbgVariableRecord` records that refer to a "
"`Value`. You should be able to treat them the same as intrinsics."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:282
msgid "Examining debug records at positions"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:284
msgid ""
"Call `Instruction::getDbgRecordRange()` to get the range of `DbgRecord` "
"objects that are attached to an instruction."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:305
msgid ""
"This can also be passed through the function `filterDbgVars` to specifically "
"iterate over DbgVariableRecords, which are more commonly used."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:330
msgid "Processing individual debug records"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:332
msgid ""
"In most cases, any code that operates on debug intrinsics can be extracted "
"to a template function or auto lambda (if it is not already in one) that can "
"be applied to both debug intrinsics and debug records - though keep in mind "
"the main exception that `isa`/`cast`/`dyn_cast` do not apply to "
"`DbgVariableRecord` types."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:384
msgid "Moving and deleting debug records"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:386
msgid ""
"You can use `DbgRecord::removeFromParent` to unlink a `DbgRecord` from it's "
"marker, and then `BasicBlock::insertDbgRecordBefore` or `BasicBlock::"
"insertDbgRecordAfter` to re-insert the `DbgRecord` somewhere else. You "
"cannot insert a `DbgRecord` at an arbitary point in a list of `DbgRecord`s "
"(if you're doing this with `llvm.dbg.value`s then it's unlikely to be "
"correct)."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:388
msgid "Erase `DbgRecord`s by calling `eraseFromParent`."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:416
msgid "What about dangling debug records?"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:418
msgid "If you have a block like so:"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:427
msgid ""
"your optimisation pass may wish to erase the terminator and then do "
"something to the block. This is easy to do when debug info is kept in "
"instructions, but with `DbgRecord`s there is no trailing instruction to "
"attach the variable information to in the block above, once the terminator "
"is erased. For such degenerate blocks, `DbgRecord`s are stored temporarily "
"in a map in `LLVMContext`, and are re-inserted when a terminator is "
"reinserted to the block or other instruction inserted at `end()`."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:429
msgid ""
"This can technically lead to trouble in the vanishingly rare scenario where "
"an optimisation pass erases a terminator and then decides to erase the whole "
"block. (We recommend not doing that)."
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:431
msgid "Anything else?"
msgstr ""

#: ../../../RemoveDIsDebugInfo.md:433
msgid ""
"The above guide does not comprehensively cover every pattern that could "
"apply to debug intrinsics; as mentioned at the [start of the guide](#how-to-"
"update-existing-code), you can temporarily convert the target module from "
"debug records to intrinsics as a stopgap measure. Most operations that can "
"be performed on debug intrinsics have exact equivalents for debug records, "
"but if you encounter any exceptions, reading the class docs (linked [here]"
"(#what-exactly-have-you-replaced-debug-intrinsics-with)) may give some "
"insight, there may be examples in the existing codebase, and you can always "
"ask for help on the [forums](https://discourse.llvm.org/tag/debuginfo)."
msgstr ""
