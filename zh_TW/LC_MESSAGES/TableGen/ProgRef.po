# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TableGen/ProgRef.rst:3
msgid "TableGen Programmer's Reference"
msgstr ""

#: ../../../TableGen/ProgRef.rst:11
msgid "Introduction"
msgstr "簡介"

#: ../../../TableGen/ProgRef.rst:13
msgid ""
"The purpose of TableGen is to generate complex output files based on "
"information from source files that are significantly easier to code than the "
"output files would be, and also easier to maintain and modify over time. The "
"information is coded in a declarative style involving classes and records, "
"which are then processed by TableGen. The internalized records are passed on "
"to various *backends*, which extract information from a subset of the "
"records and generate one or more output files. These output files are "
"typically ``.inc`` files for C++, but may be any type of file that the "
"backend developer needs."
msgstr ""

#: ../../../TableGen/ProgRef.rst:23
msgid ""
"This document describes the LLVM TableGen facility in detail. It is intended "
"for the programmer who is using TableGen to produce code for a project. If "
"you are looking for a simple overview, check out the :doc:`TableGen Overview "
"<./index>`.  The various ``*-tblgen`` commands used to invoke TableGen are "
"described in :doc:`tblgen Family - Description to C++ Code<../CommandGuide/"
"tblgen>`."
msgstr ""

#: ../../../TableGen/ProgRef.rst:30
msgid ""
"An example of a backend is ``RegisterInfo``, which generates the register "
"file information for a particular target machine, for use by the LLVM target-"
"independent code generator. See :doc:`TableGen Backends <./BackEnds>` for a "
"description of the LLVM TableGen backends, and :doc:`TableGen Backend "
"Developer's Guide <./BackGuide>` for a guide to writing a new backend."
msgstr ""

#: ../../../TableGen/ProgRef.rst:37
msgid "Here are a few of the things backends can do."
msgstr ""

#: ../../../TableGen/ProgRef.rst:39
msgid "Generate the register file information for a particular target machine."
msgstr ""

#: ../../../TableGen/ProgRef.rst:41
msgid "Generate the instruction definitions for a target."
msgstr ""

#: ../../../TableGen/ProgRef.rst:43
msgid ""
"Generate the patterns that the code generator uses to match instructions to "
"intermediate representation (IR) nodes."
msgstr ""

#: ../../../TableGen/ProgRef.rst:46
msgid "Generate semantic attribute identifiers for Clang."
msgstr ""

#: ../../../TableGen/ProgRef.rst:48
msgid ""
"Generate abstract syntax tree (AST) declaration node definitions for Clang."
msgstr ""

#: ../../../TableGen/ProgRef.rst:50
msgid "Generate AST statement node definitions for Clang."
msgstr ""

#: ../../../TableGen/ProgRef.rst:54
msgid "Concepts"
msgstr ""

#: ../../../TableGen/ProgRef.rst:56
msgid ""
"TableGen source files contain two primary items: *abstract records* and "
"*concrete records*. In this and other TableGen documents, abstract records "
"are called *classes.* (These classes are different from C++ classes and do "
"not map onto them.) In addition, concrete records are usually just called "
"records, although sometimes the term *record* refers to both classes and "
"concrete records. The distinction should be clear in context."
msgstr ""

#: ../../../TableGen/ProgRef.rst:63
msgid ""
"Classes and concrete records have a unique *name*, either chosen by the "
"programmer or generated by TableGen. Associated with that name is a list of "
"*fields* with values and an optional list of *parent classes* (sometimes "
"called base or super classes). The fields are the primary data that backends "
"will process. Note that TableGen assigns no meanings to fields; the meanings "
"are entirely up to the backends and the programs that incorporate the output "
"of those backends."
msgstr ""

#: ../../../TableGen/ProgRef.rst:73
msgid ""
"The term \"parent class\" can refer to a class that is a parent of another "
"class, and also to a class from which a concrete record inherits. This "
"nonstandard use of the term arises because TableGen treats classes and "
"concrete records similarly."
msgstr ""

#: ../../../TableGen/ProgRef.rst:78
msgid ""
"A backend processes some subset of the concrete records built by the "
"TableGen parser and emits the output files. These files are usually C++ ``."
"inc`` files that are included by the programs that require the data in those "
"records. However, a backend can produce any type of output files. For "
"example, it could produce a data file containing messages tagged with "
"identifiers and substitution parameters. In a complex use case such as the "
"LLVM code generator, there can be many concrete records and some of them can "
"have an unexpectedly large number of fields, resulting in large output files."
msgstr ""

#: ../../../TableGen/ProgRef.rst:87
msgid ""
"In order to reduce the complexity of TableGen files, classes are used to "
"abstract out groups of record fields. For example, a few classes may "
"abstract the concept of a machine register file, while other classes may "
"abstract the instruction formats, and still others may abstract the "
"individual instructions. TableGen allows an arbitrary hierarchy of classes, "
"so that the abstract classes for two concepts can share a third superclass "
"that abstracts common \"sub-concepts\" from the two original concepts."
msgstr ""

#: ../../../TableGen/ProgRef.rst:95
msgid ""
"In order to make classes more useful, a concrete record (or another class) "
"can request a class as a parent class and pass *template arguments* to it. "
"These template arguments can be used in the fields of the parent class to "
"initialize them in a custom manner. That is, record or class ``A`` can "
"request parent class ``S`` with one set of template arguments, while record "
"or class ``B`` can request ``S`` with a different set of arguments. Without "
"template arguments, many more classes would be required, one for each "
"combination of the template arguments."
msgstr ""

#: ../../../TableGen/ProgRef.rst:104
msgid ""
"Both classes and concrete records can include fields that are uninitialized. "
"The uninitialized \"value\" is represented by a question mark (``?``). "
"Classes often have uninitialized fields that are expected to be filled in "
"when those classes are inherited by concrete records. Even so, some fields "
"of concrete records may remain uninitialized."
msgstr ""

#: ../../../TableGen/ProgRef.rst:110
msgid ""
"TableGen provides *multiclasses* to collect a group of record definitions in "
"one place. A multiclass is a sort of macro that can be \"invoked\" to define "
"multiple concrete records all at once. A multiclass can inherit from other "
"multiclasses, which means that the multiclass inherits all the definitions "
"from its parent multiclasses."
msgstr ""

#: ../../../TableGen/ProgRef.rst:116
msgid ""
"`Appendix C: Sample Record`_ illustrates a complex record in the Intel X86 "
"target and the simple way in which it is defined."
msgstr ""

#: ../../../TableGen/ProgRef.rst:120
msgid "Source Files"
msgstr ""

#: ../../../TableGen/ProgRef.rst:122
msgid ""
"TableGen source files are plain ASCII text files. The files can contain "
"statements, comments, and blank lines (see `Lexical Analysis`_). The "
"standard file extension for TableGen files is ``.td``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:126
msgid ""
"TableGen files can grow quite large, so there is an include mechanism that "
"allows one file to include the content of another file (see `Include "
"Files`_). This allows large files to be broken up into smaller ones, and "
"also provides a simple library mechanism where multiple source files can "
"include the same library file."
msgstr ""

#: ../../../TableGen/ProgRef.rst:132
msgid ""
"TableGen supports a simple preprocessor that can be used to conditionalize "
"portions of ``.td`` files. See `Preprocessing Facilities`_ for more "
"information."
msgstr ""

#: ../../../TableGen/ProgRef.rst:137
msgid "Lexical Analysis"
msgstr ""

#: ../../../TableGen/ProgRef.rst:139
msgid ""
"The lexical and syntax notation used here is intended to imitate `Python's`_ "
"notation. In particular, for lexical definitions, the productions operate at "
"the character level and there is no implied whitespace between elements. The "
"syntax definitions operate at the token level, so there is implied "
"whitespace between tokens."
msgstr ""

#: ../../../TableGen/ProgRef.rst:147
msgid ""
"TableGen supports BCPL-style comments (``// ...``) and nestable C-style "
"comments (``/* ... */``). TableGen also provides simple `Preprocessing "
"Facilities`_."
msgstr ""

#: ../../../TableGen/ProgRef.rst:151
msgid ""
"Formfeed characters may be used freely in files to produce page breaks when "
"the file is printed for review."
msgstr ""

#: ../../../TableGen/ProgRef.rst:154
msgid "The following are the basic punctuation tokens::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:159
msgid "Literals"
msgstr ""

#: ../../../TableGen/ProgRef.rst:161
msgid "Numeric literals take one of the following forms:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:169
msgid ""
"Observe that the :token:`DecimalInteger` token includes the optional ``+`` "
"or ``-`` sign, unlike most languages where the sign would be treated as a "
"unary operator."
msgstr ""

#: ../../../TableGen/ProgRef.rst:173
msgid "TableGen has two kinds of string literals:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:179
msgid ""
"A :token:`TokCode` is nothing more than a multi-line string literal "
"delimited by ``[{`` and ``}]``. It can break across lines and the line "
"breaks are retained in the string."
msgstr ""

#: ../../../TableGen/ProgRef.rst:183
msgid "The current implementation accepts the following escape sequences::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:188
msgid "Identifiers"
msgstr ""

#: ../../../TableGen/ProgRef.rst:190
msgid ""
"TableGen has name- and identifier-like tokens, which are case-sensitive."
msgstr ""

#: ../../../TableGen/ProgRef.rst:197
msgid ""
"Note that, unlike most languages, TableGen allows :token:`TokIdentifier` to "
"begin with an integer. In case of ambiguity, a token is interpreted as a "
"numeric literal rather than an identifier."
msgstr ""

#: ../../../TableGen/ProgRef.rst:201
msgid ""
"TableGen has the following reserved keywords, which cannot be used as "
"identifiers::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:211
msgid ""
"The ``field`` reserved word is deprecated, except when used with the "
"CodeEmitterGen backend where it's used to distinguish normal record fields "
"from encoding fields."
msgstr ""

#: ../../../TableGen/ProgRef.rst:216
msgid "Bang operators"
msgstr ""

#: ../../../TableGen/ProgRef.rst:218
msgid "TableGen provides \"bang operators\" that have a wide variety of uses:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:234
msgid ""
"The ``!cond`` operator has a slightly different syntax compared to other "
"bang operators, so it is defined separately:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:240
msgid ""
"See `Appendix A: Bang Operators`_ for a description of each bang operator."
msgstr ""

#: ../../../TableGen/ProgRef.rst:243
msgid "Include files"
msgstr ""

#: ../../../TableGen/ProgRef.rst:245
msgid ""
"TableGen has an include mechanism. The content of the included file "
"lexically replaces the ``include`` directive and is then parsed as if it was "
"originally in the main file."
msgstr ""

#: ../../../TableGen/ProgRef.rst:252
msgid ""
"Portions of the main file and included files can be conditionalized using "
"preprocessor directives."
msgstr ""

#: ../../../TableGen/ProgRef.rst:259
msgid "Types"
msgstr ""

#: ../../../TableGen/ProgRef.rst:261
msgid ""
"The TableGen language is statically typed, using a simple but complete type "
"system. Types are used to check for errors, to perform implicit conversions, "
"and to help interface designers constrain the allowed input. Every value is "
"required to have an associated type."
msgstr ""

#: ../../../TableGen/ProgRef.rst:266
msgid ""
"TableGen supports a mixture of low-level types (e.g., ``bit``) and high-"
"level types (e.g., ``dag``). This flexibility allows you to describe a wide "
"range of records conveniently and compactly."
msgstr ""

#: ../../../TableGen/ProgRef.rst:278
msgid "``bit``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:278
msgid "A ``bit`` is a boolean value that can be 0 or 1."
msgstr ""

#: ../../../TableGen/ProgRef.rst:282
msgid "``int``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:281
msgid ""
"The ``int`` type represents a simple 64-bit integer value, such as 5 or -42."
msgstr ""

#: ../../../TableGen/ProgRef.rst:286
msgid "``string``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:285
msgid ""
"The ``string`` type represents an ordered sequence of characters of "
"arbitrary length."
msgstr ""

#: ../../../TableGen/ProgRef.rst:295
msgid "``bits<``\\ *n*\\ ``>``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:289
msgid ""
"The ``bits`` type is a fixed-sized integer of arbitrary length *n* that is "
"treated as separate bits. These bits can be accessed individually. A field "
"of this type is useful for representing an instruction operation code, "
"register number, or address mode/register/displacement.  The bits of the "
"field can be set individually or as subfields. For example, in an "
"instruction address, the addressing mode, base register number, and "
"displacement can be set separately."
msgstr ""

#: ../../../TableGen/ProgRef.rst:300
msgid "``list<``\\ *type*\\ ``>``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:298
msgid ""
"This type represents a list whose elements are of the *type* specified in "
"angle brackets. The element type is arbitrary; it can even be another list "
"type. List elements are indexed from 0."
msgstr ""

#: ../../../TableGen/ProgRef.rst:309
msgid "``dag``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:303
msgid ""
"This type represents a nestable directed acyclic graph (DAG) of nodes. Each "
"node has an *operator* and zero or more *arguments* (or *operands*). An "
"argument can be another ``dag`` object, allowing an arbitrary tree of nodes "
"and edges. As an example, DAGs are used to represent code patterns for use "
"by the code generator instruction selection algorithms. See `Directed "
"acyclic graphs (DAGs)`_ for more details;"
msgstr ""

#: ../../../TableGen/ProgRef.rst:320
msgid ":token:`ClassID`"
msgstr ""

#: ../../../TableGen/ProgRef.rst:312
msgid ""
"Specifying a class name in a type context indicates that the type of the "
"defined value must be a subclass of the specified class. This is useful in "
"conjunction with the ``list`` type; for example, to constrain the elements "
"of the list to a common base class (e.g., a ``list<Register>`` can only "
"contain definitions derived from the ``Register`` class). The :token:"
"`ClassID` must name a class that has been previously declared or defined."
msgstr ""

#: ../../../TableGen/ProgRef.rst:323
msgid "Values and Expressions"
msgstr ""

#: ../../../TableGen/ProgRef.rst:325
msgid ""
"There are many contexts in TableGen statements where a value is required. A "
"common example is in the definition of a record, where each field is "
"specified by a name and an optional value. TableGen allows for a reasonable "
"number of different forms when building up value expressions. These forms "
"allow the TableGen file to be written in a syntax that is natural for the "
"application."
msgstr ""

#: ../../../TableGen/ProgRef.rst:332
msgid ""
"Note that all of the values have rules for converting them from one type to "
"another. For example, these rules allow you to assign a value like ``7`` to "
"an entity of type ``bits<4>``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:354
msgid ""
"The peculiar last form of :token:`RangePiece` and :token:`SliceElement` is "
"due to the fact that the \"``-``\" is included in the :token:`TokInteger`, "
"hence ``1-5`` gets lexed as two consecutive tokens, with values ``1`` and "
"``-5``, instead of \"1\", \"-\", and \"5\". The use of hyphen as the range "
"punctuation is deprecated."
msgstr ""

#: ../../../TableGen/ProgRef.rst:361
msgid "Simple values"
msgstr ""

#: ../../../TableGen/ProgRef.rst:363
msgid "The :token:`SimpleValue` has a number of forms."
msgstr ""

#: ../../../TableGen/ProgRef.rst:368
msgid ""
"A value can be an integer literal, a string literal, or a code literal. "
"Multiple adjacent string literals are concatenated as in C/C++; the simple "
"value is the concatenation of the strings. Code literals become strings and "
"are then indistinguishable from them."
msgstr ""

#: ../../../TableGen/ProgRef.rst:376
msgid ""
"The ``true`` and ``false`` literals are essentially syntactic sugar for the "
"integer values 1 and 0. They improve the readability of TableGen files when "
"boolean values are used in field initializations, bit sequences, ``if`` "
"statements, etc. When parsed, these literals are converted to integers."
msgstr ""

#: ../../../TableGen/ProgRef.rst:383
msgid ""
"Although ``true`` and ``false`` are literal names for 1 and 0, we recommend "
"as a stylistic rule that you use them for boolean values only."
msgstr ""

#: ../../../TableGen/ProgRef.rst:390
msgid "A question mark represents an uninitialized value."
msgstr ""

#: ../../../TableGen/ProgRef.rst:397
msgid ""
"This value represents a sequence of bits, which can be used to initialize a "
"``bits<``\\ *n*\\ ``>`` field (note the braces). When doing so, the values "
"must represent a total of *n* bits."
msgstr ""

#: ../../../TableGen/ProgRef.rst:404
msgid ""
"This value is a list initializer (note the brackets). The values in brackets "
"are the elements of the list. The optional :token:`Type` can be used to "
"indicate a specific element type; otherwise the element type is inferred "
"from the given values. TableGen can usually infer the type, although "
"sometimes not when the value is the empty list (``[]``)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:415
msgid ""
"This represents a DAG initializer (note the parentheses).  The first :token:"
"`DagArg` is called the \"operator\" of the DAG and must be a record. See "
"`Directed acyclic graphs (DAGs)`_ for more details."
msgstr ""

#: ../../../TableGen/ProgRef.rst:422
msgid ""
"The resulting value is the value of the entity named by the identifier. The "
"possible identifiers are described here, but the descriptions will make more "
"sense after reading the remainder of this guide."
msgstr ""

#: ../../../TableGen/ProgRef.rst:429
msgid "A template argument of a ``class``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:435
msgid ""
"The implicit template argument ``NAME`` in a ``class`` or ``multiclass`` "
"definition (see `NAME`_)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:438
msgid "A field local to a ``class``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:445
msgid ""
"The name of a record definition, such as the use of ``Bar`` in the "
"definition of ``Foo``::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:456
msgid "A field local to a record definition, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:463
msgid ""
"Fields inherited from the record's parent classes can be accessed the same "
"way."
msgstr ""

#: ../../../TableGen/ProgRef.rst:465
msgid ""
"A template argument of a ``multiclass``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:471
msgid "A variable defined with the ``defvar`` or ``defset`` statements."
msgstr ""

#: ../../../TableGen/ProgRef.rst:473
msgid "The iteration variable of a ``foreach``, such as the use of ``i`` in::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:481
msgid ""
"This form creates a new anonymous record definition (as would be created by "
"an unnamed ``def`` inheriting from the given class with the given template "
"arguments; see `def`_) and the value is that record. A field of the record "
"can be obtained using a suffix; see `Suffixed Values`_."
msgstr ""

#: ../../../TableGen/ProgRef.rst:486
msgid ""
"Invoking a class in this manner can provide a simple subroutine facility. "
"See `Using Classes as Subroutines`_ for more information."
msgstr ""

#: ../../../TableGen/ProgRef.rst:494
msgid ""
"The bang operators provide functions that are not available with the other "
"simple values. Except in the case of ``!cond``, a bang operator takes a list "
"of arguments enclosed in parentheses and performs some function on those "
"arguments, producing a value for that bang operator. The ``!cond`` operator "
"takes a list of pairs of arguments separated by colons. See `Appendix A: "
"Bang Operators`_ for a description of each bang operator."
msgstr ""

#: ../../../TableGen/ProgRef.rst:503
msgid "Suffixed values"
msgstr ""

#: ../../../TableGen/ProgRef.rst:505
msgid ""
"The :token:`SimpleValue` values described above can be specified with "
"certain suffixes. The purpose of a suffix is to obtain a subvalue of the "
"primary value. Here are the possible suffixes for some primary *value*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:510
msgid "*value*\\ ``{17}``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:510
msgid "The final value is bit 17 of the integer *value* (note the braces)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:514
msgid "*value*\\ ``{8...15}``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:513
msgid ""
"The final value is bits 8--15 of the integer *value*. The order of the bits "
"can be reversed by specifying ``{15...8}``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:519
msgid "*value*\\ ``[i]``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:517
msgid ""
"The final value is element `i` of the list *value* (note the brackets). In "
"other words, the brackets act as a subscripting operator on the list. This "
"is the case only when a single element is specified."
msgstr ""

#: ../../../TableGen/ProgRef.rst:523
msgid "*value*\\ ``[i,]``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:522
msgid ""
"The final value is a list that contains a single element `i` of the list. In "
"short, a list slice with a single element."
msgstr ""

#: ../../../TableGen/ProgRef.rst:534
msgid "*value*\\ ``[4...7,17,2...3,4]``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:526
msgid ""
"The final value is a new list that is a slice of the list *value*. The new "
"list contains elements 4, 5, 6, 7, 17, 2, 3, and 4. Elements may be included "
"multiple times and in any order. This is the result only when more than one "
"element is specified."
msgstr ""

#: ../../../TableGen/ProgRef.rst:534
msgid "*value*\\ ``[i,m...n,j,ls]``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:532
msgid ""
"Each element may be an expression (variables, bang operators). The type of "
"`m` and `n` should be `int`. The type of `i`, `j`, and `ls` should be either "
"`int` or `list<int>`."
msgstr ""

#: ../../../TableGen/ProgRef.rst:538
msgid "*value*\\ ``.``\\ *field*"
msgstr ""

#: ../../../TableGen/ProgRef.rst:537
msgid ""
"The final value is the value of the specified *field* in the specified "
"record *value*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:541
msgid "The paste operator"
msgstr ""

#: ../../../TableGen/ProgRef.rst:543
msgid ""
"The paste operator (``#``) is the only infix operator available in TableGen "
"expressions. It allows you to concatenate strings or lists, but has a few "
"unusual features."
msgstr ""

#: ../../../TableGen/ProgRef.rst:547
msgid ""
"The paste operator can be used when specifying the record name in a :token:"
"`Def` or :token:`Defm` statement, in which case it must construct a string. "
"If an operand is an undefined name (:token:`TokIdentifier`) or the name of a "
"global :token:`Defvar` or :token:`Defset`, it is treated as a verbatim "
"string of characters. The value of a global name is not used."
msgstr ""

#: ../../../TableGen/ProgRef.rst:553
msgid ""
"The paste operator can be used in all other value expressions, in which case "
"it can construct a string or a list. Rather oddly, but consistent with the "
"previous case, if the *right-hand-side* operand is an undefined name or a "
"global name, it is treated as a verbatim string of characters. The left-hand-"
"side operand is treated normally."
msgstr ""

#: ../../../TableGen/ProgRef.rst:559
msgid ""
"Values can have a trailing paste operator, in which case the left-hand-side "
"operand is concatenated to an empty string."
msgstr ""

#: ../../../TableGen/ProgRef.rst:562
msgid ""
"`Appendix B: Paste Operator Examples`_ presents examples of the behavior of "
"the paste operator."
msgstr ""

#: ../../../TableGen/ProgRef.rst:566
msgid "Statements"
msgstr ""

#: ../../../TableGen/ProgRef.rst:568
msgid ""
"The following statements may appear at the top level of TableGen source "
"files."
msgstr ""

#: ../../../TableGen/ProgRef.rst:577
msgid "The following sections describe each of these top-level statements."
msgstr ""

#: ../../../TableGen/ProgRef.rst:581
msgid "``class`` --- define an abstract record class"
msgstr ""

#: ../../../TableGen/ProgRef.rst:583
msgid ""
"A ``class`` statement defines an abstract record class from which other "
"classes and records can inherit."
msgstr ""

#: ../../../TableGen/ProgRef.rst:591
msgid ""
"A class can be parameterized by a list of \"template arguments,\" whose "
"values can be used in the class's record body. These template arguments are "
"specified each time the class is inherited by another class or record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:595
msgid ""
"If a template argument is not assigned a default value with ``=``, it is "
"uninitialized (has the \"value\" ``?``) and must be specified in the "
"template argument list when the class is inherited (required argument). If "
"an argument is assigned a default value, then it need not be specified in "
"the argument list (optional argument). In the declaration, all required "
"template arguments must precede any optional arguments. The template "
"argument default values are evaluated from left to right."
msgstr ""

#: ../../../TableGen/ProgRef.rst:603
msgid ""
"The :token:`RecordBody` is defined below. It can include a list of parent "
"classes from which the current class inherits, along with field definitions "
"and other statements. When a class ``C`` inherits from another class ``D``, "
"the fields of ``D`` are effectively merged into the fields of ``C``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:609
msgid ""
"A given class can only be defined once. A ``class`` statement is considered "
"to define the class if *any* of the following are true (the :token:"
"`RecordBody` elements are described below)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:613
msgid "The :token:`TemplateArgList` is present, or"
msgstr ""

#: ../../../TableGen/ProgRef.rst:614
msgid "The :token:`ParentClassList` in the :token:`RecordBody` is present, or"
msgstr ""

#: ../../../TableGen/ProgRef.rst:615
msgid "The :token:`Body` in the :token:`RecordBody` is present and not empty."
msgstr ""

#: ../../../TableGen/ProgRef.rst:617
msgid ""
"You can declare an empty class by specifying an empty :token:"
"`TemplateArgList` and an empty :token:`RecordBody`. This can serve as a "
"restricted form of forward declaration. Note that records derived from a "
"forward-declared class will inherit no fields from it, because those records "
"are built when their declarations are parsed, and thus before the class is "
"finally defined."
msgstr ""

#: ../../../TableGen/ProgRef.rst:625
msgid ""
"Every class has an implicit template argument named ``NAME`` (uppercase), "
"which is bound to the name of the :token:`Def` or :token:`Defm` inheriting "
"from the class. If the class is inherited by an anonymous record, the name "
"is unspecified but globally unique."
msgstr ""

#: ../../../TableGen/ProgRef.rst:630 ../../../TableGen/ProgRef.rst:748
msgid "See `Examples: classes and records`_ for examples."
msgstr ""

#: ../../../TableGen/ProgRef.rst:633
msgid "Record Bodies"
msgstr ""

#: ../../../TableGen/ProgRef.rst:635
msgid ""
"Record bodies appear in both class and record definitions. A record body can "
"include a parent class list, which specifies the classes from which the "
"current class or record inherits fields. Such classes are called the parent "
"classes of the class or record. The record body also includes the main body "
"of the definition, which contains the specification of the fields of the "
"class or record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:651
msgid ""
"A :token:`ParentClassList` containing a :token:`MultiClassID` is valid only "
"in the class list of a ``defm`` statement. In that case, the ID must be the "
"name of a multiclass."
msgstr ""

#: ../../../TableGen/ProgRef.rst:655
msgid "The argument values can be specified in two forms:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:657
msgid ""
"Positional argument (``value``). The value is assigned to the argument in "
"the corresponding position. For ``Foo<a0, a1>``, ``a0`` will be assigned to "
"first argument and ``a1`` will be assigned to second argument."
msgstr ""

#: ../../../TableGen/ProgRef.rst:660
msgid ""
"Named argument (``name=value``). The value is assigned to the argument with "
"the specified name. For ``Foo<a=a0, b=a1>``, ``a0`` will be assigned to the "
"argument with name ``a`` and ``a1`` will be assigned to the argument with "
"name ``b``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:665
msgid "Required arguments can also be specified as named argument."
msgstr ""

#: ../../../TableGen/ProgRef.rst:667
msgid ""
"Note that the argument can only be specified once regardless of the way "
"(named or positional) to specify and positional arguments should be put "
"before named arguments."
msgstr ""

#: ../../../TableGen/ProgRef.rst:678
msgid ""
"A field definition in the body specifies a field to be included in the class "
"or record. If no initial value is specified, then the field's value is "
"uninitialized. The type must be specified; TableGen will not infer it from "
"the value. The keyword ``code`` may be used to emphasize that the field has "
"a string value that is code."
msgstr ""

#: ../../../TableGen/ProgRef.rst:684
msgid ""
"The ``let`` form is used to reset a field to a new value. This can be done "
"for fields defined directly in the body or fields inherited from parent "
"classes.  A :token:`RangeList` can be specified to reset certain bits in a "
"``bit<n>`` field."
msgstr ""

#: ../../../TableGen/ProgRef.rst:689
msgid ""
"The ``defvar`` form defines a variable whose value can be used in other "
"value expressions within the body. The variable is not a field: it does not "
"become a field of the class or record being defined. Variables are provided "
"to hold temporary values while processing the body. See `Defvar in a Record "
"Body`_ for more details."
msgstr ""

#: ../../../TableGen/ProgRef.rst:695
msgid ""
"When class ``C2`` inherits from class ``C1``, it acquires all the field "
"definitions of ``C1``. As those definitions are merged into class ``C2``, "
"any template arguments passed to ``C1`` by ``C2`` are substituted into the "
"definitions. In other words, the abstract record fields defined by ``C1`` "
"are expanded with the template arguments before being merged into ``C2``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:705
msgid "``def`` --- define a concrete record"
msgstr ""

#: ../../../TableGen/ProgRef.rst:707
msgid "A ``def`` statement defines a new concrete record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:713
msgid ""
"The name value is optional. If specified, it is parsed in a special mode "
"where undefined (unrecognized) identifiers are interpreted as literal "
"strings. In particular, global identifiers are considered unrecognized. "
"These include global variables defined by ``defvar`` and ``defset``. A "
"record name can be the null string."
msgstr ""

#: ../../../TableGen/ProgRef.rst:719
msgid ""
"If no name value is given, the record is *anonymous*. The final name of an "
"anonymous record is unspecified but globally unique."
msgstr ""

#: ../../../TableGen/ProgRef.rst:722
msgid ""
"Special handling occurs if a ``def`` appears inside a ``multiclass`` "
"statement. See the ``multiclass`` section below for details."
msgstr ""

#: ../../../TableGen/ProgRef.rst:725
msgid ""
"A record can inherit from one or more classes by specifying the :token:"
"`ParentClassList` clause at the beginning of its record body. All of the "
"fields in the parent classes are added to the record. If two or more parent "
"classes provide the same field, the record ends up with the field value of "
"the last parent class."
msgstr ""

#: ../../../TableGen/ProgRef.rst:731
msgid ""
"As a special case, the name of a record can be passed as a template argument "
"to that record's parent classes. For example:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:742
msgid ""
"The DAG ``(ops rec1)`` is passed as a template argument to class ``A``. "
"Notice that the DAG includes ``rec1``, the record being defined."
msgstr ""

#: ../../../TableGen/ProgRef.rst:745
msgid ""
"The steps taken to create a new record are somewhat complex. See `How "
"records are built`_."
msgstr ""

#: ../../../TableGen/ProgRef.rst:752
msgid "Examples: classes and records"
msgstr ""

#: ../../../TableGen/ProgRef.rst:754
msgid ""
"Here is a simple TableGen file with one class and two record definitions."
msgstr ""

#: ../../../TableGen/ProgRef.rst:768
msgid ""
"First, the abstract class ``C`` is defined. It has one field named ``V`` "
"that is a bit initialized to true."
msgstr ""

#: ../../../TableGen/ProgRef.rst:771
msgid ""
"Next, two records are defined, derived from class ``C``; that is, with ``C`` "
"as their parent class. Thus they both inherit the ``V`` field. Record ``Y`` "
"also defines another string field, ``Greeting``, which is initialized to "
"``\"Hello!\"``. In addition, ``Y`` overrides the inherited ``V`` field, "
"setting it to false."
msgstr ""

#: ../../../TableGen/ProgRef.rst:777
msgid ""
"A class is useful for isolating the common features of multiple records in "
"one place. A class can initialize common fields to default values, but "
"records inheriting from that class can override the defaults."
msgstr ""

#: ../../../TableGen/ProgRef.rst:781
msgid ""
"TableGen supports the definition of parameterized classes as well as "
"nonparameterized ones. Parameterized classes specify a list of variable "
"declarations, which may optionally have defaults, that are bound when the "
"class is specified as a parent class of another class or record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:801
msgid ""
"The purpose of the ``FPFormat`` class is to act as a sort of enumerated "
"type. It provides a single field, ``Value``, which holds a 3-bit number. Its "
"template argument, ``val``, is used to set the ``Value`` field.  Each of the "
"eight records is defined with ``FPFormat`` as its parent class. The "
"enumeration value is passed in angle brackets as the template argument. Each "
"record will inherent the ``Value`` field with the appropriate enumeration "
"value."
msgstr ""

#: ../../../TableGen/ProgRef.rst:809
msgid ""
"Here is a more complex example of classes with template arguments. First, we "
"define a class similar to the ``FPFormat`` class above. It takes a template "
"argument and uses it to initialize a field named ``Value``. Then we define "
"four records that inherit the ``Value`` field with its four different "
"integer values."
msgstr ""

#: ../../../TableGen/ProgRef.rst:826
msgid ""
"This is somewhat contrived, but let's say we would like to examine the two "
"bits of the ``Value`` field independently. We can define a class that "
"accepts a ``ModRefVal`` record as a template argument and splits up its "
"value into two fields, one bit each. Then we can define records that inherit "
"from ``ModRefBits`` and so acquire two fields from it, one for each bit in "
"the ``ModRefVal`` record passed as the template argument."
msgstr ""

#: ../../../TableGen/ProgRef.rst:847
msgid ""
"This illustrates how one class can be defined to reorganize the fields in "
"another class, thus hiding the internal representation of that other class."
msgstr ""

#: ../../../TableGen/ProgRef.rst:851
msgid ""
"Running ``llvm-tblgen`` on the example prints the following definitions:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:869
msgid "``let`` --- override fields in classes or records"
msgstr ""

#: ../../../TableGen/ProgRef.rst:871
msgid ""
"A ``let`` statement collects a set of field values (sometimes called "
"*bindings*) and applies them to all the classes and records defined by "
"statements within the scope of the ``let``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:881
msgid ""
"The ``let`` statement establishes a scope, which is a sequence of statements "
"in braces or a single statement with no braces. The bindings in the :token:"
"`LetList` apply to the statements in that scope."
msgstr ""

#: ../../../TableGen/ProgRef.rst:885
msgid ""
"The field names in the :token:`LetList` must name fields in classes "
"inherited by the classes and records defined in the statements. The field "
"values are applied to the classes and records *after* the records inherit "
"all the fields from their parent classes. So the ``let`` acts to override "
"inherited field values. A ``let`` cannot override the value of a template "
"argument."
msgstr ""

#: ../../../TableGen/ProgRef.rst:891
msgid ""
"Top-level ``let`` statements are often useful when a few fields need to be "
"overridden in several records. Here are two examples. Note that ``let`` "
"statements can be nested."
msgstr ""

#: ../../../TableGen/ProgRef.rst:913
msgid ""
"Note that a top-level ``let`` will not override fields defined in the "
"classes or records themselves."
msgstr ""

#: ../../../TableGen/ProgRef.rst:918
msgid "``multiclass`` --- define multiple records"
msgstr ""

#: ../../../TableGen/ProgRef.rst:920
msgid ""
"While classes with template arguments are a good way to factor out "
"commonality between multiple records, multiclasses allow a convenient method "
"for defining many records at once. For example, consider a 3-address "
"instruction architecture whose instructions come in two formats: ``reg = reg "
"op reg`` and ``reg = reg op imm`` (e.g., SPARC). We would like to specify in "
"one place that these two common formats exist, then in a separate place "
"specify what all the operations are. The ``multiclass`` and ``defm`` "
"statements accomplish this goal. You can think of a multiclass as a macro or "
"template that expands into multiple records."
msgstr ""

#: ../../../TableGen/ProgRef.rst:937
msgid ""
"As with regular classes, the multiclass has a name and can accept template "
"arguments. A multiclass can inherit from other multiclasses, which causes "
"the other multiclasses to be expanded and contribute to the record "
"definitions in the inheriting multiclass. The body of the multiclass "
"contains a series of statements that define records, using :token:`Def` and :"
"token:`Defm`. In addition, :token:`Defvar`, :token:`Foreach`, and :token:"
"`Let` statements can be used to factor out even more common elements. The :"
"token:`If` and :token:`Assert` statements can also be used."
msgstr ""

#: ../../../TableGen/ProgRef.rst:946
msgid ""
"Also as with regular classes, the multiclass has the implicit template "
"argument ``NAME`` (see NAME_). When a named (non-anonymous) record is "
"defined in a multiclass and the record's name does not include a use of the "
"template argument ``NAME``, such a use is automatically *prepended* to the "
"name.  That is, the following are equivalent inside a multiclass::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:955
msgid ""
"The records defined in a multiclass are created when the multiclass is "
"\"instantiated\" or \"invoked\" by a ``defm`` statement outside the "
"multiclass definition. Each ``def`` statement in the multiclass produces a "
"record. As with top-level ``def`` statements, these definitions can inherit "
"from multiple parent classes."
msgstr ""

#: ../../../TableGen/ProgRef.rst:961 ../../../TableGen/ProgRef.rst:1007
msgid "See `Examples: multiclasses and defms`_ for examples."
msgstr ""

#: ../../../TableGen/ProgRef.rst:965
msgid "``defm`` --- invoke multiclasses to define multiple records"
msgstr ""

#: ../../../TableGen/ProgRef.rst:967
msgid ""
"Once multiclasses have been defined, you use the ``defm`` statement to "
"\"invoke\" them and process the multiple record definitions in those "
"multiclasses. Those record definitions are specified by ``def`` statements "
"in the multiclasses, and indirectly by ``defm`` statements."
msgstr ""

#: ../../../TableGen/ProgRef.rst:975
msgid ""
"The optional :token:`NameValue` is formed in the same way as the name of a "
"``def``. The :token:`ParentClassList` is a colon followed by a list of at "
"least one multiclass and any number of regular classes. The multiclasses "
"must precede the regular classes. Note that the ``defm`` does not have a "
"body."
msgstr ""

#: ../../../TableGen/ProgRef.rst:981
msgid ""
"This statement instantiates all the records defined in all the specified "
"multiclasses, either directly by ``def`` statements or indirectly by "
"``defm`` statements. These records also receive the fields defined in any "
"regular classes included in the parent class list. This is useful for adding "
"a common set of fields to all the records created by the ``defm``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:987
msgid ""
"The name is parsed in the same special mode used by ``def``. If the name is "
"not included, an unspecified but globally unique name is provided. That is, "
"the following examples end up with different names::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:994
msgid ""
"The ``defm`` statement can be used in a multiclass body. When this occurs, "
"the second variant is equivalent to::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:999
msgid ""
"More generally, when ``defm`` occurs in a multiclass and its name does not "
"include a use of the implicit template argument ``NAME``, then ``NAME`` will "
"be prepended automatically. That is, the following are equivalent inside a "
"multiclass::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1010
msgid "Examples: multiclasses and defms"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1012
msgid ""
"Here is a simple example using ``multiclass`` and ``defm``.  Consider a 3-"
"address instruction architecture whose instructions come in two formats: "
"``reg = reg op reg`` and ``reg = reg op imm`` (immediate). The SPARC is an "
"example of such an architecture."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1036
msgid ""
"Each use of the ``ri_inst`` multiclass defines two records, one with the "
"``_rr`` suffix and one with ``_ri``. Recall that the name of the ``defm`` "
"that uses a multiclass is prepended to the names of the records defined in "
"that multiclass. So the resulting definitions are named::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1045
msgid ""
"Without the ``multiclass`` feature, the instructions would have to be "
"defined as follows."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1071
msgid ""
"A ``defm`` can be used in a multiclass to \"invoke\" other multiclasses and "
"create the records defined in those multiclasses in addition to the records "
"defined in the current multiclass. In the following example, the ``basic_s`` "
"and ``basic_p`` multiclasses contain ``defm`` statements that refer to the "
"``basic_r`` multiclass. The ``basic_r`` multiclass contains only ``def`` "
"statements."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1104
msgid ""
"The final ``defm`` creates the following records, five from the ``basic_s`` "
"multiclass and five from the ``basic_p`` multiclass::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1114
msgid ""
"A ``defm`` statement, both at top level and in a multiclass, can inherit "
"from regular classes in addition to multiclasses. The rule is that the "
"regular classes must be listed after the multiclasses, and there must be at "
"least one multiclass."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1143
msgid ""
"This example will create four records, shown here in alphabetical order with "
"their fields."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1168
msgid ""
"It's also possible to use ``let`` statements inside multiclasses, providing "
"another way to factor out commonality from the records, especially when "
"using several levels of multiclass instantiations."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1195
msgid "``defset`` --- create a definition set"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1197
msgid ""
"The ``defset`` statement is used to collect a set of records into a global "
"list of records."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1203
msgid ""
"All records defined inside the braces via ``def`` and ``defm`` are defined "
"as usual, and they are also collected in a global list of the given name (:"
"token:`TokIdentifier`)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1207
msgid ""
"The specified type must be ``list<``\\ *class*\\ ``>``, where *class* is "
"some record class.  The ``defset`` statement establishes a scope for its "
"statements. It is an error to define a record in the scope of the ``defset`` "
"that is not of type *class*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1212
msgid ""
"The ``defset`` statement can be nested. The inner ``defset`` adds the "
"records to its own set, and all those records are also added to the outer "
"set."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1216
msgid ""
"Anonymous records created inside initialization expressions using the "
"``ClassID<...>`` syntax are not collected in the set."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1220
msgid "``deftype`` --- define a type"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1222
msgid ""
"A ``deftype`` statement defines a type. The type can be used throughout the "
"statements that follow the definition."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1228
msgid ""
"The identifier on the left of the ``=`` is defined to be a type name whose "
"actual type is given by the type expression on the right of the ``=``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1231
msgid ""
"Currently, only primitive types and type aliases are supported to be the "
"source type and `deftype` statements can only appear at the top level."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1235
msgid "``defvar`` --- define a variable"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1237
msgid ""
"A ``defvar`` statement defines a global variable. Its value can be used "
"throughout the statements that follow the definition."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1243
msgid ""
"The identifier on the left of the ``=`` is defined to be a global variable "
"whose value is given by the value expression on the right of the ``=``. The "
"type of the variable is automatically inferred."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1247
msgid "Once a variable has been defined, it cannot be set to another value."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1249
msgid ""
"Variables defined in a top-level ``foreach`` go out of scope at the end of "
"each loop iteration, so their value in one iteration is not available in the "
"next iteration.  The following ``defvar`` will not work::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1255
msgid ""
"Variables can also be defined with ``defvar`` in a record body. See `Defvar "
"in a Record Body`_ for more details."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1259
msgid "``foreach`` --- iterate over a sequence of statements"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1261
msgid ""
"The ``foreach`` statement iterates over a series of statements, varying a "
"variable over a sequence of values."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1269
msgid ""
"The body of the ``foreach`` is a series of statements in braces or a single "
"statement with no braces. The statements are re-evaluated once for each "
"value in the range list, range piece, or single value. On each iteration, "
"the :token:`TokIdentifier` variable is set to the value and can be used in "
"the statements."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1275
msgid ""
"The statement list establishes an inner scope. Variables local to a "
"``foreach`` go out of scope at the end of each loop iteration, so their "
"values do not carry over from one iteration to the next. Foreach loops may "
"be nested."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1290
msgid ""
"This loop defines records named ``R0``, ``R1``, ``R2``, and ``R3``, along "
"with ``F0``, ``F1``, ``F2``, and ``F3``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1294
msgid "``dump`` --- print messages to stderr"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1296
msgid ""
"A ``dump`` statement prints the input string to standard error output. It is "
"intended for debugging purpose."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1299
msgid "At top level, the message is printed immediately."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1301
msgid ""
"Within a record/class/multiclass, `dump` gets evaluated at each "
"instantiation point of the containing record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1307
msgid ""
"For example, it can be used in combination with `!repr` to investigate the "
"values passed to a multiclass:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1318
msgid "``if`` --- select statements based on a test"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1320
msgid ""
"The ``if`` statement allows one of two statement groups to be selected based "
"on the value of an expression."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1328
msgid ""
"The value expression is evaluated. If it evaluates to true (in the same "
"sense used by the bang operators), then the statements following the "
"``then`` reserved word are processed. Otherwise, if there is an ``else`` "
"reserved word, the statements following the ``else`` are processed. If the "
"value is false and there is no ``else`` arm, no statements are processed."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1334
msgid ""
"Because the braces around the ``then`` statements are optional, this grammar "
"rule has the usual ambiguity with \"dangling else\" clauses, and it is "
"resolved in the usual way: in a case like ``if v1 then if v2 then {...} else "
"{...}``, the ``else`` associates with the inner ``if`` rather than the outer "
"one."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1339
msgid ""
"The :token:`IfBody` of the then and else arms of the ``if`` establish an "
"inner scope. Any ``defvar`` variables defined in the bodies go out of scope "
"when the bodies are finished (see `Defvar in a Record Body`_ for more "
"details)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1343
msgid "The ``if`` statement can also be used in a record :token:`Body`."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1347
msgid "``assert`` --- check that a condition is true"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1349
msgid ""
"The ``assert`` statement checks a boolean condition to be sure that it is "
"true and prints an error message if it is not."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1355
msgid ""
"If the boolean condition is true, the statement does nothing. If the "
"condition is false, it prints a nonfatal error message. The **message**, "
"which can be an arbitrary string expression, is included in the error "
"message as a note. The exact behavior of the ``assert`` statement depends on "
"its placement."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1361
msgid "At top level, the assertion is checked immediately."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1363
msgid ""
"In a record definition, the statement is saved and all assertions are "
"checked after the record is completely built."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1366
msgid ""
"In a class definition, the assertions are saved and inherited by all the "
"subclasses and records that inherit from the class. The assertions are then "
"checked when the records are completely built."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1370
msgid ""
"In a multiclass definition, the assertions are saved with the other "
"components of the multiclass and then checked each time the multiclass is "
"instantiated with ``defm``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1374
msgid ""
"Using assertions in TableGen files can simplify record checking in TableGen "
"backends. Here is an example of an ``assert`` in two class definitions."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1395
msgid "Additional Details"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1398
msgid "Directed acyclic graphs (DAGs)"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1400
msgid ""
"A directed acyclic graph can be represented directly in TableGen using the "
"``dag`` datatype. A DAG node consists of an operator and zero or more "
"arguments (or operands). Each argument can be of any desired type. By using "
"another DAG node as an argument, an arbitrary graph of DAG nodes can be "
"built."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1406
msgid "The syntax of a ``dag`` instance is:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1408
msgid "``(`` *operator* *argument1*\\ ``,`` *argument2*\\ ``,`` ... ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1410
msgid ""
"The operator must be present and must be a record. There can be zero or more "
"arguments, separated by commas. The operator and arguments can have three "
"formats."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1415
msgid "Format"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1415
msgid "Meaning"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1417
msgid "*value*"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1417
msgid "argument value"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1418
msgid "*value*\\ ``:``\\ *name*"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1418
msgid "argument value and associated name"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1419
msgid "*name*"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1419
msgid "argument name with unset (uninitialized) value"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1422
msgid ""
"The *value* can be any TableGen value. The *name*, if present, must be a :"
"token:`TokVarName`, which starts with a dollar sign (``$``). The purpose of "
"a name is to tag an operator or argument in a DAG with a particular meaning, "
"or to associate an argument in one DAG with a like-named argument in another "
"DAG."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1428
msgid ""
"The following bang operators are useful for working with DAGs: ``!con``, ``!"
"dag``, ``!empty``, ``!foreach``, ``!getdagarg``, ``!getdagname``, ``!"
"getdagop``, ``!setdagarg``, ``!setdagname``, ``!setdagop``, ``!size``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1433
msgid "Defvar in a record body"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1435
msgid ""
"In addition to defining global variables, the ``defvar`` statement can be "
"used inside the :token:`Body` of a class or record definition to define "
"local variables. Template arguments of ``class`` or ``multiclass`` can be "
"used in the value expression. The scope of the variable extends from the "
"``defvar`` statement to the end of the body. It cannot be set to a different "
"value within its scope. The ``defvar`` statement can also be used in the "
"statement list of a ``foreach``, which establishes a scope."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1443
msgid ""
"A variable named ``V`` in an inner scope shadows (hides) any variables ``V`` "
"in outer scopes. In particular, there are several cases:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1446
msgid "``V`` in a record body shadows a global ``V``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1448
msgid "``V`` in a record body shadows template argument ``V``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1450
msgid "``V`` in template arguments shadows a global ``V``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1452
msgid ""
"``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding "
"record or global scopes."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1455
msgid ""
"Variables defined in a ``foreach`` go out of scope at the end of each loop "
"iteration, so their value in one iteration is not available in the next "
"iteration.  The following ``defvar`` will not work::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1462
msgid "How records are built"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1464
msgid ""
"The following steps are taken by TableGen when a record is built. Classes "
"are simply abstract records and so go through the same steps."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1467
msgid "Build the record name (:token:`NameValue`) and create an empty record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1469
msgid ""
"Parse the parent classes in the :token:`ParentClassList` from left to right, "
"visiting each parent class's ancestor classes from top to bottom."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1472
msgid "Add the fields from the parent class to the record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1473
msgid "Substitute the template arguments into those fields."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1474
msgid "Add the parent class to the record's list of inherited classes."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1476
msgid ""
"Apply any top-level ``let`` bindings to the record. Recall that top-level "
"bindings only apply to inherited fields."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1479
msgid "Parse the body of the record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1481
msgid "Add any fields to the record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1482
msgid "Modify the values of fields according to local ``let`` statements."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1483
msgid "Define any ``defvar`` variables."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1485
msgid "Make a pass over all the fields to resolve any inter-field references."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1487
msgid "Add the record to the final record list."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1489
msgid ""
"Because references between fields are resolved (step 5) after ``let`` "
"bindings are applied (step 3), the ``let`` statement has unusual power. For "
"example:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1509
msgid ""
"In both cases, one where a top-level ``let`` is used to bind ``Y`` and one "
"where a local ``let`` does the same thing, the results are:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1525
msgid ""
"``Yplus1`` is 11 because the ``let Y`` is performed before the ``!add(Y, "
"1)`` is resolved. Use this power wisely."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1530
msgid "Using Classes as Subroutines"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1532
msgid ""
"As described in `Simple values`_, a class can be invoked in an expression "
"and passed template arguments. This causes TableGen to create a new "
"anonymous record inheriting from that class. As usual, the record receives "
"all the fields defined in the class."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1537
msgid ""
"This feature can be employed as a simple subroutine facility. The class can "
"use the template arguments to define various variables and fields, which end "
"up in the anonymous record. Those fields can then be retrieved in the "
"expression invoking the class as follows. Assume that the field ``ret`` "
"contains the final value of the subroutine."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1547
msgid ""
"The ``CalcValue`` class is invoked with the template argument ``arg``. It "
"calculates a value for the ``ret`` field, which is then retrieved at the "
"\"point of call\" in the initialization for the Result field. The anonymous "
"record created in this example serves no other purpose than to carry the "
"result value."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1553
msgid ""
"Here is a practical example. The class ``isValidSize`` determines whether a "
"specified number of bytes represents a valid data size. The bit ``ret`` is "
"set appropriately. The field ``ValidSize`` obtains its initial value by "
"invoking ``isValidSize`` with the data size and retrieving the ``ret`` field "
"from the resulting anonymous record."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1576
msgid "Preprocessing Facilities"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1578
msgid ""
"The preprocessor embedded in TableGen is intended only for simple "
"conditional compilation. It supports the following directives, which are "
"specified somewhat informally."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1611
msgid ""
"A :token:`MacroName` can be defined anywhere in a TableGen file. The name "
"has no value; it can only be tested to see whether it is defined."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1614
msgid ""
"A macro test region begins with an ``#ifdef`` or ``#ifndef`` directive. If "
"the macro name is defined (``#ifdef``) or undefined (``#ifndef``), then the "
"source code between the directive and the corresponding ``#else`` or "
"``#endif`` is processed. If the test fails but there is an ``#else`` clause, "
"the source code between the ``#else`` and the ``#endif`` is processed. If "
"the test fails and there is no ``#else`` clause, then no source code in the "
"test region is processed."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1622
msgid ""
"Test regions may be nested, but they must be properly nested. A region "
"started in a file must end in that file; that is, must have its ``#endif`` "
"in the same file."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1626
msgid ""
"A :token:`MacroName` may be defined externally using the ``-D`` option on "
"the ``*-tblgen`` command line::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1632
msgid "Appendix A: Bang Operators"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1634
msgid ""
"Bang operators act as functions in value expressions. A bang operator takes "
"one or more arguments, operates on them, and produces a result. If the "
"operator produces a boolean result, the result value will be 1 for true or 0 "
"for false. When an operator tests a boolean argument, it interprets 0 as "
"false and non-0 as true."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1641
msgid ""
"The ``!getop`` and ``!setop`` bang operators are deprecated in favor of ``!"
"getdagop`` and ``!setdagop``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1645
msgid "``!add(``\\ *a*\\ ``,`` *b*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1645
msgid "This operator adds *a*, *b*, etc., and produces the sum."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1651
msgid "``!and(``\\ *a*\\ ``,`` *b*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1648
msgid ""
"This operator does a bitwise AND on *a*, *b*, etc., and produces the result. "
"A logical AND can be performed if all the arguments are either 0 or 1. This "
"operator is short-circuit to 0 when the left-most operand is 0."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1676
msgid "``!cast<``\\ *type*\\ ``>(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1654
msgid ""
"This operator performs a cast on *a* and produces the result. If *a* is not "
"a string, then a straightforward cast is performed, say between an ``int`` "
"and a ``bit``, or between record types. This allows casting a record to a "
"class. If a record is cast to ``string``, the record's name is produced."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1660
msgid ""
"If *a* is a string, then it is treated as a record name and looked up in the "
"list of all defined records. The resulting record is expected to be of the "
"specified *type*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1664
msgid ""
"For example, if ``!cast<``\\ *type*\\ ``>(``\\ *name*\\ ``)`` appears in a "
"multiclass definition, or in a class instantiated inside a multiclass "
"definition, and the *name* does not reference any template arguments of the "
"multiclass, then a record by that name must have been instantiated earlier "
"in the source file. If *name* does reference a template argument, then the "
"lookup is delayed until ``defm`` statements instantiating the multiclass (or "
"later, if the defm occurs in another multiclass and template arguments of "
"the inner multiclass that are referenced by *name* are substituted by values "
"that themselves contain references to template arguments of the outer "
"multiclass)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1676
msgid "If the type of *a* does not match *type*, TableGen raises an error."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1684
msgid "``!con(``\\ *a*\\ ``,`` *b*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1679
msgid ""
"This operator concatenates the DAG nodes *a*, *b*, etc. Their operations "
"must equal."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1682
msgid "``!con((op a1:$name1, a2:$name2), (op b1:$name3))``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1684
msgid "results in the DAG node ``(op a1:$name1, a2:$name2, b1:$name3)``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1693
msgid ""
"``!cond(``\\ *cond1* ``:`` *val1*\\ ``,`` *cond2* ``:`` *val2*\\ ``, ...,`` "
"*condn* ``:`` *valn*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1687
msgid ""
"This operator tests *cond1* and returns *val1* if the result is true. If "
"false, the operator tests *cond2* and returns *val2* if the result is true. "
"And so forth. An error is reported if no conditions are true."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1691
msgid "This example produces the sign word for an integer::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1707
msgid "``!dag(``\\ *op*\\ ``,`` *arguments*\\ ``,`` *names*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1696
msgid ""
"This operator creates a DAG node with the given operator and arguments. The "
"*arguments* and *names* arguments must be lists of equal length or "
"uninitialized (``?``). The *names* argument must be of type ``list<string>``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1701
msgid ""
"Due to limitations of the type system, *arguments* must be a list of items "
"of a common type. In practice, this means that they should either have the "
"same type or be records with a common parent class. Mixing ``dag`` and non-"
"``dag`` items is not possible. However, ``?`` can be used."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1706
msgid ""
"Example: ``!dag(op, [a1, a2, ?], [\"name1\", \"name2\", \"name3\"])`` "
"results in ``(op a1-value:$name1, a2-value:$name2, ?:$name3)``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1711
msgid "``!div(``\\ *a*\\ ``,`` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1710
msgid ""
"This operator performs signed division of *a* by *b*, and produces the "
"quotient. Division by 0 produces an error. Division of INT64_MIN by -1 "
"produces an error."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1715
msgid "``!empty(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1714
msgid ""
"This operator produces 1 if the string, list, or DAG *a* is empty; 0 "
"otherwise. A dag is empty if it has no arguments; the operator does not "
"count."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1720
msgid "``!eq(`` *a*\\ `,` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1718
msgid ""
"This operator produces 1 if *a* is equal to *b*; 0 otherwise. The arguments "
"must be ``bit``, ``bits``, ``int``, ``string``, or record values. Use ``!"
"cast<string>`` to compare other types of objects."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1724
msgid "``!exists<``\\ *type*\\ ``>(``\\ *name*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1723
msgid ""
"This operator produces 1 if a record of the given *type* whose name is "
"*name* exists; 0 otherwise. *name* should be of type *string*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1726
msgid "``!filter(``\\ *var*\\ ``,`` *list*\\ ``,`` *predicate*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1728
msgid ""
"This operator creates a new ``list`` by filtering the elements in *list*. To "
"perform the filtering, TableGen binds the variable *var* to each element and "
"then evaluates the *predicate* expression, which presumably refers to *var*. "
"The predicate must produce a boolean value (``bit``, ``bits``, or ``int``). "
"The value is interpreted as with ``!if``: if the value is 0, the element is "
"not included in the new list. If the value is anything else, the element is "
"included."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1741
msgid "``!find(``\\ *string1*\\ ``,`` *string2*\\ [``,`` *start*]\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1738
msgid ""
"This operator searches for *string2* in *string1* and produces its position. "
"The starting position of the search may be specified by *start*, which can "
"range between 0 and the length of *string1*; the default is 0. If the string "
"is not found, the result is -1."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1758
msgid ""
"``!foldl(``\\ *init*\\ ``,`` *list*\\ ``,`` *acc*\\ ``,`` *var*\\ ``,`` "
"*expr*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1744
msgid ""
"This operator performs a left-fold over the items in *list*. The variable "
"*acc* acts as the accumulator and is initialized to *init*. The variable "
"*var* is bound to each element in the *list*. The expression is evaluated "
"for each element and presumably uses *acc* and *var* to calculate the "
"accumulated value, which ``!foldl`` stores back in *acc*. The type of *acc* "
"is the same as *init*; the type of *var* is the same as the elements of "
"*list*; *expr* must have the same type as *init*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1752
msgid ""
"The following example computes the total of the ``Number`` field in the list "
"of records in ``RecList``::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1757
msgid ""
"If your goal is to filter the list and produce a new list that includes only "
"some of the elements, see ``!filter``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1768
msgid "``!foreach(``\\ *var*\\ ``,`` *sequence*\\ ``,`` *expr*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1761
msgid ""
"This operator creates a new ``list``/``dag`` in which each element is a "
"function of the corresponding element in the *sequence* ``list``/``dag``. To "
"perform the function, TableGen binds the variable *var* to an element and "
"then evaluates the expression. The expression presumably refers to the "
"variable *var* and calculates the result value."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1767
msgid ""
"If you simply want to create a list of a certain length containing the same "
"value repeated multiple times, see ``!listsplat``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1772
msgid "``!ge(``\\ *a*\\ `,` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1771
msgid ""
"This operator produces 1 if *a* is greater than or equal to *b*; 0 "
"otherwise. The arguments must be ``bit``, ``bits``, ``int``, or ``string`` "
"values."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1777
msgid "``!getdagarg<``\\ *type*\\ ``>(``\\ *dag*\\ ``,``\\ *key*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1775
msgid ""
"This operator retrieves the argument from the given *dag* node by the "
"specified *key*, which is either an integer index or a string name. If that "
"argument is not convertible to the specified *type*, ``?`` is returned."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1782
msgid "``!getdagname(``\\ *dag*\\ ``,``\\ *index*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1780
msgid ""
"This operator retrieves the argument name from the given *dag* node by the "
"specified *index*. If that argument has no name associated, ``?`` is "
"returned."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1804
msgid ""
"``!getdagop(``\\ *dag*\\ ``)`` --or-- ``!getdagop<``\\ *type*\\ ``>(``\\ "
"*dag*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1785
msgid ""
"This operator produces the operator of the given *dag* node. Example: ``!"
"getdagop((foo 1, 2))`` results in ``foo``. Recall that DAG operators are "
"always records."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1789
msgid ""
"The result of ``!getdagop`` can be used directly in a context where any "
"record class at all is acceptable (typically placing it into another dag "
"value). But in other contexts, it must be explicitly cast to a particular "
"class. The ``<``\\ *type*\\ ``>`` syntax is provided to make this easy."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1795
msgid ""
"For example, to assign the result to a value of type ``BaseClass``, you "
"could write either of these::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1801
msgid ""
"But to create a new DAG node that reuses the operator from another, no cast "
"is necessary::"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1808
msgid "``!gt(``\\ *a*\\ `,` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1807
msgid ""
"This operator produces 1 if *a* is greater than *b*; 0 otherwise. The "
"arguments must be ``bit``, ``bits``, ``int``, or ``string`` values."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1812
msgid "``!head(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1811
msgid ""
"This operator produces the zeroth element of the list *a*. (See also ``!"
"tail``.)"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1817
msgid "``!if(``\\ *test*\\ ``,`` *then*\\ ``,`` *else*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1815
msgid ""
"This operator evaluates the *test*, which must produce a ``bit`` or ``int``. "
"If the result is not 0, the *then* expression is produced; otherwise the "
"*else* expression is produced."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1821
msgid "``!initialized(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1820
msgid ""
"This operator produces 1 if *a* is not the uninitialized value (``?``) and 0 "
"otherwise."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1827
msgid "``!interleave(``\\ *list*\\ ``,`` *delim*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1824
msgid ""
"This operator concatenates the items in the *list*, interleaving the *delim* "
"string between each pair, and produces the resulting string. The list can be "
"a list of string, int, bits, or bit. An empty list results in an empty "
"string. The delimiter can be the empty string."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1831
msgid "``!isa<``\\ *type*\\ ``>(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1830
msgid ""
"This operator produces 1 if the type of *a* is a subtype of the given "
"*type*; 0 otherwise."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1835
msgid "``!le(``\\ *a*\\ ``,`` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1834
msgid ""
"This operator produces 1 if *a* is less than or equal to *b*; 0 otherwise. "
"The arguments must be ``bit``, ``bits``, ``int``, or ``string`` values."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1839
msgid "``!listconcat(``\\ *list1*\\ ``,`` *list2*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1838
msgid ""
"This operator concatenates the list arguments *list1*, *list2*, etc., and "
"produces the resulting list. The lists must have the same element type."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1845
msgid "``!listflatten(``\\ *list*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1842
msgid ""
"This operator flattens a list of lists *list* and produces a list with all "
"elements of the constituent lists concatenated. If *list* is of type "
"``list<list<X>>`` the resulting list is of type ``list<X>``. If *list*'s "
"element type is not a list, the result is *list* itself."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1849
msgid "``!listremove(``\\ *list1*\\ ``,`` *list2*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1848
msgid ""
"This operator returns a copy of *list1* removing all elements that also "
"occur in *list2*. The lists must have the same element type."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1854
msgid "``!listsplat(``\\ *value*\\ ``,`` *count*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1852
msgid ""
"This operator produces a list of length *count* whose elements are all equal "
"to the *value*. For example, ``!listsplat(42, 3)`` results in ``[42, 42, "
"42]``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1859
msgid "``!logtwo(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1857
msgid ""
"This operator produces the base 2 log of *a* and produces the integer "
"result. The log of 0 or a negative number produces an error. This is a "
"flooring operation."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1863
msgid "``!lt(``\\ *a*\\ `,` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1862
msgid ""
"This operator produces 1 if *a* is less than *b*; 0 otherwise. The arguments "
"must be ``bit``, ``bits``, ``int``, or ``string`` values."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1866
msgid "``!mul(``\\ *a*\\ ``,`` *b*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1866
msgid "This operator multiplies *a*, *b*, etc., and produces the product."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1871
msgid "``!ne(``\\ *a*\\ `,` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1869
msgid ""
"This operator produces 1 if *a* is not equal to *b*; 0 otherwise. The "
"arguments must be ``bit``, ``bits``, ``int``, ``string``, or record values. "
"Use ``!cast<string>`` to compare other types of objects."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1876
msgid "``!not(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1874
msgid ""
"This operator performs a logical NOT on *a*, which must be an integer. The "
"argument 0 results in 1 (true); any other argument results in 0 (false)."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1882
msgid "``!or(``\\ *a*\\ ``,`` *b*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1879
msgid ""
"This operator does a bitwise OR on *a*, *b*, etc., and produces the result. "
"A logical OR can be performed if all the arguments are either 0 or 1. This "
"operator is short-circuit to -1 (all ones) the left-most operand is -1."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1898
msgid "``!range([``\\ *start*\\ ``,]`` *end*\\ ``[,``\\ *step*\\ ``])``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1885
msgid ""
"This operator produces half-open range sequence ``[start : end : step)`` as "
"``list<int>``. *start* is ``0`` and *step* is ``1`` by default. *step* can "
"be negative and cannot be 0. If *start* ``<`` *end* and *step* is negative, "
"or *start* ``>`` *end* and *step* is positive, the result is an empty list "
"``[]<list<int>>``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1891
msgid "For example:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1893
msgid ""
"``!range(4)`` is equivalent to ``!range(0, 4, 1)`` and the result is `[0, 1, "
"2, 3]`."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1895
msgid ""
"``!range(1, 4)`` is equivalent to ``!range(1, 4, 1)`` and the result is `[1, "
"2, 3]`."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1897
msgid "The result of ``!range(0, 4, 2)`` is `[0, 2]`."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1898
msgid "The results of ``!range(0, 4, -1)`` and ``!range(4, 0, 1)`` are empty."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1901
msgid "``!range(``\\ *list*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1901
msgid "Equivalent to ``!range(0, !size(list))``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1905
msgid "``!repr(``\\ *value*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1904
msgid ""
"Represents *value* as a string. String format for the value is not "
"guaranteed to be stable. Intended for debugging purposes only."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1910
msgid "``!setdagarg(``\\ *dag*\\ ``,``\\ *key*\\ ``,``\\ *arg*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1908
msgid ""
"This operator produces a DAG node with the same operator and arguments as "
"*dag*, but replacing the value of the argument specified by the *key* with "
"*arg*. That *key* could be either an integer index or a string name."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1915
msgid "``!setdagname(``\\ *dag*\\ ``,``\\ *key*\\ ``,``\\ *name*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1913
msgid ""
"This operator produces a DAG node with the same operator and arguments as "
"*dag*, but replacing the name of the argument specified by the *key* with "
"*name*. That *key* could be either an integer index or a string name."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1921
msgid "``!setdagop(``\\ *dag*\\ ``,`` *op*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1918
msgid ""
"This operator produces a DAG node with the same arguments as *dag*, but with "
"its operator replaced with *op*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1921
msgid "Example: ``!setdagop((foo 1, 2), bar)`` results in ``(bar 1, 2)``."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1926
msgid "``!shl(``\\ *a*\\ ``,`` *count*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1924
msgid ""
"This operator shifts *a* left logically by *count* bits and produces the "
"resulting value. The operation is performed on a 64-bit integer; the result "
"is undefined for shift counts outside 0...63."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1930
msgid "``!size(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1929
msgid ""
"This operator produces the size of the string, list, or dag *a*. The size of "
"a DAG is the number of arguments; the operator does not count."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1935
msgid "``!sra(``\\ *a*\\ ``,`` *count*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1933
msgid ""
"This operator shifts *a* right arithmetically by *count* bits and produces "
"the resulting value. The operation is performed on a 64-bit integer; the "
"result is undefined for shift counts outside 0...63."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1940
msgid "``!srl(``\\ *a*\\ ``,`` *count*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1938
msgid ""
"This operator shifts *a* right logically by *count* bits and produces the "
"resulting value. The operation is performed on a 64-bit integer; the result "
"is undefined for shift counts outside 0...63."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1944
msgid "``!strconcat(``\\ *str1*\\ ``,`` *str2*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1943
msgid ""
"This operator concatenates the string arguments *str1*, *str2*, etc., and "
"produces the resulting string."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1947
msgid "``!sub(``\\ *a*\\ ``,`` *b*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1947
msgid ""
"This operator subtracts *b* from *a* and produces the arithmetic difference."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1956
msgid "``!subst(``\\ *target*\\ ``,`` *repl*\\ ``,`` *value*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1950
msgid ""
"This operator replaces all occurrences of the *target* in the *value* with "
"the *repl* and produces the resulting value. The *value* can be a string, in "
"which case substring substitution is performed."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1954
msgid ""
"The *value* can be a record name, in which case the operator produces the "
"*repl* record if the *target* record name equals the *value* record name; "
"otherwise it produces the *value*."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1963
msgid "``!substr(``\\ *string*\\ ``,`` *start*\\ [``,`` *length*]\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1959
msgid ""
"This operator extracts a substring of the given *string*. The starting "
"position of the substring is specified by *start*, which can range between 0 "
"and the length of the string. The length of the substring is specified by "
"*length*; if not specified, the rest of the string is extracted. The *start* "
"and *length* arguments must be integers."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1967
msgid "``!tail(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1966
msgid ""
"This operator produces a new list with all the elements of the list *a* "
"except for the zeroth one. (See also ``!head``.)"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1970
msgid "``!tolower(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1970
msgid "This operator converts a string input *a* to lower case."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1973
msgid "``!toupper(``\\ *a*\\ ``)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1973
msgid "This operator converts a string input *a* to upper case."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1978
msgid "``!xor(``\\ *a*\\ ``,`` *b*\\ ``, ...)``"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1976
msgid ""
"This operator does a bitwise EXCLUSIVE OR on *a*, *b*, etc., and produces "
"the result. A logical XOR can be performed if all the arguments are either 0 "
"or 1."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1981
msgid "Appendix B: Paste Operator Examples"
msgstr ""

#: ../../../TableGen/ProgRef.rst:1983
msgid ""
"Here is an example illustrating the use of the paste operator in record "
"names."
msgstr ""

#: ../../../TableGen/ProgRef.rst:1998
msgid ""
"The first ``def`` does not use the value of the ``suffix`` variable. The "
"second def does use the value of the ``i`` iterator variable, because it is "
"not a global name. The following records are produced."
msgstr ""

#: ../../../TableGen/ProgRef.rst:2011
msgid ""
"Here is a second example illustrating the paste operator in field value "
"expressions."
msgstr ""

#: ../../../TableGen/ProgRef.rst:2020
msgid ""
"The ``strings`` field expression uses ``suffix`` on both sides of the paste "
"operator. It is evaluated normally on the left hand side, but taken verbatim "
"on the right hand side. The ``integers`` field expression uses the value of "
"the ``some_ints`` variable and a literal list. The following record is "
"produced."
msgstr ""

#: ../../../TableGen/ProgRef.rst:2035
msgid "Appendix C: Sample Record"
msgstr ""

#: ../../../TableGen/ProgRef.rst:2037
msgid ""
"One target machine supported by LLVM is the Intel x86. The following output "
"from TableGen shows the record that is created to represent the 32-bit "
"register-to-register ADD instruction."
msgstr ""

#: ../../../TableGen/ProgRef.rst:2155
msgid ""
"On the first line of the record, you can see that the ``ADD32rr`` record "
"inherited from eight classes. Although the inheritance hierarchy is complex, "
"using parent classes is much simpler than specifying the 109 individual "
"fields for each instruction."
msgstr ""

#: ../../../TableGen/ProgRef.rst:2160
msgid ""
"Here is the code fragment used to define ``ADD32rr`` and multiple other "
"``ADD`` instructions:"
msgstr ""

#: ../../../TableGen/ProgRef.rst:2168
msgid ""
"The ``defm`` statement tells TableGen that ``ArithBinOp_RF`` is a "
"multiclass, which contains multiple concrete record definitions that inherit "
"from ``BinOpRR_RF``. That class, in turn, inherits from ``BinOpRR``, which "
"inherits from ``ITy`` and ``Sched``, and so forth. The fields are inherited "
"from all the parent classes; for example, ``IsIndirectBranch`` is inherited "
"from the ``Instruction`` class."
msgstr ""
