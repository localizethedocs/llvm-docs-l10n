# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/OCamlLangImpl4.rst:3
msgid "Kaleidoscope: Adding JIT and Optimizer Support"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:9
msgid "Chapter 4 Introduction"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:11
msgid ""
"Welcome to Chapter 4 of the \"`Implementing a language with LLVM <index."
"html>`_\" tutorial. Chapters 1-3 described the implementation of a simple "
"language and added support for generating LLVM IR. This chapter describes "
"two new techniques: adding optimizer support to your language, and adding "
"JIT compiler support. These additions will demonstrate how to get nice, "
"efficient code for the Kaleidoscope language."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:20
msgid "Trivial Constant Folding"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:22
msgid ""
"**Note:** the default ``IRBuilder`` now always includes the constant folding "
"optimisations below."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:25
msgid ""
"Our demonstration for Chapter 3 is elegant and easy to extend. "
"Unfortunately, it does not produce wonderful code. For example, when "
"compiling simple code, we don't get obvious optimizations:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:40
msgid ""
"This code is a very, very literal transcription of the AST built by parsing "
"the input. As such, this transcription lacks optimizations like constant "
"folding (we'd like to get \"``add x, 3.0``\" in the example above) as well "
"as other more important optimizations. Constant folding, in particular, is a "
"very common and very important optimization: so much so that many language "
"implementors implement constant folding support in their AST representation."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:48
msgid ""
"With LLVM, you don't need this support in the AST. Since all calls to build "
"LLVM IR go through the LLVM builder, it would be nice if the builder itself "
"checked to see if there was a constant folding opportunity when you call it. "
"If so, it could just do the constant fold and return the constant instead of "
"creating an instruction. This is exactly what the ``LLVMFoldingBuilder`` "
"class does."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:55
msgid ""
"All we did was switch from ``LLVMBuilder`` to ``LLVMFoldingBuilder``. Though "
"we change no other code, we now have all of our instructions implicitly "
"constant folded without us having to do anything about it. For example, the "
"input above now compiles to:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:70
msgid ""
"Well, that was easy :). In practice, we recommend always using "
"``LLVMFoldingBuilder`` when generating code like this. It has no \"syntactic "
"overhead\" for its use (you don't have to uglify your compiler with constant "
"checks everywhere) and it can dramatically reduce the amount of LLVM IR that "
"is generated in some cases (particular for languages with a macro "
"preprocessor or that use a lot of constants)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:77
msgid ""
"On the other hand, the ``LLVMFoldingBuilder`` is limited by the fact that it "
"does all of its analysis inline with the code as it is built. If you take a "
"slightly more complex example:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:93
msgid ""
"In this case, the LHS and RHS of the multiplication are the same value. We'd "
"really like to see this generate \"``tmp = x+3; result = tmp*tmp;``\" "
"instead of computing \"``x*3``\" twice."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:97
msgid ""
"Unfortunately, no amount of local analysis will be able to detect and "
"correct this. This requires two transformations: reassociation of "
"expressions (to make the add's lexically identical) and Common Subexpression "
"Elimination (CSE) to delete the redundant add instruction. Fortunately, LLVM "
"provides a broad range of optimizations that you can use, in the form of "
"\"passes\"."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:105
msgid "LLVM Optimization Passes"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:107
msgid ""
"LLVM provides many optimization passes, which do many different sorts of "
"things and have different tradeoffs. Unlike other systems, LLVM doesn't hold "
"to the mistaken notion that one set of optimizations is right for all "
"languages and for all situations. LLVM allows a compiler implementor to make "
"complete decisions about what optimizations to use, in which order, and in "
"what situation."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:114
msgid ""
"As a concrete example, LLVM supports both \"whole module\" passes, which "
"look across as large of body of code as they can (often a whole file, but if "
"run at link time, this can be a substantial portion of the whole program). "
"It also supports and includes \"per-function\" passes which just operate on "
"a single function at a time, without looking at other functions. For more "
"information on passes and how they are run, see the `How to Write a Pass <../"
"WritingAnLLVMPass.html>`_ document and the `List of LLVM Passes <../Passes."
"html>`_."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:123
msgid ""
"For Kaleidoscope, we are currently generating functions on the fly, one at a "
"time, as the user types them in. We aren't shooting for the ultimate "
"optimization experience in this setting, but we also want to catch the easy "
"and quick stuff where possible. As such, we will choose to run a few per-"
"function optimizations as the user types the function in. If we wanted to "
"make a \"static Kaleidoscope compiler\", we would use exactly the code we "
"have now, except that we would defer running the optimizer until the entire "
"file has been parsed."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:132
msgid ""
"In order to get per-function optimizations going, we need to set up a `Llvm."
"PassManager <../WritingAnLLVMPass.html#what-passmanager-does>`_ to hold and "
"organize the LLVM optimizations that we want to run. Once we have that, we "
"can add a set of optimizations to run. The code looks like this:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:164
msgid ""
"The meat of the matter here, is the definition of \"``the_fpm``\". It "
"requires a pointer to the ``the_module`` to construct itself. Once it is set "
"up, we use a series of \"add\" calls to add a bunch of LLVM passes. The "
"first pass is basically boilerplate, it adds a pass so that later "
"optimizations know how the data structures in the program are laid out. The "
"\"``the_execution_engine``\" variable is related to the JIT, which we will "
"get to in the next section."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:172
msgid ""
"In this case, we choose to add 4 optimization passes. The passes we chose "
"here are a pretty standard set of \"cleanup\" optimizations that are useful "
"for a wide variety of code. I won't delve into what they do but, believe me, "
"they are a good starting place :)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:177
msgid ""
"Once the ``Llvm.PassManager.`` is set up, we need to make use of it. We do "
"this by running it after our newly created function is constructed (in "
"``Codegen.codegen_func``), but before it is returned to the client:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:199
msgid ""
"As you can see, this is pretty straightforward. The ``the_fpm`` optimizes "
"and updates the LLVM Function\\* in place, improving (hopefully) its body. "
"With this in place, we can try our test above again:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:215
msgid ""
"As expected, we now get our nicely optimized code, saving a floating point "
"add instruction from every execution of this function."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:218
msgid ""
"LLVM provides a wide variety of optimizations that can be used in certain "
"circumstances. Some `documentation about the various passes <../Passes."
"html>`_ is available, but it isn't very complete. Another good source of "
"ideas can come from looking at the passes that ``Clang`` runs to get "
"started. The \"``opt``\" tool allows you to experiment with passes from the "
"command line, so you can see if they do anything."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:226
msgid ""
"Now that we have reasonable code coming out of our front-end, lets talk "
"about executing it!"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:230
msgid "Adding a JIT Compiler"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:232
msgid ""
"Code that is available in LLVM IR can have a wide variety of tools applied "
"to it. For example, you can run optimizations on it (as we did above), you "
"can dump it out in textual or binary forms, you can compile the code to an "
"assembly file (.s) for some target, or you can JIT compile it. The nice "
"thing about the LLVM IR representation is that it is the \"common currency\" "
"between many different parts of the compiler."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:239
msgid ""
"In this section, we'll add JIT compiler support to our interpreter. The "
"basic idea that we want for Kaleidoscope is to have the user enter function "
"bodies as they do now, but immediately evaluate the top-level expressions "
"they type in. For example, if they type in \"1 + 2;\", we should evaluate "
"and print out 3. If they define a function, they should be able to call it "
"from the command line."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:246
msgid ""
"In order to do this, we first declare and initialize the JIT. This is done "
"by adding a global variable and a call in ``main``:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:258
msgid ""
"This creates an abstract \"Execution Engine\" which can be either a JIT "
"compiler or the LLVM interpreter. LLVM will automatically pick a JIT "
"compiler for you if one is available for your platform, otherwise it will "
"fall back to the interpreter."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:263
msgid ""
"Once the ``Llvm_executionengine.ExecutionEngine.t`` is created, the JIT is "
"ready to be used. There are a variety of APIs that are useful, but the "
"simplest one is the \"``Llvm_executionengine.ExecutionEngine."
"run_function``\" function. This method JIT compiles the specified LLVM "
"Function and returns a function pointer to the generated machine code. In "
"our case, this means that we can change the code that parses a top-level "
"expression to look like this:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:288
msgid ""
"Recall that we compile top-level expressions into a self-contained LLVM "
"function that takes no arguments and returns the computed double. Because "
"the LLVM JIT compiler matches the native platform ABI, this means that you "
"can just cast the result pointer to a function pointer of that type and call "
"it directly. This means, there is no difference between JIT compiled code "
"and native machine code that is statically linked into your application."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:296
msgid "With just these two changes, lets see how Kaleidoscope works now!"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:308
msgid ""
"Well this looks like it is basically working. The dump of the function shows "
"the \"no argument function that always returns double\" that we synthesize "
"for each top level expression that is typed in. This demonstrates very basic "
"functionality, but can we do more?"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:333
msgid ""
"This illustrates that we can now call user code, but there is something a "
"bit subtle going on here. Note that we only invoke the JIT on the anonymous "
"functions that *call testfunc*, but we never invoked it on *testfunc* "
"itself. What actually happened here is that the JIT scanned for all non-"
"JIT'd functions transitively called from the anonymous function and compiled "
"all of them before returning from ``run_function``."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:341
msgid ""
"The JIT provides a number of other more advanced interfaces for things like "
"freeing allocated machine code, rejit'ing functions to update them, etc. "
"However, even with this simple code, we get some surprisingly powerful "
"capabilities - check this out (I removed the dump of the anonymous "
"functions, you should get the idea by now :) :"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:375
msgid ""
"Whoa, how does the JIT know about sin and cos? The answer is surprisingly "
"simple: in this example, the JIT started execution of a function and got to "
"a function call. It realized that the function was not yet JIT compiled and "
"invoked the standard set of routines to resolve the function. In this case, "
"there is no body defined for the function, so the JIT ended up calling "
"\"``dlsym(\"sin\")``\" on the Kaleidoscope process itself. Since \"``sin``\" "
"is defined within the JIT's address space, it simply patches up calls in the "
"module to call the libm version of ``sin`` directly."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:385
msgid ""
"The LLVM JIT provides a number of interfaces (look in the "
"``llvm_executionengine.mli`` file) for controlling how unknown functions get "
"resolved. It allows you to establish explicit mappings between IR objects "
"and addresses (useful for LLVM global variables that you want to map to "
"static tables, for example), allows you to dynamically decide on the fly "
"based on the function name, and even allows you to have the JIT compile "
"functions lazily the first time they're called."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:393
msgid ""
"One interesting application of this is that we can now extend the language "
"by writing arbitrary C code to implement operations. For example, if we add:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:406
msgid ""
"Now we can produce simple output to the console by using things like: "
"\"``extern putchard(x); putchard(120);``\", which prints a lowercase 'x' on "
"the console (120 is the ASCII code for 'x'). Similar code could be used to "
"implement file I/O, console input, and many other capabilities in "
"Kaleidoscope."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:412
msgid ""
"This completes the JIT and optimizer chapter of the Kaleidoscope tutorial. "
"At this point, we can compile a non-Turing-complete programming language, "
"optimize and JIT compile it in a user-driven way. Next up we'll look into "
"`extending the language with control flow constructs <OCamlLangImpl5."
"html>`_, tackling some interesting LLVM IR issues along the way."
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:420
msgid "Full Code Listing"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:422
msgid ""
"Here is the complete code listing for our running example, enhanced with the "
"LLVM JIT and optimizer. To build this example, use:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:432
msgid "Here is the code:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:440
msgid "\\_tags:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:454
msgid "myocamlbuild.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:473
msgid "token.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:529
msgid "lexer.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:558
msgid "ast.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:684
msgid "parser.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:791
msgid "codegen.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:844
msgid "toplevel.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:901
msgid "toy.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:912
msgid "bindings.c"
msgstr ""

#: ../../../tutorial/OCamlLangImpl4.rst:914
msgid "`Next: Extending the language: control flow <OCamlLangImpl5.html>`_"
msgstr ""
