# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../Lexicon.rst:3
msgid "The LLVM Lexicon"
msgstr ""

#: ../../../Lexicon.rst:7
msgid "This document is a work in progress!"
msgstr ""

#: ../../../Lexicon.rst:10
msgid "Definitions"
msgstr ""

#: ../../../Lexicon.rst:13
msgid "A"
msgstr ""

#: ../../../Lexicon.rst:16
msgid "**ADCE**"
msgstr ""

#: ../../../Lexicon.rst:16
msgid "Aggressive Dead Code Elimination"
msgstr ""

#: ../../../Lexicon.rst:31
msgid "**AST**"
msgstr ""

#: ../../../Lexicon.rst:19
msgid "Abstract Syntax Tree."
msgstr ""

#: ../../../Lexicon.rst:21
msgid ""
"Due to Clang's influence (mostly the fact that parsing and semantic analysis "
"are so intertwined for C and especially C++), the typical working definition "
"of AST in the LLVM community is roughly \"the compiler's first complete "
"symbolic (as opposed to textual) representation of an input program\". As "
"such, an \"AST\" might be a more general graph instead of a "
"\"tree\" (consider the symbolic representation for the type of a typical "
"\"linked list node\"). This working definition is closer to what some "
"authors call an \"annotated abstract syntax tree\"."
msgstr ""

#: ../../../Lexicon.rst:31
msgid "Consult your favorite compiler book or search engine for more details."
msgstr ""

#: ../../../Lexicon.rst:34
msgid "B"
msgstr ""

#: ../../../Lexicon.rst:39
msgid "**BB Vectorization**"
msgstr ""

#: ../../../Lexicon.rst:39
msgid "Basic-Block Vectorization"
msgstr ""

#: ../../../Lexicon.rst:46
msgid "**BDCE**"
msgstr ""

#: ../../../Lexicon.rst:42
msgid ""
"Bit-tracking dead code elimination. Some bit-wise instructions (shifts, "
"ands, ors, etc.) \"kill\" some of their input bits -- that is, they make it "
"such that those bits can be either zero or one without affecting control or "
"data flow of a program. The BDCE pass removes instructions that only compute "
"these dead bits."
msgstr ""

#: ../../../Lexicon.rst:51
msgid "**BURS**"
msgstr ""

#: ../../../Lexicon.rst:49
msgid ""
"Bottom Up Rewriting System --- A method of instruction selection for code "
"generation.  An example is the `BURG <http://www.program-transformation.org/"
"Transform/BURG>`_ tool."
msgstr ""

#: ../../../Lexicon.rst:54
msgid "C"
msgstr ""

#: ../../../Lexicon.rst:58
msgid "**CFI**"
msgstr ""

#: ../../../Lexicon.rst:57
msgid ""
"Call Frame Information. Used in DWARF debug info and in C++ unwind info to "
"show how the function prolog lays out the stack frame."
msgstr ""

#: ../../../Lexicon.rst:63
msgid "**CIE**"
msgstr ""

#: ../../../Lexicon.rst:61
msgid ""
"Common Information Entry.  A kind of CFI used to reduce the size of FDEs. "
"The compiler creates a CIE which contains the information common across all "
"the FDEs.  Each FDE then points to its CIE."
msgstr ""

#: ../../../Lexicon.rst:70
msgid "**CSE**"
msgstr ""

#: ../../../Lexicon.rst:66
msgid ""
"Common Subexpression Elimination. An optimization that removes common "
"subexpression computation. For example ``(a+b)*(a+b)`` has two "
"subexpressions that are the same: ``(a+b)``. This optimization would perform "
"the addition only once and then perform the multiply (but only if it's "
"computationally correct/safe)."
msgstr ""

#: ../../../Lexicon.rst:73
msgid "D"
msgstr ""

#: ../../../Lexicon.rst:76
msgid "**DAG**"
msgstr ""

#: ../../../Lexicon.rst:76
msgid "Directed Acyclic Graph"
msgstr ""

#: ../../../Lexicon.rst:87
msgid "**Derived Pointer**"
msgstr ""

#: ../../../Lexicon.rst:82
msgid ""
"A pointer to the interior of an object, such that a garbage collector is "
"unable to use the pointer for reachability analysis. While a derived pointer "
"is live, the corresponding object pointer must be kept in a root, otherwise "
"the collector might free the referenced object. With copying collectors, "
"derived pointers pose an additional hazard that they may be invalidated at "
"any `safe point`_. This term is used in opposition to `object pointer`_."
msgstr ""

#: ../../../Lexicon.rst:90
msgid "**DSA**"
msgstr ""

#: ../../../Lexicon.rst:90
msgid "Data Structure Analysis"
msgstr ""

#: ../../../Lexicon.rst:93
msgid "**DSE**"
msgstr ""

#: ../../../Lexicon.rst:93
msgid "Dead Store Elimination"
msgstr ""

#: ../../../Lexicon.rst:96
msgid "F"
msgstr ""

#: ../../../Lexicon.rst:99
msgid "**FCA**"
msgstr ""

#: ../../../Lexicon.rst:99
msgid "First Class Aggregate"
msgstr ""

#: ../../../Lexicon.rst:103
msgid "**FDE**"
msgstr ""

#: ../../../Lexicon.rst:102
msgid ""
"Frame Description Entry. A kind of CFI used to describe the stack frame of "
"one function."
msgstr ""

#: ../../../Lexicon.rst:106
msgid "G"
msgstr ""

#: ../../../Lexicon.rst:110
msgid "**GC**"
msgstr ""

#: ../../../Lexicon.rst:109
msgid ""
"Garbage Collection. The practice of using reachability analysis instead of "
"explicit memory management to reclaim unused memory."
msgstr ""

#: ../../../Lexicon.rst:115
msgid "**GEP**"
msgstr ""

#: ../../../Lexicon.rst:113
msgid ""
"``GetElementPtr``. An LLVM IR instruction that is used to get the address of "
"a subelement of an aggregate data structure. It is documented in detail "
"`here <https://llvm.org/docs/GetElementPtr.html>`_."
msgstr ""

#: ../../../Lexicon.rst:122
msgid "**GVN**"
msgstr ""

#: ../../../Lexicon.rst:118
msgid ""
"Global Value Numbering. GVN is a pass that partitions values computed by a "
"function into congruence classes. Values ending up in the same congruence "
"class are guaranteed to be the same for every execution of the program. In "
"that respect, congruency is a compile-time approximation of equivalence of "
"values at runtime."
msgstr ""

#: ../../../Lexicon.rst:125
msgid "H"
msgstr ""

#: ../../../Lexicon.rst:131
msgid "**Heap**"
msgstr ""

#: ../../../Lexicon.rst:130
msgid ""
"In garbage collection, the region of memory which is managed using "
"reachability analysis."
msgstr ""

#: ../../../Lexicon.rst:134
msgid "I"
msgstr ""

#: ../../../Lexicon.rst:140
msgid "**ICE**"
msgstr ""

#: ../../../Lexicon.rst:137
msgid ""
"Internal Compiler Error. This abbreviation is used to describe errors that "
"occur in LLVM or Clang as they are compiling source code. For example, if a "
"valid C++ source program were to trigger an assert in Clang when compiled, "
"that could be referred to as an \"ICE\"."
msgstr ""

#: ../../../Lexicon.rst:144
msgid "**IPA**"
msgstr ""

#: ../../../Lexicon.rst:143
msgid ""
"Inter-Procedural Analysis. Refers to any variety of code analysis that "
"occurs between procedures, functions or compilation units (modules)."
msgstr ""

#: ../../../Lexicon.rst:148
msgid "**IPO**"
msgstr ""

#: ../../../Lexicon.rst:147
msgid ""
"Inter-Procedural Optimization. Refers to any variety of code optimization "
"that occurs between procedures, functions or compilation units (modules)."
msgstr ""

#: ../../../Lexicon.rst:151
msgid "**ISel**"
msgstr ""

#: ../../../Lexicon.rst:151
msgid "Instruction Selection"
msgstr ""

#: ../../../Lexicon.rst:154
msgid "L"
msgstr ""

#: ../../../Lexicon.rst:157
msgid "**LCSSA**"
msgstr ""

#: ../../../Lexicon.rst:157
msgid "Loop-Closed Static Single Assignment Form"
msgstr ""

#: ../../../Lexicon.rst:161
msgid "**LGTM**"
msgstr ""

#: ../../../Lexicon.rst:160
msgid ""
"\"Looks Good To Me\". In a review thread, this indicates that the reviewer "
"thinks that the patch is okay to commit."
msgstr ""

#: ../../../Lexicon.rst:164
msgid "**LICM**"
msgstr ""

#: ../../../Lexicon.rst:164
msgid "Loop Invariant Code Motion"
msgstr ""

#: ../../../Lexicon.rst:172
msgid "**LSDA**"
msgstr ""

#: ../../../Lexicon.rst:167
msgid ""
"Language Specific Data Area.  C++ \"zero cost\" unwinding is built on top a "
"generic unwinding mechanism.  As the unwinder walks each frame, it calls a "
"\"personality\" function to do language specific analysis.  Each function's "
"FDE points to an optional LSDA which is passed to the personality function. "
"For C++, the LSDA contain info about the type and location of catch "
"statements in that function."
msgstr ""

#: ../../../Lexicon.rst:175
msgid "**Load-VN**"
msgstr ""

#: ../../../Lexicon.rst:175
msgid "Load Value Numbering"
msgstr ""

#: ../../../Lexicon.rst:178
msgid "**LTO**"
msgstr ""

#: ../../../Lexicon.rst:178
msgid "Link-Time Optimization"
msgstr ""

#: ../../../Lexicon.rst:181
msgid "M"
msgstr ""

#: ../../../Lexicon.rst:184
msgid "**MC**"
msgstr ""

#: ../../../Lexicon.rst:184
msgid "Machine Code"
msgstr ""

#: ../../../Lexicon.rst:187
msgid "N"
msgstr ""

#: ../../../Lexicon.rst:194
msgid "**NFC**"
msgstr ""

#: ../../../Lexicon.rst:191
msgid ""
"\"No functional change\". Used in a commit message to indicate that a patch "
"is a pure refactoring/cleanup. Usually used in the first line, so it is "
"visible without opening the actual commit email."
msgstr ""

#: ../../../Lexicon.rst:197
msgid "O"
msgstr ""

#: ../../../Lexicon.rst:204
msgid "**Object Pointer**"
msgstr ""

#: ../../../Lexicon.rst:202
msgid ""
"A pointer to an object such that the garbage collector is able to trace "
"references contained within the object. This term is used in opposition to "
"`derived pointer`_."
msgstr ""

#: ../../../Lexicon.rst:207
msgid "P"
msgstr ""

#: ../../../Lexicon.rst:211
msgid "**PR**"
msgstr ""

#: ../../../Lexicon.rst:210
msgid ""
"Problem report. A bug filed on `the LLVM Bug Tracking System <https://bugs."
"llvm.org/enter_bug.cgi>`_."
msgstr ""

#: ../../../Lexicon.rst:214
msgid "**PRE**"
msgstr ""

#: ../../../Lexicon.rst:214
msgid "Partial Redundancy Elimination"
msgstr ""

#: ../../../Lexicon.rst:217
msgid "R"
msgstr ""

#: ../../../Lexicon.rst:219
msgid "**RAUW**"
msgstr ""

#: ../../../Lexicon.rst:221
msgid ""
"Replace All Uses With. The functions ``User::replaceUsesOfWith()``, ``Value::"
"replaceAllUsesWith()``, and ``Constant::replaceUsesOfWithOnConstant()`` "
"implement the replacement of one Value with another by iterating over its "
"def/use chain and fixing up all of the pointers to point to the new value.  "
"See also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-"
"def-chains>`_."
msgstr ""

#: ../../../Lexicon.rst:231
msgid "**Reassociation**"
msgstr ""

#: ../../../Lexicon.rst:229
msgid ""
"Rearranging associative expressions to promote better redundancy elimination "
"and other optimization.  For example, changing ``(A+B-A)`` into ``(B+A-A)``, "
"permitting it to be optimized into ``(B+0)`` then ``(B)``."
msgstr ""

#: ../../../Lexicon.rst:235
msgid "**RFC**"
msgstr ""

#: ../../../Lexicon.rst:234
msgid ""
"Request for Comment. An email sent to a project mailing list in order to "
"solicit feedback on a proposed change."
msgstr ""

#: ../../../Lexicon.rst:244
msgid "**Root**"
msgstr ""

#: ../../../Lexicon.rst:241
msgid ""
"In garbage collection, a pointer variable lying outside of the `heap`_ from "
"which the collector begins its reachability analysis. In the context of code "
"generation, \"root\" almost always refers to a \"stack root\" --- a local or "
"temporary variable within an executing function."
msgstr ""

#: ../../../Lexicon.rst:247
msgid "**RPO**"
msgstr ""

#: ../../../Lexicon.rst:247
msgid "Reverse postorder"
msgstr ""

#: ../../../Lexicon.rst:250
msgid "S"
msgstr ""

#: ../../../Lexicon.rst:260
msgid "**Safe Point**"
msgstr ""

#: ../../../Lexicon.rst:255
msgid ""
"In garbage collection, it is necessary to identify `stack roots`_ so that "
"reachability analysis may proceed. It may be infeasible to provide this "
"information for every instruction, so instead the information is calculated "
"only at designated safe points. With a copying collector, `derived "
"pointers`_ must not be retained across safe points and `object pointers`_ "
"must be reloaded from stack roots."
msgstr ""

#: ../../../Lexicon.rst:263
msgid "**SDISel**"
msgstr ""

#: ../../../Lexicon.rst:263
msgid "Selection DAG Instruction Selection."
msgstr ""

#: ../../../Lexicon.rst:266
msgid "**SCC**"
msgstr ""

#: ../../../Lexicon.rst:266
msgid "Strongly Connected Component"
msgstr ""

#: ../../../Lexicon.rst:269
msgid "**SCCP**"
msgstr ""

#: ../../../Lexicon.rst:269
msgid "Sparse Conditional Constant Propagation"
msgstr ""

#: ../../../Lexicon.rst:273
msgid "**SLP**"
msgstr ""

#: ../../../Lexicon.rst:272
msgid ""
"Superword-Level Parallelism, same as :ref:`Basic-Block Vectorization "
"<lexicon-bb-vectorization>`."
msgstr ""

#: ../../../Lexicon.rst:281
msgid "**Splat**"
msgstr ""

#: ../../../Lexicon.rst:276
msgid "Splat refers to a vector of identical scalar elements."
msgstr ""

#: ../../../Lexicon.rst:278
msgid ""
"The term is based on the PowerPC Altivec instructions that provided this "
"functionality in hardware. For example, \"vsplth\" and the corresponding "
"software intrinsic \"vec_splat()\". Examples of other hardware names for "
"this action include \"duplicate\" (ARM) and \"broadcast\" (x86)."
msgstr ""

#: ../../../Lexicon.rst:284
msgid "**SRoA**"
msgstr ""

#: ../../../Lexicon.rst:284
msgid "Scalar Replacement of Aggregates"
msgstr ""

#: ../../../Lexicon.rst:287
msgid "**SSA**"
msgstr ""

#: ../../../Lexicon.rst:287
msgid "Static Single Assignment"
msgstr ""

#: ../../../Lexicon.rst:291
msgid "**Stack Map**"
msgstr ""

#: ../../../Lexicon.rst:290
msgid ""
"In garbage collection, metadata emitted by the code generator which "
"identifies `roots`_ within the stack frame of an executing function."
msgstr ""

#: ../../../Lexicon.rst:294
msgid "T"
msgstr ""

#: ../../../Lexicon.rst:297
msgid "**TBAA**"
msgstr ""

#: ../../../Lexicon.rst:297
msgid "Type-Based Alias Analysis"
msgstr ""
