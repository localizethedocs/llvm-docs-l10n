# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../Vectorizers.rst:3
msgid "Auto-Vectorization in LLVM"
msgstr ""

#: ../../../Vectorizers.rst:8
msgid ""
"LLVM has two vectorizers: The :ref:`Loop Vectorizer <loop-vectorizer>`, "
"which operates on Loops, and the :ref:`SLP Vectorizer <slp-vectorizer>`. "
"These vectorizers focus on different optimization opportunities and use "
"different techniques. The SLP vectorizer merges multiple scalars that are "
"found in the code into vectors while the Loop Vectorizer widens instructions "
"in loops to operate on multiple consecutive iterations."
msgstr ""

#: ../../../Vectorizers.rst:16
msgid "Both the Loop Vectorizer and the SLP Vectorizer are enabled by default."
msgstr ""

#: ../../../Vectorizers.rst:21
msgid "The Loop Vectorizer"
msgstr ""

#: ../../../Vectorizers.rst:24 ../../../Vectorizers.rst:449
msgid "Usage"
msgstr ""

#: ../../../Vectorizers.rst:26
msgid ""
"The Loop Vectorizer is enabled by default, but it can be disabled through "
"clang using the command line flag:"
msgstr ""

#: ../../../Vectorizers.rst:34
msgid "Command line flags"
msgstr ""

#: ../../../Vectorizers.rst:36
msgid ""
"The loop vectorizer uses a cost model to decide on the optimal vectorization "
"factor and unroll factor. However, users of the vectorizer can force the "
"vectorizer to use specific values. Both 'clang' and 'opt' support the flags "
"below."
msgstr ""

#: ../../../Vectorizers.rst:40
msgid ""
"Users can control the vectorization SIMD width using the command line flag "
"\"-force-vector-width\"."
msgstr ""

#: ../../../Vectorizers.rst:47
msgid ""
"Users can control the unroll factor using the command line flag \"-force-"
"vector-interleave\""
msgstr ""

#: ../../../Vectorizers.rst:55
msgid "Pragma loop hint directives"
msgstr ""

#: ../../../Vectorizers.rst:57
msgid ""
"The ``#pragma clang loop`` directive allows loop vectorization hints to be "
"specified for the subsequent for, while, do-while, or c++11 range-based for "
"loop. The directive allows vectorization and interleaving to be enabled or "
"disabled. Vector width as well as interleave count can also be manually "
"specified. The following example explicitly enables vectorization and "
"interleaving:"
msgstr ""

#: ../../../Vectorizers.rst:71
msgid ""
"The following example implicitly enables vectorization and interleaving by "
"specifying a vector width and interleaving count:"
msgstr ""

#: ../../../Vectorizers.rst:81
msgid ""
"See the Clang `language extensions <https://clang.llvm.org/docs/"
"LanguageExtensions.html#extensions-for-loop-hint-optimizations>`_ for "
"details."
msgstr ""

#: ../../../Vectorizers.rst:87
msgid "Diagnostics"
msgstr ""

#: ../../../Vectorizers.rst:89
msgid ""
"Many loops cannot be vectorized including loops with complicated control "
"flow, unvectorizable types, and unvectorizable calls. The loop vectorizer "
"generates optimization remarks which can be queried using command line "
"options to identify and diagnose loops that are skipped by the loop-"
"vectorizer."
msgstr ""

#: ../../../Vectorizers.rst:94
msgid "Optimization remarks are enabled using:"
msgstr ""

#: ../../../Vectorizers.rst:96
msgid ""
"``-Rpass=loop-vectorize`` identifies loops that were successfully vectorized."
msgstr ""

#: ../../../Vectorizers.rst:98
msgid ""
"``-Rpass-missed=loop-vectorize`` identifies loops that failed vectorization "
"and indicates if vectorization was specified."
msgstr ""

#: ../../../Vectorizers.rst:101
msgid ""
"``-Rpass-analysis=loop-vectorize`` identifies the statements that caused "
"vectorization to fail. If in addition ``-fsave-optimization-record`` is "
"provided, multiple causes of vectorization failure may be listed (this "
"behavior might change in the future)."
msgstr ""

#: ../../../Vectorizers.rst:106
msgid "Consider the following loop:"
msgstr ""

#: ../../../Vectorizers.rst:119
msgid "The command line ``-Rpass-missed=loop-vectorize`` prints the remark:"
msgstr ""

#: ../../../Vectorizers.rst:125
msgid ""
"And the command line ``-Rpass-analysis=loop-vectorize`` indicates that the "
"switch statement cannot be vectorized."
msgstr ""

#: ../../../Vectorizers.rst:134
msgid ""
"To ensure line and column numbers are produced include the command line "
"options ``-gline-tables-only`` and ``-gcolumn-info``. See the Clang `user "
"manual <https://clang.llvm.org/docs/UsersManual.html#options-to-emit-"
"optimization-reports>`_ for details"
msgstr ""

#: ../../../Vectorizers.rst:140
msgid "Features"
msgstr ""

#: ../../../Vectorizers.rst:142
msgid ""
"The LLVM Loop Vectorizer has a number of features that allow it to vectorize "
"complex loops."
msgstr ""

#: ../../../Vectorizers.rst:146
msgid "Loops with unknown trip count"
msgstr ""

#: ../../../Vectorizers.rst:148
msgid ""
"The Loop Vectorizer supports loops with an unknown trip count. In the loop "
"below, the iteration ``start`` and ``finish`` points are unknown, and the "
"Loop Vectorizer has a mechanism to vectorize loops that do not start at "
"zero. In this example, 'n' may not be a multiple of the vector width, and "
"the vectorizer has to execute the last few iterations as scalar code. "
"Keeping a scalar copy of the loop increases the code size."
msgstr ""

#: ../../../Vectorizers.rst:163
msgid "Runtime Checks of Pointers"
msgstr ""

#: ../../../Vectorizers.rst:165
msgid ""
"In the example below, if the pointers A and B point to consecutive "
"addresses, then it is illegal to vectorize the code because some elements of "
"A will be written before they are read from array B."
msgstr ""

#: ../../../Vectorizers.rst:169
msgid ""
"Some programmers use the 'restrict' keyword to notify the compiler that the "
"pointers are disjointed, but in our example, the Loop Vectorizer has no way "
"of knowing that the pointers A and B are unique. The Loop Vectorizer handles "
"this loop by placing code that checks, at runtime, if the arrays A and B "
"point to disjointed memory locations. If arrays A and B overlap, then the "
"scalar version of the loop is executed."
msgstr ""

#: ../../../Vectorizers.rst:185
msgid "Reductions"
msgstr ""

#: ../../../Vectorizers.rst:187
msgid ""
"In this example the ``sum`` variable is used by consecutive iterations of "
"the loop. Normally, this would prevent vectorization, but the vectorizer can "
"detect that 'sum' is a reduction variable. The variable 'sum' becomes a "
"vector of integers, and at the end of the loop the elements of the array are "
"added together to create the correct result. We support a number of "
"different reduction operations, such as addition, multiplication, XOR, AND "
"and OR."
msgstr ""

#: ../../../Vectorizers.rst:203
msgid ""
"We support floating point reduction operations when `-ffast-math` is used."
msgstr ""

#: ../../../Vectorizers.rst:206
msgid "Inductions"
msgstr ""

#: ../../../Vectorizers.rst:208
msgid ""
"In this example the value of the induction variable ``i`` is saved into an "
"array. The Loop Vectorizer knows to vectorize induction variables."
msgstr ""

#: ../../../Vectorizers.rst:219
msgid "If Conversion"
msgstr ""

#: ../../../Vectorizers.rst:221
msgid ""
"The Loop Vectorizer is able to \"flatten\" the IF statement in the code and "
"generate a single stream of instructions. The Loop Vectorizer supports any "
"control flow in the innermost loop. The innermost loop may contain complex "
"nesting of IFs, ELSEs and even GOTOs."
msgstr ""

#: ../../../Vectorizers.rst:237
msgid "Pointer Induction Variables"
msgstr ""

#: ../../../Vectorizers.rst:239
msgid ""
"This example uses the \"accumulate\" function of the standard c++ library. "
"This loop uses C++ iterators, which are pointers, and not integer indices. "
"The Loop Vectorizer detects pointer induction variables and can vectorize "
"this loop. This feature is important because many C++ programs use iterators."
msgstr ""

#: ../../../Vectorizers.rst:251
msgid "Reverse Iterators"
msgstr ""

#: ../../../Vectorizers.rst:253
msgid "The Loop Vectorizer can vectorize loops that count backwards."
msgstr ""

#: ../../../Vectorizers.rst:263
msgid "Scatter / Gather"
msgstr ""

#: ../../../Vectorizers.rst:265
msgid ""
"The Loop Vectorizer can vectorize code that becomes a sequence of scalar "
"instructions that scatter/gathers memory."
msgstr ""

#: ../../../Vectorizers.rst:275
msgid ""
"In many situations the cost model will inform LLVM that this is not "
"beneficial and LLVM will only vectorize such code if forced with \"-mllvm -"
"force-vector-width=#\"."
msgstr ""

#: ../../../Vectorizers.rst:279
msgid "Vectorization of Mixed Types"
msgstr ""

#: ../../../Vectorizers.rst:281
msgid ""
"The Loop Vectorizer can vectorize programs with mixed types. The Vectorizer "
"cost model can estimate the cost of the type conversion and decide if "
"vectorization is profitable."
msgstr ""

#: ../../../Vectorizers.rst:293
msgid "Global Structures Alias Analysis"
msgstr ""

#: ../../../Vectorizers.rst:295
msgid ""
"Access to global structures can also be vectorized, with alias analysis "
"being used to make sure accesses don't alias. Run-time checks can also be "
"added on pointer access to structure members."
msgstr ""

#: ../../../Vectorizers.rst:299
msgid ""
"Many variations are supported, but some that rely on undefined behaviour "
"being ignored (as other compilers do) are still being left un-vectorized."
msgstr ""

#: ../../../Vectorizers.rst:312
msgid "Vectorization of function calls"
msgstr ""

#: ../../../Vectorizers.rst:314
msgid ""
"The Loop Vectorizer can vectorize intrinsic math functions. See the table "
"below for a list of these functions."
msgstr ""

#: ../../../Vectorizers.rst:318
msgid "pow"
msgstr ""

#: ../../../Vectorizers.rst:318
msgid "exp"
msgstr ""

#: ../../../Vectorizers.rst:318
msgid "exp2"
msgstr ""

#: ../../../Vectorizers.rst:320
msgid "sin"
msgstr ""

#: ../../../Vectorizers.rst:320
msgid "cos"
msgstr ""

#: ../../../Vectorizers.rst:320
msgid "sqrt"
msgstr ""

#: ../../../Vectorizers.rst:322
msgid "log"
msgstr ""

#: ../../../Vectorizers.rst:322
msgid "log2"
msgstr ""

#: ../../../Vectorizers.rst:322
msgid "log10"
msgstr ""

#: ../../../Vectorizers.rst:324
msgid "fabs"
msgstr ""

#: ../../../Vectorizers.rst:324
msgid "floor"
msgstr ""

#: ../../../Vectorizers.rst:324
msgid "ceil"
msgstr ""

#: ../../../Vectorizers.rst:326
msgid "fma"
msgstr ""

#: ../../../Vectorizers.rst:326
msgid "trunc"
msgstr ""

#: ../../../Vectorizers.rst:326
msgid "nearbyint"
msgstr ""

#: ../../../Vectorizers.rst:328
msgid "fmuladd"
msgstr ""

#: ../../../Vectorizers.rst:331
msgid ""
"Note that the optimizer may not be able to vectorize math library functions "
"that correspond to these intrinsics if the library calls access external "
"state such as \"errno\". To allow better optimization of C/C++ math library "
"functions, use \"-fno-math-errno\"."
msgstr ""

#: ../../../Vectorizers.rst:336
msgid ""
"The loop vectorizer knows about special instructions on the target and will "
"vectorize a loop containing a function call that maps to the instructions. "
"For example, the loop below will be vectorized on Intel x86 if the SSE4.1 "
"roundps instruction is available."
msgstr ""

#: ../../../Vectorizers.rst:349
msgid "Partial unrolling during vectorization"
msgstr ""

#: ../../../Vectorizers.rst:351
msgid ""
"Modern processors feature multiple execution units, and only programs that "
"contain a high degree of parallelism can fully utilize the entire width of "
"the machine. The Loop Vectorizer increases the instruction level parallelism "
"(ILP) by performing partial-unrolling of loops."
msgstr ""

#: ../../../Vectorizers.rst:356
msgid ""
"In the example below the entire array is accumulated into the variable "
"'sum'. This is inefficient because only a single execution port can be used "
"by the processor. By unrolling the code the Loop Vectorizer allows two or "
"more execution ports to be used simultaneously."
msgstr ""

#: ../../../Vectorizers.rst:370
msgid ""
"The Loop Vectorizer uses a cost model to decide when it is profitable to "
"unroll loops. The decision to unroll the loop depends on the register "
"pressure and the generated code size."
msgstr ""

#: ../../../Vectorizers.rst:374
msgid "Epilogue Vectorization"
msgstr ""

#: ../../../Vectorizers.rst:376
msgid ""
"When vectorizing a loop, often a scalar remainder (epilogue) loop is "
"necessary to execute tail iterations of the loop if the loop trip count is "
"unknown or it does not evenly divide the vectorization and unroll factors. "
"When the vectorization and unroll factors are large, it's possible for loops "
"with smaller trip counts to end up spending most of their time in the scalar "
"(rather than the vector) code. In order to address this issue, the inner "
"loop vectorizer is enhanced with a feature that allows it to vectorize "
"epilogue loops with a vectorization and unroll factor combination that makes "
"it more likely for small trip count loops to still execute in vectorized "
"code. The diagram below shows the CFG for a typical epilogue vectorized loop "
"with runtime checks. As illustrated the control flow is structured in a way "
"that avoids duplicating the runtime pointer checks and optimizes the path "
"length for loops that have very small trip counts."
msgstr ""

#: ../../../Vectorizers.rst:393
msgid "Performance"
msgstr ""

#: ../../../Vectorizers.rst:395
msgid ""
"This section shows the execution time of Clang on a simple benchmark: `gcc-"
"loops <https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/"
"UnitTests/Vectorizer>`_. This benchmarks is a collection of loops from the "
"GCC autovectorization `page <http://gcc.gnu.org/projects/tree-ssa/"
"vectorization.html>`_ by Dorit Nuzman."
msgstr ""

#: ../../../Vectorizers.rst:400
msgid ""
"The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without "
"loop vectorization at -O3, tuned for \"corei7-avx\", running on a "
"Sandybridge iMac. The Y-axis shows the time in msec. Lower is better. The "
"last column shows the geomean of all the kernels."
msgstr ""

#: ../../../Vectorizers.rst:405
msgid ""
"And Linpack-pc with the same configuration. Result is Mflops, higher is "
"better."
msgstr ""

#: ../../../Vectorizers.rst:410
msgid "Ongoing Development Directions"
msgstr ""

#: ../../../Vectorizers.rst:418
msgid ":doc:`Proposals/VectorizationPlan`"
msgstr ""

#: ../../../Vectorizers.rst:418
msgid ""
"Modeling the process and upgrading the infrastructure of LLVM's Loop "
"Vectorizer."
msgstr ""

#: ../../../Vectorizers.rst:423
msgid "The SLP Vectorizer"
msgstr ""

#: ../../../Vectorizers.rst:426
msgid "Details"
msgstr ""

#: ../../../Vectorizers.rst:428
msgid ""
"The goal of SLP vectorization (a.k.a. superword-level parallelism) is to "
"combine similar independent instructions into vector instructions. Memory "
"accesses, arithmetic operations, comparison operations, PHI-nodes, can all "
"be vectorized using this technique."
msgstr ""

#: ../../../Vectorizers.rst:433
msgid ""
"For example, the following function performs very similar operations on its "
"inputs (a1, b1) and (a2, b2). The basic-block vectorizer may combine these "
"into vector operations."
msgstr ""

#: ../../../Vectorizers.rst:446
msgid ""
"The SLP-vectorizer processes the code bottom-up, across basic blocks, in "
"search of scalars to combine."
msgstr ""

#: ../../../Vectorizers.rst:451
msgid ""
"The SLP Vectorizer is enabled by default, but it can be disabled through "
"clang using the command line flag:"
msgstr ""
