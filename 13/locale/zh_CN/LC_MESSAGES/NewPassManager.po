# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../NewPassManager.rst:3
msgid "Using the New Pass Manager"
msgstr ""

#: ../../../NewPassManager.rst:9
msgid "Overview"
msgstr ""

#: ../../../NewPassManager.rst:11
msgid ""
"For an overview of the new pass manager, see the `blog post <https://blog."
"llvm.org/posts/2021-03-26-the-new-pass-manager/>`_."
msgstr ""

#: ../../../NewPassManager.rst:15
msgid "Adding Passes to a Pass Manager"
msgstr ""

#: ../../../NewPassManager.rst:17
msgid ""
"For how to write a new PM pass, see :doc:`this page "
"<WritingAnLLVMNewPMPass>`."
msgstr ""

#: ../../../NewPassManager.rst:19
msgid ""
"To add a pass to a new PM pass manager, the important thing is to match the "
"pass type and the pass manager type. For example, a ``FunctionPassManager`` "
"can only contain function passes:"
msgstr ""

#: ../../../NewPassManager.rst:29
msgid ""
"If you want add a loop pass that runs on all loops in a function to a "
"``FunctionPassManager``, the loop pass must be wrapped in a function pass "
"adaptor that goes through all the loops in the function and runs the loop "
"pass on each one."
msgstr ""

#: ../../../NewPassManager.rst:40
msgid ""
"The IR hierarchy in terms of the new PM is Module -> (CGSCC ->) Function -> "
"Loop, where going through a CGSCC is optional."
msgstr ""

#: ../../../NewPassManager.rst:67
msgid ""
"A pass manager of a specific IR unit is also a pass of that kind. For "
"example, a ``FunctionPassManager`` is a function pass, meaning it can be "
"added to a ``ModulePassManager``:"
msgstr ""

#: ../../../NewPassManager.rst:81
msgid ""
"Generally you want to group CGSCC/function/loop passes together in a pass "
"manager, as opposed to adding adaptors for each pass to the containing upper "
"level pass manager. For example,"
msgstr ""

#: ../../../NewPassManager.rst:92
msgid ""
"will run ``FunctionPass1`` on each function in a module, then run "
"``FunctionPass2`` on each function in the module. In contrast,"
msgstr ""

#: ../../../NewPassManager.rst:105
msgid ""
"will run ``FunctionPass1`` and ``FunctionPass2`` on the first function in a "
"module, then run both passes on the second function in the module, and so "
"on. This is better for cache locality around LLVM data structures. This "
"similarly applies for the other IR types, and in some cases can even affect "
"the quality of optimization. For example, running all loop passes on a loop "
"may cause a later loop to be able to be optimized more than if each loop "
"pass were run separately."
msgstr ""

#: ../../../NewPassManager.rst:114
msgid "Inserting Passes into Default Pipelines"
msgstr ""

#: ../../../NewPassManager.rst:116
msgid ""
"Rather than manually adding passes to a pass manager, the typical way of "
"creating a pass manager is to use a ``PassBuilder`` and call something like "
"``PassBuilder::buildPerModuleDefaultPipeline()`` which creates a typical "
"pipeline for a given optimization level."
msgstr ""

#: ../../../NewPassManager.rst:121
msgid ""
"Sometimes either frontends or backends will want to inject passes into the "
"pipeline. For example, frontends may want to add instrumentation, and target "
"backends may want to add passes that lower custom intrinsics. For these "
"cases, ``PassBuilder`` exposes callbacks that allow injecting passes into "
"certain parts of the pipeline. For example,"
msgstr ""

#: ../../../NewPassManager.rst:135
msgid ""
"will add ``FooPass`` near the very beginning of the pipeline for pass "
"managers created by that ``PassBuilder``. See the documentation for "
"``PassBuilder`` for the various places that passes can be added."
msgstr ""

#: ../../../NewPassManager.rst:139
msgid ""
"If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it "
"will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the "
"backend to inject passes into the pipeline. This is equivalent to the legacy "
"PM's ``TargetMachine::adjustPassManager()``."
msgstr ""

#: ../../../NewPassManager.rst:144
msgid ""
"Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly "
"sanitizer) passes to various parts of the pipeline. ``AMDGPUTargetMachine::"
"registerPassBuilderCallbacks()`` is an example of a backend adding passes to "
"various parts of the pipeline."
msgstr ""

#: ../../../NewPassManager.rst:150
msgid "Using Analyses"
msgstr ""

#: ../../../NewPassManager.rst:152
msgid ""
"LLVM provides many analyses that passes can use, such as a dominator tree. "
"Calculating these can be expensive, so the new pass manager has "
"infrastructure to cache analyses and reuse them when possible."
msgstr ""

#: ../../../NewPassManager.rst:156
msgid ""
"When a pass runs on some IR, it also receives an analysis manager which it "
"can query for analyses. Querying for an analysis will cause the manager to "
"check if it has already computed the result for the requested IR. If it "
"already has and the result is still valid, it will return that. Otherwise it "
"will construct a new result by calling the analysis's ``run()`` method, "
"cache it, and return it. You can also ask the analysis manager to only "
"return an analysis if it's already cached."
msgstr ""

#: ../../../NewPassManager.rst:164
msgid ""
"The analysis manager only provides analysis results for the same IR type as "
"what the pass runs on. For example, a function pass receives an analysis "
"manager that only provides function-level analyses. This works for many "
"passes which work on a fixed scope. However, some passes want to peek up or "
"down the IR hierarchy. For example, an SCC pass may want to look at function "
"analyses for the functions inside the SCC. Or it may want to look at some "
"immutable global analysis. In these cases, the analysis manager can provide "
"a proxy to an outer or inner level analysis manager. For example, to get a "
"``FunctionAnalysisManager`` from a ``CGSCCAnalysisManager``, you can call"
msgstr ""

#: ../../../NewPassManager.rst:180
msgid ""
"and use ``FAM`` as a typical ``FunctionAnalysisManager`` that a function "
"pass would have access to. To get access to an outer level IR analysis, you "
"can call"
msgstr ""

#: ../../../NewPassManager.rst:190
msgid ""
"Getting direct access to an outer level IR analysis manager is not allowed. "
"This is to keep in mind potential future pass concurrency, for example "
"parallelizing function passes over different functions in a CGSCC or module. "
"Since passes can ask for a cached analysis result, allowing passes to "
"trigger outer level analysis computation could result in non-determinism if "
"concurrency was supported. Therefore a pass running on inner level IR cannot "
"change the state of outer level IR analyses. Another limitation is that "
"outer level IR analyses that are used must be immutable, or else they could "
"be invalidated by changes to inner level IR. Outer analyses unused by inner "
"passes can and often will be invalidated by changes to inner level IR. These "
"invalidations happen after the inner pass manager finishes, so accessing "
"mutable analyses would give invalid results."
msgstr ""

#: ../../../NewPassManager.rst:203
msgid ""
"The exception to the above is accessing function analyses in loop passes. "
"Loop passes inherently require modifying the function the loop is in, and "
"that includes some function analyses the loop analyses depend on. This "
"discounts future concurrency over separate loops in a function, but that's a "
"tradeoff due to how tightly a loop and its function are coupled. To make "
"sure the function analyses loop passes use are valid, they are manually "
"updated in the loop passes to ensure that invalidation is not necessary. "
"There is a set of common function analyses that loop passes and analyses "
"have access to which is passed into loop passes as a "
"``LoopStandardAnalysisResults`` parameter. Other function analyses are not "
"accessible from loop passes."
msgstr ""

#: ../../../NewPassManager.rst:214
msgid ""
"As with any caching mechanism, we need some way to tell analysis managers "
"when results are no longer valid. Much of the analysis manager complexity "
"comes from trying to invalidate as few analysis results as possible to keep "
"compile times as low as possible."
msgstr ""

#: ../../../NewPassManager.rst:219
msgid ""
"There are two ways to deal with potentially invalid analysis results. One is "
"to simply force clear the results. This should generally only be used when "
"the IR that the result is keyed on becomes invalid. For example, a function "
"is deleted, or a CGSCC has become invalid due to call graph changes."
msgstr ""

#: ../../../NewPassManager.rst:224
msgid ""
"The typical way to invalidate analysis results is for a pass to declare what "
"types of analyses it preserves and what types it does not. When transforming "
"IR, a pass either has the option to update analyses alongside the IR "
"transformation, or tell the analysis manager that analyses are no longer "
"valid and should be invalidated. If a pass wants to keep some specific "
"analysis up to date, such as when updating it would be faster than "
"invalidating and recalculating it, the analysis itself may have methods to "
"update it for specific transformations, or there may be helper updaters like "
"``DomTreeUpdater`` for a ``DominatorTree``. Otherwise to mark some analysis "
"as no longer valid, the pass can return a ``PreservedAnalyses`` with the "
"proper analyses invalidated."
msgstr ""

#: ../../../NewPassManager.rst:254
msgid ""
"The pass manager will call the analysis manager's ``invalidate()`` method "
"with the pass's returned ``PreservedAnalyses``. This can be also done "
"manually within the pass:"
msgstr ""

#: ../../../NewPassManager.rst:272
msgid ""
"This is especially important when a pass removes then adds a function. The "
"analysis manager may store a pointer to a function that has been deleted, "
"and if the pass creates a new function before invalidating analysis results, "
"the new function may be at the same address as the old one, causing invalid "
"cached results. This is also useful for being more precise about "
"invalidation. Selectively invalidating analysis results only for functions "
"modified in an SCC pass can allow more analysis results to remain. But "
"except for complex fine-grain invalidation with inner proxies, passes should "
"typically just return a proper ``PreservedAnalyses`` and let the pass "
"manager deal with proper invalidation."
msgstr ""

#: ../../../NewPassManager.rst:284
msgid "Implementing Analysis Invalidation"
msgstr ""

#: ../../../NewPassManager.rst:286
msgid ""
"By default, an analysis is invalidated if ``PreservedAnalyses`` says that "
"analyses on the IR unit it runs on are not preserved (see "
"``AnalysisResultModel::invalidate()``). An analysis can implement "
"``invalidate()`` to be more conservative when it comes to invalidation. For "
"example,"
msgstr ""

#: ../../../NewPassManager.rst:303
msgid ""
"says that if the ``PreservedAnalyses`` specifically preserves "
"``FooAnalysis``, or if ``PreservedAnalyses`` preserves all analyses "
"(implicit in ``PAC.preserved()``), or if ``PreservedAnalyses`` preserves all "
"function analyses, or ``PreservedAnalyses`` preserves all analyses that only "
"care about the CFG, the ``FooAnalysisResult`` should not be invalidated."
msgstr ""

#: ../../../NewPassManager.rst:309
msgid ""
"If an analysis is stateless and generally shouldn't be invalidated, use the "
"following:"
msgstr ""

#: ../../../NewPassManager.rst:322
msgid ""
"If an analysis depends on other analyses, those analyses also need to be "
"checked if they are invalidated:"
msgstr ""

#: ../../../NewPassManager.rst:338
msgid ""
"Combining invalidation and analysis manager proxies results in some "
"complexity. For example, when we invalidate all analyses in a module pass, "
"we have to make sure that we also invalidate function analyses accessible "
"via any existing inner proxies. The inner proxy's ``invalidate()`` first "
"checks if the proxy itself should be invalidated. If so, that means the "
"proxy may contain pointers to IR that is no longer valid, meaning that the "
"inner proxy needs to completely clear all relevant analysis results. "
"Otherwise the proxy simply forwards the invalidation to the inner analysis "
"manager."
msgstr ""

#: ../../../NewPassManager.rst:347
msgid ""
"Generally for outer proxies, analysis results from the outer analysis "
"manager should be immutable, so invalidation shouldn't be a concern. "
"However, it is possible for some inner analysis to depend on some outer "
"analysis, and when the outer analysis is invalidated, we need to make sure "
"that dependent inner analyses are also invalidated. This actually happens "
"with alias analysis results. Alias analysis is a function-level analysis, "
"but there are module-level implementations of specific types of alias "
"analysis. Currently ``GlobalsAA`` is the only module-level alias analysis "
"and it generally is not invalidated so this is not so much of a concern. See "
"``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()`` "
"for more details."
msgstr ""

#: ../../../NewPassManager.rst:360
msgid "Invoking ``opt``"
msgstr ""

#: ../../../NewPassManager.rst:362
msgid "To use the legacy pass manager:"
msgstr ""

#: ../../../NewPassManager.rst:368
msgid ""
"This will be removed once the legacy pass manager is deprecated and removed "
"for the optimization pipeline."
msgstr ""

#: ../../../NewPassManager.rst:371
msgid "To use the new PM:"
msgstr ""

#: ../../../NewPassManager.rst:377
msgid ""
"The new PM typically requires explicit pass nesting. For example, to run a "
"function pass, then a module pass, we need to wrap the function pass in a "
"module adaptor:"
msgstr ""

#: ../../../NewPassManager.rst:385
msgid ""
"A more complete example, and ``-debug-pass-manager`` to show the execution "
"order:"
msgstr ""

#: ../../../NewPassManager.rst:392
msgid "Improper nesting can lead to error messages such as"
msgstr ""

#: ../../../NewPassManager.rst:399
msgid ""
"The nesting is: module (-> cgscc) -> function -> loop, where the CGSCC "
"nesting is optional."
msgstr ""

#: ../../../NewPassManager.rst:401
msgid "There are a couple of special cases for easier typing:"
msgstr ""

#: ../../../NewPassManager.rst:403
msgid ""
"If the first pass is not a module pass, a pass manager of the first pass is "
"implicitly created"
msgstr ""

#: ../../../NewPassManager.rst:406 ../../../NewPassManager.rst:416
msgid "For example, the following are equivalent"
msgstr ""

#: ../../../NewPassManager.rst:413
msgid ""
"If there is an adaptor for a pass that lets it fit in the previous pass "
"manager, that is implicitly created"
msgstr ""

#: ../../../NewPassManager.rst:423
msgid ""
"For a list of available passes and analyses, including the IR unit (module, "
"CGSCC, function, loop) they operate on, run"
msgstr ""

#: ../../../NewPassManager.rst:430
msgid "or take a look at ``PassRegistry.def``."
msgstr ""

#: ../../../NewPassManager.rst:432
msgid ""
"To make sure an analysis named ``foo`` is available before a pass, add "
"``require<foo>`` to the pass pipeline. This adds a pass that simply requests "
"that the analysis is run. This pass is also subject to proper nesting.  For "
"example, to make sure some function analysis is already computed for all "
"functions before a module pass:"
msgstr ""

#: ../../../NewPassManager.rst:443
msgid "Status of the New and Legacy Pass Managers"
msgstr ""

#: ../../../NewPassManager.rst:445
msgid ""
"LLVM currently contains two pass managers, the legacy PM and the new PM. The "
"optimization pipeline (aka the middle-end) works with both the legacy PM and "
"the new PM, whereas the backend target-dependent code generation only works "
"with the legacy PM."
msgstr ""

#: ../../../NewPassManager.rst:450
msgid ""
"For the optimization pipeline, the new PM is the default PM. The legacy PM "
"is available for the optimization pipeline either by setting the CMake flag "
"``-DLLVM_ENABLE_NEW_PASS_MANAGER=OFF`` when building LLVM, or by various "
"compiler/linker flags, e.g. ``-flegacy-pass-manager`` for ``clang``."
msgstr ""

#: ../../../NewPassManager.rst:455
msgid ""
"There will be efforts to deprecate and remove the legacy PM for the "
"optimization pipeline in the future."
msgstr ""

#: ../../../NewPassManager.rst:458
msgid ""
"Some IR passes are considered part of the backend codegen pipeline even if "
"they are LLVM IR passes (whereas all MIR passes are codegen passes). This "
"includes anything added via ``TargetPassConfig`` hooks, e.g. "
"``TargetPassConfig::addCodeGenPrepare()``. As mentioned before, passes added "
"in ``TargetMachine::adjustPassManager()`` are part of the optimization "
"pipeline, and should have a corresponding line in ``TargetMachine::"
"registerPassBuilderCallbacks()``."
msgstr ""

#: ../../../NewPassManager.rst:466
msgid ""
"Currently there are efforts to make the codegen pipeline work with the new "
"PM."
msgstr ""
