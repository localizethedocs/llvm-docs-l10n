# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 08:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CodingStandards.rst:3
msgid "LLVM Coding Standards"
msgstr ""

#: ../../../CodingStandards.rst:9
msgid "Introduction"
msgstr "簡介"

#: ../../../CodingStandards.rst:11
msgid ""
"This document describes coding standards that are used in the LLVM project. "
"Although no coding standards should be regarded as absolute requirements to "
"be followed in all instances, coding standards are particularly important "
"for large-scale code bases that follow a library-based design (like LLVM)."
msgstr ""

#: ../../../CodingStandards.rst:17
msgid ""
"While this document may provide guidance for some mechanical formatting "
"issues, whitespace, or other \"microscopic details\", these are not fixed "
"standards. Always follow the golden rule:"
msgstr ""

#: ../../../CodingStandards.rst:23
msgid ""
"**If you are extending, enhancing, or bug fixing already implemented code, "
"use the style that is already being used so that the source is uniform and "
"easy to follow.**"
msgstr ""

#: ../../../CodingStandards.rst:27
msgid ""
"Note that some code bases (e.g. ``libc++``) have special reasons to deviate "
"from the coding standards.  For example, in the case of ``libc++``, this is "
"because the naming and other conventions are dictated by the C++ standard."
msgstr ""

#: ../../../CodingStandards.rst:31
msgid ""
"There are some conventions that are not uniformly followed in the code base "
"(e.g. the naming convention).  This is because they are relatively new, and "
"a lot of code was written before they were put in place.  Our long-term goal "
"is for the entire codebase to follow the convention, but we explicitly *do "
"not* want patches that do large-scale reformatting of existing code.  On the "
"other hand, it is reasonable to rename the methods of a class if you're "
"about to change it in some other way.  Please commit such changes separately "
"to make code review easier."
msgstr ""

#: ../../../CodingStandards.rst:40
msgid ""
"The ultimate goal of these guidelines is to increase the readability and "
"maintainability of our common source base."
msgstr ""

#: ../../../CodingStandards.rst:44
msgid "Languages, Libraries, and Standards"
msgstr ""

#: ../../../CodingStandards.rst:46
msgid ""
"Most source code in LLVM and other LLVM projects using these coding "
"standards is C++ code. There are some places where C code is used either due "
"to environment restrictions, historical restrictions, or due to third-party "
"source code imported into the tree. Generally, our preference is for "
"standards-conforming, modern, and portable C++ code as the implementation "
"language of choice."
msgstr ""

#: ../../../CodingStandards.rst:53
msgid ""
"For automation, build systems, and utility scripts, Python is preferred and "
"is widely used in the LLVM repository already."
msgstr ""

#: ../../../CodingStandards.rst:57
msgid "C++ Standard Versions"
msgstr ""

#: ../../../CodingStandards.rst:59
msgid ""
"Unless otherwise documented, LLVM subprojects are written using standard C+"
"+17 code and avoid unnecessary vendor-specific extensions."
msgstr ""

#: ../../../CodingStandards.rst:62
msgid ""
"Nevertheless, we restrict ourselves to features which are available in the "
"major toolchains supported as host compilers (see :doc:`GettingStarted` "
"page, section `Software`)."
msgstr ""

#: ../../../CodingStandards.rst:66
msgid "Each toolchain provides a good reference for what it accepts:"
msgstr ""

#: ../../../CodingStandards.rst:68
msgid "Clang: https://clang.llvm.org/cxx_status.html"
msgstr ""

#: ../../../CodingStandards.rst:70
msgid "libc++: https://libcxx.llvm.org/Status/Cxx17.html"
msgstr ""

#: ../../../CodingStandards.rst:72
msgid "GCC: https://gcc.gnu.org/projects/cxx-status.html#cxx17"
msgstr ""

#: ../../../CodingStandards.rst:74
msgid ""
"libstdc++: https://gcc.gnu.org/onlinedocs/libstdc++/manual/status."
"html#status.iso.2017"
msgstr ""

#: ../../../CodingStandards.rst:76
msgid ""
"MSVC: https://learn.microsoft.com/cpp/overview/visual-cpp-language-"
"conformance"
msgstr ""

#: ../../../CodingStandards.rst:78
msgid ""
"Additionally, there are compiler comparison tables of supported C++ features "
"on `cppreference.com <https://en.cppreference.com/w/cpp/"
"compiler_support/17>`_."
msgstr ""

#: ../../../CodingStandards.rst:81
msgid ""
"To keep track with the evolution of the standard, newer C++ versions can be "
"used to build LLVM. However, our support focuses on the minimum supported C+"
"+ version and a very recent standard may not yet be supported, or only using "
"the latest version of the supported toolchains and possibly not across all "
"the subprojects."
msgstr ""

#: ../../../CodingStandards.rst:89
msgid "C++ Standard Library"
msgstr ""

#: ../../../CodingStandards.rst:91
msgid ""
"Instead of implementing custom data structures, we encourage the use of C++ "
"standard library facilities or LLVM support libraries whenever they are "
"available for a particular task. LLVM and related projects emphasize and "
"rely on the standard library facilities and the LLVM support libraries as "
"much as possible."
msgstr ""

#: ../../../CodingStandards.rst:97
msgid ""
"LLVM support libraries (for example, `ADT <https://github.com/llvm/llvm-"
"project/tree/main/llvm/include/llvm/ADT>`_) implement specialized data "
"structures or functionality missing in the standard library. Such libraries "
"are usually implemented in the ``llvm`` namespace and follow the expected "
"standard interface when there is one."
msgstr ""

#: ../../../CodingStandards.rst:103
msgid ""
"When both C++ and the LLVM support libraries provide similar functionality, "
"and there isn't a specific reason to favor the C++ implementation, it is "
"generally preferable to use the LLVM library. For example, ``llvm::"
"DenseMap`` should almost always be used instead of ``std::map`` or ``std::"
"unordered_map``, and ``llvm::SmallVector`` should usually be used instead of "
"``std::vector``."
msgstr ""

#: ../../../CodingStandards.rst:109
msgid ""
"We explicitly avoid some standard facilities, like the I/O streams, and "
"instead use LLVM's streams library (raw_ostream_). More detailed information "
"on these subjects is available in the :doc:`ProgrammersManual`."
msgstr ""

#: ../../../CodingStandards.rst:113
msgid ""
"For more information about LLVM's data structures and the tradeoffs they "
"make, please consult `that section of the programmer's manual <https://llvm."
"org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-"
"task>`_."
msgstr ""

#: ../../../CodingStandards.rst:118
msgid "Python version and Source Code Formatting"
msgstr ""

#: ../../../CodingStandards.rst:120
msgid ""
"The current minimum version of Python required is documented in the :doc:"
"`GettingStarted` section. Python code in the LLVM repository should only use "
"language features available in this version of Python."
msgstr ""

#: ../../../CodingStandards.rst:124
msgid ""
"The Python code within the LLVM repository should adhere to the formatting "
"guidelines outlined in `PEP 8 <https://peps.python.org/pep-0008/>`_."
msgstr ""

#: ../../../CodingStandards.rst:127
msgid ""
"For consistency and to limit churn, code should be automatically formatted "
"with the `black <https://github.com/psf/black>`_ utility, which is PEP 8 "
"compliant. Use its default rules. For example, avoid specifying ``--line-"
"length`` even though it does not default to 80. The default rules can change "
"between major versions of black. In order to avoid unnecessary churn in the "
"formatting rules, we currently use black version 23.x in LLVM."
msgstr ""

#: ../../../CodingStandards.rst:134
msgid ""
"When contributing a patch unrelated to formatting, you should format only "
"the Python code that the patch modifies. For this purpose, use the `darker "
"<https://pypi.org/project/darker/>`_ utility, which runs default black rules "
"over only the modified Python code. Doing so should ensure the patch will "
"pass the Python format checks in LLVM's pre-commit CI, which also uses "
"darker. When contributing a patch specifically for reformatting Python "
"files, use black, which currently only supports formatting entire files."
msgstr ""

#: ../../../CodingStandards.rst:142
msgid ""
"Here are some quick examples, but see the black and darker documentation for "
"details:"
msgstr ""

#: ../../../CodingStandards.rst:152
msgid ""
"Instead of individual file names, you can specify directories to darker, and "
"it will find the changed files. However, if a directory is large, like a "
"clone of the LLVM repository, darker can be painfully slow. In that case, "
"you might wish to use git to list changed files. For example:"
msgstr ""

#: ../../../CodingStandards.rst:163
msgid "Mechanical Source Issues"
msgstr ""

#: ../../../CodingStandards.rst:166
msgid "Source Code Formatting"
msgstr ""

#: ../../../CodingStandards.rst:169
msgid "Commenting"
msgstr ""

#: ../../../CodingStandards.rst:171
msgid ""
"Comments are important for readability and maintainability. When writing "
"comments, write them as English prose, using proper capitalization, "
"punctuation, etc. Aim to describe what the code is trying to do and why, not "
"*how* it does it at a micro level. Here are a few important things to "
"document:"
msgstr ""

#: ../../../CodingStandards.rst:179
msgid "File Headers"
msgstr ""

#: ../../../CodingStandards.rst:181
msgid ""
"Every source file should have a header on it that describes the basic "
"purpose of the file. The standard header looks like this:"
msgstr ""

#: ../../../CodingStandards.rst:200
msgid ""
"The first section in the file is a concise note that defines the license "
"that the file is released under.  This makes it perfectly clear what terms "
"the source code can be distributed under and should not be modified in any "
"way."
msgstr ""

#: ../../../CodingStandards.rst:204
msgid ""
"The main body is a `Doxygen <http://www.doxygen.nl/>`_ comment (identified "
"by the ``///`` comment marker instead of the usual ``//``) describing the "
"purpose of the file.  The first sentence (or a passage beginning with "
"``\\brief``) is used as an abstract.  Any additional information should be "
"separated by a blank line.  If an algorithm is based on a paper or is "
"described in another source, provide a reference."
msgstr ""

#: ../../../CodingStandards.rst:212
msgid "Header Guard"
msgstr ""

#: ../../../CodingStandards.rst:214
msgid ""
"The header file's guard should be the all-caps path that a user of this "
"header would #include, using '_' instead of path separator and extension "
"marker. For example, the header file ``llvm/include/llvm/Analysis/Utils/"
"Local.h`` would be ``#include``-ed as ``#include \"llvm/Analysis/Utils/Local."
"h\"``, so its guard is ``LLVM_ANALYSIS_UTILS_LOCAL_H``."
msgstr ""

#: ../../../CodingStandards.rst:222
msgid "Class overviews"
msgstr ""

#: ../../../CodingStandards.rst:224
msgid ""
"Classes are a fundamental part of an object-oriented design.  As such, a "
"class definition should have a comment block that explains what the class is "
"used for and how it works.  Every non-trivial class is expected to have a "
"``doxygen`` comment block."
msgstr ""

#: ../../../CodingStandards.rst:230
msgid "Method information"
msgstr ""

#: ../../../CodingStandards.rst:232
msgid ""
"Methods and global functions should also be documented.  A quick note about "
"what it does and a description of the edge cases is all that is necessary "
"here. The reader should be able to understand how to use interfaces without "
"reading the code itself."
msgstr ""

#: ../../../CodingStandards.rst:237
msgid ""
"Good things to talk about here are what happens when something unexpected "
"happens, for instance, does the method return null?"
msgstr ""

#: ../../../CodingStandards.rst:241
msgid "Comment Formatting"
msgstr ""

#: ../../../CodingStandards.rst:243
msgid ""
"In general, prefer C++-style comments (``//`` for normal comments, ``///`` "
"for ``doxygen`` documentation comments).  There are a few cases when it is "
"useful to use C-style (``/* */``) comments, however:"
msgstr ""

#: ../../../CodingStandards.rst:247
msgid "When writing C code to be compatible with C89."
msgstr ""

#: ../../../CodingStandards.rst:249
msgid ""
"When writing a header file that may be ``#include``\\d by a C source file."
msgstr ""

#: ../../../CodingStandards.rst:251
msgid ""
"When writing a source file that is used by a tool that only accepts C-style "
"comments."
msgstr ""

#: ../../../CodingStandards.rst:254
msgid ""
"When documenting the significance of constants used as actual parameters in "
"a call. This is most helpful for ``bool`` parameters, or passing ``0`` or "
"``nullptr``. The comment should contain the parameter name, which ought to "
"be meaningful. For example, it's not clear what the parameter means in this "
"call:"
msgstr ""

#: ../../../CodingStandards.rst:263
msgid "An in-line C-style comment makes the intent obvious:"
msgstr ""

#: ../../../CodingStandards.rst:269
msgid ""
"Commenting out large blocks of code is discouraged, but if you really have "
"to do this (for documentation purposes or as a suggestion for debug "
"printing), use ``#if 0`` and ``#endif``. These nest properly and are better "
"behaved in general than C-style comments."
msgstr ""

#: ../../../CodingStandards.rst:275
msgid "Doxygen Use in Documentation Comments"
msgstr ""

#: ../../../CodingStandards.rst:277
msgid ""
"Use the ``\\file`` command to turn the standard file header into a file-"
"level comment."
msgstr ""

#: ../../../CodingStandards.rst:280
msgid ""
"Include descriptive paragraphs for all public interfaces (public classes, "
"member and non-member functions).  Avoid restating the information that can "
"be inferred from the API name.  The first sentence (or a paragraph beginning "
"with ``\\brief``) is used as an abstract. Try to use a single sentence as "
"the ``\\brief`` adds visual clutter.  Put detailed discussion into separate "
"paragraphs."
msgstr ""

#: ../../../CodingStandards.rst:287
msgid ""
"To refer to parameter names inside a paragraph, use the ``\\p name`` "
"command. Don't use the ``\\arg name`` command since it starts a new "
"paragraph that contains documentation for the parameter."
msgstr ""

#: ../../../CodingStandards.rst:291
msgid "Wrap non-inline code examples in ``\\code ... \\endcode``."
msgstr ""

#: ../../../CodingStandards.rst:293
msgid ""
"To document a function parameter, start a new paragraph with the ``\\param "
"name`` command.  If the parameter is used as an out or an in/out parameter, "
"use the ``\\param [out] name`` or ``\\param [in,out] name`` command, "
"respectively."
msgstr ""

#: ../../../CodingStandards.rst:298
msgid ""
"To describe function return value, start a new paragraph with the "
"``\\returns`` command."
msgstr ""

#: ../../../CodingStandards.rst:301
msgid "A minimal documentation comment:"
msgstr ""

#: ../../../CodingStandards.rst:308
msgid ""
"A documentation comment that uses all Doxygen features in a preferred way:"
msgstr ""

#: ../../../CodingStandards.rst:327
msgid ""
"Don't duplicate the documentation comment in the header file and in the "
"implementation file.  Put the documentation comments for public APIs into "
"the header file.  Documentation comments for private APIs can go to the "
"implementation file.  In any case, implementation files can include "
"additional comments (not necessarily in Doxygen markup) to explain "
"implementation details as needed."
msgstr ""

#: ../../../CodingStandards.rst:334
msgid ""
"Don't duplicate the function or class name at the beginning of the comment. "
"For humans, it is obvious which function or class is being documented; "
"automatic documentation processing tools are smart enough to bind the "
"comment to the correct declaration."
msgstr ""

#: ../../../CodingStandards.rst:339
msgid "Avoid:"
msgstr ""

#: ../../../CodingStandards.rst:353
msgid "Preferred:"
msgstr ""

#: ../../../CodingStandards.rst:368
msgid "Error and Warning Messages"
msgstr ""

#: ../../../CodingStandards.rst:370
msgid ""
"Clear diagnostic messages are important to help users identify and fix "
"issues in their inputs. Use succinct but correct English prose that gives "
"the user the context needed to understand what went wrong. Also, to match "
"error message styles commonly produced by other tools, start the first "
"sentence with a lowercase letter, and finish the last sentence without a "
"period, if it would end in one otherwise. Sentences which end with different "
"punctuation, such as \"did you forget ';'?\", should still do so."
msgstr ""

#: ../../../CodingStandards.rst:378
msgid "For example, this is a good error message:"
msgstr ""

#: ../../../CodingStandards.rst:384
msgid ""
"This is a bad message, since it does not provide useful information and uses "
"the wrong style:"
msgstr ""

#: ../../../CodingStandards.rst:391
msgid ""
"As with other coding standards, individual projects, such as the Clang "
"Static Analyzer, may have preexisting styles that do not conform to this. If "
"a different formatting scheme is used consistently throughout the project, "
"use that style instead. Otherwise, this standard applies to all LLVM tools, "
"including clang, clang-tidy, and so on."
msgstr ""

#: ../../../CodingStandards.rst:397
msgid ""
"If the tool or project does not have existing functions to emit warnings or "
"errors, use the error and warning handlers provided in ``Support/WithColor."
"h`` to ensure they are printed in the appropriate style, rather than "
"printing to stderr directly."
msgstr ""

#: ../../../CodingStandards.rst:402
msgid ""
"When using ``report_fatal_error``, follow the same standards for the message "
"as regular error messages. Assertion messages and ``llvm_unreachable`` calls "
"do not necessarily need to follow these same styles as they are "
"automatically formatted, and thus these guidelines may not be suitable."
msgstr ""

#: ../../../CodingStandards.rst:408
msgid "``#include`` Style"
msgstr ""

#: ../../../CodingStandards.rst:410
msgid ""
"Immediately after the `header file comment`_ (and include guards if working "
"on a header file), the `minimal list of #includes`_ required by the file "
"should be listed.  We prefer these ``#include``\\s to be listed in this "
"order:"
msgstr ""

#: ../../../CodingStandards.rst:417
msgid "Main Module Header"
msgstr ""

#: ../../../CodingStandards.rst:418
msgid "Local/Private Headers"
msgstr ""

#: ../../../CodingStandards.rst:419
msgid ""
"LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, "
"etc)"
msgstr ""

#: ../../../CodingStandards.rst:420
msgid "System ``#include``\\s"
msgstr ""

#: ../../../CodingStandards.rst:422
msgid "and each category should be sorted lexicographically by the full path."
msgstr ""

#: ../../../CodingStandards.rst:424
msgid ""
"The `Main Module Header`_ file applies to ``.cpp`` files which implement an "
"interface defined by a ``.h`` file.  This ``#include`` should always be "
"included **first** regardless of where it lives on the file system.  By "
"including a header file first in the ``.cpp`` files that implement the "
"interfaces, we ensure that the header does not have any hidden dependencies "
"which are not explicitly ``#include``\\d in the header, but should be. It is "
"also a form of documentation in the ``.cpp`` file to indicate where the "
"interfaces it implements are defined."
msgstr ""

#: ../../../CodingStandards.rst:432
msgid ""
"LLVM project and subproject headers should be grouped from most specific to "
"least specific, for the same reasons described above.  For example, LLDB "
"depends on both clang and LLVM, and clang depends on LLVM.  So an LLDB "
"source file should include ``lldb`` headers first, followed by ``clang`` "
"headers, followed by ``llvm`` headers, to reduce the possibility (for "
"example) of an LLDB header accidentally picking up a missing include due to "
"the previous inclusion of that header in the main source file or some "
"earlier header file.  clang should similarly include its own headers before "
"including llvm headers.  This rule applies to all LLVM subprojects."
msgstr ""

#: ../../../CodingStandards.rst:445
msgid "Source Code Width"
msgstr ""

#: ../../../CodingStandards.rst:447
msgid "Write your code to fit within 80 columns."
msgstr ""

#: ../../../CodingStandards.rst:449
msgid ""
"There must be some limit to the width of the code in order to allow "
"developers to have multiple files side-by-side in windows on a modest "
"display.  If you are going to pick a width limit, it is somewhat arbitrary, "
"but you might as well pick something standard.  Going with 90 columns (for "
"example) instead of 80 columns wouldn't add any significant value and would "
"be detrimental to printing out code.  Also many other projects have "
"standardized on 80 columns, so some people have already configured their "
"editors for it (vs something else, like 90 columns)."
msgstr ""

#: ../../../CodingStandards.rst:459
msgid "Whitespace"
msgstr ""

#: ../../../CodingStandards.rst:461
msgid ""
"In all cases, prefer spaces to tabs in source files.  People have different "
"preferred indentation levels, and different styles of indentation that they "
"like; this is fine.  What isn't fine is that different editors/viewers "
"expand tabs out to different tab stops.  This can cause your code to look "
"completely unreadable, and it is not worth dealing with."
msgstr ""

#: ../../../CodingStandards.rst:467
msgid ""
"As always, follow the `Golden Rule`_ above: follow the style of existing "
"code if you are modifying and extending it."
msgstr ""

#: ../../../CodingStandards.rst:470
msgid ""
"Do not add trailing whitespace.  Some common editors will automatically "
"remove trailing whitespace when saving a file which causes unrelated changes "
"to appear in diffs and commits."
msgstr ""

#: ../../../CodingStandards.rst:475
msgid "Format Lambdas Like Blocks Of Code"
msgstr ""

#: ../../../CodingStandards.rst:477
msgid ""
"When formatting a multi-line lambda, format it like a block of code. If "
"there is only one multi-line lambda in a statement, and there are no "
"expressions lexically after it in the statement, drop the indent to the "
"standard two space indent for a block of code, as if it were an if-block "
"opened by the preceding part of the statement:"
msgstr ""

#: ../../../CodingStandards.rst:493
msgid ""
"To take best advantage of this formatting, if you are designing an API which "
"accepts a continuation or single callable argument (be it a function object, "
"or a ``std::function``), it should be the last argument if at all possible."
msgstr ""

#: ../../../CodingStandards.rst:497
msgid ""
"If there are multiple multi-line lambdas in a statement, or additional "
"parameters after the lambda, indent the block two spaces from the indent of "
"the ``[]``:"
msgstr ""

#: ../../../CodingStandards.rst:518
msgid "Braced Initializer Lists"
msgstr ""

#: ../../../CodingStandards.rst:520
msgid ""
"Starting from C++11, there are significantly more uses of braced lists to "
"perform initialization. For example, they can be used to construct aggregate "
"temporaries in expressions. They now have a natural way of ending up nested "
"within each other and within function calls in order to build up aggregates "
"(such as option structs) from local variables."
msgstr ""

#: ../../../CodingStandards.rst:526
msgid ""
"The historically common formatting of braced initialization of aggregate "
"variables does not mix cleanly with deep nesting, general expression "
"contexts, function arguments, and lambdas. We suggest new code use a simple "
"rule for formatting braced initialization lists: act as if the braces were "
"parentheses in a function call. The formatting rules exactly match those "
"already well understood for formatting nested function calls. Examples:"
msgstr ""

#: ../../../CodingStandards.rst:542
msgid ""
"This formatting scheme also makes it particularly easy to get predictable, "
"consistent, and automatic formatting with tools like `Clang Format`_."
msgstr ""

#: ../../../CodingStandards.rst:548
msgid "Language and Compiler Issues"
msgstr ""

#: ../../../CodingStandards.rst:551
msgid "Treat Compiler Warnings Like Errors"
msgstr ""

#: ../../../CodingStandards.rst:553
msgid ""
"Compiler warnings are often useful and help improve the code.  Those that "
"are not useful, can be often suppressed with a small code change. For "
"example, an assignment in the ``if`` condition is often a typo:"
msgstr ""

#: ../../../CodingStandards.rst:563
msgid ""
"Several compilers will print a warning for the code above. It can be "
"suppressed by adding parentheses:"
msgstr ""

#: ../../../CodingStandards.rst:573
msgid "Write Portable Code"
msgstr ""

#: ../../../CodingStandards.rst:575
msgid ""
"In almost all cases, it is possible to write completely portable code.  When "
"you need to rely on non-portable code, put it behind a well-defined and well-"
"documented interface."
msgstr ""

#: ../../../CodingStandards.rst:580
msgid "Do not use RTTI or Exceptions"
msgstr ""

#: ../../../CodingStandards.rst:582
msgid ""
"In an effort to reduce code and executable size, LLVM does not use "
"exceptions or RTTI (`runtime type information <https://en.wikipedia.org/wiki/"
"Run-time_type_information>`_, for example, ``dynamic_cast<>``)."
msgstr ""

#: ../../../CodingStandards.rst:587
msgid ""
"That said, LLVM does make extensive use of a hand-rolled form of RTTI that "
"use templates like :ref:`isa\\<>, cast\\<>, and dyn_cast\\<> <isa>`. This "
"form of RTTI is opt-in and can be :doc:`added to any class "
"<HowToSetUpLLVMStyleRTTI>`."
msgstr ""

#: ../../../CodingStandards.rst:593
msgid "Prefer C++-style casts"
msgstr ""

#: ../../../CodingStandards.rst:595
msgid ""
"When casting, use ``static_cast``, ``reinterpret_cast``, and ``const_cast``, "
"rather than C-style casts. There are two exceptions to this:"
msgstr ""

#: ../../../CodingStandards.rst:598
msgid ""
"When casting to ``void`` to suppress warnings about unused variables (as an "
"alternative to ``[[maybe_unused]]``). Prefer C-style casts in this instance. "
"Note that if the variable is unused because it's used only in ``assert``, "
"use ``[[maybe_unused]]`` instead of a C-style void cast."
msgstr ""

#: ../../../CodingStandards.rst:603
msgid ""
"When casting between integral types (including enums that are not strongly- "
"typed), functional-style casts are permitted as an alternative to "
"``static_cast``."
msgstr ""

#: ../../../CodingStandards.rst:610
msgid "Do not use Static Constructors"
msgstr ""

#: ../../../CodingStandards.rst:612
msgid ""
"Static constructors and destructors (e.g., global variables whose types have "
"a constructor or destructor) should not be added to the code base, and "
"should be removed wherever possible."
msgstr ""

#: ../../../CodingStandards.rst:616
msgid ""
"Globals in different source files are initialized in an `arbitrary order "
"<https://yosefk.com/c++fqa/ctors.html#fqa-10.12>`_, making the code more "
"difficult to reason about."
msgstr ""

#: ../../../CodingStandards.rst:620
msgid ""
"Static constructors have a negative impact on the launch time of programs "
"that use LLVM as a library. We would really like for there to be zero cost "
"for linking in an additional LLVM target or other library into an "
"application, but static constructors undermine this goal."
msgstr ""

#: ../../../CodingStandards.rst:626
msgid "Use of ``class`` and ``struct`` Keywords"
msgstr ""

#: ../../../CodingStandards.rst:628
msgid ""
"In C++, the ``class`` and ``struct`` keywords can be used almost "
"interchangeably. The only difference is when they are used to declare a "
"class: ``class`` makes all members private by default while ``struct`` makes "
"all members public by default."
msgstr ""

#: ../../../CodingStandards.rst:633
msgid ""
"All declarations and definitions of a given ``class`` or ``struct`` must use "
"the same keyword.  For example:"
msgstr ""

#: ../../../CodingStandards.rst:646
msgid "``struct`` should be used when *all* members are declared public."
msgstr ""

#: ../../../CodingStandards.rst:667
msgid "Do not use Braced Initializer Lists to Call a Constructor"
msgstr ""

#: ../../../CodingStandards.rst:669
msgid ""
"Starting from C++11 there is a \"generalized initialization syntax\" which "
"allows calling constructors using braced initializer lists. Do not use these "
"to call constructors with non-trivial logic or if you care that you're "
"calling some *particular* constructor. Those should look like function calls "
"using parentheses rather than like aggregate initialization. Similarly, if "
"you need to explicitly name the type and call its constructor to create a "
"temporary, don't use a braced initializer list. Instead, use a braced "
"initializer list (without any type for temporaries) when doing aggregate "
"initialization or something notionally equivalent. Examples:"
msgstr ""

#: ../../../CodingStandards.rst:698
msgid ""
"If you use a braced initializer list when initializing a variable, use an "
"equals before the open curly brace:"
msgstr ""

#: ../../../CodingStandards.rst:705
msgid "Use ``auto`` Type Deduction to Make Code More Readable"
msgstr ""

#: ../../../CodingStandards.rst:707
msgid ""
"Some are advocating a policy of \"almost always ``auto``\" in C++11; "
"however, LLVM uses a more moderate stance. Use ``auto`` if and only if it "
"makes the code more readable or easier to maintain. Don't \"almost always\" "
"use ``auto``, but do use ``auto`` with initializers like ``cast<Foo>(...)`` "
"or other places where the type is already obvious from the context. Another "
"time when ``auto`` works well for these purposes is when the type would have "
"been abstracted away anyway, often behind a container's typedef such as "
"``std::vector<T>::iterator``."
msgstr ""

#: ../../../CodingStandards.rst:715
msgid ""
"Similarly, C++14 adds generic lambda expressions where parameter types can "
"be ``auto``. Use these where you would have used a template."
msgstr ""

#: ../../../CodingStandards.rst:719
msgid "Beware unnecessary copies with ``auto``"
msgstr ""

#: ../../../CodingStandards.rst:721
msgid ""
"The convenience of ``auto`` makes it easy to forget that its default "
"behavior is a copy.  Particularly in range-based ``for`` loops, careless "
"copies are expensive."
msgstr ""

#: ../../../CodingStandards.rst:725
msgid ""
"Use ``auto &`` for values and ``auto *`` for pointers unless you need to "
"make a copy."
msgstr ""

#: ../../../CodingStandards.rst:742
msgid "Beware of non-determinism due to ordering of pointers"
msgstr ""

#: ../../../CodingStandards.rst:744
msgid ""
"In general, there is no relative ordering among pointers. As a result, when "
"unordered containers like sets and maps are used with pointer keys the "
"iteration order is undefined. Hence, iterating such containers may result in "
"non-deterministic code generation. While the generated code might work "
"correctly, non-determinism can make it harder to reproduce bugs and debug "
"the compiler."
msgstr ""

#: ../../../CodingStandards.rst:751
msgid ""
"In case an ordered result is expected, remember to sort an unordered "
"container before iteration. Or use ordered containers like ``vector``/"
"``MapVector``/``SetVector`` if you want to iterate pointer keys."
msgstr ""

#: ../../../CodingStandards.rst:757
msgid "Beware of non-deterministic sorting order of equal elements"
msgstr ""

#: ../../../CodingStandards.rst:759
msgid ""
"``std::sort`` uses a non-stable sorting algorithm in which the order of "
"equal elements is not guaranteed to be preserved. Thus using ``std::sort`` "
"for a container having equal elements may result in non-deterministic "
"behavior. To uncover such instances of non-determinism, LLVM has introduced "
"a new ``llvm::sort`` wrapper function. For an ``EXPENSIVE_CHECKS`` build "
"this will randomly shuffle the container before sorting. Default to using "
"``llvm::sort`` instead of ``std::sort``."
msgstr ""

#: ../../../CodingStandards.rst:768
msgid "Style Issues"
msgstr ""

#: ../../../CodingStandards.rst:771
msgid "The High-Level Issues"
msgstr ""

#: ../../../CodingStandards.rst:774
msgid "Self-contained Headers"
msgstr ""

#: ../../../CodingStandards.rst:776
msgid ""
"Header files should be self-contained (compile on their own) and end in ``."
"h``. Non-header files that are meant for inclusion should end in ``.inc`` "
"and be used sparingly."
msgstr ""

#: ../../../CodingStandards.rst:780
msgid ""
"All header files should be self-contained. Users and refactoring tools "
"should not have to adhere to special conditions to include the header. "
"Specifically, a header should have header guards and include all other "
"headers it needs."
msgstr ""

#: ../../../CodingStandards.rst:784
msgid ""
"There are rare cases where a file designed to be included is not self-"
"contained. These are typically intended to be included at unusual locations, "
"such as the middle of another file. They might not use header guards, and "
"might not include their prerequisites. Name such files with the .inc "
"extension. Use sparingly, and prefer self-contained headers when possible."
msgstr ""

#: ../../../CodingStandards.rst:790
msgid ""
"In general, a header should be implemented by one or more ``.cpp`` files.  "
"Each of these ``.cpp`` files should include the header that defines their "
"interface first.  This ensures that all of the dependencies of the header "
"have been properly added to the header itself, and are not implicit.  System "
"headers should be included after user headers for a translation unit."
msgstr ""

#: ../../../CodingStandards.rst:797
msgid "Library Layering"
msgstr ""

#: ../../../CodingStandards.rst:799
msgid ""
"A directory of header files (for example, ``include/llvm/Foo``) defines a "
"library (``Foo``). One library (both its headers and implementation) should "
"only use things from the libraries listed in its dependencies."
msgstr ""

#: ../../../CodingStandards.rst:804
msgid ""
"Some of this constraint can be enforced by classic Unix linkers (Mac & "
"Windows linkers, as well as lld, do not enforce this constraint). A Unix "
"linker searches left to right through the libraries specified on its command "
"line and never revisits a library. In this way, no circular dependencies "
"between libraries can exist."
msgstr ""

#: ../../../CodingStandards.rst:810
msgid ""
"This doesn't fully enforce all inter-library dependencies, and importantly "
"doesn't enforce header file circular dependencies created by inline "
"functions. A good way to answer the \"is this layered correctly\" would be "
"to consider whether a Unix linker would succeed at linking the program if "
"all inline functions were defined out-of-line. (& for all valid orderings of "
"dependencies - since linking resolution is linear, it's possible that some "
"implicit dependencies can sneak through: A depends on B and C, so valid "
"orderings are \"C B A\" or \"B C A\", in both cases the explicit "
"dependencies come before their use. But in the first case, B could still "
"link successfully if it implicitly depended on C, or the opposite in the "
"second case)"
msgstr ""

#: ../../../CodingStandards.rst:824
msgid "``#include`` as Little as Possible"
msgstr ""

#: ../../../CodingStandards.rst:826
msgid ""
"``#include`` hurts compile time performance.  Don't do it unless you have "
"to, especially in header files."
msgstr ""

#: ../../../CodingStandards.rst:829
msgid ""
"But wait! Sometimes you need to have the definition of a class to use it, or "
"to inherit from it.  In these cases go ahead and ``#include`` that header "
"file.  Be aware, however, that there are many cases where you don't need to "
"have the full definition of a class.  If you are using a pointer or "
"reference to a class, you don't need the header file.  If you are simply "
"returning a class instance from a prototyped function or method, you don't "
"need it.  In fact, for most cases, you simply don't need the definition of a "
"class. And not ``#include``\\ing speeds up compilation."
msgstr ""

#: ../../../CodingStandards.rst:838
msgid ""
"It is easy to try to go overboard on this recommendation, however.  You "
"**must** include all of the header files that you are using --- you can "
"include them either directly or indirectly through another header file.  To "
"make sure that you don't accidentally forget to include a header file in "
"your module header, make sure to include your module header **first** in the "
"implementation file (as mentioned above).  This way there won't be any "
"hidden dependencies that you'll find out about later."
msgstr ""

#: ../../../CodingStandards.rst:847
msgid "Keep \"Internal\" Headers Private"
msgstr ""

#: ../../../CodingStandards.rst:849
msgid ""
"Many modules have a complex implementation that causes them to use more than "
"one implementation (``.cpp``) file.  It is often tempting to put the "
"internal communication interface (helper classes, extra functions, etc) in "
"the public module header file.  Don't do this!"
msgstr ""

#: ../../../CodingStandards.rst:854
msgid ""
"If you really need to do something like this, put a private header file in "
"the same directory as the source files, and include it locally.  This "
"ensures that your private interface remains private and undisturbed by "
"outsiders."
msgstr ""

#: ../../../CodingStandards.rst:860
msgid ""
"It's okay to put extra implementation methods in a public class itself. Just "
"make them private (or protected) and all is well."
msgstr ""

#: ../../../CodingStandards.rst:864
msgid "Use Namespace Qualifiers to Define Previously Declared Symbols"
msgstr ""

#: ../../../CodingStandards.rst:866
msgid ""
"When providing an out-of-line definition for various symbols (variables, "
"functions, opaque classes) in a source file, do not open namespace blocks in "
"the source file. Instead, use namespace qualifiers to help ensure that your "
"definition matches an existing declaration. Do this:"
msgstr ""

#: ../../../CodingStandards.rst:897
msgid ""
"Doing this helps to avoid bugs where the definition does not match the "
"declaration from the header. For example, the following C++ code defines a "
"new overload of ``llvm::foo`` instead of providing a definition for the "
"existing function declared in the header:"
msgstr ""

#: ../../../CodingStandards.rst:911
msgid ""
"This error will not be caught until the build is nearly complete, when the "
"linker fails to find a definition for any uses of the original function.  If "
"the function were instead defined with a namespace qualifier, the error "
"would have been caught immediately when the definition was compiled."
msgstr ""

#: ../../../CodingStandards.rst:916
msgid ""
"Class method implementations must already name the class and new overloads "
"cannot be introduced out of line, so this recommendation does not apply to "
"them."
msgstr ""

#: ../../../CodingStandards.rst:922
msgid "Use Early Exits and ``continue`` to Simplify Code"
msgstr ""

#: ../../../CodingStandards.rst:924
msgid ""
"When reading code, keep in mind how much state and how many previous "
"decisions have to be remembered by the reader to understand a block of "
"code.  Aim to reduce indentation where possible when it doesn't make it more "
"difficult to understand the code.  One great way to do this is by making use "
"of early exits and the ``continue`` keyword in long loops. Consider this "
"code that does not use an early exit:"
msgstr ""

#: ../../../CodingStandards.rst:942
msgid ""
"This code has several problems if the body of the ``'if'`` is large.  When "
"you're looking at the top of the function, it isn't immediately clear that "
"this *only* does interesting things with non-terminator instructions, and "
"only applies to things with the other predicates.  Second, it is relatively "
"difficult to describe (in comments) why these predicates are important "
"because the ``if`` statement makes it difficult to lay out the comments.  "
"Third, when you're deep within the body of the code, it is indented an extra "
"level.  Finally, when reading the top of the function, it isn't clear what "
"the result is if the predicate isn't true; you have to read to the end of "
"the function to know that it returns null."
msgstr ""

#: ../../../CodingStandards.rst:953
msgid "It is much preferred to format the code like this:"
msgstr ""

#: ../../../CodingStandards.rst:974
msgid ""
"This fixes these problems.  A similar problem frequently happens in ``for`` "
"loops.  A silly example is something like this:"
msgstr ""

#: ../../../CodingStandards.rst:989
msgid ""
"When you have very, very small loops, this sort of structure is fine. But if "
"it exceeds more than 10-15 lines, it becomes difficult for people to read "
"and understand at a glance. The problem with this sort of code is that it "
"gets very nested very quickly. This means that the reader of the code has to "
"keep a lot of context in their brain to remember what is going immediately "
"on in the loop, because they don't know if/when the ``if`` conditions will "
"have ``else``\\s etc. It is strongly preferred to structure the loop like "
"this:"
msgstr ""

#: ../../../CodingStandards.rst:1010
msgid ""
"This has all the benefits of using early exits for functions: it reduces the "
"nesting of the loop, it makes it easier to describe why the conditions are "
"true, and it makes it obvious to the reader that there is no ``else`` coming "
"up that they have to push context into their brain for.  If a loop is large, "
"this can be a big understandability win."
msgstr ""

#: ../../../CodingStandards.rst:1017
msgid "Don't use ``else`` after a ``return``"
msgstr ""

#: ../../../CodingStandards.rst:1019
msgid ""
"For similar reasons as above (reduction of indentation and easier reading), "
"please do not use ``'else'`` or ``'else if'`` after something that "
"interrupts control flow --- like ``return``, ``break``, ``continue``, "
"``goto``, etc. For example:"
msgstr ""

#: ../../../CodingStandards.rst:1045
msgid "It is better to write it like this:"
msgstr ""

#: ../../../CodingStandards.rst:1065
msgid "Or better yet (in this case) as:"
msgstr ""

#: ../../../CodingStandards.rst:1082
msgid ""
"The idea is to reduce indentation and the amount of code you have to keep "
"track of when reading the code."
msgstr ""

#: ../../../CodingStandards.rst:1085
msgid ""
"Note: this advice does not apply to a ``constexpr if`` statement. The "
"substatement of the ``else`` clause may be a discarded statement, so "
"removing the ``else`` can cause unexpected template instantiations. Thus, "
"the following example is correct:"
msgstr ""

#: ../../../CodingStandards.rst:1104
msgid "Turn Predicate Loops into Predicate Functions"
msgstr ""

#: ../../../CodingStandards.rst:1106
msgid ""
"It is very common to write small loops that just compute a boolean value.  "
"There are a number of ways that people commonly write these, but an example "
"of this sort of thing is:"
msgstr ""

#: ../../../CodingStandards.rst:1123
msgid ""
"Instead of this sort of loop, we prefer to use a predicate function (which "
"may be `static`_) that uses `early exits`_:"
msgstr ""

#: ../../../CodingStandards.rst:1141
msgid ""
"There are many reasons for doing this: it reduces indentation and factors "
"out code which can often be shared by other code that checks for the same "
"predicate. More importantly, it *forces you to pick a name* for the "
"function, and forces you to write a comment for it.  In this silly example, "
"this doesn't add much value.  However, if the condition is complex, this can "
"make it a lot easier for the reader to understand the code that queries for "
"this predicate.  Instead of being faced with the in-line details of how we "
"check to see if the BarList contains a foo, we can trust the function name "
"and continue reading with better locality."
msgstr ""

#: ../../../CodingStandards.rst:1152
msgid "The Low-Level Issues"
msgstr ""

#: ../../../CodingStandards.rst:1155
msgid "Name Types, Functions, Variables, and Enumerators Properly"
msgstr ""

#: ../../../CodingStandards.rst:1157
msgid ""
"Poorly-chosen names can mislead the reader and cause bugs. We cannot stress "
"enough how important it is to use *descriptive* names.  Pick names that "
"match the semantics and role of the underlying entities, within reason.  "
"Avoid abbreviations unless they are well known.  After picking a good name, "
"make sure to use consistent capitalization for the name, as inconsistency "
"requires clients to either memorize the APIs or to look it up to find the "
"exact spelling."
msgstr ""

#: ../../../CodingStandards.rst:1164
msgid ""
"In general, names should be in camel case (e.g. ``TextFileReader`` and "
"``isLValue()``).  Different kinds of declarations have different rules:"
msgstr ""

#: ../../../CodingStandards.rst:1167
msgid ""
"**Type names** (including classes, structs, enums, typedefs, etc) should be "
"nouns and start with an upper-case letter (e.g. ``TextFileReader``)."
msgstr ""

#: ../../../CodingStandards.rst:1170
msgid ""
"**Variable names** should be nouns (as they represent state).  The name "
"should be camel case, and start with an upper-case letter (e.g. ``Leader`` "
"or ``Boats``)."
msgstr ""

#: ../../../CodingStandards.rst:1174
msgid ""
"**Function names** should be verb phrases (as they represent actions), and "
"command-like function should be imperative.  The name should be camel case, "
"and start with a lowercase letter (e.g. ``openFile()`` or ``isFoo()``)."
msgstr ""

#: ../../../CodingStandards.rst:1178
msgid ""
"**Enum declarations** (e.g. ``enum Foo {...}``) are types, so they should "
"follow the naming conventions for types.  A common use for enums is as a "
"discriminator for a union, or an indicator of a subclass.  When an enum is "
"used for something like this, it should have a ``Kind`` suffix (e.g. "
"``ValueKind``)."
msgstr ""

#: ../../../CodingStandards.rst:1184
msgid ""
"**Enumerators** (e.g. ``enum { Foo, Bar }``) and **public member variables** "
"should start with an upper-case letter, just like types.  Unless the "
"enumerators are defined in their own small namespace or inside a class, "
"enumerators should have a prefix corresponding to the enum declaration name. "
"For example, ``enum ValueKind { ... };`` may contain enumerators like "
"``VK_Argument``, ``VK_BasicBlock``, etc.  Enumerators that are just "
"convenience constants are exempt from the requirement for a prefix.  For "
"instance:"
msgstr ""

#: ../../../CodingStandards.rst:1200
msgid ""
"As an exception, classes that mimic STL classes can have member names in "
"STL's style of lowercase words separated by underscores (e.g. ``begin()``, "
"``push_back()``, and ``empty()``). Classes that provide multiple iterators "
"should add a singular prefix to ``begin()`` and ``end()`` (e.g. "
"``global_begin()`` and ``use_begin()``)."
msgstr ""

#: ../../../CodingStandards.rst:1206
msgid "Here are some examples:"
msgstr ""

#: ../../../CodingStandards.rst:1226
msgid "Assert Liberally"
msgstr ""

#: ../../../CodingStandards.rst:1228
msgid ""
"Use the \"``assert``\" macro to its fullest.  Check all of your "
"preconditions and assumptions.  You never know when a bug (not necessarily "
"even yours) might be caught early by an assertion, which reduces debugging "
"time dramatically.  The \"``<cassert>``\" header file is probably already "
"included by the header files you are using, so it doesn't cost anything to "
"use it."
msgstr ""

#: ../../../CodingStandards.rst:1234
msgid ""
"To further assist with debugging, make sure to put some kind of error "
"message in the assertion statement, which is printed if the assertion is "
"tripped. This helps the poor debugger make sense of why an assertion is "
"being made and enforced, and hopefully what to do about it.  Here is one "
"complete example:"
msgstr ""

#: ../../../CodingStandards.rst:1246
msgid "Here are more examples:"
msgstr ""

#: ../../../CodingStandards.rst:1260
msgid "You get the idea."
msgstr ""

#: ../../../CodingStandards.rst:1262
msgid ""
"In the past, asserts were used to indicate a piece of code that should not "
"be reached.  These were typically of the form:"
msgstr ""

#: ../../../CodingStandards.rst:1269
msgid ""
"This has a few issues, the main one being that some compilers might not "
"understand the assertion, or warn about a missing return in builds where "
"assertions are compiled out."
msgstr ""

#: ../../../CodingStandards.rst:1273
msgid "Today, we have something much better: ``llvm_unreachable``:"
msgstr ""

#: ../../../CodingStandards.rst:1279
msgid ""
"When assertions are enabled, this will print the message if it's ever "
"reached and then exit the program. When assertions are disabled (i.e. in "
"release builds), ``llvm_unreachable`` becomes a hint to compilers to skip "
"generating code for this branch. If the compiler does not support this, it "
"will fall back to the \"abort\" implementation."
msgstr ""

#: ../../../CodingStandards.rst:1285
msgid ""
"Use ``llvm_unreachable`` to mark a specific point in code that should never "
"be reached. This is especially desirable for addressing warnings about "
"unreachable branches, etc., but can be used whenever reaching a particular "
"code path is unconditionally a bug (not originating from user input; see "
"below) of some kind. Use of ``assert`` should always include a testable "
"predicate (as opposed to ``assert(false)``)."
msgstr ""

#: ../../../CodingStandards.rst:1292
msgid ""
"If the error condition can be triggered by user input then the recoverable "
"error mechanism described in :doc:`ProgrammersManual` should be used "
"instead. In cases where this is not practical, ``report_fatal_error`` may be "
"used."
msgstr ""

#: ../../../CodingStandards.rst:1297
msgid ""
"Another issue is that values used only by assertions will produce an "
"\"unused value\" warning when assertions are disabled.  For example, this "
"code will warn:"
msgstr ""

#: ../../../CodingStandards.rst:1308
msgid ""
"These are two interesting different cases. In the first case, the call to "
"``V.size()`` is only useful for the assert, and we don't want it executed "
"when assertions are disabled.  Code like this should move the call into the "
"assert itself.  In the second case, the side effects of the call must happen "
"whether the assert is enabled or not. In this case, the value should be "
"defined using the ``[[maybe_unused]]`` attribute to suppress the warning. To "
"be specific, it is preferred to write the code like this:"
msgstr ""

#: ../../../CodingStandards.rst:1323
msgid ""
"In C code where ``[[maybe_unused]]`` is not supported, use ``void`` cast to "
"suppress an unused variable warning as follows:"
msgstr ""

#: ../../../CodingStandards.rst:1333
msgid "Do Not Use ``using namespace std``"
msgstr ""

#: ../../../CodingStandards.rst:1335
msgid ""
"In LLVM, we prefer to explicitly prefix all identifiers from the standard "
"namespace with an \"``std::``\" prefix, rather than rely on \"``using "
"namespace std;``\"."
msgstr ""

#: ../../../CodingStandards.rst:1339
msgid ""
"In header files, adding a ``'using namespace XXX'`` directive pollutes the "
"namespace of any source file that ``#include``\\s the header, creating "
"maintenance issues."
msgstr ""

#: ../../../CodingStandards.rst:1343
msgid ""
"In implementation files (e.g. ``.cpp`` files), the rule is more of a "
"stylistic rule, but is still important.  Basically, using explicit namespace "
"prefixes makes the code **clearer**, because it is immediately obvious what "
"facilities are being used and where they are coming from. And **more "
"portable**, because namespace clashes cannot occur between LLVM code and "
"other namespaces.  The portability rule is important because different "
"standard library implementations expose different symbols (potentially ones "
"they shouldn't), and future revisions to the C++ standard will add more "
"symbols to the ``std`` namespace.  As such, we never use ``'using namespace "
"std;'`` in LLVM."
msgstr ""

#: ../../../CodingStandards.rst:1353
msgid ""
"The exception to the general rule (i.e. it's not an exception for the "
"``std`` namespace) is for implementation files.  For example, all of the "
"code in the LLVM project implements code that lives in the 'llvm' "
"namespace.  As such, it is ok, and actually clearer, for the ``.cpp`` files "
"to have a ``'using namespace llvm;'`` directive at the top, after the "
"``#include``\\s.  This reduces indentation in the body of the file for "
"source editors that indent based on braces, and keeps the conceptual context "
"cleaner.  The general form of this rule is that any ``.cpp`` file that "
"implements code in any namespace may use that namespace (and its parents'), "
"but should not use any others."
msgstr ""

#: ../../../CodingStandards.rst:1364
msgid "Provide a Virtual Method Anchor for Classes in Headers"
msgstr ""

#: ../../../CodingStandards.rst:1366
msgid ""
"If a class is defined in a header file and has a vtable (either it has "
"virtual methods or it derives from classes with virtual methods), it must "
"always have at least one out-of-line virtual method in the class.  Without "
"this, the compiler will copy the vtable and RTTI into every ``.o`` file that "
"``#include``\\s the header, bloating ``.o`` file sizes and increasing link "
"times."
msgstr ""

#: ../../../CodingStandards.rst:1373
msgid "Don't use default labels in fully covered switches over enumerations"
msgstr ""

#: ../../../CodingStandards.rst:1375
msgid ""
"``-Wswitch`` warns if a switch, without a default label, over an enumeration "
"does not cover every enumeration value. If you write a default label on a "
"fully covered switch over an enumeration then the ``-Wswitch`` warning won't "
"fire when new elements are added to that enumeration. To help avoid adding "
"these kinds of defaults, Clang has the warning ``-Wcovered-switch-default`` "
"which is off by default but turned on when building LLVM with a version of "
"Clang that supports the warning."
msgstr ""

#: ../../../CodingStandards.rst:1383
msgid ""
"A knock-on effect of this stylistic requirement is that when building LLVM "
"with GCC you may get warnings related to \"control may reach end of non-void "
"function\" if you return from each case of a covered switch-over-enum "
"because GCC assumes that the enum expression may take any representable "
"value, not just those of individual enumerators. To suppress this warning, "
"use ``llvm_unreachable`` after the switch."
msgstr ""

#: ../../../CodingStandards.rst:1391
msgid "Use range-based ``for`` loops wherever possible"
msgstr ""

#: ../../../CodingStandards.rst:1393
msgid ""
"The introduction of range-based ``for`` loops in C++11 means that explicit "
"manipulation of iterators is rarely necessary. We use range-based ``for`` "
"loops wherever possible for all newly added code. For example:"
msgstr ""

#: ../../../CodingStandards.rst:1403
msgid ""
"Usage of ``std::for_each()``/``llvm::for_each()`` functions is discouraged, "
"unless the callable object already exists."
msgstr ""

#: ../../../CodingStandards.rst:1407
msgid "Don't evaluate ``end()`` every time through a loop"
msgstr ""

#: ../../../CodingStandards.rst:1409
msgid ""
"In cases where range-based ``for`` loops can't be used and it is necessary "
"to write an explicit iterator-based loop, pay close attention to whether "
"``end()`` is re-evaluated on each loop iteration. One common mistake is to "
"write a loop in this style:"
msgstr ""

#: ../../../CodingStandards.rst:1420
msgid ""
"The problem with this construct is that it evaluates \"``BB->end()``\" every "
"time through the loop.  Instead of writing the loop like this, we strongly "
"prefer loops to be written so that they evaluate it once before the loop "
"starts.  A convenient way to do this is like so:"
msgstr ""

#: ../../../CodingStandards.rst:1431
msgid ""
"The observant may quickly point out that these two loops may have different "
"semantics: if the container (a basic block in this case) is being mutated, "
"then \"``BB->end()``\" may change its value every time through the loop and "
"the second loop may not in fact be correct.  If you actually do depend on "
"this behavior, please write the loop in the first form and add a comment "
"indicating that you did it intentionally."
msgstr ""

#: ../../../CodingStandards.rst:1438
msgid ""
"Why do we prefer the second form (when correct)?  Writing the loop in the "
"first form has two problems. First, it may be less efficient than evaluating "
"it at the start of the loop.  In this case, the cost is probably minor --- a "
"few extra loads every time through the loop.  However, if the base "
"expression is more complex, then the cost can rise quickly.  I've seen loops "
"where the end expression was actually something like: \"``SomeMap[X]-"
">end()``\" and map lookups really aren't cheap.  By writing it in the second "
"form consistently, you eliminate the issue entirely and don't even have to "
"think about it."
msgstr ""

#: ../../../CodingStandards.rst:1447
msgid ""
"The second (even bigger) issue is that writing the loop in the first form "
"hints to the reader that the loop is mutating the container (a fact that a "
"comment would handily confirm!).  If you write the loop in the second form, "
"it is immediately obvious without even looking at the body of the loop that "
"the container isn't being modified, which makes it easier to read the code "
"and understand what it does."
msgstr ""

#: ../../../CodingStandards.rst:1454
msgid ""
"While the second form of the loop is a few extra keystrokes, we do strongly "
"prefer it."
msgstr ""

#: ../../../CodingStandards.rst:1458
msgid "``#include <iostream>`` is Forbidden"
msgstr ""

#: ../../../CodingStandards.rst:1460
msgid ""
"The use of ``#include <iostream>`` in library files is hereby **forbidden**, "
"because many common implementations transparently inject a `static "
"constructor`_ into every translation unit that includes it."
msgstr ""

#: ../../../CodingStandards.rst:1464
msgid ""
"Note that using the other stream headers (``<sstream>`` for example) is not "
"problematic in this regard --- just ``<iostream>``. However, ``raw_ostream`` "
"provides various APIs that are better performing for almost every use than "
"``std::ostream`` style APIs."
msgstr ""

#: ../../../CodingStandards.rst:1471
msgid ""
"New code should always use `raw_ostream`_ for writing, or the ``llvm::"
"MemoryBuffer`` API for reading files."
msgstr ""

#: ../../../CodingStandards.rst:1477
msgid "Use ``raw_ostream``"
msgstr ""

#: ../../../CodingStandards.rst:1479
msgid ""
"LLVM includes a lightweight, simple, and efficient stream implementation in "
"``llvm/Support/raw_ostream.h``, which provides all of the common features of "
"``std::ostream``.  All new code should use ``raw_ostream`` instead of "
"``ostream``."
msgstr ""

#: ../../../CodingStandards.rst:1484
msgid ""
"Unlike ``std::ostream``, ``raw_ostream`` is not a template and can be "
"forward declared as ``class raw_ostream``.  Public headers should generally "
"not include the ``raw_ostream`` header, but use forward declarations and "
"constant references to ``raw_ostream`` instances."
msgstr ""

#: ../../../CodingStandards.rst:1490
msgid "Avoid ``std::endl``"
msgstr ""

#: ../../../CodingStandards.rst:1492
msgid ""
"The ``std::endl`` modifier, when used with ``iostreams`` outputs a newline "
"to the output stream specified.  In addition to doing this, however, it also "
"flushes the output stream.  In other words, these are equivalent:"
msgstr ""

#: ../../../CodingStandards.rst:1501
msgid ""
"Most of the time, you probably have no reason to flush the output stream, so "
"it's better to use a literal ``'\\n'``."
msgstr ""

#: ../../../CodingStandards.rst:1505
msgid "Don't use ``inline`` when defining a function in a class definition"
msgstr ""

#: ../../../CodingStandards.rst:1507
msgid ""
"A member function defined in a class definition is implicitly inline, so "
"don't put the ``inline`` keyword in this case."
msgstr ""

#: ../../../CodingStandards.rst:1510
msgid "Don't:"
msgstr ""

#: ../../../CodingStandards.rst:1521
msgid "Do:"
msgstr ""

#: ../../../CodingStandards.rst:1533
msgid "Microscopic Details"
msgstr ""

#: ../../../CodingStandards.rst:1535
msgid ""
"This section describes preferred low-level formatting guidelines along with "
"reasoning on why we prefer them."
msgstr ""

#: ../../../CodingStandards.rst:1539
msgid "Spaces Before Parentheses"
msgstr ""

#: ../../../CodingStandards.rst:1541
msgid ""
"Put a space before an open parenthesis only in control flow statements, but "
"not in normal function call expressions and function-like macros.  For "
"example:"
msgstr ""

#: ../../../CodingStandards.rst:1555
msgid ""
"The reason for doing this is not completely arbitrary.  This style makes "
"control flow operators stand out more, and makes expressions flow better."
msgstr ""

#: ../../../CodingStandards.rst:1559
msgid "Prefer Preincrement"
msgstr ""

#: ../../../CodingStandards.rst:1561
msgid ""
"Hard fast rule: Preincrement (``++X``) may be no slower than postincrement "
"(``X++``) and could very well be a lot faster than it.  Use "
"preincrementation whenever possible."
msgstr ""

#: ../../../CodingStandards.rst:1565
msgid ""
"The semantics of postincrement include making a copy of the value being "
"incremented, returning it, and then preincrementing the \"work value\".  For "
"primitive types, this isn't a big deal. But for iterators, it can be a huge "
"issue (for example, some iterators contain stack and set objects in them... "
"copying an iterator could invoke the copy ctor's of these as well).  In "
"general, get in the habit of always using preincrement, and you won't have a "
"problem."
msgstr ""

#: ../../../CodingStandards.rst:1574
msgid "Namespace Indentation"
msgstr ""

#: ../../../CodingStandards.rst:1576
msgid ""
"In general, we strive to reduce indentation wherever possible.  This is "
"useful because we want code to `fit into 80 columns`_ without excessive "
"wrapping, but also because it makes it easier to understand the code. To "
"facilitate this and avoid some insanely deep nesting on occasion, don't "
"indent namespaces. If it helps readability, feel free to add a comment "
"indicating what namespace is being closed by a ``}``.  For example:"
msgstr ""

#: ../../../CodingStandards.rst:1604
msgid ""
"Feel free to skip the closing comment when the namespace being closed is "
"obvious for any reason. For example, the outer-most namespace in a header "
"file is rarely a source of confusion. But namespaces both anonymous and "
"named in source files that are being closed half way through the file "
"probably could use clarification."
msgstr ""

#: ../../../CodingStandards.rst:1613
msgid "Restrict Visibility"
msgstr ""

#: ../../../CodingStandards.rst:1615
msgid ""
"Functions and variables should have the most restricted visibility possible."
msgstr ""

#: ../../../CodingStandards.rst:1617
msgid ""
"For class members, that means using appropriate ``private``, ``protected``, "
"or ``public`` keyword to restrict their access."
msgstr ""

#: ../../../CodingStandards.rst:1620
msgid ""
"For non-member functions, variables, and classes, that means restricting "
"visibility to a single ``.cpp`` file if it is not referenced outside that "
"file."
msgstr ""

#: ../../../CodingStandards.rst:1623
msgid ""
"Visibility of file-scope non-member variables and functions can be "
"restricted to the current translation unit by using either the ``static`` "
"keyword or an anonymous namespace."
msgstr ""

#: ../../../CodingStandards.rst:1627
msgid ""
"Anonymous namespaces are a great language feature that tells the C++ "
"compiler that the contents of the namespace are only visible within the "
"current translation unit, allowing more aggressive optimization and "
"eliminating the possibility of symbol name collisions."
msgstr ""

#: ../../../CodingStandards.rst:1632
msgid ""
"Anonymous namespaces are to C++ as ``static`` is to C functions and global "
"variables.  While ``static`` is available in C++, anonymous namespaces are "
"more general: they can make entire classes private to a file."
msgstr ""

#: ../../../CodingStandards.rst:1636
msgid ""
"The problem with anonymous namespaces is that they naturally want to "
"encourage indentation of their body, and they reduce locality of reference: "
"if you see a random function definition in a C++ file, it is easy to see if "
"it is marked static, but seeing if it is in an anonymous namespace requires "
"scanning a big chunk of the file."
msgstr ""

#: ../../../CodingStandards.rst:1642
msgid ""
"Because of this, we have a simple guideline: make anonymous namespaces as "
"small as possible, and only use them for class declarations.  For example:"
msgstr ""

#: ../../../CodingStandards.rst:1664
msgid ""
"Avoid putting declarations other than classes into anonymous namespaces:"
msgstr ""

#: ../../../CodingStandards.rst:1680
msgid ""
"When you are looking at ``runHelper`` in the middle of a large C++ file, you "
"have no immediate way to tell if this function is local to the file."
msgstr ""

#: ../../../CodingStandards.rst:1683
msgid ""
"In contrast, when the function is marked static, you don't need to cross-"
"reference faraway places in the file to tell that the function is local:"
msgstr ""

#: ../../../CodingStandards.rst:1693
msgid ""
"Don't Use Braces on Simple Single-Statement Bodies of if/else/loop Statements"
msgstr ""

#: ../../../CodingStandards.rst:1695
msgid ""
"When writing the body of an ``if``, ``else``, or ``for``/``while`` loop "
"statement, we aim to reduce unnecessary line noise."
msgstr ""

#: ../../../CodingStandards.rst:1698
msgid "**Omit braces when:**"
msgstr ""

#: ../../../CodingStandards.rst:1700
msgid "The body consists of a single **simple** statement."
msgstr ""

#: ../../../CodingStandards.rst:1701
msgid ""
"The single statement is not preceded by a comment. (Hoist comments above the "
"control statement if you can.)"
msgstr ""

#: ../../../CodingStandards.rst:1703
msgid ""
"An ``else`` clause, if present, also meets the above criteria (single simple "
"statement, no associated comments)."
msgstr ""

#: ../../../CodingStandards.rst:1706
msgid "**Use braces in all other cases, including:**"
msgstr ""

#: ../../../CodingStandards.rst:1708
msgid "Multi-statement bodies"
msgstr ""

#: ../../../CodingStandards.rst:1709
msgid "Single-statement bodies with non-hoistable comments"
msgstr ""

#: ../../../CodingStandards.rst:1710
msgid ""
"Complex single-statement bodies (e.g., deep nesting, complex nested loops)"
msgstr ""

#: ../../../CodingStandards.rst:1712
msgid ""
"Inconsistent bracing within ``if``/``else if``/``else`` chains (if one block "
"requires braces, all must)"
msgstr ""

#: ../../../CodingStandards.rst:1714
msgid ""
"``if`` statements ending with a nested ``if`` lacking an ``else`` (to "
"prevent \"dangling else\")"
msgstr ""

#: ../../../CodingStandards.rst:1717
msgid "The examples below provide guidelines for these cases:"
msgstr ""

#: ../../../CodingStandards.rst:1807
msgid "Use Unix line endings for files"
msgstr ""

#: ../../../CodingStandards.rst:1809
msgid ""
"Use Unix line endings for all files. CRLF line endings are allowed as an "
"exception for test files that intend to test CRLF handling or when the file "
"format requires it (like ``.bat`` or ``.rc`` files)."
msgstr ""

#: ../../../CodingStandards.rst:1814
msgid "See Also"
msgstr ""

#: ../../../CodingStandards.rst:1816
msgid ""
"A lot of these comments and recommendations have been culled from other "
"sources. Two particularly important books for our work are:"
msgstr ""

#: ../../../CodingStandards.rst:1819
msgid ""
"`Effective C++ <https://www.amazon.com/Effective-Specific-Addison-Wesley-"
"Professional-Computing/dp/0321334876>`_ by Scott Meyers.  Also interesting "
"and useful are \"More Effective C++\" and \"Effective STL\" by the same "
"author."
msgstr ""

#: ../../../CodingStandards.rst:1824
msgid ""
"`Large-Scale C++ Software Design <https://www.amazon.com/Large-Scale-"
"Software-Design-John-Lakos/dp/0201633620>`_ by John Lakos"
msgstr ""

#: ../../../CodingStandards.rst:1828
msgid ""
"If you get some free time, and you haven't read them: do so, you might learn "
"something."
msgstr ""
