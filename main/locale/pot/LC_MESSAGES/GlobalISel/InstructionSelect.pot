# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../GlobalISel/InstructionSelect.rst:5
msgid "InstructionSelect"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:7
msgid ""
"This pass transforms generic machine instructions into equivalent target-"
"specific instructions."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:10
msgid ""
"The legacy instruction selector, SelectionDAG, iterated over each function's "
"basic block and constructed a dataflow graph. Every backend defines tree "
"patterns in the ``XXXInstrInfo.td``. The legacy selector started at the "
"bottom and replaced the SDNodes greedily."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:15
msgid ""
"The GlobalISel's instruction selector traverses the ``MachineFunction`` "
"bottom-up, selecting uses before definitions, enabling trivial dead code "
"elimination. It does that by iterating over the basic blocks in post-order. "
"Each gMIR instruction is then replaced by a MIR instruction when a matching "
"pattern is found. So, when there is a 1:1 mapping between gMIR and MIR, "
"where is the benefit of the global scope? Even in the case of a 1:1 mapping, "
"GlobalISel includes a combiner that can match and fuse multiple gMIR "
"instructions. The scope of the combination is not limited to a basic block, "
"but can extend across the entire function."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:28
msgid "API: InstructionSelector"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:30
msgid ""
"The target implements the ``InstructionSelector`` class, containing the "
"target-specific selection logic proper."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:33
msgid ""
"The instance is provided by the subtarget, so that it can specialize the "
"selector by subtarget feature (with, e.g., a vector selector overriding "
"parts of a general-purpose common selector). We might also want to "
"parameterize it by MachineFunction, to enable selector variants based on "
"function attributes like optsize."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:39
msgid "The simple API consists of:"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:45
msgid ""
"This target-provided method is responsible for mutating (or replacing) a "
"possibly-generic MI into a fully target-specific equivalent. It is also "
"responsible for doing the necessary constraining of gvregs into the "
"appropriate register classes as well as passing through COPY instructions to "
"the register allocator."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:51
msgid ""
"The ``InstructionSelector`` can fold other instructions into the selected "
"MI, by walking the use-def chain of the vreg operands. As GlobalISel is "
"Global, this folding can occur across basic blocks."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:56
msgid "SelectionDAG Rule Imports"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:58
msgid ""
"TableGen will import SelectionDAG rules and provide the following function "
"to execute them:"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:65
msgid ""
"The ``--stats`` option can be used to determine what proportion of rules "
"were successfully imported. The easiest way to use this is to copy the ``-"
"gen-globalisel`` tablegen command from ``ninja -v`` and modify it."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:69
msgid ""
"Similarly, the ``--warn-on-skipped-patterns`` option can be used to obtain "
"the reasons that rules weren't imported. This can be used to focus on the "
"most important rejection reasons."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:74
msgid "PatLeaf Predicates"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:76
msgid ""
"PatLeafs cannot be imported because their C++ is implemented in terms of "
"``SDNode`` objects. PatLeafs that handle immediate predicates should be "
"replaced by ``ImmLeaf``, ``IntImmLeaf``, or ``FPImmLeaf`` as appropriate."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:80
msgid ""
"There's no standard answer for other PatLeafs. Some standard predicates have "
"been baked into TableGen but this should not generally be done."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:84
msgid "Custom SDNodes"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:86
msgid ""
"Custom SDNodes should be mapped to Target Pseudos using ``GINodeEquiv``. "
"This will cause the instruction selector to import them but you will also "
"need to ensure the target pseudo is introduced to the MIR before the "
"instruction selector. Any preceding pass is suitable but the legalizer will "
"be a particularly common choice."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:93
msgid "ComplexPatterns"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:95
msgid ""
"ComplexPatterns cannot be imported because their C++ is implemented in terms "
"of ``SDNode`` objects. GlobalISel versions should be defined with "
"``GIComplexOperandMatcher`` and mapped to ComplexPattern with "
"``GIComplexPatternEquiv``."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:100
msgid "The following predicates are useful for porting ComplexPattern:"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:102
msgid "isBaseWithConstantOffset() - Check for base+offset structures"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:103
msgid "isOperandImmEqual() - Check for a particular constant"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:104
msgid ""
"isObviouslySafeToFold() - Check for reasons an instruction can't be sunk and "
"folded into another."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:106
msgid "There are some important points for the C++ implementation:"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:108
msgid "Don't modify MIR in the predicate"
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:109
msgid ""
"Renderer lambdas should capture by value to avoid use-after-free. They will "
"be used after the predicate returns."
msgstr ""

#: ../../../GlobalISel/InstructionSelect.rst:110
msgid ""
"Only create instructions in a renderer lambda. GlobalISel won't clean up "
"things you create but don't use."
msgstr ""
