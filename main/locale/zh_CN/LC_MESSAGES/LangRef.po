# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../LangRef.rst:3
msgid "LLVM Language Reference Manual"
msgstr ""

#: ../../../LangRef.rst:10
msgid "Abstract"
msgstr ""

#: ../../../LangRef.rst:12
msgid ""
"This document is a reference manual for the LLVM assembly language. LLVM is "
"a Static Single Assignment (SSA) based representation that provides type "
"safety, low-level operations, flexibility, and the capability of "
"representing 'all' high-level languages cleanly. It is the common code "
"representation used throughout all phases of the LLVM compilation strategy."
msgstr ""

#: ../../../LangRef.rst:20
msgid "Introduction"
msgstr ""

#: ../../../LangRef.rst:22
msgid ""
"The LLVM code representation is designed to be used in three different "
"forms: as an in-memory compiler IR, as an on-disk bitcode representation "
"(suitable for fast loading by a Just-In-Time compiler), and as a human "
"readable assembly language representation. This allows LLVM to provide a "
"powerful intermediate representation for efficient compiler transformations "
"and analysis, while providing a natural means to debug and visualize the "
"transformations. The three different forms of LLVM are all equivalent. This "
"document describes the human-readable representation and notation."
msgstr ""

#: ../../../LangRef.rst:32
msgid ""
"The LLVM representation aims to be light-weight and low-level while being "
"expressive, typed, and extensible at the same time. It aims to be a "
"\"universal IR\" of sorts, by being at a low enough level that high-level "
"ideas may be cleanly mapped to it (similar to how microprocessors are "
"\"universal IR's\", allowing many source languages to be mapped to them). By "
"providing type information, LLVM can be used as the target of optimizations: "
"for example, through pointer analysis, it can be proven that a C automatic "
"variable is never accessed outside of the current function, allowing it to "
"be promoted to a simple SSA value instead of a memory location."
msgstr ""

#: ../../../LangRef.rst:46
msgid "Well-Formedness"
msgstr ""

#: ../../../LangRef.rst:48
msgid ""
"It is important to note that this document describes 'well formed' LLVM "
"assembly language. There is a difference between what the parser accepts and "
"what is considered 'well formed'. For example, the following instruction is "
"syntactically okay, but not well formed:"
msgstr ""

#: ../../../LangRef.rst:57
msgid ""
"because the definition of ``%x`` does not dominate all of its uses. The LLVM "
"infrastructure provides a verification pass that may be used to verify that "
"an LLVM module is well formed. This pass is automatically run by the parser "
"after parsing input assembly and by the optimizer before it outputs bitcode. "
"The violations pointed out by the verifier pass indicate bugs in "
"transformation passes or input to the parser."
msgstr ""

#: ../../../LangRef.rst:0 ../../../LangRef.rst:65 ../../../LangRef.rst:18704
#: ../../../LangRef.rst:18754 ../../../LangRef.rst:18803
#: ../../../LangRef.rst:18853 ../../../LangRef.rst:18900
#: ../../../LangRef.rst:18953 ../../../LangRef.rst:19056
#: ../../../LangRef.rst:19116 ../../../LangRef.rst:19175
#: ../../../LangRef.rst:19245 ../../../LangRef.rst:19312
#: ../../../LangRef.rst:19372 ../../../LangRef.rst:19432
#: ../../../LangRef.rst:19499
msgid "Syntax"
msgstr ""

#: ../../../LangRef.rst:70
msgid "Identifiers"
msgstr ""

#: ../../../LangRef.rst:72
msgid ""
"LLVM identifiers come in two basic types: global and local. Global "
"identifiers (functions, global variables) begin with the ``'@'`` character. "
"Local identifiers (register names, types) begin with the ``'%'`` character. "
"Additionally, there are three different formats for identifiers, for "
"different purposes:"
msgstr ""

#: ../../../LangRef.rst:78
msgid ""
"Named values are represented as a string of characters with their prefix. "
"For example, ``%foo``, ``@DivisionByZero``, ``%a.really.long.identifier``. "
"The actual regular expression used is '``[%@][-a-zA-Z$._][-a-zA-Z$."
"_0-9]*``'. Identifiers that require other characters in their names can be "
"surrounded with quotes. Special characters may be escaped using ``\"\\xx\"`` "
"where ``xx`` is the ASCII code for the character in hexadecimal. In this "
"way, any character can be used in a name value, even quotes themselves. The "
"``\"\\01\"`` prefix can be used on global values to suppress mangling."
msgstr ""

#: ../../../LangRef.rst:87
msgid ""
"Unnamed values are represented as an unsigned numeric value with their "
"prefix. For example, ``%12``, ``@2``, ``%44``."
msgstr ""

#: ../../../LangRef.rst:89
msgid "Constants, which are described in the section Constants_ below."
msgstr ""

#: ../../../LangRef.rst:91
msgid ""
"LLVM requires that values start with a prefix for two reasons: Compilers "
"don't need to worry about name clashes with reserved words, and the set of "
"reserved words may be expanded in the future without penalty. Additionally, "
"unnamed identifiers allow a compiler to quickly come up with a temporary "
"variable without having to avoid symbol table conflicts."
msgstr ""

#: ../../../LangRef.rst:98
msgid ""
"Reserved words in LLVM are very similar to reserved words in other "
"languages. There are keywords for different opcodes ('``add``', "
"'``bitcast``', '``ret``', etc...), for primitive type names ('``void``', "
"'``i32``', etc...), and others. These reserved words cannot conflict with "
"variable names, because none of them start with a prefix character (``'%'`` "
"or ``'@'``)."
msgstr ""

#: ../../../LangRef.rst:105
msgid ""
"Here is an example of LLVM code to multiply the integer variable '``%X``' by "
"8:"
msgstr ""

#: ../../../LangRef.rst:108
msgid "The easy way:"
msgstr ""

#: ../../../LangRef.rst:114
msgid "After strength reduction:"
msgstr ""

#: ../../../LangRef.rst:120
msgid "And the hard way:"
msgstr ""

#: ../../../LangRef.rst:128
msgid ""
"This last way of multiplying ``%X`` by 8 illustrates several important "
"lexical features of LLVM:"
msgstr ""

#: ../../../LangRef.rst:131
msgid ""
"Comments are delimited with a '``;``' and go until the end of line. "
"Alternatively, comments can start with ``/*`` and terminate with ``*/``."
msgstr ""

#: ../../../LangRef.rst:133
msgid ""
"Unnamed temporaries are created when the result of a computation is not "
"assigned to a named value."
msgstr ""

#: ../../../LangRef.rst:135
msgid ""
"By default, unnamed temporaries are numbered sequentially (using a per-"
"function incrementing counter, starting with 0). However, when explicitly "
"specifying temporary numbers, it is allowed to skip over numbers."
msgstr ""

#: ../../../LangRef.rst:139
msgid ""
"Note that basic blocks and unnamed function parameters are included in this "
"numbering. For example, if the entry basic block is not given a label name "
"and all function parameters are named, then it will get number 0."
msgstr ""

#: ../../../LangRef.rst:143
msgid ""
"It also shows a convention that we follow in this document. When "
"demonstrating instructions, we will follow an instruction with a comment "
"that defines the type and name of value produced."
msgstr ""

#: ../../../LangRef.rst:150
msgid "String constants"
msgstr ""

#: ../../../LangRef.rst:152
msgid ""
"Strings in LLVM programs are delimited by ``\"`` characters. Within a "
"string, all bytes are treated literally with the exception of ``\\`` "
"characters, which start escapes, and the first ``\"`` character, which ends "
"the string."
msgstr ""

#: ../../../LangRef.rst:157
msgid "There are two kinds of escapes."
msgstr ""

#: ../../../LangRef.rst:159
msgid "``\\\\`` represents a single ``\\`` character."
msgstr ""

#: ../../../LangRef.rst:161
msgid ""
"``\\`` followed by two hexadecimal characters (0-9, a-f, or A-F) represents "
"the byte with the given value (e.g. ``\\00`` represents a null byte)."
msgstr ""

#: ../../../LangRef.rst:165
msgid ""
"To represent a ``\"`` character, use ``\\22``. (``\\\"`` will end the string "
"with a trailing ``\\``.)"
msgstr ""

#: ../../../LangRef.rst:168
msgid ""
"Newlines do not terminate string constants; strings can span multiple lines."
msgstr ""

#: ../../../LangRef.rst:171
msgid ""
"The interpretation of string constants (e.g. their character encoding) "
"depends on context."
msgstr ""

#: ../../../LangRef.rst:176
msgid "High Level Structure"
msgstr ""

#: ../../../LangRef.rst:179
msgid "Module Structure"
msgstr ""

#: ../../../LangRef.rst:181
msgid ""
"LLVM programs are composed of ``Module``'s, each of which is a translation "
"unit of the input programs. Each module consists of functions, global "
"variables, and symbol table entries. Modules may be combined together with "
"the LLVM linker, which merges function (and global variable) definitions, "
"resolves forward declarations, and merges symbol table entries. Here is an "
"example of the \"hello world\" module:"
msgstr ""

#: ../../../LangRef.rst:207
msgid ""
"This example is made up of a :ref:`global variable <globalvars>` named \"``."
"str``\", an external declaration of the \"``puts``\" function, a :ref:"
"`function definition <functionstructure>` for \"``main``\" and :ref:`named "
"metadata <namedmetadatastructure>` \"``foo``\"."
msgstr ""

#: ../../../LangRef.rst:212
msgid ""
"In general, a module is made up of a list of global values (where both "
"functions and global variables are global values). Global values are "
"represented by a pointer to a memory location (in this case, a pointer to an "
"array of char, and a pointer to a function), and have one of the following :"
"ref:`linkage types <linkage>`."
msgstr ""

#: ../../../LangRef.rst:221
msgid "Linkage Types"
msgstr ""

#: ../../../LangRef.rst:223
msgid ""
"All Global Variables and Functions have one of the following types of "
"linkage:"
msgstr ""

#: ../../../LangRef.rst:231
msgid "``private``"
msgstr ""

#: ../../../LangRef.rst:227
msgid ""
"Global values with \"``private``\" linkage are only directly accessible by "
"objects in the current module. In particular, linking code into a module "
"with a private global value may cause the private to be renamed as necessary "
"to avoid collisions. Because the symbol is private to the module, all "
"references can be updated. This doesn't show up in any symbol table in the "
"object file."
msgstr ""

#: ../../../LangRef.rst:235
msgid "``internal``"
msgstr ""

#: ../../../LangRef.rst:234
msgid ""
"Similar to private, but the value shows as a local symbol (``STB_LOCAL`` in "
"the case of ELF) in the object file. This corresponds to the notion of the "
"'``static``' keyword in C."
msgstr ""

#: ../../../LangRef.rst:245
msgid "``available_externally``"
msgstr ""

#: ../../../LangRef.rst:238
msgid ""
"Globals with \"``available_externally``\" linkage are never emitted into the "
"object file corresponding to the LLVM module. From the linker's perspective, "
"an ``available_externally`` global is equivalent to an external declaration. "
"They exist to allow inlining and other optimizations to take place given "
"knowledge of the definition of the global, which is known to be somewhere "
"outside the module. Globals with ``available_externally`` linkage are "
"allowed to be discarded at will, and allow inlining and other optimizations. "
"This linkage type is only allowed on definitions, not declarations."
msgstr ""

#: ../../../LangRef.rst:258
msgid "``linkonce``"
msgstr ""

#: ../../../LangRef.rst:248
msgid ""
"Globals with \"``linkonce``\" linkage are merged with other globals of the "
"same name when linkage occurs. This can be used to implement some forms of "
"inline functions, templates, or other code which must be generated in each "
"translation unit that uses it, but where the body may be overridden with a "
"more definitive definition later. Unreferenced ``linkonce`` globals are "
"allowed to be discarded. Note that ``linkonce`` linkage does not actually "
"allow the optimizer to inline the body of this function into callers because "
"it doesn't know if this definition of the function is the definitive "
"definition within the program or whether it will be overridden by a stronger "
"definition. To enable inlining and other optimizations, use "
"\"``linkonce_odr``\" linkage."
msgstr ""

#: ../../../LangRef.rst:263
msgid "``weak``"
msgstr ""

#: ../../../LangRef.rst:261
msgid ""
"\"``weak``\" linkage has the same merging semantics as ``linkonce`` linkage, "
"except that unreferenced globals with ``weak`` linkage may not be discarded. "
"This is used for globals that are declared \"weak\" in C source code."
msgstr ""

#: ../../../LangRef.rst:273
msgid "``common``"
msgstr ""

#: ../../../LangRef.rst:266
msgid ""
"\"``common``\" linkage is most similar to \"``weak``\" linkage, but they are "
"used for tentative definitions in C, such as \"``int X;``\" at global scope. "
"Symbols with \"``common``\" linkage are merged in the same way as ``weak "
"symbols``, and they may not be deleted if unreferenced. ``common`` symbols "
"may not have an explicit section, must have a zero initializer, and may not "
"be marked ':ref:`constant <globalvars>`'. Functions and aliases may not have "
"common linkage."
msgstr ""

#: ../../../LangRef.rst:287
msgid "``appending``"
msgstr ""

#: ../../../LangRef.rst:278
msgid ""
"\"``appending``\" linkage may only be applied to global variables of pointer "
"to array type. When two global variables with appending linkage are linked "
"together, the two global arrays are appended together. This is the LLVM, "
"typesafe, equivalent of having the system linker append together "
"\"sections\" with identical names when ``.o`` files are linked."
msgstr ""

#: ../../../LangRef.rst:285
msgid ""
"Unfortunately this doesn't correspond to any feature in ``.o`` files, so it "
"can only be used for variables like ``llvm.global_ctors`` which llvm "
"interprets specially."
msgstr ""

#: ../../../LangRef.rst:291
msgid "``extern_weak``"
msgstr ""

#: ../../../LangRef.rst:290
msgid ""
"The semantics of this linkage follow the ELF object file model: the symbol "
"is weak until linked, if not linked, the symbol becomes null instead of "
"being an undefined reference."
msgstr ""

#: ../../../LangRef.rst:303
msgid "``linkonce_odr``, ``weak_odr``"
msgstr ""

#: ../../../LangRef.rst:294
msgid ""
"The ``odr`` suffix indicates that all globals defined with the given name "
"are equivalent, along the lines of the C++ \"one definition "
"rule\" (\"ODR\"). Informally, this means we can inline functions and fold "
"loads of constants."
msgstr ""

#: ../../../LangRef.rst:298
msgid ""
"Formally, use the following definition: when an ``odr`` function is called, "
"one of the definitions is non-deterministically chosen to run. For ``odr`` "
"variables, if any byte in the value is not equal in all initializers, that "
"byte is a :ref:`poison value <poisonvalues>`. For aliases and ifuncs, apply "
"the rule for the underlying function or variable."
msgstr ""

#: ../../../LangRef.rst:304
msgid ""
"These linkage types are otherwise the same as their non-``odr`` versions."
msgstr ""

#: ../../../LangRef.rst:308
msgid "``external``"
msgstr ""

#: ../../../LangRef.rst:306
msgid ""
"If none of the above identifiers are used, the global is externally visible, "
"meaning that it participates in linkage and can be used to resolve external "
"symbol references."
msgstr ""

#: ../../../LangRef.rst:310
msgid ""
"It is illegal for a global variable or function *declaration* to have any "
"linkage type other than ``external`` or ``extern_weak``."
msgstr ""

#: ../../../LangRef.rst:316
msgid "Calling Conventions"
msgstr ""

#: ../../../LangRef.rst:318
msgid ""
"LLVM :ref:`functions <functionstructure>`, :ref:`calls <i_call>` and :ref:"
"`invokes <i_invoke>` can all have an optional calling convention specified "
"for the call. The calling convention of any pair of dynamic caller/callee "
"must match, or the behavior of the program is undefined. The following "
"calling conventions are supported by LLVM, and more may be added in the "
"future:"
msgstr ""

#: ../../../LangRef.rst:329
msgid "\"``ccc``\" - The C calling convention"
msgstr ""

#: ../../../LangRef.rst:326
msgid ""
"This calling convention (the default if no other calling convention is "
"specified) matches the target C calling conventions. This calling convention "
"supports varargs function calls and tolerates some mismatch in the declared "
"prototype and implemented declaration of the function (as does normal C)."
msgstr ""

#: ../../../LangRef.rst:339
msgid "\"``fastcc``\" - The fast calling convention"
msgstr ""

#: ../../../LangRef.rst:332
msgid ""
"This calling convention attempts to make calls as fast as possible (e.g. by "
"passing things in registers). This calling convention allows the target to "
"use whatever tricks it wants to produce fast code for the target, without "
"having to conform to an externally specified ABI (Application Binary "
"Interface). `Tail calls can only be optimized when this, the tailcc, the GHC "
"or the HiPE convention is used. <CodeGenerator.html#tail-call-"
"optimization>`_ This calling convention does not support varargs and "
"requires the prototype of all callees to exactly match the prototype of the "
"function definition."
msgstr ""

#: ../../../LangRef.rst:348
msgid "\"``coldcc``\" - The cold calling convention"
msgstr ""

#: ../../../LangRef.rst:342
msgid ""
"This calling convention attempts to make code in the caller as efficient as "
"possible under the assumption that the call is not commonly executed. As "
"such, these calls often preserve all registers so that the call does not "
"break any live ranges in the caller side. This calling convention does not "
"support varargs and requires the prototype of all callees to exactly match "
"the prototype of the function definition. Furthermore the inliner doesn't "
"consider such function calls for inlining."
msgstr ""

#: ../../../LangRef.rst:373
msgid "\"``ghccc``\" - GHC convention"
msgstr ""

#: ../../../LangRef.rst:351
msgid ""
"This calling convention has been implemented specifically for use by the "
"`Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_. It passes "
"everything in registers, going to extremes to achieve this by disabling "
"callee save registers. This calling convention should not be used lightly "
"but only for specific situations such as an alternative to the *register "
"pinning* performance technique often used when implementing functional "
"programming languages. At the moment only X86, AArch64, and RISCV support "
"this convention. The following limitations exist:"
msgstr ""

#: ../../../LangRef.rst:361
msgid ""
"On *X86-32* only up to 4 bit type parameters are supported. No floating-"
"point types are supported."
msgstr ""

#: ../../../LangRef.rst:363
msgid ""
"On *X86-64* only up to 10 bit type parameters and 6 floating-point "
"parameters are supported."
msgstr ""

#: ../../../LangRef.rst:365
msgid ""
"On *AArch64* only up to 4 32-bit floating-point parameters, 4 64-bit "
"floating-point parameters, and 10 bit type parameters are supported."
msgstr ""

#: ../../../LangRef.rst:368
msgid ""
"*RISCV64* only supports up to 11 bit type parameters, 4 32-bit floating-"
"point parameters, and 4 64-bit floating-point parameters."
msgstr ""

#: ../../../LangRef.rst:372
msgid ""
"This calling convention supports `tail call optimization <CodeGenerator."
"html#tail-call-optimization>`_ but requires both the caller and callee to "
"use it."
msgstr ""

#: ../../../LangRef.rst:388
msgid "\"``cc 11``\" - The HiPE calling convention"
msgstr ""

#: ../../../LangRef.rst:376
msgid ""
"This calling convention has been implemented specifically for use by the "
"`High-Performance Erlang (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ "
"compiler, *the* native code compiler of the `Ericsson's Open Source Erlang/"
"OTP system <http://www.erlang.org/download.shtml>`_. It uses more registers "
"for argument passing than the ordinary C calling convention and defines no "
"callee-saved registers. The calling convention properly supports `tail call "
"optimization <CodeGenerator.html#tail-call-optimization>`_ but requires that "
"both the caller and the callee use it. It uses a *register pinning* "
"mechanism, similar to GHC's convention, for keeping frequently accessed "
"runtime components pinned to specific hardware registers. At the moment only "
"X86 supports this convention (both 32 and 64 bit)."
msgstr ""

#: ../../../LangRef.rst:395
msgid "\"``anyregcc``\" - Dynamic calling convention for code patching"
msgstr ""

#: ../../../LangRef.rst:391
msgid ""
"This is a special convention that supports patching an arbitrary code "
"sequence in place of a call site. This convention forces the call arguments "
"into registers but allows them to be dynamically allocated. This can "
"currently only be used with calls to ``llvm.experimental.patchpoint`` "
"because only this intrinsic records the location of its arguments in a side "
"table. See :doc:`StackMaps`."
msgstr ""

#: ../../../LangRef.rst:437
msgid "\"``preserve_mostcc``\" - The `PreserveMost` calling convention"
msgstr ""

#: ../../../LangRef.rst:398
msgid ""
"This calling convention attempts to make the code in the caller as "
"unintrusive as possible. This convention behaves identically to the `C` "
"calling convention on how arguments and return values are passed, but it "
"uses a different set of caller/callee-saved registers. This alleviates the "
"burden of saving and recovering a large register set before and after the "
"call in the caller. If the arguments are passed in callee-saved registers, "
"then they will be preserved by the callee across the call. This doesn't "
"apply for values returned in callee-saved registers."
msgstr ""

#: ../../../LangRef.rst:407
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for R11 "
"and return registers, if any. R11 can be used as a scratch register. The "
"treatment of floating-point registers (XMMs/YMMs) matches the OS's C calling "
"convention: on most platforms, they are not preserved and need to be saved "
"by the caller, but on Windows, xmm6-xmm15 are preserved."
msgstr ""

#: ../../../LangRef.rst:413
msgid ""
"On AArch64 the callee preserves all general purpose registers, except X0-X8 "
"and X16-X18. Not allowed with ``nest``."
msgstr ""

#: ../../../LangRef.rst:416
msgid "On RISC-V the callee preserves x5-x31 except x6, x7 and x28 registers."
msgstr ""

#: ../../../LangRef.rst:418
msgid ""
"On LoongArch the callee preserves r4-r31 except r12-r15 and r20-r21 "
"registers."
msgstr ""

#: ../../../LangRef.rst:420
msgid ""
"The idea behind this convention is to support calls to runtime functions "
"that have a hot path and a cold path. The hot path is usually a small piece "
"of code that doesn't use many registers. The cold path might need to call "
"out to another function and therefore only needs to preserve the caller-"
"saved registers, which haven't already been saved by the caller. The "
"`PreserveMost` calling convention is very similar to the `cold` calling "
"convention in terms of caller/callee-saved registers, but they are used for "
"different types of function calls. `coldcc` is for function calls that are "
"rarely executed, whereas `preserve_mostcc` function calls are intended to be "
"on the hot path and definitely executed a lot. Furthermore `preserve_mostcc` "
"doesn't prevent the inliner from inlining the function call."
msgstr ""

#: ../../../LangRef.rst:432
msgid ""
"This calling convention will be used by a future version of the Objective-C "
"runtime and should therefore still be considered experimental at this time. "
"Although this convention was created to optimize certain runtime calls to "
"the Objective-C runtime, it is not limited to this runtime and might be used "
"by other runtimes in the future too. The current implementation only "
"supports X86-64, but the intention is to support more architectures in the "
"future."
msgstr ""

#: ../../../LangRef.rst:462
msgid "\"``preserve_allcc``\" - The `PreserveAll` calling convention"
msgstr ""

#: ../../../LangRef.rst:440
msgid ""
"This calling convention attempts to make the code in the caller even less "
"intrusive than the `PreserveMost` calling convention. This calling "
"convention also behaves identical to the `C` calling convention on how "
"arguments and return values are passed, but it uses a different set of "
"caller/callee-saved registers. This removes the burden of saving and "
"recovering a large register set before and after the call in the caller. If "
"the arguments are passed in callee-saved registers, then they will be "
"preserved by the callee across the call. This doesn't apply for values "
"returned in callee-saved registers."
msgstr ""

#: ../../../LangRef.rst:450
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for "
"R11. R11 can be used as a scratch register. Furthermore it also preserves "
"all floating-point registers (XMMs/YMMs)."
msgstr ""

#: ../../../LangRef.rst:454
msgid ""
"On AArch64 the callee preserves all general purpose registers, except X0-X8 "
"and X16-X18. Furthermore it also preserves lower 128 bits of V8-V31 SIMD "
"floating point registers. Not allowed with ``nest``."
msgstr ""

#: ../../../LangRef.rst:458
msgid ""
"The idea behind this convention is to support calls to runtime functions "
"that don't need to call out to any other functions."
msgstr ""

#: ../../../LangRef.rst:461
msgid ""
"This calling convention, like the `PreserveMost` calling convention, will be "
"used by a future version of the Objective-C runtime and should be considered "
"experimental at this time."
msgstr ""

#: ../../../LangRef.rst:469
msgid "\"``preserve_nonecc``\" - The `PreserveNone` calling convention"
msgstr ""

#: ../../../LangRef.rst:465
msgid ""
"This calling convention doesn't preserve any general registers. So all "
"general registers are caller saved registers. It also uses all general "
"registers to pass arguments. This attribute doesn't impact non-general "
"purpose registers (e.g. floating point registers, on X86 XMMs/YMMs). Non-"
"general purpose registers still follow the standard C calling convention. "
"Currently it is for x86_64 and AArch64 only."
msgstr ""

#: ../../../LangRef.rst:489
msgid ""
"\"``cxx_fast_tlscc``\" - The `CXX_FAST_TLS` calling convention for access "
"functions"
msgstr ""

#: ../../../LangRef.rst:472
msgid ""
"Clang generates an access function to access C++-style Thread Local Storage "
"(TLS). The access function generally has an entry block, an exit block and "
"an initialization block that is run at the first time. The entry and exit "
"blocks can access a few TLS IR variables, each access will be lowered to a "
"platform-specific sequence."
msgstr ""

#: ../../../LangRef.rst:478
msgid ""
"This calling convention aims to minimize overhead in the caller by "
"preserving as many registers as possible (all the registers that are "
"preserved on the fast path, composed of the entry and exit blocks)."
msgstr ""

#: ../../../LangRef.rst:482
msgid ""
"This calling convention behaves identical to the `C` calling convention on "
"how arguments and return values are passed, but it uses a different set of "
"caller/callee-saved registers."
msgstr ""

#: ../../../LangRef.rst:486
msgid ""
"Given that each platform has its own lowering sequence, hence its own set of "
"preserved registers, we can't use the existing `PreserveMost`."
msgstr ""

#: ../../../LangRef.rst:489
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for RDI "
"and RAX."
msgstr ""

#: ../../../LangRef.rst:497
msgid "\"``tailcc``\" - Tail callable calling convention"
msgstr ""

#: ../../../LangRef.rst:492
msgid ""
"This calling convention ensures that calls in tail position will always be "
"tail call optimized. This calling convention is equivalent to fastcc, except "
"for an additional guarantee that tail calls will be produced whenever "
"possible. `Tail calls can only be optimized when this, the fastcc, the GHC "
"or the HiPE convention is used. <CodeGenerator.html#tail-call-"
"optimization>`_ This calling convention does not support varargs and "
"requires the prototype of all callees to exactly match the prototype of the "
"function definition."
msgstr ""

#: ../../../LangRef.rst:501
msgid "\"``swiftcc``\" - This calling convention is used for Swift language."
msgstr ""

#: ../../../LangRef.rst:500
msgid ""
"On X86-64 RCX and R8 are available for additional integer returns, and XMM2 "
"and XMM3 are available for additional FP/vector returns."
msgstr ""

#: ../../../LangRef.rst:502
msgid "On iOS platforms, we use AAPCS-VFP calling convention."
msgstr ""

#: ../../../LangRef.rst:505
msgid "\"``swifttailcc``\""
msgstr ""

#: ../../../LangRef.rst:504
msgid ""
"This calling convention is like ``swiftcc`` in most respects, but also the "
"callee pops the argument area of the stack so that mandatory tail calls are "
"possible as in ``tailcc``."
msgstr ""

#: ../../../LangRef.rst:516
msgid "\"``cfguard_checkcc``\" - Windows Control Flow Guard (Check mechanism)"
msgstr ""

#: ../../../LangRef.rst:508
msgid ""
"This calling convention is used for the Control Flow Guard check function, "
"calls to which can be inserted before indirect calls to check that the call "
"target is a valid function address. The check function has no return value, "
"but it will trigger an OS-level error if the address is not a valid target. "
"The set of registers preserved by the check function, and the register "
"containing the target address are architecture-specific."
msgstr ""

#: ../../../LangRef.rst:515
msgid "On X86 the target address is passed in ECX."
msgstr ""

#: ../../../LangRef.rst:516
msgid "On ARM the target address is passed in R0."
msgstr ""

#: ../../../LangRef.rst:517
msgid "On AArch64 the target address is passed in X15."
msgstr ""

#: ../../../LangRef.rst:521
msgid "\"``cc <n>``\" - Numbered convention"
msgstr ""

#: ../../../LangRef.rst:519
msgid ""
"Any calling convention may be specified by number, allowing target-specific "
"calling conventions to be used. Target-specific calling conventions start at "
"64."
msgstr ""

#: ../../../LangRef.rst:523
msgid ""
"More calling conventions can be added/defined on an as-needed basis, to "
"support Pascal conventions or any other well-known target-independent "
"convention."
msgstr ""

#: ../../../LangRef.rst:530
msgid "Visibility Styles"
msgstr ""

#: ../../../LangRef.rst:532
msgid ""
"All Global Variables and Functions have one of the following visibility "
"styles:"
msgstr ""

#: ../../../LangRef.rst:543
msgid "\"``default``\" - Default style"
msgstr ""

#: ../../../LangRef.rst:536
msgid ""
"On targets that use the ELF object file format, default visibility means "
"that the declaration is visible to other modules and, in shared libraries, "
"means that the declared entity may be overridden. On Darwin, default "
"visibility means that the declaration is visible to other modules. On XCOFF, "
"default visibility means no explicit visibility bit will be set and whether "
"the symbol is visible (i.e \"exported\") to other modules depends primarily "
"on export lists provided to the linker. Default visibility corresponds to "
"\"external linkage\" in the language."
msgstr ""

#: ../../../LangRef.rst:549
msgid "\"``hidden``\" - Hidden style"
msgstr ""

#: ../../../LangRef.rst:546
msgid ""
"Two declarations of an object with hidden visibility refer to the same "
"object if they are in the same shared object. Usually, hidden visibility "
"indicates that the symbol will not be placed into the dynamic symbol table, "
"so no other module (executable or shared library) can reference it directly."
msgstr ""

#: ../../../LangRef.rst:555
msgid "\"``protected``\" - Protected style"
msgstr ""

#: ../../../LangRef.rst:552
msgid ""
"On ELF, protected visibility indicates that the symbol will be placed in the "
"dynamic symbol table, but that references within the defining module will "
"bind to the local symbol. That is, the symbol cannot be overridden by "
"another module."
msgstr ""

#: ../../../LangRef.rst:557
msgid ""
"A symbol with ``internal`` or ``private`` linkage must have ``default`` "
"visibility."
msgstr ""

#: ../../../LangRef.rst:563
msgid "DLL Storage Classes"
msgstr ""

#: ../../../LangRef.rst:565
msgid ""
"All Global Variables, Functions and Aliases can have one of the following "
"DLL storage classes:"
msgstr ""

#: ../../../LangRef.rst:571
msgid "``dllimport``"
msgstr ""

#: ../../../LangRef.rst:569
msgid ""
"\"``dllimport``\" causes the compiler to reference a function or variable "
"via a global pointer to a pointer that is set up by the DLL exporting the "
"symbol. On Microsoft Windows targets, the pointer name is formed by "
"combining ``__imp_`` and the function or variable name."
msgstr ""

#: ../../../LangRef.rst:582
msgid "``dllexport``"
msgstr ""

#: ../../../LangRef.rst:574
msgid ""
"On Microsoft Windows targets, \"``dllexport``\" causes the compiler to "
"provide a global pointer to a pointer in a DLL, so that it can be referenced "
"with the ``dllimport`` attribute. The pointer name is formed by combining "
"``__imp_`` and the function or variable name. On XCOFF targets, "
"``dllexport`` indicates that the symbol will be made visible to other "
"modules using \"exported\" visibility and thus placed by the linker in the "
"loader section symbol table. Since this storage class exists for defining a "
"DLL interface, the compiler, assembler and linker know it is externally "
"referenced and must refrain from deleting the symbol."
msgstr ""

#: ../../../LangRef.rst:584
msgid ""
"A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage "
"class."
msgstr ""

#: ../../../LangRef.rst:590
msgid "Thread Local Storage Models"
msgstr ""

#: ../../../LangRef.rst:592
msgid ""
"A variable may be defined as ``thread_local``, which means that it will not "
"be shared by threads (each thread will have a separate copy of the "
"variable). Not all targets support thread-local variables. Optionally, a TLS "
"model may be specified:"
msgstr ""

#: ../../../LangRef.rst:597
msgid "``localdynamic``"
msgstr ""

#: ../../../LangRef.rst:598
msgid "For variables that are only used within the current shared library."
msgstr ""

#: ../../../LangRef.rst:599
msgid "``initialexec``"
msgstr ""

#: ../../../LangRef.rst:600
msgid "For variables in modules that will not be loaded dynamically."
msgstr ""

#: ../../../LangRef.rst:602
msgid "``localexec``"
msgstr ""

#: ../../../LangRef.rst:602
msgid "For variables defined in the executable and only used within it."
msgstr ""

#: ../../../LangRef.rst:604
msgid "If no explicit model is given, the \"general dynamic\" model is used."
msgstr ""

#: ../../../LangRef.rst:606
msgid ""
"The models correspond to the ELF TLS models; see `ELF Handling For Thread-"
"Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for more "
"information on under which circumstances the different models may be used. "
"The target may choose a different TLS model if the specified model is not "
"supported, or if a better choice of model can be made."
msgstr ""

#: ../../../LangRef.rst:612
msgid ""
"A model can also be specified in an alias, but then it only governs how the "
"alias is accessed. It will not have any effect on the aliasee."
msgstr ""

#: ../../../LangRef.rst:615
msgid ""
"For platforms without linker support of ELF TLS model, the ``-femulated-"
"tls`` flag can be used to generate GCC-compatible emulated TLS code."
msgstr ""

#: ../../../LangRef.rst:621
msgid "Runtime Preemption Specifiers"
msgstr ""

#: ../../../LangRef.rst:623
msgid ""
"Global variables, functions and aliases may have an optional runtime "
"preemption specifier. If a preemption specifier isn't given explicitly, then "
"a symbol is assumed to be ``dso_preemptable``."
msgstr ""

#: ../../../LangRef.rst:629
msgid "``dso_preemptable``"
msgstr ""

#: ../../../LangRef.rst:628
msgid ""
"Indicates that the function or variable may be replaced by a symbol from "
"outside the linkage unit at runtime."
msgstr ""

#: ../../../LangRef.rst:634
msgid "``dso_local``"
msgstr ""

#: ../../../LangRef.rst:632
msgid ""
"The compiler may assume that a function or variable marked as ``dso_local`` "
"will resolve to a symbol within the same linkage unit. Direct access will be "
"generated even if the definition is not within this compilation unit."
msgstr ""

#: ../../../LangRef.rst:639
msgid "Structure Types"
msgstr ""

#: ../../../LangRef.rst:641
msgid ""
"LLVM IR allows you to specify both \"identified\" and \"literal\" :ref:"
"`structure types <t_struct>`. Literal types are uniqued structurally, but "
"identified types are never uniqued. An :ref:`opaque structural type "
"<t_opaque>` can also be used to forward declare a type that is not yet "
"available."
msgstr ""

#: ../../../LangRef.rst:646
msgid "An example of an identified structure specification is:"
msgstr ""

#: ../../../LangRef.rst:652
msgid ""
"Prior to the LLVM 3.0 release, identified types were structurally uniqued. "
"Only literal types are uniqued in recent versions of LLVM."
msgstr ""

#: ../../../LangRef.rst:658
msgid "Non-Integral Pointer Type"
msgstr ""

#: ../../../LangRef.rst:660
msgid ""
"Note: non-integral pointer types are a work in progress, and they should be "
"considered experimental at this time."
msgstr ""

#: ../../../LangRef.rst:663
msgid ""
"For most targets, the pointer representation is a direct mapping from the "
"bitwise representation to the address of the underlying memory location. "
"Such pointers are considered \"integral\", and any pointers where the "
"representation is not just an integer address are called \"non-integral\"."
msgstr ""

#: ../../../LangRef.rst:668
msgid ""
"Non-integral pointers have at least one of the following three properties:"
msgstr ""

#: ../../../LangRef.rst:670
msgid "the pointer representation contains non-address bits"
msgstr ""

#: ../../../LangRef.rst:671
msgid ""
"the pointer representation is unstable (may changed at any time in a target-"
"specific way)"
msgstr ""

#: ../../../LangRef.rst:673
msgid "the pointer representation has external state"
msgstr ""

#: ../../../LangRef.rst:675
msgid ""
"These properties (or combinations thereof) can be applied to pointers via "
"the :ref:`datalayout string<langref_datalayout>`."
msgstr ""

#: ../../../LangRef.rst:678
msgid ""
"The exact implications of these properties are target-specific. The "
"following subsections describe the IR semantics and restrictions to "
"optimization passes for each of these properties."
msgstr ""

#: ../../../LangRef.rst:683
msgid "Pointers with non-address bits"
msgstr ""

#: ../../../LangRef.rst:685
msgid ""
"Pointers in this address space have a bitwise representation that not only "
"has address bits, but also some other target-specific metadata. In most "
"cases pointers with non-address bits behave exactly the same as integral "
"pointers, the only difference is that it is not possible to create a pointer "
"just from an address unless all the non-address bits are also recreated "
"correctly in a target-specific way."
msgstr ""

#: ../../../LangRef.rst:692
msgid ""
"An example of pointers with non-address bits are the AMDGPU buffer "
"descriptors which are 160 bits: a 128-bit fat pointer and a 32-bit offset. "
"Similarly, CHERI capabilities contain a 32 or 64 bit address as well as the "
"same number of metadata bits, but unlike the AMDGPU buffer descriptors they "
"have external state in addition to non-address bits."
msgstr ""

#: ../../../LangRef.rst:700
msgid "Unstable pointer representation"
msgstr ""

#: ../../../LangRef.rst:702
msgid ""
"Pointers in this address space have an *unspecified* bitwise representation "
"(i.e. not backed by a fixed integer). The bitwise pattern of such pointers "
"is allowed to change in a target-specific way. For example, this could be a "
"pointer type used with copying garbage collection where the garbage "
"collector could update the pointer at any time in the collection sweep."
msgstr ""

#: ../../../LangRef.rst:708
msgid ""
"``inttoptr`` and ``ptrtoint`` instructions have the same semantics as for "
"integral (i.e., normal) pointers in that they convert integers to and from "
"corresponding pointer types, but there are additional implications to be "
"aware of."
msgstr ""

#: ../../../LangRef.rst:713
msgid ""
"For \"unstable\" pointer representations, the bit-representation of the "
"pointer may not be stable, so two identical casts of the same operand may or "
"may not return the same value.  Said differently, the conversion to or from "
"the \"unstable\" pointer type depends on environmental state in an "
"implementation defined manner."
msgstr ""

#: ../../../LangRef.rst:719
msgid ""
"If the frontend wishes to observe a *particular* value following a cast, the "
"generated IR must fence with the underlying environment in an implementation "
"defined manner. (In practice, this tends to require ``noinline`` routines "
"for such operations.)"
msgstr ""

#: ../../../LangRef.rst:724
msgid ""
"From the perspective of the optimizer, ``inttoptr`` and ``ptrtoint`` for "
"\"unstable\" pointer types are analogous to ones on integral types with one "
"key exception: the optimizer may not, in general, insert new dynamic "
"occurrences of such casts.  If a new cast is inserted, the optimizer would "
"need to either ensure that a) all possible values are valid, or b) "
"appropriate fencing is inserted.  Since the appropriate fencing is "
"implementation defined, the optimizer can't do the latter.  The former is "
"challenging as many commonly expected properties, such as ``ptrtoint(v)-"
"ptrtoint(v) == 0``, don't hold for \"unstable\" pointer types. Similar "
"restrictions apply to intrinsics that might examine the pointer bits, such "
"as :ref:`llvm.ptrmask<int_ptrmask>`."
msgstr ""

#: ../../../LangRef.rst:736
msgid ""
"The alignment information provided by the frontend for an \"unstable\" "
"pointer (typically using attributes or metadata) must be valid for every "
"possible representation of the pointer."
msgstr ""

#: ../../../LangRef.rst:741
msgid "Pointers with external state"
msgstr ""

#: ../../../LangRef.rst:743
msgid ""
"A further special case of non-integral pointers is ones that include "
"external state (such as bounds information or a type tag) with a target-"
"defined size. An example of such a type is a CHERI capability, where there "
"is an additional validity bit that is part of all pointer-typed registers, "
"but is located in memory at an implementation-defined address separate from "
"the pointer itself. Another example would be a fat-pointer scheme where "
"pointers remain plain integers, but the associated bounds are stored in an "
"out-of-band table."
msgstr ""

#: ../../../LangRef.rst:751
msgid ""
"Unless also marked as \"unstable\", the bit-wise representation of pointers "
"with external state is stable and ``ptrtoint(x)`` always yields a "
"deterministic value. This means transformation passes are still permitted to "
"insert new ``ptrtoint`` instructions."
msgstr ""

#: ../../../LangRef.rst:756
msgid "The following restrictions apply to IR level optimization passes:"
msgstr ""

#: ../../../LangRef.rst:758
msgid ""
"The ``inttoptr`` instruction does not recreate the external state and "
"therefore it is target dependent whether it can be used to create a "
"dereferenceable pointer. In general passes should assume that the result of "
"such an inttoptr is not dereferenceable. For example, on CHERI targets an "
"``inttoptr`` will yield a capability with the external state (the validity "
"tag bit) set to zero, which will cause any dereference to trap. The "
"``ptrtoint`` instruction also only returns the \"in-band\" state and omits "
"all external  state."
msgstr ""

#: ../../../LangRef.rst:767
msgid ""
"When a ``store ptr addrspace(N) %p, ptr @dst`` of such a non-integral "
"pointer is performed, the external metadata is also stored to an "
"implementation-defined location. Similarly, a ``%val = load ptr "
"addrspace(N), ptr @dst`` will fetch the external metadata and make it "
"available for all uses of ``%val``. Similarly, the ``llvm.memcpy`` and "
"``llvm.memmove`` intrinsics also transfer the external state. This is "
"essential to allow frontends to efficiently emit copies of structures "
"containing such pointers, since expanding all these copies as individual "
"loads and stores would affect compilation speed and inhibit optimizations."
msgstr ""

#: ../../../LangRef.rst:777
msgid ""
"Notionally, these external bits are part of the pointer, but since "
"``inttoptr`` / ``ptrtoint``` only operate on the \"in-band\" bits of the "
"pointer and the external bits are not explicitly exposed, they are not "
"included in the size specified in the :ref:`datalayout "
"string<langref_datalayout>`."
msgstr ""

#: ../../../LangRef.rst:782
msgid ""
"When a pointer type has external state, all roundtrips via memory must be "
"performed as loads and stores of the correct type since stores of other "
"types may not propagate the external data. Therefore it is not legal to "
"convert an existing load/store (or a ``llvm.memcpy`` / ``llvm.memmove`` "
"intrinsic) of pointer types with external state to a load/store of an "
"integer type with same bitwidth, as that may drop the external state."
msgstr ""

#: ../../../LangRef.rst:794
msgid "Global Variables"
msgstr ""

#: ../../../LangRef.rst:796
msgid ""
"Global variables define regions of memory allocated at compilation time "
"instead of run-time."
msgstr ""

#: ../../../LangRef.rst:799
msgid "Global variable definitions must be initialized with a sized value."
msgstr ""

#: ../../../LangRef.rst:801
msgid ""
"Global variables in other translation units can also be declared, in which "
"case they don't have an initializer."
msgstr ""

#: ../../../LangRef.rst:804
msgid ""
"Global variables can optionally specify a :ref:`linkage type <linkage>`."
msgstr ""

#: ../../../LangRef.rst:806
msgid ""
"Either global variable definitions or declarations may have an explicit "
"section to be placed in and may have an optional explicit alignment "
"specified. If there is a mismatch between the explicit or inferred section "
"information for the variable declaration and its definition the resulting "
"behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:811
msgid ""
"A variable may be defined as a global ``constant``, which indicates that the "
"contents of the variable will **never** be modified (enabling better "
"optimization, allowing the global data to be placed in the read-only section "
"of an executable, etc). Note that variables that need runtime initialization "
"cannot be marked ``constant`` as there is a store to the variable."
msgstr ""

#: ../../../LangRef.rst:818
msgid ""
"LLVM explicitly allows *declarations* of global variables to be marked "
"constant, even if the final definition of the global is not. This capability "
"can be used to enable slightly better optimization of the program, but "
"requires the language definition to guarantee that optimizations based on "
"the 'constantness' are valid for the translation units that do not include "
"the definition."
msgstr ""

#: ../../../LangRef.rst:825
msgid ""
"As SSA values, global variables define pointer values that are in scope for "
"(i.e., they dominate) all basic blocks in the program. Global variables "
"always define a pointer to their \"content\" type because they describe a "
"region of memory, and all :ref:`allocated object<allocatedobjects>` in LLVM "
"are accessed through pointers."
msgstr ""

#: ../../../LangRef.rst:831
msgid ""
"Global variables can be marked with ``unnamed_addr`` which indicates that "
"the address is not significant, only the content. Constants marked like this "
"can be merged with other constants if they have the same initializer. Note "
"that a constant with significant address *can* be merged with a "
"``unnamed_addr`` constant, the result being a constant whose address is "
"significant."
msgstr ""

#: ../../../LangRef.rst:838 ../../../LangRef.rst:1046 ../../../LangRef.rst:1082
msgid ""
"If the ``local_unnamed_addr`` attribute is given, the address is known to "
"not be significant within the module."
msgstr ""

#: ../../../LangRef.rst:841
msgid ""
"A global variable may be declared to reside in a target-specific numbered "
"address space. For targets that support them, address spaces may affect how "
"optimizations are performed and/or what target instructions are used to "
"access the variable. The default address space is zero. The address space "
"qualifier must precede any other attributes."
msgstr ""

#: ../../../LangRef.rst:847
msgid ""
"LLVM allows an explicit section to be specified for globals. If the target "
"supports it, it will emit globals to the section specified. Additionally, "
"the global can be placed in a comdat if the target has the necessary support."
msgstr ""

#: ../../../LangRef.rst:852
msgid ""
"External declarations may have an explicit section specified. Section "
"information is retained in LLVM IR for targets that make use of this "
"information. Attaching section information to an external declaration is an "
"assertion that its definition is located in the specified section. If the "
"definition is located in a different section, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:858
msgid ""
"LLVM allows an explicit code model to be specified for globals. If the "
"target supports it, it will emit globals in the code model specified, "
"overriding the code model used to compile the translation unit. The allowed "
"values are \"tiny\", \"small\", \"kernel\", \"medium\", \"large\". This may "
"be extended in the future to specify global data layout that doesn't cleanly "
"fit into a specific code model."
msgstr ""

#: ../../../LangRef.rst:865
msgid ""
"By default, global initializers are optimized by assuming that global "
"variables defined within the module are not modified from their initial "
"values before the start of the global initializer. This is true even for "
"variables potentially accessible from outside the module, including those "
"with external linkage or appearing in ``@llvm.used`` or dllexported "
"variables. This assumption may be suppressed by marking the variable with "
"``externally_initialized``."
msgstr ""

#: ../../../LangRef.rst:873
msgid ""
"An explicit alignment may be specified for a global, which must be a power "
"of 2. If not present, or if the alignment is set to zero, the alignment of "
"the global is set by the target to whatever it feels convenient. If an "
"explicit alignment is specified, the global is forced to have exactly that "
"alignment. Targets and optimizers are not allowed to over-align the global "
"if the global has an assigned section. In this case, the extra alignment "
"could be observable: for example, code could assume that the globals are "
"densely packed in their section and try to iterate over them as an array, "
"alignment padding would break this iteration. For TLS variables, the module "
"flag ``MaxTLSAlign``, if present, limits the alignment to the given value. "
"Optimizers are not allowed to impose a stronger alignment on these "
"variables. The maximum alignment is ``1 << 32``."
msgstr ""

#: ../../../LangRef.rst:887
msgid ""
"For global variable declarations, as well as definitions that may be "
"replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and "
"``common`` linkage types), the allocation size and alignment of the "
"definition it resolves to must be greater than or equal to that of the "
"declaration or replaceable definition, otherwise the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:893
msgid ""
"Globals can also have a :ref:`DLL storage class <dllstorageclass>`, an "
"optional :ref:`runtime preemption specifier <runtime_preemption_model>`, an "
"optional :ref:`global attributes <glattrs>` and an optional list of "
"attached :ref:`metadata <metadata>`."
msgstr ""

#: ../../../LangRef.rst:898
msgid ""
"Variables and aliases can have a :ref:`Thread Local Storage Model "
"<tls_model>`."
msgstr ""

#: ../../../LangRef.rst:901
msgid ""
"Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because "
"their size is unknown at compile time. They are allowed in structs to "
"facilitate intrinsics returning multiple values. Generally, structs "
"containing scalable vectors are not considered \"sized\" and cannot be used "
"in loads, stores, allocas, or GEPs. The only exception to this rule is for "
"structs that contain scalable vectors of the same type (e.g. ``{<vscale x 2 "
"x i32>, <vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x "
"i32>, <vscale x 2 x i64>}`` doesn't). These kinds of structs (we may call "
"them homogeneous scalable vector structs) are considered sized and can be "
"used in loads, stores, allocas, but not GEPs."
msgstr ""

#: ../../../LangRef.rst:912
msgid ""
"Globals with ``toc-data`` attribute set are stored in TOC of XCOFF. Their "
"alignments are not larger than that of a TOC entry. Optimizations should not "
"increase their alignments to mitigate TOC overflow."
msgstr ""

#: ../../../LangRef.rst:916 ../../../LangRef.rst:979 ../../../LangRef.rst:992
#: ../../../LangRef.rst:1006 ../../../LangRef.rst:1068
#: ../../../LangRef.rst:1121 ../../../LangRef.rst:1143
#: ../../../LangRef.rst:1241 ../../../LangRef.rst:2872
msgid "Syntax::"
msgstr ""

#: ../../../LangRef.rst:930
msgid ""
"For example, the following defines a global in a numbered address space with "
"an initializer, section, and alignment:"
msgstr ""

#: ../../../LangRef.rst:937
msgid "The following example just declares a global variable"
msgstr ""

#: ../../../LangRef.rst:943
msgid ""
"The following example defines a global variable with the ``large`` code "
"model:"
msgstr ""

#: ../../../LangRef.rst:950
msgid ""
"The following example defines a thread-local global with the ``initialexec`` "
"TLS model:"
msgstr ""

#: ../../../LangRef.rst:960
msgid "Functions"
msgstr ""

#: ../../../LangRef.rst:962
msgid ""
"LLVM function definitions consist of the \"``define``\" keyword, an "
"optional :ref:`linkage type <linkage>`, an optional :ref:`runtime preemption "
"specifier <runtime_preemption_model>`,  an optional :ref:`visibility style "
"<visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`, an "
"optional :ref:`calling convention <callingconv>`, an optional "
"``unnamed_addr`` attribute, a return type, an optional :ref:`parameter "
"attribute <paramattrs>` for the return type, a function name, a (possibly "
"empty) argument list (each with optional :ref:`parameter attributes "
"<paramattrs>`), optional :ref:`function attributes <fnattrs>`, an optional "
"address space, an optional section, an optional partition, an optional "
"alignment, an optional :ref:`comdat <langref_comdats>`, an optional :ref:"
"`garbage collector name <gc>`, an optional :ref:`prefix <prefixdata>`, an "
"optional :ref:`prologue <prologuedata>`, an optional :ref:`personality "
"<personalityfn>`, an optional list of attached :ref:`metadata <metadata>`, "
"an opening curly brace, a list of basic blocks, and a closing curly brace."
msgstr ""

#: ../../../LangRef.rst:989
msgid ""
"The argument list is a comma-separated sequence of arguments where each "
"argument is of the following form:"
msgstr ""

#: ../../../LangRef.rst:996
msgid ""
"LLVM function declarations consist of the \"``declare``\" keyword, an "
"optional :ref:`linkage type <linkage>`, an optional :ref:`visibility style "
"<visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`, an "
"optional :ref:`calling convention <callingconv>`, an optional "
"``unnamed_addr`` or ``local_unnamed_addr`` attribute, an optional address "
"space, a return type, an optional :ref:`parameter attribute <paramattrs>` "
"for the return type, a function name, a possibly empty list of arguments, an "
"optional alignment, an optional :ref:`garbage collector name <gc>`, an "
"optional :ref:`prefix <prefixdata>`, and an optional :ref:`prologue "
"<prologuedata>`."
msgstr ""

#: ../../../LangRef.rst:1014
msgid ""
"A function definition contains a list of basic blocks, forming the CFG "
"(Control Flow Graph) for the function. Each basic block may optionally start "
"with a label (giving the basic block a symbol table entry), contains a list "
"of instructions and :ref:`debug records <debugrecords>`, and ends with a :"
"ref:`terminator <terminators>` instruction (such as a branch or function "
"return). If an explicit label name is not provided, a block is assigned an "
"implicit numbered label, using the next value from the same counter as used "
"for unnamed temporaries (:ref:`see above<identifiers>`). For example, if a "
"function entry block does not have an explicit label, it will be assigned "
"label \"%0\", then the first unnamed temporary in that block will be \"%1\", "
"etc. If a numeric label is explicitly specified, it must match the numeric "
"label that would be used implicitly."
msgstr ""

#: ../../../LangRef.rst:1027
msgid ""
"The first basic block in a function is special in two ways: it is "
"immediately executed on entrance to the function, and it is not allowed to "
"have predecessor basic blocks (i.e., there can not be any branches to the "
"entry block of a function). Because the block can have no predecessors, it "
"also cannot have any :ref:`PHI nodes <i_phi>`."
msgstr ""

#: ../../../LangRef.rst:1033
msgid ""
"LLVM allows an explicit section to be specified for functions. If the target "
"supports it, it will emit functions to the section specified. Additionally, "
"the function can be placed in a COMDAT."
msgstr ""

#: ../../../LangRef.rst:1037
msgid ""
"An explicit alignment may be specified for a function. If not present, or if "
"the alignment is set to zero, the alignment of the function is set by the "
"target to whatever it feels convenient. If an explicit alignment is "
"specified, the function is forced to have at least that much alignment. All "
"alignments must be a power of 2."
msgstr ""

#: ../../../LangRef.rst:1043
msgid ""
"If the ``unnamed_addr`` attribute is given, the address is known to not be "
"significant and two identical functions can be merged."
msgstr ""

#: ../../../LangRef.rst:1049
msgid ""
"If an explicit address space is not given, it will default to the program "
"address space from the :ref:`datalayout string<langref_datalayout>`."
msgstr ""

#: ../../../LangRef.rst:1055
msgid "Aliases"
msgstr ""

#: ../../../LangRef.rst:1057
msgid ""
"Aliases, unlike function or variables, don't create any new data. They are "
"just a new symbol and metadata for an existing position."
msgstr ""

#: ../../../LangRef.rst:1060
msgid ""
"Aliases have a name and an aliasee that is either a global value or a "
"constant expression."
msgstr ""

#: ../../../LangRef.rst:1063
msgid ""
"Aliases may have an optional :ref:`linkage type <linkage>`, an optional :ref:"
"`runtime preemption specifier <runtime_preemption_model>`, an optional :ref:"
"`visibility style <visibility>`, an optional :ref:`DLL storage class "
"<dllstorageclass>` and an optional :ref:`tls model <tls_model>`."
msgstr ""

#: ../../../LangRef.rst:1073
msgid ""
"The linkage must be one of ``private``, ``internal``, ``linkonce``, "
"``weak``, ``linkonce_odr``, ``weak_odr``, ``external``, "
"``available_externally``. Note that some system linkers might not correctly "
"handle dropping a weak symbol that is aliased."
msgstr ""

#: ../../../LangRef.rst:1078
msgid ""
"Aliases that are not ``unnamed_addr`` are guaranteed to have the same "
"address as the aliasee expression. ``unnamed_addr`` ones are only guaranteed "
"to point to the same content."
msgstr ""

#: ../../../LangRef.rst:1085
msgid ""
"Since aliases are only a second name, some restrictions apply, of which some "
"can only be checked when producing an object file:"
msgstr ""

#: ../../../LangRef.rst:1088
msgid ""
"The expression defining the aliasee must be computable at assembly time. "
"Since it is just a name, no relocations can be used."
msgstr ""

#: ../../../LangRef.rst:1091
msgid ""
"No alias in the expression can be weak as the possibility of the "
"intermediate alias being overridden cannot be represented in an object file."
msgstr ""

#: ../../../LangRef.rst:1095
msgid ""
"If the alias has the ``available_externally`` linkage, the aliasee must be "
"an ``available_externally`` global value; otherwise the aliasee can be an "
"expression but no global value in the expression can be a declaration, since "
"that would require a relocation, which is not possible."
msgstr ""

#: ../../../LangRef.rst:1100
msgid ""
"If either the alias or the aliasee may be replaced by a symbol outside the "
"module at link time or runtime, any optimization cannot replace the alias "
"with the aliasee, since the behavior may be different. The alias may be used "
"as a name guaranteed to point to the content in the current module."
msgstr ""

#: ../../../LangRef.rst:1108
msgid "IFuncs"
msgstr ""

#: ../../../LangRef.rst:1110
msgid ""
"IFuncs, like aliases, don't create any new data or func. They are just a new "
"symbol that is resolved at runtime by calling a resolver function."
msgstr ""

#: ../../../LangRef.rst:1113
msgid ""
"On ELF platforms, IFuncs are resolved by the dynamic linker at load time. On "
"Mach-O platforms, they are lowered in terms of ``.symbol_resolver`` "
"functions, which lazily resolve the callee the first time they are called."
msgstr ""

#: ../../../LangRef.rst:1117
msgid ""
"IFunc may have an optional :ref:`linkage type <linkage>`, an optional :ref:"
"`visibility style <visibility>`, an option partition, and an optional list "
"of attached :ref:`metadata <metadata>`."
msgstr ""

#: ../../../LangRef.rst:1130
msgid "Comdats"
msgstr ""

#: ../../../LangRef.rst:1132
msgid ""
"Comdat IR provides access to object file COMDAT/section group functionality "
"which represents interrelated sections."
msgstr ""

#: ../../../LangRef.rst:1135
msgid ""
"Comdats have a name which represents the COMDAT key and a selection kind to "
"provide input on how the linker deduplicates comdats with the same key in "
"two different object files. A comdat must be included or omitted as a unit. "
"Discarding the whole comdat is allowed but discarding a subset is not."
msgstr ""

#: ../../../LangRef.rst:1140
msgid ""
"A global object may be a member of at most one comdat. Aliases are placed in "
"the same COMDAT that their aliasee computes to, if any."
msgstr ""

#: ../../../LangRef.rst:1147
msgid ""
"For selection kinds other than ``nodeduplicate``, only one of the duplicate "
"comdats may be retained by the linker and the members of the remaining "
"comdats must be discarded. The following selection kinds are supported:"
msgstr ""

#: ../../../LangRef.rst:1151
msgid "``any``"
msgstr ""

#: ../../../LangRef.rst:1152
msgid "The linker may choose any COMDAT key, the choice is arbitrary."
msgstr ""

#: ../../../LangRef.rst:1154
msgid "``exactmatch``"
msgstr ""

#: ../../../LangRef.rst:1154
msgid ""
"The linker may choose any COMDAT key but the sections must contain the same "
"data."
msgstr ""

#: ../../../LangRef.rst:1156
msgid "``largest``"
msgstr ""

#: ../../../LangRef.rst:1157
msgid "The linker will choose the section containing the largest COMDAT key."
msgstr ""

#: ../../../LangRef.rst:1158
msgid "``nodeduplicate``"
msgstr ""

#: ../../../LangRef.rst:1159
msgid "No deduplication is performed."
msgstr ""

#: ../../../LangRef.rst:1162
msgid "``samesize``"
msgstr ""

#: ../../../LangRef.rst:1161
msgid ""
"The linker may choose any COMDAT key but the sections must contain the same "
"amount of data."
msgstr ""

#: ../../../LangRef.rst:1164
msgid "XCOFF and Mach-O don't support COMDATs."
msgstr ""

#: ../../../LangRef.rst:1165
msgid ""
"COFF supports all selection kinds. Non-``nodeduplicate`` selection kinds "
"need a non-local linkage COMDAT symbol."
msgstr ""

#: ../../../LangRef.rst:1167
msgid "ELF supports ``any`` and ``nodeduplicate``."
msgstr ""

#: ../../../LangRef.rst:1168
msgid "WebAssembly only supports ``any``."
msgstr ""

#: ../../../LangRef.rst:1170
msgid ""
"Here is an example of a COFF COMDAT where a function will only be selected "
"if the COMDAT key's section is the largest:"
msgstr ""

#: ../../../LangRef.rst:1182
msgid ""
"In a COFF object file, this will create a COMDAT section with selection kind "
"``IMAGE_COMDAT_SELECT_LARGEST`` containing the contents of the ``@foo`` "
"symbol and another COMDAT section with selection kind "
"``IMAGE_COMDAT_SELECT_ASSOCIATIVE`` which is associated with the first "
"COMDAT section and contains the contents of the ``@bar`` symbol."
msgstr ""

#: ../../../LangRef.rst:1188
msgid ""
"As a syntactic sugar the ``$name`` can be omitted if the name is the same as "
"the global name:"
msgstr ""

#: ../../../LangRef.rst:1197
msgid ""
"There are some restrictions on the properties of the global object. It, or "
"an alias to it, must have the same name as the COMDAT group when targeting "
"COFF. The contents and size of this object may be used during link-time to "
"determine which COMDAT groups get selected depending on the selection kind. "
"Because the name of the object must match the name of the COMDAT group, the "
"linkage of the global object must not be local; local symbols can get "
"renamed if a collision occurs in the symbol table."
msgstr ""

#: ../../../LangRef.rst:1206
msgid ""
"The combined use of COMDATS and section attributes may yield surprising "
"results. For example:"
msgstr ""

#: ../../../LangRef.rst:1216
msgid ""
"From the object file perspective, this requires the creation of two sections "
"with the same name. This is necessary because both globals belong to "
"different COMDAT groups and COMDATs, at the object file level, are "
"represented by sections."
msgstr ""

#: ../../../LangRef.rst:1221
msgid ""
"Note that certain IR constructs like global variables and functions may "
"create COMDATs in the object file in addition to any which are specified "
"using COMDAT IR. This arises when the code generator is configured to emit "
"globals in individual sections (e.g. when `-data-sections` or `-function-"
"sections` is supplied to `llc`)."
msgstr ""

#: ../../../LangRef.rst:1230
msgid "Named Metadata"
msgstr ""

#: ../../../LangRef.rst:1232
msgid ""
"Named metadata is a collection of metadata. :ref:`Metadata nodes <metadata>` "
"(but not metadata strings) are the only valid operands for a named metadata."
msgstr ""

#: ../../../LangRef.rst:1236
msgid ""
"Named metadata are represented as a string of characters with the metadata "
"prefix. The rules for metadata names are the same as for identifiers, but "
"quoted names are not allowed. ``\"\\xx\"`` type escapes are still valid, "
"which allows any character to be part of a name."
msgstr ""

#: ../../../LangRef.rst:1253
msgid "Parameter Attributes"
msgstr ""

#: ../../../LangRef.rst:1255
msgid ""
"The return type and each parameter of a function type may have a set of "
"*parameter attributes* associated with them. Parameter attributes are used "
"to communicate additional information about the result or parameters of a "
"function. Parameter attributes are considered to be part of the function, "
"not of the function type, so functions with different parameter attributes "
"can have the same function type. Parameter attributes can be placed both on "
"function declarations/definitions, and at call-sites."
msgstr ""

#: ../../../LangRef.rst:1263
msgid ""
"Parameter attributes are either simple keywords or strings that follow the "
"specified type. Multiple parameter attributes, when required, are separated "
"by spaces. For example:"
msgstr ""

#: ../../../LangRef.rst:1279
msgid ""
"Note that any attributes for the function result (``nonnull``, ``signext``) "
"come before the result type."
msgstr ""

#: ../../../LangRef.rst:1282
msgid ""
"Parameter attributes can be broadly separated into two kinds: ABI attributes "
"that affect how values are passed to/from functions, like ``zeroext``, "
"``inreg``, ``byval``, or ``sret``. And optimization attributes, which "
"provide additional optimization guarantees, like ``noalias``, ``nonnull`` "
"and ``dereferenceable``."
msgstr ""

#: ../../../LangRef.rst:1288
msgid ""
"ABI attributes must be specified *both* at the function declaration/"
"definition and call-site, otherwise the behavior may be undefined. ABI "
"attributes cannot be safely dropped. Optimization attributes do not have to "
"match between call-site and function: The intersection of their implied "
"semantics applies. Optimization attributes can also be freely dropped."
msgstr ""

#: ../../../LangRef.rst:1294
msgid ""
"If an integer argument to a function is not marked signext/zeroext/noext, "
"the kind of extension used is target-specific. Some targets depend for "
"correctness on the kind of extension to be explicitly specified."
msgstr ""

#: ../../../LangRef.rst:1298
msgid "Currently, only the following parameter attributes are defined:"
msgstr ""

#: ../../../LangRef.rst:1302
msgid "``zeroext``"
msgstr ""

#: ../../../LangRef.rst:1301
msgid ""
"This indicates to the code generator that the parameter or return value "
"should be zero-extended to the extent required by the target's ABI by the "
"caller (for a parameter) or the callee (for a return value)."
msgstr ""

#: ../../../LangRef.rst:1307
msgid "``signext``"
msgstr ""

#: ../../../LangRef.rst:1305
msgid ""
"This indicates to the code generator that the parameter or return value "
"should be sign-extended to the extent required by the target's ABI (which is "
"usually 32-bits) by the caller (for a parameter) or the callee (for a return "
"value)."
msgstr ""

#: ../../../LangRef.rst:1313
msgid "``noext``"
msgstr ""

#: ../../../LangRef.rst:1310
msgid ""
"This indicates to the code generator that the parameter or return value has "
"the high bits undefined, as for a struct in a register, and therefore does "
"not need to be sign or zero extended. This is the same as default behavior "
"and is only actually used (by some targets) to validate that one of the "
"attributes is always present."
msgstr ""

#: ../../../LangRef.rst:1320
msgid "``inreg``"
msgstr ""

#: ../../../LangRef.rst:1316
msgid ""
"This indicates that this parameter or return value should be treated in a "
"special target-dependent fashion while emitting code for a function call or "
"return (usually, by putting it in a register as opposed to memory, though "
"some targets use it to distinguish between two different kinds of "
"registers). Use of this attribute is target-specific."
msgstr ""

#: ../../../LangRef.rst:1340
msgid "``byval(<ty>)``"
msgstr ""

#: ../../../LangRef.rst:1323
msgid ""
"This indicates that the pointer parameter should really be passed by value "
"to the function. The attribute implies that a hidden copy of the pointee is "
"made between the caller and the callee, so the callee is unable to modify "
"the value in the caller. This attribute is only valid on LLVM pointer "
"arguments. It is generally used to pass structs and arrays by value, but is "
"also valid on pointers to scalars. The copy is considered to belong to the "
"caller not the callee (for example, ``readonly`` functions should not write "
"to ``byval`` parameters). This is not a valid attribute for return values."
msgstr ""

#: ../../../LangRef.rst:1334
msgid "The byval type argument indicates the in-memory value type."
msgstr ""

#: ../../../LangRef.rst:1336
msgid ""
"The byval attribute also supports specifying an alignment with the align "
"attribute. It indicates the alignment of the stack slot to form and the "
"known alignment of the pointer specified to the call site. If the alignment "
"is not specified, then the code generator makes a target-specific assumption."
msgstr ""

#: ../../../LangRef.rst:1344
msgid "``byref(<ty>)``"
msgstr ""

#: ../../../LangRef.rst:1346
msgid ""
"The ``byref`` argument attribute allows specifying the pointee memory type "
"of an argument. This is similar to ``byval``, but does not imply a copy is "
"made anywhere, or that the argument is passed on the stack. This implies the "
"pointer is dereferenceable up to the storage size of the type."
msgstr ""

#: ../../../LangRef.rst:1352
msgid ""
"It is not generally permissible to introduce a write to a ``byref`` pointer. "
"The pointer may have any address space and may be read only."
msgstr ""

#: ../../../LangRef.rst:1356
msgid "This is not a valid attribute for return values."
msgstr ""

#: ../../../LangRef.rst:1358
msgid ""
"The alignment for an ``byref`` parameter can be explicitly specified by "
"combining it with the ``align`` attribute, similar to ``byval``. If the "
"alignment is not specified, then the code generator makes a target-specific "
"assumption."
msgstr ""

#: ../../../LangRef.rst:1363
msgid ""
"This is intended for representing ABI constraints, and is not intended to be "
"inferred for optimization use."
msgstr ""

#: ../../../LangRef.rst:1388 ../../../LangRef.rst:2820
msgid "``preallocated(<ty>)``"
msgstr ""

#: ../../../LangRef.rst:1369
msgid ""
"This indicates that the pointer parameter should really be passed by value "
"to the function, and that the pointer parameter's pointee has already been "
"initialized before the call instruction. This attribute is only valid on "
"LLVM pointer arguments. The argument must be the value returned by the "
"appropriate :ref:`llvm.call.preallocated.arg<int_call_preallocated_arg>` on "
"non ``musttail`` calls, or the corresponding caller parameter in "
"``musttail`` calls, although it is ignored during codegen."
msgstr ""

#: ../../../LangRef.rst:1378
msgid ""
"A non ``musttail`` function call with a ``preallocated`` attribute in any "
"parameter must have a ``\"preallocated\"`` operand bundle. A ``musttail`` "
"function call cannot have a ``\"preallocated\"`` operand bundle."
msgstr ""

#: ../../../LangRef.rst:1382
msgid "The preallocated attribute requires a type argument."
msgstr ""

#: ../../../LangRef.rst:1384
msgid ""
"The preallocated attribute also supports specifying an alignment with the "
"align attribute. It indicates the alignment of the stack slot to form and "
"the known alignment of the pointer specified to the call site. If the "
"alignment is not specified, then the code generator makes a target-specific "
"assumption."
msgstr ""

#: ../../../LangRef.rst:1392
msgid "``inalloca(<ty>)``"
msgstr ""

#: ../../../LangRef.rst:1394
msgid ""
"The ``inalloca`` argument attribute allows the caller to take the address of "
"outgoing stack arguments. An ``inalloca`` argument must be a pointer to "
"stack memory produced by an ``alloca`` instruction. The alloca, or argument "
"allocation, must also be tagged with the inalloca keyword. Only the last "
"argument may have the ``inalloca`` attribute, and that argument is "
"guaranteed to be passed in memory."
msgstr ""

#: ../../../LangRef.rst:1401
msgid ""
"An argument allocation may be used by a call at most once because the call "
"may deallocate it. The ``inalloca`` attribute cannot be used in conjunction "
"with other attributes that affect argument storage, like ``inreg``, "
"``nest``, ``sret``, or ``byval``. The ``inalloca`` attribute also disables "
"LLVM's implicit lowering of large aggregate return values, which means that "
"frontend authors must lower them with ``sret`` pointers."
msgstr ""

#: ../../../LangRef.rst:1409
msgid ""
"When the call site is reached, the argument allocation must have been the "
"most recent stack allocation that is still live, or the behavior is "
"undefined. It is possible to allocate additional stack space after an "
"argument allocation and before its call site, but it must be cleared off "
"with :ref:`llvm.stackrestore <int_stackrestore>`."
msgstr ""

#: ../../../LangRef.rst:1416
msgid "The ``inalloca`` attribute requires a type argument."
msgstr ""

#: ../../../LangRef.rst:1418
msgid "See :doc:`InAlloca` for more information on how to use this attribute."
msgstr ""

#: ../../../LangRef.rst:1431
msgid "``sret(<ty>)``"
msgstr ""

#: ../../../LangRef.rst:1422
msgid ""
"This indicates that the pointer parameter specifies the address of a "
"structure that is the return value of the function in the source program. "
"This pointer must be guaranteed by the caller to be valid: loads and stores "
"to the structure may be assumed by the callee not to trap and to be properly "
"aligned."
msgstr ""

#: ../../../LangRef.rst:1428
msgid "The sret type argument specifies the in-memory type."
msgstr ""

#: ../../../LangRef.rst:1430
msgid ""
"A function that accepts an ``sret`` argument must return ``void``. A return "
"value may not be ``sret``."
msgstr ""

#: ../../../LangRef.rst:1435
msgid "``elementtype(<ty>)``"
msgstr ""

#: ../../../LangRef.rst:1437
msgid ""
"The ``elementtype`` argument attribute can be used to specify a pointer "
"element type in a way that is compatible with `opaque pointers "
"<OpaquePointers.html>`__."
msgstr ""

#: ../../../LangRef.rst:1441
msgid ""
"The ``elementtype`` attribute by itself does not carry any specific "
"semantics. However, certain intrinsics may require this attribute to be "
"present and assign it particular semantics. This will be documented on "
"individual intrinsics."
msgstr ""

#: ../../../LangRef.rst:1446
msgid ""
"The attribute may only be applied to pointer typed arguments of intrinsic "
"calls. It cannot be applied to non-intrinsic calls, and cannot be applied to "
"parameters on function declarations. For non-opaque pointers, the type "
"passed to ``elementtype`` must match the pointer element type."
msgstr ""

#: ../../../LangRef.rst:1464
msgid "``align <n>`` or ``align(<n>)``"
msgstr ""

#: ../../../LangRef.rst:1454
msgid ""
"This indicates that the pointer value or vector of pointers has the "
"specified alignment. If applied to a vector of pointers, *all* pointers "
"(elements) have the specified alignment. If the pointer value does not have "
"the specified alignment, :ref:`poison value <poisonvalues>` is returned or "
"passed instead.  The ``align`` attribute should be combined with the "
"``noundef`` attribute to ensure a pointer is aligned, or otherwise the "
"behavior is undefined. Note that ``align 1`` has no effect on non-byval, non-"
"preallocated arguments."
msgstr ""

#: ../../../LangRef.rst:1463
msgid ""
"Note that this attribute has additional semantics when combined with the "
"``byval`` or ``preallocated`` attribute, which are documented there."
msgstr ""

#: ../../../LangRef.rst:1490
msgid "``noalias``"
msgstr ""

#: ../../../LangRef.rst:1469
msgid ""
"This indicates that memory locations accessed via pointer values :ref:`based "
"<pointeraliasing>` on the argument or return value are not also accessed, "
"during the execution of the function, via pointer values not *based* on the "
"argument or return value. This guarantee only holds for memory locations "
"that are *modified*, by any means, during the execution of the function. If "
"there are other accesses not based on the argument or return value, the "
"behavior is undefined. The attribute on a return value also has additional "
"semantics, as described below. Both the caller and the callee share the "
"responsibility of ensuring that these requirements are met. For further "
"details, please see the discussion of the NoAlias response in :ref:`alias "
"analysis <Must, May,  or No>`."
msgstr ""

#: ../../../LangRef.rst:1481
msgid ""
"Note that this definition of ``noalias`` is intentionally similar to the "
"definition of ``restrict`` in C99 for function arguments."
msgstr ""

#: ../../../LangRef.rst:1484
msgid ""
"For function return values, C99's ``restrict`` is not meaningful, while "
"LLVM's ``noalias`` is. Furthermore, the semantics of the ``noalias`` "
"attribute on return values are stronger than the semantics of the attribute "
"when used on function arguments. On function return values, the ``noalias`` "
"attribute indicates that the function acts like a system memory allocation "
"function, returning a pointer to allocated storage disjoint from the storage "
"for any other object accessible to the caller."
msgstr ""

#: ../../../LangRef.rst:1528
msgid "``captures(...)``"
msgstr ""

#: ../../../LangRef.rst:1495
msgid ""
"This attribute restricts the ways in which the callee may capture the "
"pointer. This is not a valid attribute for return values. This attribute "
"applies only to the particular copy of the pointer passed in this argument."
msgstr ""

#: ../../../LangRef.rst:1499
msgid ""
"The arguments of ``captures`` are a list of captured pointer components, "
"which may be ``none``, or a combination of:"
msgstr ""

#: ../../../LangRef.rst:1502
msgid "``address``: The integral address of the pointer."
msgstr ""

#: ../../../LangRef.rst:1503
msgid ""
"``address_is_null`` (subset of ``address``): Whether the address is null."
msgstr ""

#: ../../../LangRef.rst:1504
msgid ""
"``provenance``: The ability to access the pointer for both read and write "
"after the function returns."
msgstr ""

#: ../../../LangRef.rst:1506
msgid ""
"``read_provenance`` (subset of ``provenance``): The ability to access the "
"pointer only for reads after the function returns."
msgstr ""

#: ../../../LangRef.rst:1509
msgid ""
"Additionally, it is possible to specify that some components are only "
"captured in certain locations. Currently only the return value (``ret``) and "
"other (default) locations are supported."
msgstr ""

#: ../../../LangRef.rst:1513
msgid ""
"The :ref:`pointer capture section <pointercapture>` discusses these "
"semantics in more detail."
msgstr ""

#: ../../../LangRef.rst:1516
msgid "Some examples of how to use the attribute:"
msgstr ""

#: ../../../LangRef.rst:1518
msgid "``captures(none)``: Pointer not captured."
msgstr ""

#: ../../../LangRef.rst:1519
msgid ""
"``captures(address, provenance)``: Equivalent to omitting the attribute."
msgstr ""

#: ../../../LangRef.rst:1520
msgid "``captures(address)``: Address may be captured, but not provenance."
msgstr ""

#: ../../../LangRef.rst:1521
msgid ""
"``captures(address_is_null)``: Only captures whether the address is null."
msgstr ""

#: ../../../LangRef.rst:1522
msgid ""
"``captures(address, read_provenance)``: Both address and provenance "
"captured, but only for read-only access."
msgstr ""

#: ../../../LangRef.rst:1524
msgid ""
"``captures(ret: address, provenance)``: Pointer captured through return "
"value only."
msgstr ""

#: ../../../LangRef.rst:1526
msgid ""
"``captures(address_is_null, ret: address, provenance)``: The whole pointer "
"is captured through the return value, and additionally whether the pointer "
"is null is captured in some other way."
msgstr ""

#: ../../../LangRef.rst:1532 ../../../LangRef.rst:2302
msgid "``nofree``"
msgstr ""

#: ../../../LangRef.rst:1531
msgid ""
"This indicates that the callee does not free the pointer argument. This is "
"not a valid attribute for return values."
msgstr ""

#: ../../../LangRef.rst:1539
msgid "``nest``"
msgstr ""

#: ../../../LangRef.rst:1537
msgid ""
"This indicates that the pointer parameter can be excised using the :ref:"
"`trampoline intrinsics <int_trampoline>`. This is not a valid attribute for "
"return values and can only be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1549
msgid "``returned``"
msgstr ""

#: ../../../LangRef.rst:1542
msgid ""
"This indicates that the function always returns the argument as its return "
"value. This is a hint to the optimizer and code generator used when "
"generating the caller, allowing value propagation, tail call optimization, "
"and omission of register saves and restores in some cases; it is not checked "
"or enforced when generating the callee. The parameter and the function "
"return type must be valid operands for the :ref:`bitcast instruction "
"<i_bitcast>`. This is not a valid attribute for return values and can only "
"be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1557
msgid "``nonnull``"
msgstr ""

#: ../../../LangRef.rst:1552
msgid ""
"This indicates that the parameter or return pointer is not null. This "
"attribute may only be applied to pointer typed parameters. This is not "
"checked or enforced by LLVM; if the parameter or return pointer is null, :"
"ref:`poison value <poisonvalues>` is returned or passed instead. The "
"``nonnull`` attribute should be combined with the ``noundef`` attribute to "
"ensure a pointer is not null or otherwise the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:1574
msgid "``dereferenceable(<n>)``"
msgstr ""

#: ../../../LangRef.rst:1560
msgid ""
"This indicates that the parameter or return pointer is dereferenceable. This "
"attribute may only be applied to pointer typed parameters. A pointer that is "
"dereferenceable can be loaded from speculatively without a risk of trapping. "
"The number of bytes known to be dereferenceable must be provided in "
"parentheses. It is legal for the number of bytes to be less than the size of "
"the pointee type. The ``nonnull`` attribute does not imply "
"dereferenceability (consider a pointer to one element past the end of an "
"array), however ``dereferenceable(<n>)`` does imply ``nonnull`` in "
"``addrspace(0)`` (which is the default address space), except if the "
"``null_pointer_is_valid`` function attribute is present. ``n`` should be a "
"positive number. The pointer should be well defined, otherwise it is "
"undefined behavior. This means ``dereferenceable(<n>)`` implies ``noundef``. "
"When used in an assume operand bundle, more restricted semantics apply. "
"See  :ref:`assume operand bundles <assume_opbundles>` for more details."
msgstr ""

#: ../../../LangRef.rst:1587
msgid "``dereferenceable_or_null(<n>)``"
msgstr ""

#: ../../../LangRef.rst:1577
msgid ""
"This indicates that the parameter or return value isn't both non-null and "
"non-dereferenceable (up to ``<n>`` bytes) at the same time. All non-null "
"pointers tagged with ``dereferenceable_or_null(<n>)`` are "
"``dereferenceable(<n>)``. For address space 0 "
"``dereferenceable_or_null(<n>)`` implies that a pointer is exactly one of "
"``dereferenceable(<n>)`` or ``null``, and in other address spaces "
"``dereferenceable_or_null(<n>)`` implies that a pointer is at least one of "
"``dereferenceable(<n>)`` or ``null`` (i.e., it may be both ``null`` and "
"``dereferenceable(<n>)``). This attribute may only be applied to pointer "
"typed parameters."
msgstr ""

#: ../../../LangRef.rst:1592
msgid "``swiftself``"
msgstr ""

#: ../../../LangRef.rst:1590
msgid ""
"This indicates that the parameter is the self/context parameter. This is not "
"a valid attribute for return values and can only be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1600
msgid "``swiftasync``"
msgstr ""

#: ../../../LangRef.rst:1597
msgid ""
"This indicates that the parameter is the asynchronous context parameter and "
"triggers the creation of a target-specific extended frame record to store "
"this pointer. This is not a valid attribute for return values and can only "
"be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1620
msgid "``swifterror``"
msgstr ""

#: ../../../LangRef.rst:1603
msgid ""
"This attribute is motivated to model and optimize Swift error handling. It "
"can be applied to a parameter with pointer to pointer type or a pointer-"
"sized alloca. At the call site, the actual argument that corresponds to a "
"``swifterror`` parameter has to come from a ``swifterror`` alloca or the "
"``swifterror`` parameter of the caller. A ``swifterror`` value (either the "
"parameter or the alloca) can only be loaded and stored from, or used as a "
"``swifterror`` argument. This is not a valid attribute for return values and "
"can only be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1612
msgid ""
"These constraints allow the calling convention to optimize access to "
"``swifterror`` variables by associating them with a specific register at "
"call boundaries rather than placing them in memory. Since this does change "
"the calling convention, a function which uses the ``swifterror`` attribute "
"on a parameter is not ABI-compatible with one which does not."
msgstr ""

#: ../../../LangRef.rst:1618
msgid ""
"These constraints also allow LLVM to assume that a ``swifterror`` argument "
"does not alias any other memory visible within a function and that a "
"``swifterror`` alloca passed as an argument does not escape."
msgstr ""

#: ../../../LangRef.rst:1627
msgid "``immarg``"
msgstr ""

#: ../../../LangRef.rst:1623
msgid ""
"This indicates the parameter is required to be an immediate value. This must "
"be a trivial immediate integer or floating-point constant. Undef or constant "
"expressions are not valid. This is only valid on intrinsic declarations and "
"cannot be applied to a call site or arbitrary function."
msgstr ""

#: ../../../LangRef.rst:1636
msgid "``noundef``"
msgstr ""

#: ../../../LangRef.rst:1630
msgid ""
"This attribute applies to parameters and return values. If the value "
"representation contains any undefined or poison bits, the behavior is "
"undefined. Note that this does not refer to padding introduced by the type's "
"storage representation."
msgstr ""

#: ../../../LangRef.rst:1635
msgid ""
"If memory sanitizer is enabled, ``noundef`` becomes an ABI attribute and "
"must match between the call-site and the function definition."
msgstr ""

#: ../../../LangRef.rst:1652
msgid "``nofpclass(<test mask>)``"
msgstr ""

#: ../../../LangRef.rst:1641
msgid ""
"This attribute applies to parameters and return values with floating-point "
"and vector of floating-point types, as well as :ref:`supported aggregates "
"<fastmath_return_types>` of such types (matching the supported types for :"
"ref:`fast-math flags <fastmath>`). The test mask has the same format as the "
"second argument to the :ref:`llvm.is.fpclass <llvm.is.fpclass>`, and "
"indicates which classes of floating-point values are not permitted for the "
"value. For example, a bitmask of 3 indicates the parameter may not be a NaN."
msgstr ""

#: ../../../LangRef.rst:1650
msgid ""
"If the value is a floating-point class indicated by the ``nofpclass`` test "
"mask, a :ref:`poison value <poisonvalues>` is passed or returned instead."
msgstr ""

#: ../../../LangRef.rst:1654
msgid "The following invariants hold"
msgstr ""

#: ../../../LangRef.rst:1662
msgid ""
"In textual IR, various string names are supported for readability and can be "
"combined. For example ``nofpclass(nan pinf nzero)`` evaluates to a mask of "
"547."
msgstr ""

#: ../../../LangRef.rst:1666
msgid ""
"This does not depend on the floating-point environment. For example, a "
"function parameter marked ``nofpclass(zero)`` indicates no zero inputs. If "
"this is applied to an argument in a function marked with :ref:`\\\"denormal-"
"fp-math\\\" <denormal_fp_math>` indicating zero treatment of input "
"denormals, it does not imply the value cannot be a denormal value which "
"would compare equal to 0."
msgstr ""

#: ../../../LangRef.rst:1673
msgid "Recognized test mask names"
msgstr ""

#: ../../../LangRef.rst:1676
msgid "Name"
msgstr ""

#: ../../../LangRef.rst:1676 ../../../LangRef.rst:29639
msgid "floating-point class"
msgstr ""

#: ../../../LangRef.rst:1676
msgid "Bitmask value"
msgstr ""

#: ../../../LangRef.rst:1678
msgid "nan"
msgstr ""

#: ../../../LangRef.rst:1678
msgid "Any NaN"
msgstr ""

#: ../../../LangRef.rst:1678 ../../../LangRef.rst:8651
#: ../../../LangRef.rst:29647
msgid "3"
msgstr ""

#: ../../../LangRef.rst:1680
msgid "inf"
msgstr ""

#: ../../../LangRef.rst:1680
msgid "+/- infinity"
msgstr ""

#: ../../../LangRef.rst:1680
msgid "516"
msgstr ""

#: ../../../LangRef.rst:1682
msgid "norm"
msgstr ""

#: ../../../LangRef.rst:1682
msgid "+/- normal"
msgstr ""

#: ../../../LangRef.rst:1682
msgid "264"
msgstr ""

#: ../../../LangRef.rst:1684 ../../../LangRef.rst:11835
msgid "sub"
msgstr ""

#: ../../../LangRef.rst:1684
msgid "+/- subnormal"
msgstr ""

#: ../../../LangRef.rst:1684
msgid "144"
msgstr ""

#: ../../../LangRef.rst:1686
msgid "zero"
msgstr ""

#: ../../../LangRef.rst:1686
msgid "+/- 0"
msgstr ""

#: ../../../LangRef.rst:1686
msgid "96"
msgstr ""

#: ../../../LangRef.rst:1688
msgid "all"
msgstr ""

#: ../../../LangRef.rst:1688
msgid "All values"
msgstr ""

#: ../../../LangRef.rst:1688
msgid "1023"
msgstr ""

#: ../../../LangRef.rst:1690
msgid "snan"
msgstr ""

#: ../../../LangRef.rst:1690 ../../../LangRef.rst:29641
msgid "Signaling NaN"
msgstr ""

#: ../../../LangRef.rst:1690 ../../../LangRef.rst:8638
#: ../../../LangRef.rst:10943 ../../../LangRef.rst:10945
#: ../../../LangRef.rst:10947 ../../../LangRef.rst:10995
#: ../../../LangRef.rst:10997 ../../../LangRef.rst:10999
#: ../../../LangRef.rst:11053 ../../../LangRef.rst:11055
#: ../../../LangRef.rst:11057 ../../../LangRef.rst:29643
msgid "1"
msgstr ""

#: ../../../LangRef.rst:1692
msgid "qnan"
msgstr ""

#: ../../../LangRef.rst:1692 ../../../LangRef.rst:29643
msgid "Quiet NaN"
msgstr ""

#: ../../../LangRef.rst:1692 ../../../LangRef.rst:8643
#: ../../../LangRef.rst:29645
msgid "2"
msgstr ""

#: ../../../LangRef.rst:1694
msgid "ninf"
msgstr ""

#: ../../../LangRef.rst:1694 ../../../LangRef.rst:29645
msgid "Negative infinity"
msgstr ""

#: ../../../LangRef.rst:1694 ../../../LangRef.rst:8661
#: ../../../LangRef.rst:29649
msgid "4"
msgstr ""

#: ../../../LangRef.rst:1696
msgid "nnorm"
msgstr ""

#: ../../../LangRef.rst:1696 ../../../LangRef.rst:29647
msgid "Negative normal"
msgstr ""

#: ../../../LangRef.rst:1696 ../../../LangRef.rst:8681
#: ../../../LangRef.rst:29657
msgid "8"
msgstr ""

#: ../../../LangRef.rst:1698
msgid "nsub"
msgstr ""

#: ../../../LangRef.rst:1698 ../../../LangRef.rst:29649
msgid "Negative subnormal"
msgstr ""

#: ../../../LangRef.rst:1698
msgid "16"
msgstr ""

#: ../../../LangRef.rst:1700
msgid "nzero"
msgstr ""

#: ../../../LangRef.rst:1700 ../../../LangRef.rst:29651
msgid "Negative zero"
msgstr ""

#: ../../../LangRef.rst:1700
msgid "32"
msgstr ""

#: ../../../LangRef.rst:1702
msgid "pzero"
msgstr ""

#: ../../../LangRef.rst:1702 ../../../LangRef.rst:29653
msgid "Positive zero"
msgstr ""

#: ../../../LangRef.rst:1702
msgid "64"
msgstr ""

#: ../../../LangRef.rst:1704
msgid "psub"
msgstr ""

#: ../../../LangRef.rst:1704 ../../../LangRef.rst:29655
msgid "Positive subnormal"
msgstr ""

#: ../../../LangRef.rst:1704
msgid "128"
msgstr ""

#: ../../../LangRef.rst:1706
msgid "pnorm"
msgstr ""

#: ../../../LangRef.rst:1706 ../../../LangRef.rst:29657
msgid "Positive normal"
msgstr ""

#: ../../../LangRef.rst:1706
msgid "256"
msgstr ""

#: ../../../LangRef.rst:1708
msgid "pinf"
msgstr ""

#: ../../../LangRef.rst:1708 ../../../LangRef.rst:29659
msgid "Positive infinity"
msgstr ""

#: ../../../LangRef.rst:1708
msgid "512"
msgstr ""

#: ../../../LangRef.rst:1719 ../../../LangRef.rst:2035
msgid "``alignstack(<n>)``"
msgstr ""

#: ../../../LangRef.rst:1713
msgid ""
"This indicates the alignment that should be considered by the backend when "
"assigning this parameter or return value to a stack slot during calling "
"convention lowering. The enforcement of the specified alignment is target-"
"dependent, as target-specific calling convention rules may override this "
"value. This attribute serves the purpose of carrying language-specific "
"alignment information that is not mapped to base types in the backend (for "
"example, over-alignment specification through language attributes)."
msgstr ""

#: ../../../LangRef.rst:1727
msgid "``allocalign``"
msgstr ""

#: ../../../LangRef.rst:1722
msgid ""
"The function parameter marked with this attribute is the alignment in bytes "
"of the newly allocated block returned by this function. The returned value "
"must either have the specified alignment or be the null pointer. The return "
"value MAY be more aligned than the requested alignment, but not less "
"aligned.  Invalid (e.g. non-power-of-2) alignments are permitted for the "
"allocalign parameter, so long as the returned pointer is null. This "
"attribute may only be applied to integer parameters."
msgstr ""

#: ../../../LangRef.rst:1734
msgid "``allocptr``"
msgstr ""

#: ../../../LangRef.rst:1730
msgid ""
"The function parameter marked with this attribute is the pointer that will "
"be manipulated by the allocator. For a realloc-like function the pointer "
"will be invalidated upon success (but the same address may be returned), for "
"a free-like function the pointer will always be invalidated."
msgstr ""

#: ../../../LangRef.rst:1742
msgid "``readnone``"
msgstr ""

#: ../../../LangRef.rst:1737
msgid ""
"This attribute indicates that the function does not dereference that pointer "
"argument, even though it may read or write the memory that the pointer "
"points to if accessed through other pointers."
msgstr ""

#: ../../../LangRef.rst:1741
msgid ""
"If a function reads from or writes to a readnone pointer argument, the "
"behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:1750
msgid "``readonly``"
msgstr ""

#: ../../../LangRef.rst:1745
msgid ""
"This attribute indicates that the function does not write through this "
"pointer argument, even though it may write to the memory that the pointer "
"points to."
msgstr ""

#: ../../../LangRef.rst:1749
msgid ""
"If a function writes to a readonly pointer argument, the behavior is "
"undefined."
msgstr ""

#: ../../../LangRef.rst:1760
msgid "``writeonly``"
msgstr ""

#: ../../../LangRef.rst:1753
msgid ""
"This attribute indicates that the function may write to, but does not read "
"through this pointer argument (even though it may read from the memory that "
"the pointer points to)."
msgstr ""

#: ../../../LangRef.rst:1757
msgid ""
"This attribute is understood in the same way as the ``memory(write)`` "
"attribute. That is, the pointer may still be read as long as the read is not "
"observable outside the function. See the ``memory`` documentation for "
"precise semantics."
msgstr ""

#: ../../../LangRef.rst:1784
msgid "``writable``"
msgstr ""

#: ../../../LangRef.rst:1763
msgid ""
"This attribute is only meaningful in conjunction with ``dereferenceable(N)`` "
"or another attribute that implies the first ``N`` bytes of the pointer "
"argument are dereferenceable."
msgstr ""

#: ../../../LangRef.rst:1767
msgid ""
"In that case, the attribute indicates that the first ``N`` bytes will be "
"(non-atomically) loaded and stored back on entry to the function."
msgstr ""

#: ../../../LangRef.rst:1770
msgid ""
"This implies that it's possible to introduce spurious stores on entry to the "
"function without introducing traps or data races. This does not necessarily "
"hold throughout the whole function, as the pointer may escape to a different "
"thread during the execution of the function. See also the :ref:`atomic "
"optimization guide <Optimization outside atomic>`"
msgstr ""

#: ../../../LangRef.rst:1776
msgid ""
"The \"other attributes\" that imply dereferenceability are "
"``dereferenceable_or_null`` (if the pointer is non-null) and the ``sret``, "
"``byval``, ``byref``, ``inalloca``, ``preallocated`` family of attributes. "
"Note that not all of these combinations are useful, e.g. ``byval`` arguments "
"are known to be writable even without this attribute."
msgstr ""

#: ../../../LangRef.rst:1782
msgid ""
"The ``writable`` attribute cannot be combined with ``readnone``, "
"``readonly`` or a ``memory`` attribute that does not contain ``argmem: "
"write``."
msgstr ""

#: ../../../LangRef.rst:1823
msgid "``initializes((Lo1, Hi1), ...)``"
msgstr ""

#: ../../../LangRef.rst:1787
msgid ""
"This attribute indicates that the function initializes the ranges of the "
"pointer parameter's memory ``[%p+LoN, %p+HiN)``. Colloquially, this means "
"that all bytes in the specified range are written before the function "
"returns, and not read prior to the initializing write. If the function "
"unwinds, the write may not happen."
msgstr ""

#: ../../../LangRef.rst:1793
msgid ""
"Formally, this is specified in terms of an \"initialized\" shadow state for "
"all bytes in the range, which is set to \"not initialized\" at function "
"entry. If a memory access is performed through a pointer based on the "
"argument, and an accessed byte has not been marked as \"initialized\" yet, "
"then:"
msgstr ""

#: ../../../LangRef.rst:1798
msgid ""
"If the byte is stored with a non-volatile, non-atomic write, mark it as "
"\"initialized\"."
msgstr ""

#: ../../../LangRef.rst:1800
msgid ""
"If the byte is stored with a volatile or atomic write, the behavior is "
"undefined."
msgstr ""

#: ../../../LangRef.rst:1802
msgid "If the byte is loaded, return a poison value."
msgstr ""

#: ../../../LangRef.rst:1804
msgid ""
"Additionally, if the function returns normally, write an undef value to all "
"bytes that are part of the range and have not been marked as \"initialized\"."
msgstr ""

#: ../../../LangRef.rst:1807
msgid ""
"This attribute only holds for the memory accessed via this pointer "
"parameter. Other arbitrary accesses to the same memory via other pointers "
"are allowed."
msgstr ""

#: ../../../LangRef.rst:1811
msgid ""
"The ``writable`` or ``dereferenceable`` attribute do not imply the "
"``initializes`` attribute. The ``initializes`` attribute does not imply "
"``writeonly`` since ``initializes`` allows reading from the pointer after "
"writing."
msgstr ""

#: ../../../LangRef.rst:1816
msgid ""
"This attribute is a list of constant ranges in ascending order with no "
"overlapping or consecutive list elements. ``LoN/HiN`` are 64-bit integers, "
"and negative values are allowed in case the argument points partway into an "
"allocation. An empty list is not allowed."
msgstr ""

#: ../../../LangRef.rst:1821
msgid ""
"On a ``byval`` argument, ``initializes`` refers to the given parts of the "
"callee copy being overwritten. A ``byval`` callee can never initialize the "
"original caller memory passed to the ``byval`` argument."
msgstr ""

#: ../../../LangRef.rst:1837
msgid "``dead_on_unwind``"
msgstr ""

#: ../../../LangRef.rst:1826
msgid ""
"At a high level, this attribute indicates that the pointer argument is dead "
"if the call unwinds, in the sense that the caller will not depend on the "
"contents of the memory. Stores that would only be visible on the unwind path "
"can be elided."
msgstr ""

#: ../../../LangRef.rst:1831
msgid ""
"More precisely, the behavior is as-if any memory written through the pointer "
"during the execution of the function is overwritten with a poison value on "
"unwind. This includes memory written by the implicit write implied by the "
"``writable`` attribute. The caller is allowed to access the affected memory, "
"but all loads that are not preceded by a store will return poison."
msgstr ""

#: ../../../LangRef.rst:1837 ../../../LangRef.rst:1854
msgid "This attribute cannot be applied to return values."
msgstr ""

#: ../../../LangRef.rst:1854
msgid "``dead_on_return``"
msgstr ""

#: ../../../LangRef.rst:1840
msgid ""
"This attribute indicates that the memory pointed to by the argument is dead "
"upon function return, both upon normal return and if the calls unwinds, "
"meaning that the caller will not depend on its contents. Stores that would "
"be observable either on the return path or on the unwind path may be elided."
msgstr ""

#: ../../../LangRef.rst:1845
msgid ""
"Specifically, the behavior is as-if any memory written through the pointer "
"during the execution of the function is overwritten with a poison value upon "
"function return. The caller may access the memory, but any load not preceded "
"by a store will return poison."
msgstr ""

#: ../../../LangRef.rst:1850
msgid ""
"This attribute does not imply aliasing properties. For pointer arguments "
"that do not alias other memory locations, ``noalias`` attribute may be used "
"in conjunction. Conversely, this attribute always implies ``dead_on_unwind``."
msgstr ""

#: ../../../LangRef.rst:1871
msgid "``range(<ty> <a>, <b>)``"
msgstr ""

#: ../../../LangRef.rst:1857
msgid ""
"This attribute expresses the possible range of the parameter or return "
"value. If the value is not in the specified range, it is converted to "
"poison. The arguments passed to ``range`` have the following properties:"
msgstr ""

#: ../../../LangRef.rst:1861
msgid "The type must match the scalar type of the parameter or return value."
msgstr ""

#: ../../../LangRef.rst:1862 ../../../LangRef.rst:7359
msgid "The pair ``a,b`` represents the range ``[a,b)``."
msgstr ""

#: ../../../LangRef.rst:1863 ../../../LangRef.rst:7360
msgid "Both ``a`` and ``b`` are constants."
msgstr ""

#: ../../../LangRef.rst:1864 ../../../LangRef.rst:7361
msgid "The range is allowed to wrap."
msgstr ""

#: ../../../LangRef.rst:1865
msgid "The empty range is represented using ``0,0``."
msgstr ""

#: ../../../LangRef.rst:1866
msgid "Otherwise, ``a`` and ``b`` are not allowed to be equal."
msgstr ""

#: ../../../LangRef.rst:1868
msgid ""
"This attribute may only be applied to parameters or return values with "
"integer or vector of integer types."
msgstr ""

#: ../../../LangRef.rst:1871
msgid "For vector-typed parameters, the range is applied element-wise."
msgstr ""

#: ../../../LangRef.rst:1876
msgid "Garbage Collector Strategy Names"
msgstr ""

#: ../../../LangRef.rst:1878
msgid ""
"Each function may specify a garbage collector strategy name, which is simply "
"a string:"
msgstr ""

#: ../../../LangRef.rst:1885
msgid ""
"The supported values of *name* include those :ref:`built in to LLVM <builtin-"
"gc-strategies>` and any provided by loaded plugins. Specifying a GC strategy "
"will cause the compiler to alter its output in order to support the named "
"garbage collection algorithm. Note that LLVM itself does not contain a "
"garbage collector, this functionality is restricted to generating machine "
"code which can interoperate with a collector provided externally."
msgstr ""

#: ../../../LangRef.rst:1895
msgid "Prefix Data"
msgstr ""

#: ../../../LangRef.rst:1897
msgid ""
"Prefix data is data associated with a function which the code generator will "
"emit immediately before the function's entrypoint. The purpose of this "
"feature is to allow frontends to associate language-specific runtime "
"metadata with specific functions and make it available through the function "
"pointer while still allowing the function pointer to be called."
msgstr ""

#: ../../../LangRef.rst:1904
msgid ""
"To access the data for a given function, a program may bitcast the function "
"pointer to a pointer to the constant's type and dereference index -1. This "
"implies that the IR symbol points just past the end of the prefix data. For "
"instance, take the example of a function annotated with a single ``i32``,"
msgstr ""

#: ../../../LangRef.rst:1914
msgid "The prefix data can be referenced as,"
msgstr ""

#: ../../../LangRef.rst:1921
msgid ""
"Prefix data is laid out as if it were an initializer for a global variable "
"of the prefix data's type. The function will be placed such that the "
"beginning of the prefix data is aligned. This means that if the size of the "
"prefix data is not a multiple of the alignment size, the function's "
"entrypoint will not be aligned. If alignment of the function's entrypoint is "
"desired, padding must be added to the prefix data."
msgstr ""

#: ../../../LangRef.rst:1929
msgid ""
"A function may have prefix data but no body. This has similar semantics to "
"the ``available_externally`` linkage in that the data may be used by the "
"optimizers but will not be emitted in the object file."
msgstr ""

#: ../../../LangRef.rst:1936
msgid "Prologue Data"
msgstr ""

#: ../../../LangRef.rst:1938
msgid ""
"The ``prologue`` attribute allows arbitrary code (encoded as bytes) to be "
"inserted prior to the function body. This can be used for enabling function "
"hot-patching and instrumentation."
msgstr ""

#: ../../../LangRef.rst:1942
msgid ""
"To maintain the semantics of ordinary function calls, the prologue data must "
"have a particular format. Specifically, it must begin with a sequence of "
"bytes which decode to a sequence of machine instructions, valid for the "
"module's target, which transfer control to the point immediately succeeding "
"the prologue data, without performing any other visible action. This allows "
"the inliner and other passes to reason about the semantics of the function "
"definition without needing to reason about the prologue data. Obviously this "
"makes the format of the prologue data highly target dependent."
msgstr ""

#: ../../../LangRef.rst:1951
msgid ""
"A trivial example of valid prologue data for the x86 architecture is ``i8 "
"144``, which encodes the ``nop`` instruction:"
msgstr ""

#: ../../../LangRef.rst:1958
msgid ""
"Generally prologue data can be formed by encoding a relative branch "
"instruction which skips the metadata, as in this example of valid prologue "
"data for the x86_64 architecture, where the first two bytes encode ``jmp ."
"+10``:"
msgstr ""

#: ../../../LangRef.rst:1968
msgid ""
"A function may have prologue data but no body. This has similar semantics to "
"the ``available_externally`` linkage in that the data may be used by the "
"optimizers but will not be emitted in the object file."
msgstr ""

#: ../../../LangRef.rst:1975
msgid "Personality Function"
msgstr ""

#: ../../../LangRef.rst:1977
msgid ""
"The ``personality`` attribute permits functions to specify what function to "
"use for exception handling."
msgstr ""

#: ../../../LangRef.rst:1983
msgid "Attribute Groups"
msgstr ""

#: ../../../LangRef.rst:1985
msgid ""
"Attribute groups are groups of attributes that are referenced by objects "
"within the IR. They are important for keeping ``.ll`` files readable, "
"because a lot of functions will use the same set of attributes. In the "
"degenerate case of a ``.ll`` file that corresponds to a single ``.c`` file, "
"the single attribute group will capture the important command line flags "
"used to build that file."
msgstr ""

#: ../../../LangRef.rst:1991
msgid ""
"An attribute group is a module-level object. To use an attribute group, an "
"object references the attribute group's ID (e.g. ``#37``). An object may "
"refer to more than one attribute group. In that situation, the attributes "
"from the different groups are merged."
msgstr ""

#: ../../../LangRef.rst:1996
msgid ""
"Here is an example of attribute groups for a function that should always be "
"inlined, has a stack alignment of 4, and which shouldn't use SSE "
"instructions:"
msgstr ""

#: ../../../LangRef.rst:2013
msgid "Function Attributes"
msgstr ""

#: ../../../LangRef.rst:2015
msgid ""
"Function attributes are set to communicate additional information about a "
"function. Function attributes are considered to be part of the function, not "
"of the function type, so functions with different function attributes can "
"have the same function type."
msgstr ""

#: ../../../LangRef.rst:2020
msgid ""
"Function attributes are simple keywords or strings that follow the specified "
"type. Multiple attributes, when required, are separated by spaces. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:2033
msgid ""
"This attribute indicates that, when emitting the prologue and epilogue, the "
"backend should forcibly align the stack pointer. Specify the desired "
"alignment, which must be a power of two, in parentheses."
msgstr ""

#: ../../../LangRef.rst:2043
msgid "``\"alloc-family\"=\"FAMILY\"``"
msgstr ""

#: ../../../LangRef.rst:2038
msgid ""
"This indicates which \"family\" an allocator function is part of. To avoid "
"collisions, the family name should match the mangled name of the primary "
"allocator function, that is \"malloc\" for malloc/calloc/realloc/free, "
"\"_Znwm\" for ``::operator::new`` and ``::operator::delete``, and "
"\"_ZnwmSt11align_val_t\" for aligned ``::operator::new`` and ``::operator::"
"delete``. Matching malloc/realloc/free calls within a family can be "
"optimized, but mismatched ones will be left alone."
msgstr ""

#: ../../../LangRef.rst:2067
msgid "``allockind(\"KIND\")``"
msgstr ""

#: ../../../LangRef.rst:2046
msgid ""
"Describes the behavior of an allocation function. The KIND string contains "
"comma-separated entries from the following options:"
msgstr ""

#: ../../../LangRef.rst:2049
msgid "\"alloc\": the function returns a new block of memory or null."
msgstr ""

#: ../../../LangRef.rst:2050
msgid ""
"\"realloc\": the function returns a new block of memory or null. If the "
"result is non-null the memory contents from the start of the block up to the "
"smaller of the original allocation size and the new allocation size will "
"match that of the ``allocptr`` argument and the ``allocptr`` argument is "
"invalidated, even if the function returns the same address."
msgstr ""

#: ../../../LangRef.rst:2055
msgid ""
"\"free\": the function frees the block of memory specified by ``allocptr``. "
"Functions marked as \"free\" ``allockind`` must return void."
msgstr ""

#: ../../../LangRef.rst:2057
msgid ""
"\"uninitialized\": Any newly-allocated memory (either a new block from a "
"\"alloc\" function or the enlarged capacity from a \"realloc\" function) "
"will be uninitialized."
msgstr ""

#: ../../../LangRef.rst:2060
msgid ""
"\"zeroed\": Any newly-allocated memory (either a new block from a \"alloc\" "
"function or the enlarged capacity from a \"realloc\" function) will be "
"zeroed."
msgstr ""

#: ../../../LangRef.rst:2063
msgid ""
"\"aligned\": the function returns memory aligned according to the "
"``allocalign`` parameter."
msgstr ""

#: ../../../LangRef.rst:2066
msgid ""
"The first three options are mutually exclusive, and the remaining options "
"describe more details of how the function behaves. The remaining options are "
"invalid for \"free\"-type functions."
msgstr ""

#: ../../../LangRef.rst:2071
msgid "``\"alloc-variant-zeroed\"=\"FUNCTION\"``"
msgstr ""

#: ../../../LangRef.rst:2070
msgid ""
"This attribute indicates that another function is equivalent to an allocator "
"function, but returns zeroed memory. The function must have \"zeroed\" "
"allocation behavior, the same ``alloc-family``, and take exactly the same "
"arguments."
msgstr ""

#: ../../../LangRef.rst:2080
msgid "``allocsize(<EltSizeParam>[, <NumEltsParam>])``"
msgstr ""

#: ../../../LangRef.rst:2074
msgid ""
"This attribute indicates that the annotated function will always return at "
"least a given number of bytes (or null). Its arguments are zero-indexed "
"parameter numbers; if one argument is provided, then it's assumed that at "
"least ``CallSite.Args[EltSizeParam]`` bytes will be available at the "
"returned pointer. If two are provided, then it's assumed that ``CallSite."
"Args[EltSizeParam] * CallSite.Args[NumEltsParam]`` bytes are available. The "
"referenced parameters must be integer types. No assumptions are made about "
"the contents of the returned block of memory."
msgstr ""

#: ../../../LangRef.rst:2084
msgid "``alwaysinline``"
msgstr ""

#: ../../../LangRef.rst:2083
msgid ""
"This attribute indicates that the inliner should attempt to inline this "
"function into callers whenever possible, ignoring any active inlining size "
"threshold for this caller."
msgstr ""

#: ../../../LangRef.rst:2090
msgid "``builtin``"
msgstr ""

#: ../../../LangRef.rst:2087
msgid ""
"This indicates that the callee function at a call site should be recognized "
"as a built-in function, even though the function's declaration uses the "
"``nobuiltin`` attribute. This is only valid at call sites for direct calls "
"to functions that are declared with the ``nobuiltin`` attribute."
msgstr ""

#: ../../../LangRef.rst:2096
msgid "``cold``"
msgstr ""

#: ../../../LangRef.rst:2093
msgid ""
"This attribute indicates that this function is rarely called. When computing "
"edge weights, basic blocks post-dominated by a cold function call are also "
"considered to be cold and, thus, given a low weight."
msgstr ""

#: ../../../LangRef.rst:2111
msgid "``convergent``"
msgstr ""

#: ../../../LangRef.rst:2101
msgid ""
"This attribute indicates that this function is convergent. When it appears "
"on a call/invoke, the convergent attribute indicates that we should treat "
"the call as though we’re calling a convergent function. This is particularly "
"useful on indirect calls; without this we may treat such calls as though the "
"target is non-convergent."
msgstr ""

#: ../../../LangRef.rst:2108
msgid "See :doc:`ConvergentOperations` for further details."
msgstr ""

#: ../../../LangRef.rst:2110
msgid ""
"It is an error to call :ref:`llvm.experimental.convergence.entry <llvm."
"experimental.convergence.entry>` from a function that does not have this "
"attribute."
msgstr ""

#: ../../../LangRef.rst:2123
msgid "``disable_sanitizer_instrumentation``"
msgstr ""

#: ../../../LangRef.rst:2114
msgid ""
"When instrumenting code with sanitizers, it can be important to skip certain "
"functions to ensure no instrumentation is applied to them."
msgstr ""

#: ../../../LangRef.rst:2117
msgid ""
"This attribute is not always similar to absent ``sanitize_<name>`` "
"attributes: depending on the specific sanitizer, code can be inserted into "
"functions regardless of the ``sanitize_<name>`` attribute to prevent false "
"positive reports."
msgstr ""

#: ../../../LangRef.rst:2122
msgid ""
"``disable_sanitizer_instrumentation`` disables all kinds of instrumentation, "
"taking precedence over the ``sanitize_<name>`` attributes and other compiler "
"flags."
msgstr ""

#: ../../../LangRef.rst:2129
msgid "``\"dontcall-error\"``"
msgstr ""

#: ../../../LangRef.rst:2126
msgid ""
"This attribute denotes that an error diagnostic should be emitted when a "
"call of a function with this attribute is not eliminated via optimization. "
"Front ends can provide optional ``srcloc`` metadata nodes on call sites of "
"such callees to attach information about where in the source language such a "
"call came from. A string value can be provided as a note."
msgstr ""

#: ../../../LangRef.rst:2135
msgid "``\"dontcall-warn\"``"
msgstr ""

#: ../../../LangRef.rst:2132
msgid ""
"This attribute denotes that a warning diagnostic should be emitted when a "
"call of a function with this attribute is not eliminated via optimization. "
"Front ends can provide optional ``srcloc`` metadata nodes on call sites of "
"such callees to attach information about where in the source language such a "
"call came from. A string value can be provided as a note."
msgstr ""

#: ../../../LangRef.rst:2139
msgid "``fn_ret_thunk_extern``"
msgstr ""

#: ../../../LangRef.rst:2138
msgid ""
"This attribute tells the code generator that returns from functions should "
"be replaced with jumps to externally-defined architecture-specific symbols. "
"For X86, this symbol's identifier is ``__x86_return_thunk``."
msgstr ""

#: ../../../LangRef.rst:2153
msgid "``\"frame-pointer\"``"
msgstr ""

#: ../../../LangRef.rst:2142
msgid ""
"This attribute tells the code generator whether the function should keep the "
"frame pointer. The code generator may emit the frame pointer even if this "
"attribute says the frame pointer can be eliminated. The allowed string "
"values are:"
msgstr ""

#: ../../../LangRef.rst:2147
msgid ""
"``\"none\"`` (default) - the frame pointer can be eliminated, and its "
"register can be used for other purposes."
msgstr ""

#: ../../../LangRef.rst:2149
msgid ""
"``\"reserved\"`` - the frame pointer register must either be updated to "
"point to a valid frame record for the current function, or not be modified."
msgstr ""

#: ../../../LangRef.rst:2152
msgid ""
"``\"non-leaf\"`` - the frame pointer should be kept if the function calls "
"other functions."
msgstr ""

#: ../../../LangRef.rst:2154
msgid "``\"all\"`` - the frame pointer should be kept."
msgstr ""

#: ../../../LangRef.rst:2162
msgid "``hot``"
msgstr ""

#: ../../../LangRef.rst:2156
msgid ""
"This attribute indicates that this function is a hot spot of the program "
"execution. The function will be optimized more aggressively and will be "
"placed into a special subsection of the text section to improve locality."
msgstr ""

#: ../../../LangRef.rst:2160
msgid ""
"When profile feedback is enabled, this attribute takes precedence over the "
"profile information. By marking a function ``hot``, users can work around "
"the cases where the training input does not have good coverage on all the "
"hot functions."
msgstr ""

#: ../../../LangRef.rst:2167
msgid "``inlinehint``"
msgstr ""

#: ../../../LangRef.rst:2165
msgid ""
"This attribute indicates that the source code contained a hint that inlining "
"this function is desirable (such as the \"inline\" keyword in C/C++). It is "
"just a hint; it imposes no requirements on the inliner."
msgstr ""

#: ../../../LangRef.rst:2175
msgid "``jumptable``"
msgstr ""

#: ../../../LangRef.rst:2170
msgid ""
"This attribute indicates that the function should be added to a jump-"
"instruction table at code-generation time, and that all address-taken "
"references to this function should be replaced with a reference to the "
"appropriate jump-instruction-table function pointer. Note that this creates "
"a new pointer for the original function, which means that code that depends "
"on function-pointer identity can break. So, any function annotated with "
"``jumptable`` must also be ``unnamed_addr``."
msgstr ""

#: ../../../LangRef.rst:2233
msgid "``memory(...)``"
msgstr ""

#: ../../../LangRef.rst:2178
msgid ""
"This attribute specifies the possible memory effects of the call-site or "
"function. It allows specifying the possible access kinds (``none``, "
"``read``, ``write``, or ``readwrite``) for the possible memory location "
"kinds (``argmem``, ``inaccessiblemem``, ``errnomem``, as well as a default). "
"It is best understood by example:"
msgstr ""

#: ../../../LangRef.rst:2184
msgid "``memory(none)``: Does not access any memory."
msgstr ""

#: ../../../LangRef.rst:2185
msgid "``memory(read)``: May read (but not write) any memory."
msgstr ""

#: ../../../LangRef.rst:2186
msgid "``memory(write)``: May write (but not read) any memory."
msgstr ""

#: ../../../LangRef.rst:2187
msgid "``memory(readwrite)``: May read or write any memory."
msgstr ""

#: ../../../LangRef.rst:2188
msgid "``memory(argmem: read)``: May only read argument memory."
msgstr ""

#: ../../../LangRef.rst:2189
msgid ""
"``memory(argmem: read, inaccessiblemem: write)``: May only read argument "
"memory and only write inaccessible memory."
msgstr ""

#: ../../../LangRef.rst:2191
msgid ""
"``memory(argmem: read, errnomem: write)``: May only read argument memory and "
"only write errno."
msgstr ""

#: ../../../LangRef.rst:2193
msgid ""
"``memory(read, argmem: readwrite)``: May read any memory (default mode) and "
"additionally write argument memory."
msgstr ""

#: ../../../LangRef.rst:2195
msgid ""
"``memory(readwrite, argmem: none)``: May access any memory apart from "
"argument memory."
msgstr ""

#: ../../../LangRef.rst:2198
msgid "The supported access kinds are:"
msgstr ""

#: ../../../LangRef.rst:2200
msgid "``readwrite``: Any kind of access to the location is allowed."
msgstr ""

#: ../../../LangRef.rst:2201
msgid ""
"``read``: The location is only read. Writing to the location is immediate "
"undefined behavior. This includes the case where the location is read from "
"and then the same value is written back."
msgstr ""

#: ../../../LangRef.rst:2204
msgid ""
"``write``: Only writes to the location are observable outside the function "
"call. However, the function may still internally read the location after "
"writing it, as this is not observable. Reading the location prior to writing "
"it results in a poison value."
msgstr ""

#: ../../../LangRef.rst:2208
msgid ""
"``none``: No reads or writes to the location are observed outside the "
"function. It is always valid to read and write allocas, and to read global "
"constants, even if ``memory(none)`` is used, as these effects are not "
"externally observable."
msgstr ""

#: ../../../LangRef.rst:2213
msgid "The supported memory location kinds are:"
msgstr ""

#: ../../../LangRef.rst:2215
msgid ""
"``argmem``: This refers to accesses that are based on pointer arguments to "
"the function."
msgstr ""

#: ../../../LangRef.rst:2217
msgid ""
"``inaccessiblemem``: This refers to accesses to memory which is not "
"accessible by the current module (before return from the function -- an "
"allocator function may return newly accessible memory while only accessing "
"inaccessible memory itself). Inaccessible memory is often used to model "
"control dependencies of intrinsics."
msgstr ""

#: ../../../LangRef.rst:2222
msgid "``errnomem``: This refers to accesses to the ``errno`` variable."
msgstr ""

#: ../../../LangRef.rst:2223
msgid ""
"The default access kind (specified without a location prefix) applies to all "
"locations that haven't been specified explicitly, including those that don't "
"currently have a dedicated location kind (e.g. accesses to globals or "
"captured pointers)."
msgstr ""

#: ../../../LangRef.rst:2228
msgid ""
"If the ``memory`` attribute is not specified, then ``memory(readwrite)`` is "
"implied (all memory effects are possible)."
msgstr ""

#: ../../../LangRef.rst:2231
msgid ""
"The memory effects of a call can be computed as ``CallSiteEffects & "
"(FunctionEffects | OperandBundleEffects)``. Thus, the call-site annotation "
"takes precedence over the potential effects described by either the function "
"annotation or the operand bundles."
msgstr ""

#: ../../../LangRef.rst:2240
msgid "``minsize``"
msgstr ""

#: ../../../LangRef.rst:2236
msgid ""
"This attribute suggests that optimization passes and code generator passes "
"make choices that keep the code size of this function as small as possible "
"and perform optimizations that may sacrifice runtime performance in order to "
"minimize the size of the generated code. This attribute is incompatible with "
"the ``optdebug`` and ``optnone`` attributes."
msgstr ""

#: ../../../LangRef.rst:2244
msgid "``naked``"
msgstr ""

#: ../../../LangRef.rst:2243
msgid ""
"This attribute disables prologue / epilogue emission for the function. This "
"can have very system-specific consequences. The arguments of a ``naked`` "
"function can not be referenced through IR values."
msgstr ""

#: ../../../LangRef.rst:2251
msgid "``\"no-inline-line-tables\"``"
msgstr ""

#: ../../../LangRef.rst:2247
msgid ""
"When this attribute is set to true, the inliner discards source locations "
"when inlining code and instead uses the source location of the call site. "
"Breakpoints set on code that was inlined into the current function will not "
"fire during the execution of the inlined call sites. If the debugger stops "
"inside an inlined call site, it will appear to be stopped at the outermost "
"inlined call site."
msgstr ""

#: ../../../LangRef.rst:2254
msgid "``no-jump-tables``"
msgstr ""

#: ../../../LangRef.rst:2254
msgid ""
"When this attribute is set to true, the jump tables and lookup tables that "
"can be generated from a switch case lowering are disabled."
msgstr ""

#: ../../../LangRef.rst:2260
msgid "``nobuiltin``"
msgstr ""

#: ../../../LangRef.rst:2257
msgid ""
"This indicates that the callee function at a call site is not recognized as "
"a built-in function. LLVM will retain the original call and not replace it "
"with equivalent code based on the semantics of the built-in function, unless "
"the call site uses the ``builtin`` attribute. This is valid at call sites "
"and on function declarations and definitions."
msgstr ""

#: ../../../LangRef.rst:2267
msgid "``nocallback``"
msgstr ""

#: ../../../LangRef.rst:2263
msgid ""
"This attribute indicates that the function is only allowed to jump back into "
"the caller's module by a return or an exception, and is not allowed to jump "
"back by invoking a callback function, a direct, possibly transitive, "
"external function call, use of ``longjmp``, or other means. It is a compiler "
"hint that is used at the module level to improve dataflow analysis, dropped "
"during linking, and has no effect on functions defined in the current module."
msgstr ""

#: ../../../LangRef.rst:2273
msgid "``nodivergencesource``"
msgstr ""

#: ../../../LangRef.rst:2270
msgid ""
"A call to this function is not a source of divergence. In uniformity "
"analysis, a *source of divergence* is an instruction that generates "
"divergence even if its inputs are uniform. A call with no further "
"information would normally be considered a source of divergence; setting "
"this attribute on a function means that a call to it is not a source of "
"divergence."
msgstr ""

#: ../../../LangRef.rst:2284
msgid "``noduplicate``"
msgstr ""

#: ../../../LangRef.rst:2276
msgid ""
"This attribute indicates that calls to the function cannot be duplicated. A "
"call to a ``noduplicate`` function may be moved within its parent function, "
"but may not be duplicated within its parent function."
msgstr ""

#: ../../../LangRef.rst:2281
msgid ""
"A function containing a ``noduplicate`` call may still be an inlining "
"candidate, provided that the call is not duplicated by inlining. That "
"implies that the function has internal linkage and only has one call site, "
"so the original call is dead after inlining."
msgstr ""

#: ../../../LangRef.rst:2287
msgid ""
"This function attribute indicates that the function does not, directly or "
"transitively, call a memory-deallocation function (``free``, for example) on "
"a memory allocation which existed before the call."
msgstr ""

#: ../../../LangRef.rst:2291
msgid ""
"As a result, uncaptured pointers that are known to be dereferenceable prior "
"to a call to a function with the ``nofree`` attribute are still known to be "
"dereferenceable after the call. The capturing condition is necessary in "
"environments where the function might communicate the pointer to another "
"thread which then deallocates the memory.  Alternatively, ``nosync`` would "
"ensure such communication cannot happen and even captured pointers cannot be "
"freed by the function."
msgstr ""

#: ../../../LangRef.rst:2299
msgid ""
"A ``nofree`` function is explicitly allowed to free memory which it "
"allocated or (if not ``nosync``) arrange for another thread to free memory "
"on its behalf.  As a result, perhaps surprisingly, a ``nofree`` function can "
"return a pointer to a previously deallocated :ref:`allocated "
"object<allocatedobjects>`."
msgstr ""

#: ../../../LangRef.rst:2313
msgid "``noimplicitfloat``"
msgstr ""

#: ../../../LangRef.rst:2305
msgid ""
"Disallows implicit floating-point code. This inhibits optimizations that use "
"floating-point code and floating-point registers for operations that are not "
"nominally floating-point. LLVM instructions that perform floating-point "
"operations or require access to floating-point registers may still cause "
"floating-point code to be generated."
msgstr ""

#: ../../../LangRef.rst:2311
msgid ""
"Also inhibits optimizations that create SIMD/vector code and registers from "
"scalar code such as vectorization or memcpy/memset optimization. This "
"includes integer vectors. Vector instructions present in IR may still cause "
"vector code to be generated."
msgstr ""

#: ../../../LangRef.rst:2317
msgid "``noinline``"
msgstr ""

#: ../../../LangRef.rst:2316
msgid ""
"This attribute indicates that the inliner should never inline this function "
"in any situation. This attribute may not be used together with the "
"``alwaysinline`` attribute."
msgstr ""

#: ../../../LangRef.rst:2325
msgid "``nomerge``"
msgstr ""

#: ../../../LangRef.rst:2320
msgid ""
"This attribute indicates that calls to this function should never be merged "
"during optimization. For example, it will prevent tail merging otherwise "
"identical code sequences that raise an exception or terminate the program. "
"Tail merging normally reduces the precision of source location information, "
"making stack traces less useful for debugging. This attribute gives the user "
"control over the tradeoff between code size and debug information precision."
msgstr ""

#: ../../../LangRef.rst:2329
msgid "``nonlazybind``"
msgstr ""

#: ../../../LangRef.rst:2328
msgid ""
"This attribute suppresses lazy symbol binding for the function. This may "
"make calls to the function faster, at the cost of extra program startup time "
"if the function is not called during program startup."
msgstr ""

#: ../../../LangRef.rst:2334
msgid "``noprofile``"
msgstr ""

#: ../../../LangRef.rst:2332
msgid ""
"This function attribute prevents instrumentation-based profiling, used for "
"coverage or profile based optimization, from being added to a function. It "
"also blocks inlining if the caller and callee have different values of this "
"attribute."
msgstr ""

#: ../../../LangRef.rst:2339
msgid "``skipprofile``"
msgstr ""

#: ../../../LangRef.rst:2337
msgid ""
"This function attribute prevents instrumentation-based profiling, used for "
"coverage or profile based optimization, from being added to a function. This "
"attribute does not restrict inlining, so instrumented instructions could end "
"up in this function."
msgstr ""

#: ../../../LangRef.rst:2342
msgid "``noredzone``"
msgstr ""

#: ../../../LangRef.rst:2342
msgid ""
"This attribute indicates that the code generator should not use a red zone, "
"even if the target-specific ABI normally permits it."
msgstr ""

#: ../../../LangRef.rst:2346
msgid "``indirect-tls-seg-refs``"
msgstr ""

#: ../../../LangRef.rst:2345
msgid ""
"This attribute indicates that the code generator should not use direct TLS "
"access through segment registers, even if the target-specific ABI normally "
"permits it."
msgstr ""

#: ../../../LangRef.rst:2351
msgid "``noreturn``"
msgstr ""

#: ../../../LangRef.rst:2349
msgid ""
"This function attribute indicates that the function never returns normally, "
"hence through a return instruction. This produces undefined behavior at "
"runtime if the function ever does dynamically return. Annotated functions "
"may still raise an exception, i.a., ``nounwind`` is not implied."
msgstr ""

#: ../../../LangRef.rst:2357
msgid "``norecurse``"
msgstr ""

#: ../../../LangRef.rst:2354
msgid ""
"This function attribute indicates that the function is not recursive and "
"does not participate in recursion. This means that the function never occurs "
"inside a cycle in the dynamic call graph. For example:"
msgstr ""

#: ../../../LangRef.rst:2372
msgid "``willreturn``"
msgstr ""

#: ../../../LangRef.rst:2368
msgid ""
"This function attribute indicates that a call of this function will either "
"exhibit undefined behavior or comes back and continues execution at a point "
"in the existing call stack that includes the current invocation. Annotated "
"functions may still raise an exception, i.a., ``nounwind`` is not implied. "
"If an invocation of an annotated function does not return control back to a "
"point in the call stack, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:2386
msgid "``nosync``"
msgstr ""

#: ../../../LangRef.rst:2375
msgid ""
"This function attribute indicates that the function does not communicate "
"(synchronize) with another thread through memory or other well-defined "
"means. Synchronization is considered possible in the presence of `atomic` "
"accesses that enforce an order, thus not \"unordered\" and \"monotonic\", "
"`volatile` accesses, as well as `convergent` function calls."
msgstr ""

#: ../../../LangRef.rst:2381
msgid ""
"Note that `convergent` operations can involve communication that is "
"considered to be not through memory and does not necessarily imply an "
"ordering between threads for the purposes of the memory model. Therefore, an "
"operation can be both `convergent` and `nosync`."
msgstr ""

#: ../../../LangRef.rst:2386
msgid ""
"If a `nosync` function does ever synchronize with another thread, the "
"behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:2393
msgid "``nounwind``"
msgstr ""

#: ../../../LangRef.rst:2389
msgid ""
"This function attribute indicates that the function never raises an "
"exception. If the function does raise an exception, its runtime behavior is "
"undefined. However, functions marked nounwind may still trap or generate "
"asynchronous exceptions. Exception handling schemes that are recognized by "
"LLVM to handle asynchronous exceptions, such as SEH, will still provide "
"their implementation defined semantics."
msgstr ""

#: ../../../LangRef.rst:2396
msgid "``nosanitize_bounds``"
msgstr ""

#: ../../../LangRef.rst:2396
msgid ""
"This attribute indicates that bounds checking sanitizer instrumentation is "
"disabled for this function."
msgstr ""

#: ../../../LangRef.rst:2399
msgid "``nosanitize_coverage``"
msgstr ""

#: ../../../LangRef.rst:2399
msgid ""
"This attribute indicates that SanitizerCoverage instrumentation is disabled "
"for this function."
msgstr ""

#: ../../../LangRef.rst:2407
msgid "``null_pointer_is_valid``"
msgstr ""

#: ../../../LangRef.rst:2402
msgid ""
"If ``null_pointer_is_valid`` is set, then the ``null`` address in address-"
"space 0 is considered to be a valid address for memory loads and stores. Any "
"analysis or optimization should not treat dereferencing a pointer to "
"``null`` as undefined behavior in this function. Note: Comparing the address "
"of a global variable to ``null`` may still evaluate to false because of a "
"limitation in querying this attribute inside constant expressions."
msgstr ""

#: ../../../LangRef.rst:2413
msgid "``optdebug``"
msgstr ""

#: ../../../LangRef.rst:2410
msgid ""
"This attribute suggests that optimization passes and code generator passes "
"should make choices that try to preserve debug info without significantly "
"degrading runtime performance. This attribute is incompatible with the "
"``minsize``, ``optsize``, and ``optnone`` attributes."
msgstr ""

#: ../../../LangRef.rst:2416
msgid "``optforfuzzing``"
msgstr ""

#: ../../../LangRef.rst:2416
msgid ""
"This attribute indicates that this function should be optimized for maximum "
"fuzzing signal."
msgstr ""

#: ../../../LangRef.rst:2428
msgid "``optnone``"
msgstr ""

#: ../../../LangRef.rst:2419
msgid ""
"This function attribute indicates that most optimization passes will skip "
"this function, with the exception of interprocedural optimization passes. "
"Code generation defaults to the \"fast\" instruction selector. This "
"attribute cannot be used together with the ``alwaysinline`` attribute; this "
"attribute is also incompatible with the ``minsize``, ``optsize``, and "
"``optdebug`` attributes."
msgstr ""

#: ../../../LangRef.rst:2426
msgid ""
"This attribute requires the ``noinline`` attribute to be specified on the "
"function as well, so the function is never inlined into any caller. Only "
"functions with the ``alwaysinline`` attribute are valid candidates for "
"inlining into the body of this function."
msgstr ""

#: ../../../LangRef.rst:2435
msgid "``optsize``"
msgstr ""

#: ../../../LangRef.rst:2431
msgid ""
"This attribute suggests that optimization passes and code generator passes "
"make choices that keep the code size of this function low, and otherwise do "
"optimizations specifically to reduce code size as long as they do not "
"significantly impact runtime performance. This attribute is incompatible "
"with the ``optdebug`` and ``optnone`` attributes."
msgstr ""

#: ../../../LangRef.rst:2460
msgid "``\"patchable-function\"``"
msgstr ""

#: ../../../LangRef.rst:2438
msgid ""
"This attribute tells the code generator that the code generated for this "
"function needs to follow certain conventions that make it possible for a "
"runtime function to patch over it later. The exact effect of this attribute "
"depends on its string value, for which there currently is one legal "
"possibility:"
msgstr ""

#: ../../../LangRef.rst:2444
msgid ""
"``\"prologue-short-redirect\"`` - This style of patchable function is "
"intended to support patching a function prologue to redirect control away "
"from the function in a thread-safe manner.  It guarantees that the first "
"instruction of the function will be large enough to accommodate a short jump "
"instruction, and will be sufficiently aligned to allow being fully changed "
"via an atomic compare-and-swap instruction. While the first requirement can "
"be satisfied by inserting large enough NOP, LLVM can and will try to re-"
"purpose an existing instruction (i.e., one that would have to be emitted "
"anyway) as the patchable instruction larger than a short jump."
msgstr ""

#: ../../../LangRef.rst:2456
msgid "``\"prologue-short-redirect\"`` is currently only supported on x86-64."
msgstr ""

#: ../../../LangRef.rst:2459
msgid ""
"This attribute by itself does not imply restrictions on inter-procedural "
"optimizations.  All of the semantic effects the patching may have to be "
"separately conveyed via the linkage type."
msgstr ""

#: ../../../LangRef.rst:2473
msgid "``\"probe-stack\"``"
msgstr ""

#: ../../../LangRef.rst:2463
msgid ""
"This attribute indicates that the function will trigger a guard region in "
"the end of the stack. It ensures that accesses to the stack must be no "
"further apart than the size of the guard region to a previous access of the "
"stack. It takes one required string value, the name of the stack probing "
"function that will be called."
msgstr ""

#: ../../../LangRef.rst:2469
msgid ""
"If a function that has a ``\"probe-stack\"`` attribute is inlined into a "
"function with another ``\"probe-stack\"`` attribute, the resulting function "
"has the ``\"probe-stack\"`` attribute of the caller. If a function that has "
"a ``\"probe-stack\"`` attribute is inlined into a function that has no "
"``\"probe-stack\"`` attribute at all, the resulting function has the "
"``\"probe-stack\"`` attribute of the callee."
msgstr ""

#: ../../../LangRef.rst:2488
msgid "``\"stack-probe-size\"``"
msgstr ""

#: ../../../LangRef.rst:2476
msgid ""
"This attribute controls the behavior of stack probes: either the ``\"probe-"
"stack\"`` attribute, or ABI-required stack probes, if any. It defines the "
"size of the guard region. It ensures that if the function may use more stack "
"space than the size of the guard region, a stack probing sequence will be "
"emitted. It takes one required integer value, which is 4096 by default."
msgstr ""

#: ../../../LangRef.rst:2483
msgid ""
"If a function that has a ``\"stack-probe-size\"`` attribute is inlined into "
"a function with another ``\"stack-probe-size\"`` attribute, the resulting "
"function has the ``\"stack-probe-size\"`` attribute that has the lower "
"numeric value. If a function that has a ``\"stack-probe-size\"`` attribute "
"is inlined into a function that has no ``\"stack-probe-size\"`` attribute at "
"all, the resulting function has the ``\"stack-probe-size\"`` attribute of "
"the callee."
msgstr ""

#: ../../../LangRef.rst:2490
msgid "``\"no-stack-arg-probe\"``"
msgstr ""

#: ../../../LangRef.rst:2491
msgid "This attribute disables ABI-required stack probes, if any."
msgstr ""

#: ../../../LangRef.rst:2495
msgid "``returns_twice``"
msgstr ""

#: ../../../LangRef.rst:2493
msgid ""
"This attribute indicates that this function can return twice. The C "
"``setjmp`` is an example of such a function. The compiler disables some "
"optimizations (like tail calls) in the caller of these functions."
msgstr ""

#: ../../../LangRef.rst:2504
msgid "``safestack``"
msgstr ""

#: ../../../LangRef.rst:2498
msgid ""
"This attribute indicates that `SafeStack <https://clang.llvm.org/docs/"
"SafeStack.html>`_ protection is enabled for this function."
msgstr ""

#: ../../../LangRef.rst:2502
msgid ""
"If a function that has a ``safestack`` attribute is inlined into a function "
"that doesn't have a ``safestack`` attribute or which has an ``ssp``, "
"``sspstrong`` or ``sspreq`` attribute, then the resulting function will have "
"a ``safestack`` attribute."
msgstr ""

#: ../../../LangRef.rst:2507
msgid "``sanitize_address``"
msgstr ""

#: ../../../LangRef.rst:2507
msgid ""
"This attribute indicates that AddressSanitizer checks (dynamic address "
"safety analysis) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:2510
msgid "``sanitize_memory``"
msgstr ""

#: ../../../LangRef.rst:2510
msgid ""
"This attribute indicates that MemorySanitizer checks (dynamic detection of "
"accesses to uninitialized memory) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:2513
msgid "``sanitize_thread``"
msgstr ""

#: ../../../LangRef.rst:2513
msgid ""
"This attribute indicates that ThreadSanitizer checks (dynamic thread safety "
"analysis) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:2517
msgid "``sanitize_hwaddress``"
msgstr ""

#: ../../../LangRef.rst:2516
msgid ""
"This attribute indicates that HWAddressSanitizer checks (dynamic address "
"safety analysis based on tagged pointers) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:2521 ../../../LangRef.rst:2854
msgid "``sanitize_memtag``"
msgstr ""

#: ../../../LangRef.rst:2520
msgid ""
"This attribute indicates that MemTagSanitizer checks (dynamic address safety "
"analysis based on Armv8 MTE) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:2525
msgid "``sanitize_realtime``"
msgstr ""

#: ../../../LangRef.rst:2524
msgid ""
"This attribute indicates that RealtimeSanitizer checks (realtime safety "
"analysis - no allocations, syscalls or exceptions) are enabled for this "
"function."
msgstr ""

#: ../../../LangRef.rst:2530
msgid "``sanitize_realtime_blocking``"
msgstr ""

#: ../../../LangRef.rst:2528
msgid ""
"This attribute indicates that RealtimeSanitizer should error immediately if "
"the attributed function is called during invocation of a function attributed "
"with ``sanitize_realtime``. This attribute is incompatible with the "
"``sanitize_realtime`` attribute."
msgstr ""

#: ../../../LangRef.rst:2533
msgid "``sanitize_alloc_token``"
msgstr ""

#: ../../../LangRef.rst:2533
msgid ""
"This attribute indicates that implicit allocation token instrumentation is "
"enabled for this function."
msgstr ""

#: ../../../LangRef.rst:2551
msgid "``speculative_load_hardening``"
msgstr ""

#: ../../../LangRef.rst:2536
msgid ""
"This attribute indicates that `Speculative Load Hardening <https://llvm.org/"
"docs/SpeculativeLoadHardening.html>`_ should be enabled for the function "
"body."
msgstr ""

#: ../../../LangRef.rst:2540
msgid ""
"Speculative Load Hardening is a best-effort mitigation against information "
"leak attacks that make use of control flow miss-speculation - specifically "
"miss-speculation of whether a branch is taken or not. Typically "
"vulnerabilities enabling such attacks are classified as \"Spectre variant "
"#1\". Notably, this does not attempt to mitigate against miss-speculation of "
"branch target, classified as \"Spectre variant #2\" vulnerabilities."
msgstr ""

#: ../../../LangRef.rst:2548
msgid ""
"When inlining, the attribute is sticky. Inlining a function that carries "
"this attribute will cause the caller to gain the attribute. This is intended "
"to provide a maximally conservative model where the code in a function "
"annotated with this attribute will always (even after inlining) end up "
"hardened."
msgstr ""

#: ../../../LangRef.rst:2562
msgid "``speculatable``"
msgstr ""

#: ../../../LangRef.rst:2554
msgid ""
"This function attribute indicates that the function does not have any "
"effects besides calculating its result and does not have undefined behavior. "
"Note that ``speculatable`` is not enough to conclude that along any "
"particular execution path the number of calls to this function will not be "
"externally observable. This attribute is only valid on functions and "
"declarations, not on individual call sites. If a function is incorrectly "
"marked as speculatable and really does exhibit undefined behavior, the "
"undefined behavior may be observed even if the call site is dead code."
msgstr ""

#: ../../../LangRef.rst:2581
msgid "``ssp``"
msgstr ""

#: ../../../LangRef.rst:2565
msgid ""
"This attribute indicates that the function should emit a stack smashing "
"protector. It is in the form of a \"canary\" --- a random value placed on "
"the stack before the local variables that's checked upon return from the "
"function to see if it has been overwritten. A heuristic is used to determine "
"if a function needs stack protectors or not. The heuristic used will enable "
"protectors for functions with:"
msgstr ""

#: ../../../LangRef.rst:2572
msgid "Character arrays larger than ``ssp-buffer-size`` (default 8)."
msgstr ""

#: ../../../LangRef.rst:2573
msgid "Aggregates containing character arrays larger than ``ssp-buffer-size``."
msgstr ""

#: ../../../LangRef.rst:2574
msgid ""
"Calls to alloca() with variable sizes or constant sizes greater than ``ssp-"
"buffer-size``."
msgstr ""

#: ../../../LangRef.rst:2577
msgid ""
"Variables that are identified as requiring a protector will be arranged on "
"the stack such that they are adjacent to the stack protector guard."
msgstr ""

#: ../../../LangRef.rst:2580
msgid ""
"If a function with an ``ssp`` attribute is inlined into a calling function, "
"the attribute is not carried over to the calling function."
msgstr ""

#: ../../../LangRef.rst:2609
msgid "``sspstrong``"
msgstr ""

#: ../../../LangRef.rst:2584
msgid ""
"This attribute indicates that the function should emit a stack smashing "
"protector. This attribute causes a strong heuristic to be used when "
"determining if a function needs stack protectors. The strong heuristic will "
"enable protectors for functions with:"
msgstr ""

#: ../../../LangRef.rst:2589
msgid "Arrays of any size and type"
msgstr ""

#: ../../../LangRef.rst:2590
msgid "Aggregates containing an array of any size and type."
msgstr ""

#: ../../../LangRef.rst:2591
msgid "Calls to alloca()."
msgstr ""

#: ../../../LangRef.rst:2592
msgid "Local variables that have had their address taken."
msgstr ""

#: ../../../LangRef.rst:2594 ../../../LangRef.rst:2616
msgid ""
"Variables that are identified as requiring a protector will be arranged on "
"the stack such that they are adjacent to the stack protector guard. The "
"specific layout rules are:"
msgstr ""

#: ../../../LangRef.rst:2598 ../../../LangRef.rst:2620
msgid ""
"Large arrays and structures containing large arrays (``>= ssp-buffer-size``) "
"are closest to the stack protector."
msgstr ""

#: ../../../LangRef.rst:2600 ../../../LangRef.rst:2622
msgid ""
"Small arrays and structures containing small arrays (``< ssp-buffer-size``) "
"are 2nd closest to the protector."
msgstr ""

#: ../../../LangRef.rst:2602 ../../../LangRef.rst:2624
msgid ""
"Variables that have had their address taken are 3rd closest to the protector."
msgstr ""

#: ../../../LangRef.rst:2605
msgid "This overrides the ``ssp`` function attribute."
msgstr ""

#: ../../../LangRef.rst:2607
msgid ""
"If a function with an ``sspstrong`` attribute is inlined into a calling "
"function which has an ``ssp`` attribute, the calling function's attribute "
"will be upgraded to ``sspstrong``."
msgstr ""

#: ../../../LangRef.rst:2629
msgid "``sspreq``"
msgstr ""

#: ../../../LangRef.rst:2612
msgid ""
"This attribute indicates that the function should *always* emit a stack "
"smashing protector. This overrides the ``ssp`` and ``sspstrong`` function "
"attributes."
msgstr ""

#: ../../../LangRef.rst:2627
msgid ""
"If a function with an ``sspreq`` attribute is inlined into a calling "
"function which has an ``ssp`` or ``sspstrong`` attribute, the calling "
"function's attribute will be upgraded to ``sspreq``."
msgstr ""

#: ../../../LangRef.rst:2639
msgid "``strictfp``"
msgstr ""

#: ../../../LangRef.rst:2634
msgid ""
"This attribute indicates that the function was called from a scope that "
"requires strict floating-point semantics.  LLVM will not attempt any "
"optimizations that require assumptions about the floating-point rounding "
"mode or that might alter the state of floating-point status flags that might "
"otherwise be set or cleared by calling this function. LLVM will not "
"introduce any new floating-point instructions that may trap."
msgstr ""

#: ../../../LangRef.rst:2676
msgid "``\"denormal-fp-math\"``"
msgstr ""

#: ../../../LangRef.rst:2644
msgid ""
"This indicates the denormal (subnormal) handling that may be assumed for the "
"default floating-point environment. This is a comma separated pair. The "
"elements may be one of ``\"ieee\"``, ``\"preserve-sign\"``, ``\"positive-"
"zero\"``, or ``\"dynamic\"``. The first entry indicates the flushing mode "
"for the result of floating point operations. The second indicates the "
"handling of denormal inputs to floating point instructions. For "
"compatibility with older bitcode, if the second value is omitted, both input "
"and output modes will assume the same mode."
msgstr ""

#: ../../../LangRef.rst:2654
msgid ""
"If this is attribute is not specified, the default is ``\"ieee,ieee\"``."
msgstr ""

#: ../../../LangRef.rst:2656
msgid ""
"If the output mode is ``\"preserve-sign\"``, or ``\"positive-zero\"``, "
"denormal outputs may be flushed to zero by standard floating-point "
"operations. It is not mandated that flushing to zero occurs, but if a "
"denormal output is flushed to zero, it must respect the sign mode. Not all "
"targets support all modes."
msgstr ""

#: ../../../LangRef.rst:2662
msgid ""
"If the mode is ``\"dynamic\"``, the behavior is derived from the dynamic "
"state of the floating-point environment. Transformations which depend on the "
"behavior of denormal values should not be performed."
msgstr ""

#: ../../../LangRef.rst:2667
msgid ""
"While this indicates the expected floating point mode the function will be "
"executed with, this does not make any attempt to ensure the mode is "
"consistent. User or platform code is expected to set the floating point mode "
"appropriately before function entry."
msgstr ""

#: ../../../LangRef.rst:2672
msgid ""
"If the input mode is ``\"preserve-sign\"``, or ``\"positive-zero\"``, a "
"floating-point operation must treat any input denormal value as zero. In "
"some situations, if an instruction does not respect this mode, the input may "
"need to be converted to 0 as if by ``@llvm.canonicalize`` during lowering "
"for correctness."
msgstr ""

#: ../../../LangRef.rst:2684
msgid "``\"denormal-fp-math-f32\"``"
msgstr ""

#: ../../../LangRef.rst:2679
msgid ""
"Same as ``\"denormal-fp-math\"``, but only controls the behavior of the 32-"
"bit float type (or vectors of 32-bit floats). If both are are present, this "
"overrides ``\"denormal-fp-math\"``. Not all targets support separately "
"setting the denormal mode per type, and no attempt is made to diagnose "
"unsupported uses. Currently this attribute is respected by the AMDGPU and "
"NVPTX backends."
msgstr ""

#: ../../../LangRef.rst:2689
msgid "``\"thunk\"``"
msgstr ""

#: ../../../LangRef.rst:2687
msgid ""
"This attribute indicates that the function will delegate to some other "
"function with a tail call. The prototype of a thunk should not be used for "
"optimization purposes. The caller is expected to cast the thunk prototype to "
"match the thunk target prototype."
msgstr ""

#: ../../../LangRef.rst:2698
msgid "``uwtable[(sync|async)]``"
msgstr ""

#: ../../../LangRef.rst:2692
msgid ""
"This attribute indicates that the ABI being targeted requires that an unwind "
"table entry be produced for this function even if we can show that no "
"exceptions pass by it. This is normally the case for the ELF x86-64 abi, but "
"it can be disabled for some compilation units. The optional parameter "
"describes what kind of unwind tables to generate: ``sync`` for normal unwind "
"tables, ``async`` for asynchronous (instruction precise) unwind tables. "
"Without the parameter, the attribute ``uwtable`` is equivalent to "
"``uwtable(async)``."
msgstr ""

#: ../../../LangRef.rst:2704
msgid "``nocf_check``"
msgstr ""

#: ../../../LangRef.rst:2701
msgid ""
"This attribute indicates that no control-flow check will be performed on the "
"attributed entity. It disables -fcf-protection=<> for a specific entity to "
"fine grain the HW control flow protection mechanism. The flag is target "
"independent and currently appertains to a function or function pointer."
msgstr ""

#: ../../../LangRef.rst:2710
msgid "``shadowcallstack``"
msgstr ""

#: ../../../LangRef.rst:2707
msgid ""
"This attribute indicates that the ShadowCallStack checks are enabled for the "
"function. The instrumentation checks that the return address for the "
"function has not changed between the function prologue and epilogue. It is "
"currently x86_64-specific."
msgstr ""

#: ../../../LangRef.rst:2726
msgid "``mustprogress``"
msgstr ""

#: ../../../LangRef.rst:2715
msgid ""
"This attribute indicates that the function is required to return, unwind, or "
"interact with the environment in an observable way e.g. via a volatile "
"memory access, I/O, or other synchronization.  The ``mustprogress`` "
"attribute is intended to model the requirements of the first section of "
"[intro.progress] of the C++ Standard. As a consequence, a loop in a function "
"with the ``mustprogress`` attribute can be assumed to terminate if it does "
"not interact with the environment in an observable way, and terminating "
"loops without side-effects can be removed. If a ``mustprogress`` function "
"does not satisfy this contract, the behavior is undefined. If a "
"``mustprogress`` function calls a function not marked ``mustprogress``, and "
"that function never returns, the program is well-defined even if there isn't "
"any other observable progress.  Note that ``willreturn`` implies "
"``mustprogress``."
msgstr ""

#: ../../../LangRef.rst:2732
msgid "``\"warn-stack-size\"=\"<threshold>\"``"
msgstr ""

#: ../../../LangRef.rst:2729
msgid ""
"This attribute sets a threshold to emit diagnostics once the frame size is "
"known should the frame size exceed the specified value.  It takes one "
"required integer value, which should be a non-negative integer, and less "
"than `UINT_MAX`.  It's unspecified which threshold will be used when "
"duplicate definitions are linked together with differing values."
msgstr ""

#: ../../../LangRef.rst:2739
msgid "``vscale_range(<min>[, <max>])``"
msgstr ""

#: ../../../LangRef.rst:2735
msgid ""
"This function attribute indicates `vscale` is a power-of-two within a "
"specified range. `min` must be a power-of-two that is greater than 0. When "
"specified, `max` must be a power-of-two greater-than-or-equal to `min` or 0 "
"to signify an unbounded maximum. The syntax `vscale_range(<val>)` can be "
"used to set both `min` and `max` to the same value. Functions that don't "
"include this attribute make no assumptions about the value of `vscale`."
msgstr ""

#: ../../../LangRef.rst:2743
msgid "``\"nooutline\"``"
msgstr ""

#: ../../../LangRef.rst:2742
msgid ""
"This attribute indicates that outlining passes should not modify the "
"function."
msgstr ""

#: ../../../LangRef.rst:2746
msgid "Call Site Attributes"
msgstr ""

#: ../../../LangRef.rst:2748
msgid ""
"In addition to function attributes the following call site only attributes "
"are supported:"
msgstr ""

#: ../../../LangRef.rst:2814
msgid "``vector-function-abi-variant``"
msgstr ""

#: ../../../LangRef.rst:2752
msgid ""
"This attribute can be attached to a :ref:`call <i_call>` to list the vector "
"functions associated to the function. Notice that the attribute cannot be "
"attached to a :ref:`invoke <i_invoke>` or a :ref:`callbr <i_callbr>` "
"instruction. The attribute consists of a comma separated list of mangled "
"names. The order of the list does not imply preference (it is logically a "
"set). The compiler is free to pick any listed vector function of its "
"choosing."
msgstr ""

#: ../../../LangRef.rst:2760
msgid "The syntax for the mangled names is as follows:::"
msgstr ""

#: ../../../LangRef.rst:2764
msgid ""
"When present, the attribute informs the compiler that the function "
"``<scalar_name>`` has a corresponding vector variant that can be used to "
"perform the concurrent invocation of ``<scalar_name>`` on vectors. The shape "
"of the vector function is described by the tokens between the prefix "
"``_ZGV`` and the ``<scalar_name>`` token. The standard name of the vector "
"function is ``_ZGV<isa><mask><vlen><parameters>_<scalar_name>``. When "
"present, the optional token ``(<vector_redirection>)`` informs the compiler "
"that a custom name is provided in addition to the standard one (custom names "
"can be provided for example via the use of ``declare variant`` in OpenMP "
"5.0). The declaration of the variant must be present in the IR Module. The "
"signature of the vector variant is determined by the rules of the Vector "
"Function ABI (VFABI) specifications of the target. For Arm and X86, the "
"VFABI can be found at https://github.com/ARM-software/abi-aa and https://"
"software.intel.com/content/www/us/en/develop/download/vector-simd-function-"
"abi.html, respectively."
msgstr ""

#: ../../../LangRef.rst:2782
msgid ""
"For X86 and Arm targets, the values of the tokens in the standard name are "
"those that are defined in the VFABI. LLVM has an internal ``<isa>`` token "
"that can be used to create scalar-to-vector mappings for functions that are "
"not directly associated to any of the target ISAs (for example, some of the "
"mappings stored in the TargetLibraryInfo). Valid values for the ``<isa>`` "
"token are:::"
msgstr ""

#: ../../../LangRef.rst:2793
msgid ""
"For all targets currently supported (x86, Arm and Internal LLVM), the "
"remaining tokens can have the following values:::"
msgstr ""

#: ../../../LangRef.rst:2817
msgid ""
"This attribute is required on calls to ``llvm.call.preallocated.arg`` and "
"cannot be used on any other call. See :ref:`llvm.call.preallocated."
"arg<int_call_preallocated_arg>` for more details."
msgstr ""

#: ../../../LangRef.rst:2825
msgid "Global Attributes"
msgstr ""

#: ../../../LangRef.rst:2827
msgid ""
"Attributes may be set to communicate additional information about a global "
"variable. Unlike :ref:`function attributes <fnattrs>`, attributes on a "
"global variable are grouped into a single :ref:`attribute group <attrgrp>`."
msgstr ""

#: ../../../LangRef.rst:2835
msgid "``no_sanitize_address``"
msgstr ""

#: ../../../LangRef.rst:2832
msgid ""
"This attribute indicates that the global variable should not have "
"AddressSanitizer instrumentation applied to it, because it was annotated "
"with `__attribute__((no_sanitize(\"address\")))`, "
"`__attribute__((disable_sanitizer_instrumentation))`, or included in the `-"
"fsanitize-ignorelist` file."
msgstr ""

#: ../../../LangRef.rst:2841
msgid "``no_sanitize_hwaddress``"
msgstr ""

#: ../../../LangRef.rst:2838
msgid ""
"This attribute indicates that the global variable should not have "
"HWAddressSanitizer instrumentation applied to it, because it was annotated "
"with `__attribute__((no_sanitize(\"hwaddress\")))`, "
"`__attribute__((disable_sanitizer_instrumentation))`, or included in the `-"
"fsanitize-ignorelist` file."
msgstr ""

#: ../../../LangRef.rst:2844
msgid ""
"This attribute indicates that the global variable should have AArch64 memory "
"tags (MTE) instrumentation applied to it. This attribute causes the "
"suppression of certain optimizations, like GlobalMerge, as well as ensuring "
"extra directives are emitted in the assembly and extra bits of metadata are "
"placed in the object file so that the linker can ensure the accesses are "
"protected by MTE. This attribute is added by clang when `-fsanitize=memtag-"
"globals` is provided, as long as the global is not marked with "
"`__attribute__((no_sanitize(\"memtag\")))`, "
"`__attribute__((disable_sanitizer_instrumentation))`, or included in the `-"
"fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove this "
"attribute when it's not possible to tag the global (e.g. it's a TLS "
"variable)."
msgstr ""

#: ../../../LangRef.rst:2860
msgid "``sanitize_address_dyninit``"
msgstr ""

#: ../../../LangRef.rst:2857
msgid ""
"This attribute indicates that the global variable, when instrumented with "
"AddressSanitizer, should be checked for ODR violations. This attribute is "
"applied to global variables that are dynamically initialized according to C+"
"+ rules."
msgstr ""

#: ../../../LangRef.rst:2865
msgid "Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:2867
msgid ""
"Operand bundles are tagged sets of SSA values or metadata strings that can "
"be associated with certain LLVM instructions (currently only ``call`` s and "
"``invoke`` s).  In a way they are like metadata, but dropping them is "
"incorrect and will change program semantics."
msgstr ""

#: ../../../LangRef.rst:2879
msgid ""
"Operand bundles are **not** part of a function's signature, and a given "
"function may be called from multiple places with different kinds of operand "
"bundles.  This reflects the fact that the operand bundles are conceptually a "
"part of the ``call`` (or ``invoke``), not the callee being dispatched to."
msgstr ""

#: ../../../LangRef.rst:2885
msgid ""
"Operand bundles are a generic mechanism intended to support runtime-"
"introspection-like functionality for managed languages.  While the exact "
"semantics of an operand bundle depend on the bundle tag, there are certain "
"limitations to how much the presence of an operand bundle can influence the "
"semantics of a program.  These restrictions are described as the semantics "
"of an \"unknown\" operand bundle.  As long as the behavior of an operand "
"bundle is describable within these restrictions, LLVM does not need to have "
"special knowledge of the operand bundle to not miscompile programs "
"containing it."
msgstr ""

#: ../../../LangRef.rst:2895
msgid ""
"The bundle operands for an unknown operand bundle escape in unknown ways "
"before control is transferred to the callee or invokee."
msgstr ""

#: ../../../LangRef.rst:2897
msgid ""
"Calls and invokes with operand bundles have unknown read / write effect on "
"the heap on entry and exit (even if the call target specifies a ``memory`` "
"attribute), unless they're overridden with callsite specific attributes."
msgstr ""

#: ../../../LangRef.rst:2901
msgid ""
"An operand bundle at a call site cannot change the implementation of the "
"called function.  Inter-procedural optimizations work as usual as long as "
"they take into account the first two properties."
msgstr ""

#: ../../../LangRef.rst:2905
msgid "More specific types of operand bundles are described below."
msgstr ""

#: ../../../LangRef.rst:2910
msgid "Deoptimization Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:2912
msgid ""
"Deoptimization operand bundles are characterized by the ``\"deopt\"`` "
"operand bundle tag.  These operand bundles represent an alternate \"safe\" "
"continuation for the call site they're attached to, and can be used by a "
"suitable runtime to deoptimize the compiled frame at the specified call "
"site.  There can be at most one ``\"deopt\"`` operand bundle attached to a "
"call site.  Exact details of deoptimization are out of scope for the "
"language reference, but it usually involves rewriting a compiled frame into "
"a set of interpreted frames."
msgstr ""

#: ../../../LangRef.rst:2921
msgid ""
"From the compiler's perspective, deoptimization operand bundles make the "
"call sites they're attached to at least ``readonly``.  They read through all "
"of their pointer typed operands (even if they're not otherwise escaped) and "
"the entire visible heap.  Deoptimization operand bundles do not capture "
"their operands except during deoptimization, in which case control will not "
"be returned to the compiled frame."
msgstr ""

#: ../../../LangRef.rst:2929
msgid ""
"The inliner knows how to inline through calls that have deoptimization "
"operand bundles.  Just like inlining through a normal call site involves "
"composing the normal and exceptional continuations, inlining through a call "
"site with a deoptimization operand bundle needs to appropriately compose the "
"\"safe\" deoptimization continuation.  The inliner does this by prepending "
"the parent's deoptimization continuation to every deoptimization "
"continuation in the inlined body. E.g. inlining ``@f`` into ``@g`` in the "
"following example"
msgstr ""

#: ../../../LangRef.rst:2952
msgid "will result in"
msgstr ""

#: ../../../LangRef.rst:2963
msgid ""
"It is the frontend's responsibility to structure or encode the "
"deoptimization state in a way that syntactically prepending the caller's "
"deoptimization state to the callee's deoptimization state is semantically "
"equivalent to composing the caller's deoptimization continuation after the "
"callee's deoptimization continuation."
msgstr ""

#: ../../../LangRef.rst:2972
msgid "Funclet Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:2974
msgid ""
"Funclet operand bundles are characterized by the ``\"funclet\"`` operand "
"bundle tag.  These operand bundles indicate that a call site is within a "
"particular funclet.  There can be at most one ``\"funclet\"`` operand bundle "
"attached to a call site and it must have exactly one bundle operand."
msgstr ""

#: ../../../LangRef.rst:2980
msgid ""
"If any funclet EH pads have been \"entered\" but not \"exited\" (per the "
"`description in the EH doc\\ <ExceptionHandling.html#wineh-constraints>`_), "
"it is undefined behavior to execute a ``call`` or ``invoke`` which:"
msgstr ""

#: ../../../LangRef.rst:2984
msgid ""
"does not have a ``\"funclet\"`` bundle and is not a ``call`` to a nounwind "
"intrinsic, or"
msgstr ""

#: ../../../LangRef.rst:2986
msgid ""
"has a ``\"funclet\"`` bundle whose operand is not the most-recently-entered "
"not-yet-exited funclet EH pad."
msgstr ""

#: ../../../LangRef.rst:2989
msgid ""
"Similarly, if no funclet EH pads have been entered-but-not-yet-exited, "
"executing a ``call`` or ``invoke`` with a ``\"funclet\"`` bundle is "
"undefined behavior."
msgstr ""

#: ../../../LangRef.rst:2993
msgid "GC Transition Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:2995
msgid ""
"GC transition operand bundles are characterized by the ``\"gc-transition\"`` "
"operand bundle tag. These operand bundles mark a call as a transition "
"between a function with one GC strategy to a function with a different GC "
"strategy. If coordinating the transition between GC strategies requires "
"additional code generation at the call site, these bundles may contain any "
"values that are needed by the generated code.  For more details, see :ref:"
"`GC Transitions <gc_transition_args>`."
msgstr ""

#: ../../../LangRef.rst:3004
msgid ""
"The bundle contains an arbitrary list of Values which need to be passed to "
"GC transition code. They will be lowered and passed as operands to the "
"appropriate ``GC_TRANSITION`` nodes in the selection DAG. It is assumed that "
"these arguments must be available before and after (but not necessarily "
"during) the execution of the callee."
msgstr ""

#: ../../../LangRef.rst:3013
msgid "Assume Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:3015
msgid ""
"Operand bundles on an :ref:`llvm.assume <int_assume>` allow representing "
"assumptions, such as that a :ref:`parameter attribute <paramattrs>` or a :"
"ref:`function attribute <fnattrs>` holds for a certain value at a certain "
"location. Operand bundles enable assumptions that are either hard or "
"impossible to represent as a boolean argument of an :ref:`llvm.assume "
"<int_assume>`."
msgstr ""

#: ../../../LangRef.rst:3021
msgid ""
"Assumes with operand bundles must have ``i1 true`` as the condition operand."
msgstr ""

#: ../../../LangRef.rst:3023
msgid "An assume operand bundle has the form:"
msgstr ""

#: ../../../LangRef.rst:3029
msgid ""
"In the case of function or parameter attributes, the operand bundle has the "
"restricted form:"
msgstr ""

#: ../../../LangRef.rst:3036
msgid ""
"The tag of the operand bundle is usually the name of the attribute that can "
"be assumed to hold. It can also be `ignore`; this tag doesn't contain any "
"information and should be ignored."
msgstr ""

#: ../../../LangRef.rst:3039
msgid ""
"The first argument, if present, is the value for which the attribute holds."
msgstr ""

#: ../../../LangRef.rst:3040
msgid "The second argument, if present, is an argument of the attribute."
msgstr ""

#: ../../../LangRef.rst:3042
msgid ""
"If there are no arguments the attribute is a property of the call location."
msgstr ""

#: ../../../LangRef.rst:3044 ../../../LangRef.rst:8842
#: ../../../LangRef.rst:20512 ../../../LangRef.rst:20552
#: ../../../LangRef.rst:20634
msgid "For example:"
msgstr ""

#: ../../../LangRef.rst:3050
msgid ""
"allows the optimizer to assume that at location of call to :ref:`llvm.assume "
"<int_assume>` ``%val`` has an alignment of at least 8."
msgstr ""

#: ../../../LangRef.rst:3057
msgid ""
"allows the optimizer to assume that the :ref:`llvm.assume <int_assume>` call "
"location is cold and that ``%val`` may not be null."
msgstr ""

#: ../../../LangRef.rst:3060
msgid ""
"Just like for the argument of :ref:`llvm.assume <int_assume>`, if any of the "
"provided guarantees are violated at runtime the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:3063
msgid ""
"While attributes expect constant arguments, assume operand bundles may be "
"provided a dynamic value, for example:"
msgstr ""

#: ../../../LangRef.rst:3070
msgid ""
"If the operand bundle value violates any requirements on the attribute "
"value, the behavior is undefined, unless one of the following exceptions "
"applies:"
msgstr ""

#: ../../../LangRef.rst:3073
msgid ""
"``\"align\"`` operand bundles may specify a non-power-of-two alignment "
"(including a zero alignment). If this is the case, then the pointer value "
"must be a null pointer, otherwise the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:3077
msgid ""
"``dereferenceable(<n>)`` operand bundles only guarantee the pointer is "
"dereferenceable at the point of the assumption. The pointer may not be "
"dereferenceable at later pointers, e.g. because it could have been freed."
msgstr ""

#: ../../../LangRef.rst:3081
msgid ""
"In addition to allowing operand bundles encoding function and parameter "
"attributes, an assume operand bundle may also encode a ``separate_storage`` "
"operand bundle. This has the form:"
msgstr ""

#: ../../../LangRef.rst:3089
msgid ""
"This indicates that no pointer :ref:`based <pointeraliasing>` on one of its "
"arguments can alias any pointer based on the other."
msgstr ""

#: ../../../LangRef.rst:3092
msgid ""
"Even if the assumed property can be encoded as a boolean value, like "
"``nonnull``, using operand bundles to express the property can still have "
"benefits:"
msgstr ""

#: ../../../LangRef.rst:3096
msgid ""
"Attributes that can be expressed via operand bundles are directly the "
"property that the optimizer uses and cares about. Encoding attributes as "
"operand bundles removes the need for an instruction sequence that represents "
"the property (e.g., `icmp ne ptr %p, null` for `nonnull`) and for the "
"optimizer to deduce the property from that instruction sequence."
msgstr ""

#: ../../../LangRef.rst:3101
msgid ""
"Expressing the property using operand bundles makes it easy to identify the "
"use of the value as a use in an :ref:`llvm.assume <int_assume>`. This then "
"simplifies and improves heuristics, e.g., for use \"use-sensitive\" "
"optimizations."
msgstr ""

#: ../../../LangRef.rst:3109
msgid "Preallocated Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:3111
msgid ""
"Preallocated operand bundles are characterized by the ``\"preallocated\"`` "
"operand bundle tag.  These operand bundles allow separation of the "
"allocation of the call argument memory from the call site.  This is "
"necessary to pass non-trivially copyable objects by value in a way that is "
"compatible with MSVC on some targets.  There can be at most one "
"``\"preallocated\"`` operand bundle attached to a call site and it must have "
"exactly one bundle operand, which is a token generated by ``@llvm.call."
"preallocated.setup``.  A call with this operand bundle should not adjust the "
"stack before entering the function, as that will have been done by one of "
"the ``@llvm.call.preallocated.*`` intrinsics."
msgstr ""

#: ../../../LangRef.rst:3135
msgid "GC Live Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:3137
msgid ""
"A \"gc-live\" operand bundle is only valid on a :ref:`gc.statepoint "
"<gc_statepoint>` intrinsic. The operand bundle must contain every pointer to "
"a garbage collected object which potentially needs to be updated by the "
"garbage collector."
msgstr ""

#: ../../../LangRef.rst:3141
msgid ""
"When lowered, any relocated value will be recorded in the corresponding :ref:"
"`stackmap entry <statepoint-stackmap-format>`.  See the intrinsic "
"description for further details."
msgstr ""

#: ../../../LangRef.rst:3146
msgid "ObjC ARC Attached Call Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:3148
msgid ""
"A ``\"clang.arc.attachedcall\"`` operand bundle on a call indicates the call "
"is implicitly followed by a marker instruction and a call to an ObjC runtime "
"function that uses the result of the call. The operand bundle takes a "
"mandatory pointer to the runtime function "
"(``@objc_retainAutoreleasedReturnValue`` or "
"``@objc_unsafeClaimAutoreleasedReturnValue``). The return value of a call "
"with this bundle is used by a call to ``@llvm.objc.clang.arc.noop.use`` "
"unless the called function's return type is void, in which case the operand "
"bundle is ignored."
msgstr ""

#: ../../../LangRef.rst:3164
msgid ""
"The operand bundle is needed to ensure the call is immediately followed by "
"the marker instruction and the ObjC runtime call in the final output."
msgstr ""

#: ../../../LangRef.rst:3170
msgid "Pointer Authentication Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:3172
msgid ""
"Pointer Authentication operand bundles are characterized by the "
"``\"ptrauth\"`` operand bundle tag.  They are described in the `Pointer "
"Authentication <PointerAuth.html#operand-bundle>`__ document."
msgstr ""

#: ../../../LangRef.rst:3179
msgid "KCFI Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:3181
msgid ""
"A ``\"kcfi\"`` operand bundle on an indirect call indicates that the call "
"will be preceded by a runtime type check, which validates that the call "
"target is prefixed with a :ref:`type identifier<md_kcfi_type>` that matches "
"the operand bundle attribute. For example:"
msgstr ""

#: ../../../LangRef.rst:3190
msgid ""
"Clang emits KCFI operand bundles and the necessary metadata with ``-"
"fsanitize=kcfi``."
msgstr ""

#: ../../../LangRef.rst:3196
msgid "Convergence Control Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:3198
msgid ""
"A \"convergencectrl\" operand bundle is only valid on a ``convergent`` "
"operation. When present, the operand bundle must contain exactly one value "
"of token type. See the :doc:`ConvergentOperations` document for details."
msgstr ""

#: ../../../LangRef.rst:3205
msgid "Module-Level Inline Assembly"
msgstr ""

#: ../../../LangRef.rst:3207
msgid ""
"Modules may contain \"module-level inline asm\" blocks, which corresponds to "
"the GCC \"file scope inline asm\" blocks. These blocks are internally "
"concatenated by LLVM and treated as a single unit, but may be separated in "
"the ``.ll`` file if desired. The syntax is very simple:"
msgstr ""

#: ../../../LangRef.rst:3217
msgid ""
"The strings can contain any character by escaping non-printable characters. "
"The escape sequence used is simply \"\\\\xx\" where \"xx\" is the two digit "
"hex code for the number."
msgstr ""

#: ../../../LangRef.rst:3221
msgid ""
"Note that the assembly string *must* be parseable by LLVM's integrated "
"assembler (unless it is disabled), even when emitting a ``.s`` file."
msgstr ""

#: ../../../LangRef.rst:3227
msgid "Data Layout"
msgstr ""

#: ../../../LangRef.rst:3229
msgid ""
"A module may specify a target-specific data layout string that specifies how "
"data is to be laid out in memory. The syntax for the data layout is simply:"
msgstr ""

#: ../../../LangRef.rst:3237
msgid ""
"The *layout specification* consists of a list of specifications separated by "
"the minus sign character ('-'). Each specification starts with a letter and "
"may include other information after the letter to define some aspect of the "
"data layout. The specifications accepted are as follows:"
msgstr ""

#: ../../../LangRef.rst:3245
msgid "``E``"
msgstr ""

#: ../../../LangRef.rst:3244
msgid ""
"Specifies that the target lays out data in big-endian form. That is, the "
"bits with the most significance have the lowest address location."
msgstr ""

#: ../../../LangRef.rst:3249
msgid "``e``"
msgstr ""

#: ../../../LangRef.rst:3248
msgid ""
"Specifies that the target lays out data in little-endian form. That is, the "
"bits with the least significance have the lowest address location."
msgstr ""

#: ../../../LangRef.rst:3255
msgid "``S<size>``"
msgstr ""

#: ../../../LangRef.rst:3252
msgid ""
"Specifies the natural alignment of the stack in bits. Alignment promotion of "
"stack variables is limited to the natural stack alignment to avoid dynamic "
"stack realignment. If omitted, the natural stack alignment defaults to "
"\"unspecified\", which does not prevent any alignment promotions."
msgstr ""

#: ../../../LangRef.rst:3263
msgid "``P<address space>``"
msgstr ""

#: ../../../LangRef.rst:3258
msgid ""
"Specifies the address space that corresponds to program memory. Harvard "
"architectures can use this to specify what space LLVM should place things "
"such as functions into. If omitted, the program memory space defaults to the "
"default address space of 0, which corresponds to a Von Neumann architecture "
"that has code and data in the same space."
msgstr ""

#: ../../../LangRef.rst:3274
msgid "``G<address space>``"
msgstr ""

#: ../../../LangRef.rst:3268
msgid ""
"Specifies the address space to be used by default when creating global "
"variables. If omitted, the globals address space defaults to the default "
"address space 0. Note: variable declarations without an address space are "
"always created in address space 0, this property only affects the default "
"value to be used when creating globals without additional contextual "
"information (e.g. in LLVM passes)."
msgstr ""

#: ../../../LangRef.rst:3279
msgid "``A<address space>``"
msgstr ""

#: ../../../LangRef.rst:3279
msgid ""
"Specifies the address space of objects created by '``alloca``'. Defaults to "
"the default address space of 0."
msgstr ""

#: ../../../LangRef.rst:3300
msgid "``p[<flags>][<as>]:<size>:<abi>[:<pref>[:<idx>]]``"
msgstr ""

#: ../../../LangRef.rst:3282
msgid ""
"This specifies the properties of a pointer in address space ``as``. The "
"``<size>`` parameter specifies the size of the bitwise representation. For :"
"ref:`non-integral pointers <nointptrtype>` the representation size may be "
"larger than the address width of the underlying address space (e.g. to "
"accommodate additional metadata). The alignment requirements are specified "
"via the ``<abi>`` and ``<pref>``\\erred alignments parameters. The fourth "
"parameter ``<idx>`` is the size of the index that used for address "
"calculations such as :ref:`getelementptr <i_getelementptr>`. It must be less "
"than or equal to the pointer size. If not specified, the default index size "
"is equal to the pointer size. The index size also specifies the width of "
"addresses in this address space. All sizes are in bits. The address space, "
"``<as>``, is optional, and if not specified, denotes the default address "
"space 0. The value of ``<as>`` must be in the range [1,2^24). The optional "
"``<flags>`` are used to specify properties of pointers in this address "
"space: the character ``u`` marks pointers as having an unstable "
"representation, and ``e`` marks pointers having external state. See :ref:"
"`Non-Integral Pointer Types <nointptrtype>`."
msgstr ""

#: ../../../LangRef.rst:3305
msgid "``i<size>:<abi>[:<pref>]``"
msgstr ""

#: ../../../LangRef.rst:3303
msgid ""
"This specifies the alignment for an integer type of a given bit ``<size>``. "
"The value of ``<size>`` must be in the range [1,2^24). For ``i8``, the "
"``<abi>`` value must equal 8, that is, ``i8`` must be naturally aligned."
msgstr ""

#: ../../../LangRef.rst:3308
msgid "``v<size>:<abi>[:<pref>]``"
msgstr ""

#: ../../../LangRef.rst:3308
msgid ""
"This specifies the alignment for a vector type of a given bit ``<size>``. "
"The value of ``<size>`` must be in the range [1,2^24)."
msgstr ""

#: ../../../LangRef.rst:3314
msgid "``f<size>:<abi>[:<pref>]``"
msgstr ""

#: ../../../LangRef.rst:3311
msgid ""
"This specifies the alignment for a floating-point type of a given bit "
"``<size>``. Only values of ``<size>`` that are supported by the target will "
"work. 32 (float) and 64 (double) are supported on all targets; 80 or 128 "
"(different flavors of long double) are also supported on some targets. The "
"value of ``<size>`` must be in the range [1,2^24)."
msgstr ""

#: ../../../LangRef.rst:3318
msgid "``a:<abi>[:<pref>]``"
msgstr ""

#: ../../../LangRef.rst:3317
msgid ""
"This specifies the alignment for an object of aggregate type. In addition to "
"the usual requirements for alignment values, the value of ``<abi>`` can also "
"be zero, which means one byte alignment."
msgstr ""

#: ../../../LangRef.rst:3326
msgid "``F<type><abi>``"
msgstr ""

#: ../../../LangRef.rst:3321
msgid ""
"This specifies the alignment for function pointers. The options for "
"``<type>`` are:"
msgstr ""

#: ../../../LangRef.rst:3324
msgid ""
"``i``: The alignment of function pointers is independent of the alignment of "
"functions, and is a multiple of ``<abi>``."
msgstr ""

#: ../../../LangRef.rst:3326
msgid ""
"``n``: The alignment of function pointers is a multiple of the explicit "
"alignment specified on the function, and is a multiple of ``<abi>``."
msgstr ""

#: ../../../LangRef.rst:3345
msgid "``m:<mangling>``"
msgstr ""

#: ../../../LangRef.rst:3329
msgid ""
"If present, specifies that llvm names are mangled in the output. Symbols "
"prefixed with the mangling escape character ``\\01`` are passed through "
"directly to the assembler without the escape character. The mangling style "
"options are"
msgstr ""

#: ../../../LangRef.rst:3334
msgid "``e``: ELF mangling: Private symbols get a ``.L`` prefix."
msgstr ""

#: ../../../LangRef.rst:3335
msgid "``l``: GOFF mangling: Private symbols get a ``@`` prefix."
msgstr ""

#: ../../../LangRef.rst:3336
msgid "``m``: Mips mangling: Private symbols get a ``$`` prefix."
msgstr ""

#: ../../../LangRef.rst:3337
msgid ""
"``o``: Mach-O mangling: Private symbols get ``L`` prefix. Other symbols get "
"a ``_`` prefix."
msgstr ""

#: ../../../LangRef.rst:3339
msgid ""
"``x``: Windows x86 COFF mangling: Private symbols get the usual prefix. "
"Regular C symbols get a ``_`` prefix. Functions with ``__stdcall``, "
"``__fastcall``, and ``__vectorcall`` have custom mangling that appends "
"``@N`` where N is the number of bytes used to pass parameters. C++ symbols "
"starting with ``?`` are not mangled in any way."
msgstr ""

#: ../../../LangRef.rst:3344
msgid ""
"``w``: Windows COFF mangling: Similar to ``x``, except that normal C symbols "
"do not receive a ``_`` prefix."
msgstr ""

#: ../../../LangRef.rst:3346
msgid "``a``: XCOFF mangling: Private symbols get a ``L..`` prefix."
msgstr ""

#: ../../../LangRef.rst:3351
msgid "``n<size1>:<size2>:<size3>...``"
msgstr ""

#: ../../../LangRef.rst:3348
msgid ""
"This specifies a set of native integer widths for the target CPU in bits. "
"For example, it might contain ``n32`` for 32-bit PowerPC, ``n32:64`` for "
"PowerPC 64, or ``n8:16:32:64`` for X86-64. Elements of this set are "
"considered to support most general arithmetic operations efficiently."
msgstr ""

#: ../../../LangRef.rst:3358
msgid "``ni:<address space0>:<address space1>:<address space2>...``"
msgstr ""

#: ../../../LangRef.rst:3354
msgid ""
"This marks pointer types with the specified address spaces as :ref:`unstable "
"<nointptrtype>`. The ``0`` address space cannot be specified as non-"
"integral. It is only supported for backwards compatibility, the flags of the "
"``p`` specifier should be used instead for new code."
msgstr ""

#: ../../../LangRef.rst:3360
msgid ""
"``<abi>`` is a lower bound on what is required for a type to be considered "
"aligned. This is used in various places, such as:"
msgstr ""

#: ../../../LangRef.rst:3363
msgid "The alignment for loads and stores if none is explicitly given."
msgstr ""

#: ../../../LangRef.rst:3364
msgid "The alignment used to compute struct layout."
msgstr ""

#: ../../../LangRef.rst:3365
msgid ""
"The alignment used to compute allocation sizes and thus ``getelementptr`` "
"offsets."
msgstr ""

#: ../../../LangRef.rst:3367
msgid "The alignment below which accesses are considered underaligned."
msgstr ""

#: ../../../LangRef.rst:3369
msgid ""
"``<pref>`` allows providing a more optimal alignment that should be used "
"when possible, primarily for ``alloca`` and the alignment of global "
"variables. It is an optional value that must be greater than or equal to "
"``<abi>``. If omitted, the preceding ``:`` should also be omitted and "
"``<pref>`` will be equal to ``<abi>``."
msgstr ""

#: ../../../LangRef.rst:3375
msgid ""
"Unless explicitly stated otherwise, every alignment specification is "
"provided in bits and must be in the range [1,2^16). The value must be a "
"power of two times the width of a byte (i.e., ``align = 8 * 2^N``)."
msgstr ""

#: ../../../LangRef.rst:3379
msgid ""
"When constructing the data layout for a given target, LLVM starts with a "
"default set of specifications which are then (possibly) overridden by the "
"specifications in the ``datalayout`` keyword. The default specifications are "
"given in this list:"
msgstr ""

#: ../../../LangRef.rst:3384
msgid "``e`` - little endian"
msgstr ""

#: ../../../LangRef.rst:3385
msgid "``p:64:64:64`` - 64-bit pointers with 64-bit alignment."
msgstr ""

#: ../../../LangRef.rst:3386
msgid ""
"``p[n]:64:64:64`` - Other address spaces are assumed to be the same as the "
"default address space."
msgstr ""

#: ../../../LangRef.rst:3388
msgid "``S0`` - natural stack alignment is unspecified"
msgstr ""

#: ../../../LangRef.rst:3389
msgid "``i8:8:8`` - i8 is 8-bit (byte) aligned as mandated"
msgstr ""

#: ../../../LangRef.rst:3390
msgid "``i16:16:16`` - i16 is 16-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3391
msgid "``i32:32:32`` - i32 is 32-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3392
msgid ""
"``i64:32:64`` - i64 has ABI alignment of 32-bits but preferred alignment of "
"64-bits"
msgstr ""

#: ../../../LangRef.rst:3394
msgid "``f16:16:16`` - half is 16-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3395
msgid "``f32:32:32`` - float is 32-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3396
msgid "``f64:64:64`` - double is 64-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3397
msgid "``f128:128:128`` - quad is 128-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3398
msgid "``v64:64:64`` - 64-bit vector is 64-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3399
msgid "``v128:128:128`` - 128-bit vector is 128-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3400
msgid "``a:0:64`` - aggregates are 64-bit aligned"
msgstr ""

#: ../../../LangRef.rst:3402
msgid ""
"When LLVM is determining the alignment for a given type, it uses the "
"following rules:"
msgstr ""

#: ../../../LangRef.rst:3405
msgid ""
"If the type sought is an exact match for one of the specifications, that "
"specification is used."
msgstr ""

#: ../../../LangRef.rst:3407
msgid ""
"If no match is found, and the type sought is an integer type, then the "
"smallest integer type that is larger than the bitwidth of the sought type is "
"used. If none of the specifications are larger than the bitwidth then the "
"largest integer type is used. For example, given the default specifications "
"above, the i7 type will use the alignment of i8 (next largest) while both "
"i65 and i256 will use the alignment of i64 (largest specified)."
msgstr ""

#: ../../../LangRef.rst:3415
msgid ""
"The function of the data layout string may not be what you expect. Notably, "
"this is not a specification from the frontend of what alignment the code "
"generator should use."
msgstr ""

#: ../../../LangRef.rst:3419
msgid ""
"Instead, if specified, the target data layout is required to match what the "
"ultimate *code generator* expects. This string is used by the mid-level "
"optimizers to improve code, and this only works if it matches what the "
"ultimate code generator uses. There is no way to generate IR that does not "
"embed this target-specific detail into the IR. If you don't specify the "
"string, the default specifications will be used to generate a Data Layout "
"and the optimization phases will operate accordingly and introduce target "
"specificity into the IR with respect to these default specifications."
msgstr ""

#: ../../../LangRef.rst:3432
msgid "Target Triple"
msgstr ""

#: ../../../LangRef.rst:3434
msgid ""
"A module may specify a target triple string that describes the target host. "
"The syntax for the target triple is simply:"
msgstr ""

#: ../../../LangRef.rst:3441
msgid ""
"The *target triple* string consists of a series of identifiers delimited by "
"the minus sign character ('-'). The canonical forms are:"
msgstr ""

#: ../../../LangRef.rst:3449
msgid ""
"This information is passed along to the backend so that it generates code "
"for the proper architecture. It's possible to override this on the command "
"line with the ``-mtriple`` command-line option."
msgstr ""

#: ../../../LangRef.rst:3457
msgid "Allocated Objects"
msgstr ""

#: ../../../LangRef.rst:3459
msgid ""
"An allocated object, memory object, or simply object, is a region of a "
"memory space that is reserved by a memory allocation such as :ref:`alloca "
"<i_alloca>`, heap allocation calls, and global variable definitions. Once it "
"is allocated, the bytes stored in the region can only be read or written "
"through a pointer that is :ref:`based on <pointeraliasing>` the allocation "
"value. If a pointer that is not based on the object tries to read or write "
"to the object, it is undefined behavior."
msgstr ""

#: ../../../LangRef.rst:3467
msgid ""
"The following properties hold for all allocated objects, otherwise the "
"behavior is undefined:"
msgstr ""

#: ../../../LangRef.rst:3470
msgid ""
"no allocated object may cross the unsigned address space boundary (including "
"the pointer after the end of the object),"
msgstr ""

#: ../../../LangRef.rst:3472
msgid ""
"the size of all allocated objects must be non-negative and not exceed the "
"largest signed integer that fits into the index type."
msgstr ""

#: ../../../LangRef.rst:3475
msgid ""
"Allocated objects that are created with operations recognized by LLVM (such "
"as :ref:`alloca <i_alloca>`, heap allocation functions marked as such, and "
"global variables) may *not* change their size. (``realloc``-style operations "
"do not change the size of an existing allocated object; instead, they create "
"a new allocated object. Even if the object is at the same location as the "
"old one, old pointers cannot be used to access this new object.) However, "
"allocated objects can also be created by means not recognized by LLVM, e.g. "
"by directly calling ``mmap``. Those allocated objects are allowed to grow to "
"the right (i.e., keeping the same base address, but increasing their size) "
"while maintaining the validity of existing pointers, as long as they always "
"satisfy the properties described above. Currently, allocated objects are not "
"permitted to grow to the left or to shrink, nor can they have holes."
msgstr ""

#: ../../../LangRef.rst:3491
msgid "Object Lifetime"
msgstr ""

#: ../../../LangRef.rst:3493
msgid ""
"A lifetime of an :ref:`allocated object<allocatedobjects>` is a property "
"that decides its accessibility. Unless stated otherwise, an allocated object "
"is alive since its allocation, and dead after its deallocation. It is "
"undefined behavior to access an allocated object that isn't alive, but "
"operations that don't dereference it such as :ref:`getelementptr "
"<i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and :ref:`icmp <i_icmp>` "
"return a valid result. This explains code motion of these instructions "
"across operations that impact the object's lifetime. A stack object's "
"lifetime can be explicitly specified using :ref:`llvm.lifetime.start "
"<int_lifestart>` and :ref:`llvm.lifetime.end <int_lifeend>` intrinsic "
"function calls."
msgstr ""

#: ../../../LangRef.rst:3504
msgid ""
"As an exception to the above, loading from a stack object outside its "
"lifetime is not undefined behavior and returns a poison value instead. "
"Storing to it is still undefined behavior."
msgstr ""

#: ../../../LangRef.rst:3511
msgid "Pointer Aliasing Rules"
msgstr ""

#: ../../../LangRef.rst:3513
msgid ""
"Any memory access must be done through a pointer value associated with an "
"address range of the memory access, otherwise the behavior is undefined. "
"Pointer values are associated with address ranges according to the following "
"rules:"
msgstr ""

#: ../../../LangRef.rst:3518
msgid ""
"A pointer value is associated with the addresses associated with any value "
"it is *based* on."
msgstr ""

#: ../../../LangRef.rst:3520
msgid ""
"An address of a global variable is associated with the address range of the "
"variable's storage."
msgstr ""

#: ../../../LangRef.rst:3522
msgid ""
"The result value of an allocation instruction is associated with the address "
"range of the allocated storage."
msgstr ""

#: ../../../LangRef.rst:3524
msgid ""
"A null pointer in the default address-space is associated with no address."
msgstr ""

#: ../../../LangRef.rst:3526
msgid ""
"An :ref:`undef value <undefvalues>` in *any* address-space is associated "
"with no address."
msgstr ""

#: ../../../LangRef.rst:3528
msgid ""
"An integer constant other than zero or a pointer value returned from a "
"function not defined within LLVM may be associated with address ranges "
"allocated through mechanisms other than those provided by LLVM. Such ranges "
"shall not overlap with any ranges of addresses allocated by mechanisms "
"provided by LLVM."
msgstr ""

#: ../../../LangRef.rst:3534
msgid ""
"A pointer value is *based* on another pointer value according to the "
"following rules:"
msgstr ""

#: ../../../LangRef.rst:3537
msgid ""
"A pointer value formed from a scalar ``getelementptr`` operation is *based* "
"on the pointer-typed operand of the ``getelementptr``."
msgstr ""

#: ../../../LangRef.rst:3539
msgid ""
"The pointer in lane *l* of the result of a vector ``getelementptr`` "
"operation is *based* on the pointer in lane *l* of the vector-of-pointers-"
"typed operand of the ``getelementptr``."
msgstr ""

#: ../../../LangRef.rst:3542
msgid ""
"The result value of a ``bitcast`` is *based* on the operand of the "
"``bitcast``."
msgstr ""

#: ../../../LangRef.rst:3544
msgid ""
"A pointer value formed by an ``inttoptr`` is *based* on all pointer values "
"that contribute (directly or indirectly) to the computation of the pointer's "
"value."
msgstr ""

#: ../../../LangRef.rst:3547
msgid "The \"*based* on\" relationship is transitive."
msgstr ""

#: ../../../LangRef.rst:3549
msgid ""
"Note that this definition of *\"based\"* is intentionally similar to the "
"definition of *\"based\"* in C99, though it is slightly weaker."
msgstr ""

#: ../../../LangRef.rst:3552
msgid ""
"LLVM IR does not associate types with memory. The result type of a ``load`` "
"merely indicates the size and alignment of the memory from which to load, as "
"well as the interpretation of the value. The first operand type of a "
"``store`` similarly only indicates the size and alignment of the store."
msgstr ""

#: ../../../LangRef.rst:3558
msgid ""
"Consequently, type-based alias analysis, aka TBAA, aka ``-fstrict-"
"aliasing``, is not applicable to general unadorned LLVM IR. :ref:`Metadata "
"<metadata>` may be used to encode additional information which specialized "
"optimization passes may use to implement type-based alias analysis."
msgstr ""

#: ../../../LangRef.rst:3567
msgid "Pointer Capture"
msgstr ""

#: ../../../LangRef.rst:3569
msgid ""
"Given a function call and a pointer that is passed as an argument or stored "
"in memory before the call, the call may capture two components of the "
"pointer:"
msgstr ""

#: ../../../LangRef.rst:3572
msgid ""
"The address of the pointer, which is its integral value. This also includes "
"parts of the address or any information about the address, including the "
"fact that it does not equal one specific value. We further distinguish "
"whether only the fact that the address is/isn't null is captured."
msgstr ""

#: ../../../LangRef.rst:3576
msgid ""
"The provenance of the pointer, which is the ability to perform memory "
"accesses through the pointer, in the sense of the :ref:`pointer aliasing "
"rules <pointeraliasing>`. We further distinguish whether only read accesses "
"are allowed, or both reads and writes."
msgstr ""

#: ../../../LangRef.rst:3581
msgid ""
"For example, the following function captures the address of ``%a``, because "
"it is compared to a pointer, leaking information about the identity of the "
"pointer:"
msgstr ""

#: ../../../LangRef.rst:3594
msgid ""
"The function does not capture the provenance of the pointer, because the "
"``icmp`` instruction only operates on the pointer address. The following "
"function captures both the address and provenance of the pointer, as both "
"may be read from ``@glb`` after the function returns:"
msgstr ""

#: ../../../LangRef.rst:3608
msgid ""
"The following function captures *neither* the address nor the provenance of "
"the pointer:"
msgstr ""

#: ../../../LangRef.rst:3618
msgid ""
"While address capture includes uses of the address within the body of the "
"function, provenance capture refers exclusively to the ability to perform "
"accesses *after* the function returns. Memory accesses within the function "
"itself are not considered pointer captures."
msgstr ""

#: ../../../LangRef.rst:3623
msgid ""
"We can further say that the capture only occurs through a specific location. "
"In the following example, the pointer (both address and provenance) is "
"captured through the return value only:"
msgstr ""

#: ../../../LangRef.rst:3634
msgid ""
"However, we always consider direct inspection of the pointer address (e.g. "
"using ``ptrtoint``) to be location-independent. The following example is "
"*not* considered a return-only capture, even though the ``ptrtoint`` "
"ultimately only contributes to the return value:"
msgstr ""

#: ../../../LangRef.rst:3650
msgid ""
"This definition is chosen to allow capture analysis to continue with the "
"return value in the usual fashion."
msgstr ""

#: ../../../LangRef.rst:3653
msgid ""
"The following describes possible ways to capture a pointer in more detail, "
"where unqualified uses of the word \"capture\" refer to capturing both "
"address and provenance."
msgstr ""

#: ../../../LangRef.rst:3657
msgid ""
"The call stores any bit of the pointer carrying information into a place, "
"and the stored bits can be read from the place by the caller after this call "
"exits."
msgstr ""

#: ../../../LangRef.rst:3685
msgid ""
"The call stores any bit of the pointer carrying information into a place, "
"and the stored bits can be safely read from the place by another thread via "
"synchronization."
msgstr ""

#: ../../../LangRef.rst:3700
msgid ""
"The call's behavior depends on any bit of the pointer carrying information "
"(address capture only)."
msgstr ""

#: ../../../LangRef.rst:3717
msgid "The pointer is used as the pointer operand of a volatile access."
msgstr ""

#: ../../../LangRef.rst:3722
msgid "Volatile Memory Accesses"
msgstr ""

#: ../../../LangRef.rst:3724
msgid ""
"Certain memory accesses, such as :ref:`load <i_load>`'s, :ref:`store "
"<i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be marked "
"``volatile``. The optimizers must not change the number of volatile "
"operations or change their order of execution relative to other volatile "
"operations. The optimizers *may* change the order of volatile operations "
"relative to non-volatile operations. This is not Java's \"volatile\" and has "
"no cross-thread synchronization behavior."
msgstr ""

#: ../../../LangRef.rst:3732
msgid ""
"A volatile load or store may have additional target-specific semantics. Any "
"volatile operation can have side effects, and any volatile operation can "
"read and/or modify state which is not accessible via a regular load or store "
"in this module. Volatile operations may use addresses which do not point to "
"memory (like MMIO registers). This means the compiler may not use a volatile "
"operation to prove a non-volatile access to that address has defined "
"behavior. This includes addresses typically forbidden, such as the pointer "
"with bit-value 0."
msgstr ""

#: ../../../LangRef.rst:3741
msgid ""
"The allowed side-effects for volatile accesses are limited.  If a non-"
"volatile store to a given address would be legal, a volatile operation may "
"modify the memory at that address. A volatile operation may not modify any "
"other memory accessible by the module being compiled. A volatile operation "
"may not call any code in the current module."
msgstr ""

#: ../../../LangRef.rst:3747
msgid ""
"In general (without target-specific context), the address space of a "
"volatile operation may not be changed. Different address spaces may have "
"different trapping behavior when dereferencing an invalid pointer."
msgstr ""

#: ../../../LangRef.rst:3752
msgid ""
"The compiler may assume execution will continue after a volatile operation, "
"so operations which modify memory or may have undefined behavior can be "
"hoisted past a volatile operation."
msgstr ""

#: ../../../LangRef.rst:3756
msgid ""
"As an exception to the preceding rule, the compiler may not assume execution "
"will continue after a volatile store operation. This restriction is "
"necessary to support the somewhat common pattern in C of intentionally "
"storing to an invalid pointer to crash the program. In the future, it might "
"make sense to allow frontends to control this behavior."
msgstr ""

#: ../../../LangRef.rst:3762
msgid ""
"IR-level volatile loads and stores cannot safely be optimized into ``llvm."
"memcpy`` or ``llvm.memmove`` intrinsics even when those intrinsics are "
"flagged volatile. Likewise, the backend should never split or merge target-"
"legal volatile load/store instructions. Similarly, IR-level volatile loads "
"and stores cannot change from integer to floating-point or vice versa."
msgstr ""

#: ../../../LangRef.rst:3768
msgid "Rationale"
msgstr ""

#: ../../../LangRef.rst:3770
msgid ""
"Platforms may rely on volatile loads and stores of natively supported data "
"width to be executed as single instruction. For example, in C this holds for "
"an l-value of volatile primitive type with native hardware support, but not "
"necessarily for aggregate types. The frontend upholds these expectations, "
"which are intentionally unspecified in the IR. The rules above ensure that "
"IR transformations do not violate the frontend's contract with the language."
msgstr ""

#: ../../../LangRef.rst:3781
msgid "Memory Model for Concurrent Operations"
msgstr ""

#: ../../../LangRef.rst:3783
msgid ""
"The LLVM IR does not define any way to start parallel threads of execution "
"or to register signal handlers. Nonetheless, there are platform-specific "
"ways to create them, and we define LLVM IR's behavior in their presence. "
"This model is inspired by the C++ memory model."
msgstr ""

#: ../../../LangRef.rst:3788
msgid "For a more informal introduction to this model, see the :doc:`Atomics`."
msgstr ""

#: ../../../LangRef.rst:3790
msgid ""
"We define a *happens-before* partial order as the least partial order that"
msgstr ""

#: ../../../LangRef.rst:3793
msgid "Is a superset of single-thread program order, and"
msgstr ""

#: ../../../LangRef.rst:3794
msgid ""
"When ``a`` *synchronizes-with* ``b``, includes an edge from ``a`` to ``b``. "
"*Synchronizes-with* pairs are introduced by platform-specific techniques, "
"like pthread locks, thread creation, thread joining, etc., and by atomic "
"instructions. (See also :ref:`Atomic Memory Ordering Constraints "
"<ordering>`)."
msgstr ""

#: ../../../LangRef.rst:3800
msgid ""
"Note that program order does not introduce *happens-before* edges between a "
"thread and signals executing inside that thread."
msgstr ""

#: ../../../LangRef.rst:3803
msgid ""
"Every (defined) read operation (load instructions, memcpy, atomic loads/read-"
"modify-writes, etc.) R reads a series of bytes written by (defined) write "
"operations (store instructions, atomic stores/read-modify-writes, memcpy, "
"etc.). For the purposes of this section, initialized globals are considered "
"to have a write of the initializer which is atomic and happens before any "
"other read or write of the memory in question. For each byte of a read R, "
"R\\ :sub:`byte` may see any write to the same byte, except:"
msgstr ""

#: ../../../LangRef.rst:3812
msgid ""
"If write\\ :sub:`1`  happens before write\\ :sub:`2`, and write\\ :sub:`2` "
"happens before R\\ :sub:`byte`, then R\\ :sub:`byte` does not see write\\ :"
"sub:`1`."
msgstr ""

#: ../../../LangRef.rst:3815
msgid ""
"If R\\ :sub:`byte` happens before write\\ :sub:`3`, then R\\ :sub:`byte` "
"does not see write\\ :sub:`3`."
msgstr ""

#: ../../../LangRef.rst:3818
msgid "Given that definition, R\\ :sub:`byte` is defined as follows:"
msgstr ""

#: ../../../LangRef.rst:3820
msgid ""
"If R is volatile, the result is target-dependent. (Volatile is supposed to "
"give guarantees which can support ``sig_atomic_t`` in C/C++, and may be used "
"for accesses to addresses that do not behave like normal memory. It does not "
"generally provide cross-thread synchronization.)"
msgstr ""

#: ../../../LangRef.rst:3825
msgid ""
"Otherwise, if there is no write to the same byte that happens before R\\ :"
"sub:`byte`, R\\ :sub:`byte` returns ``undef`` for that byte."
msgstr ""

#: ../../../LangRef.rst:3827
msgid ""
"Otherwise, if R\\ :sub:`byte` may see exactly one write, R\\ :sub:`byte` "
"returns the value written by that write."
msgstr ""

#: ../../../LangRef.rst:3829
msgid ""
"Otherwise, if R is atomic, and all the writes R\\ :sub:`byte` may see are "
"atomic, it chooses one of the values written. See the :ref:`Atomic Memory "
"Ordering Constraints <ordering>` section for additional constraints on how "
"the choice is made."
msgstr ""

#: ../../../LangRef.rst:3833
msgid "Otherwise R\\ :sub:`byte` returns ``undef``."
msgstr ""

#: ../../../LangRef.rst:3835
msgid ""
"R returns the value composed of the series of bytes it read. This implies "
"that some bytes within the value may be ``undef`` **without** the entire "
"value being ``undef``. Note that this only defines the semantics of the "
"operation; it doesn't mean that targets will emit more than one instruction "
"to read the series of bytes."
msgstr ""

#: ../../../LangRef.rst:3841
msgid ""
"Note that in cases where none of the atomic intrinsics are used, this model "
"places only one restriction on IR transformations on top of what is required "
"for single-threaded execution: introducing a store to a byte which might not "
"otherwise be stored is not allowed in general. (Specifically, in the case "
"where another thread might write to and read from an address, introducing a "
"store can change a load that may see exactly one write into a load that may "
"see multiple writes.)"
msgstr ""

#: ../../../LangRef.rst:3852
msgid "Atomic Memory Ordering Constraints"
msgstr ""

#: ../../../LangRef.rst:3854
msgid ""
"Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`, :ref:`atomicrmw "
"<i_atomicrmw>`, :ref:`fence <i_fence>`, :ref:`atomic load <i_load>`, and :"
"ref:`atomic store <i_store>`) take ordering parameters that determine which "
"other atomic instructions on the same address they *synchronize with*. These "
"semantics implement the Java or C++ memory models; if these descriptions "
"aren't precise enough, check those specs (see spec references in the :doc:"
"`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions treat these "
"orderings somewhat differently since they don't take an address. See that "
"instruction's documentation for details."
msgstr ""

#: ../../../LangRef.rst:3865
msgid ""
"For a simpler introduction to the ordering constraints, see the :doc:"
"`Atomics`."
msgstr ""

#: ../../../LangRef.rst:3873
msgid "``unordered``"
msgstr ""

#: ../../../LangRef.rst:3869
msgid ""
"The set of values that can be read is governed by the happens-before partial "
"order. A value cannot be read unless some operation wrote it. This is "
"intended to provide a guarantee strong enough to model Java's non-volatile "
"shared variables. This ordering cannot be specified for read-modify-write "
"operations; it is not strong enough to make them atomic in any interesting "
"way."
msgstr ""

#: ../../../LangRef.rst:3890
msgid "``monotonic``"
msgstr ""

#: ../../../LangRef.rst:3876
msgid ""
"In addition to the guarantees of ``unordered``, there is a single total "
"order for modifications by ``monotonic`` operations on each address. All "
"modification orders must be compatible with the happens-before order. There "
"is no guarantee that the modification orders can be combined to a global "
"total order for the whole program (and this often will not be possible). The "
"read in an atomic read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` "
"and :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification "
"order immediately before the value it writes. If one atomic read happens "
"before another atomic read of the same address, the later read must see the "
"same value or a later value in the address's modification order. This "
"disallows reordering of ``monotonic`` (or stronger) operations on the same "
"address. If an address is written ``monotonic``-ally by one thread, and "
"other threads ``monotonic``-ally read that address repeatedly, the other "
"threads must eventually see the write. This corresponds to the C/C++ "
"``memory_order_relaxed``."
msgstr ""

#: ../../../LangRef.rst:3894
msgid "``acquire``"
msgstr ""

#: ../../../LangRef.rst:3893
msgid ""
"In addition to the guarantees of ``monotonic``, a *synchronizes-with* edge "
"may be formed with a ``release`` operation. This is intended to model C/C+"
"+'s ``memory_order_acquire``."
msgstr ""

#: ../../../LangRef.rst:3903
msgid "``release``"
msgstr ""

#: ../../../LangRef.rst:3897
msgid ""
"In addition to the guarantees of ``monotonic``, if this operation writes a "
"value which is subsequently read by an ``acquire`` operation, it "
"*synchronizes-with* that operation. Furthermore, this occurs even if the "
"value written by a ``release`` operation has been modified by a read-modify-"
"write operation before being read. (Such a set of operations comprises a "
"*release sequence*). This corresponds to the C/C++ ``memory_order_release``."
msgstr ""

#: ../../../LangRef.rst:3906
msgid "``acq_rel`` (acquire+release)"
msgstr ""

#: ../../../LangRef.rst:3906
msgid ""
"Acts as both an ``acquire`` and ``release`` operation on its address. This "
"corresponds to the C/C++ ``memory_order_acq_rel``."
msgstr ""

#: ../../../LangRef.rst:3921
msgid "``seq_cst`` (sequentially consistent)"
msgstr ""

#: ../../../LangRef.rst:3909
msgid ""
"In addition to the guarantees of ``acq_rel`` (``acquire`` for an operation "
"that only reads, ``release`` for an operation that only writes), there is a "
"global total order on all sequentially-consistent operations on all "
"addresses. Each sequentially-consistent read sees the last preceding write "
"to the same address in this global order. This corresponds to the C/C++ "
"``memory_order_seq_cst`` and Java ``volatile``."
msgstr ""

#: ../../../LangRef.rst:3917
msgid ""
"Note: this global total order is *not* guaranteed to be fully consistent "
"with the *happens-before* partial order if non-``seq_cst`` accesses are "
"involved. See the C++ standard `[atomics.order] <https://wg21.link/atomics."
"order>`_ section for more details on the exact guarantees."
msgstr ""

#: ../../../LangRef.rst:3925
msgid ""
"If an atomic operation is marked ``syncscope(\"singlethread\")``, it only "
"*synchronizes with* and only participates in the seq\\_cst total orderings "
"of other operations running in the same thread (for example, in signal "
"handlers)."
msgstr ""

#: ../../../LangRef.rst:3929
msgid ""
"If an atomic operation is marked ``syncscope(\"<target-scope>\")``, where "
"``<target-scope>`` is a target-specific synchronization scope, then it is "
"target dependent if it *synchronizes with* and participates in the seq\\_cst "
"total orderings of other operations."
msgstr ""

#: ../../../LangRef.rst:3934
msgid ""
"Otherwise, an atomic operation that is not marked "
"``syncscope(\"singlethread\")`` or ``syncscope(\"<target-scope>\")`` "
"*synchronizes with* and participates in the seq\\_cst total orderings of "
"other operations that are not marked ``syncscope(\"singlethread\")`` or "
"``syncscope(\"<target-scope>\")``."
msgstr ""

#: ../../../LangRef.rst:3942
msgid "Floating-Point Environment"
msgstr ""

#: ../../../LangRef.rst:3944
msgid ""
"The default LLVM floating-point environment assumes that traps are disabled "
"and status flags are not observable. Therefore, floating-point math "
"operations do not have side effects and may be speculated freely. Results "
"assume the round-to-nearest rounding mode, and subnormals are assumed to be "
"preserved."
msgstr ""

#: ../../../LangRef.rst:3949
msgid ""
"Running LLVM code in an environment where these assumptions are not met "
"typically leads to undefined behavior. The ``strictfp`` and ``denormal-fp-"
"math`` attributes as well as :ref:`Constrained Floating-Point Intrinsics "
"<constrainedfp>` can be used to weaken LLVM's assumptions and ensure defined "
"behavior in non-default floating-point environments; see their respective "
"documentation for details."
msgstr ""

#: ../../../LangRef.rst:3959
msgid "Behavior of Floating-Point NaN values"
msgstr ""

#: ../../../LangRef.rst:3961
msgid ""
"A floating-point NaN value consists of a sign bit, a quiet/signaling bit, "
"and a payload (which makes up the rest of the mantissa except for the quiet/"
"signaling bit). LLVM assumes that the quiet/signaling bit being set to ``1`` "
"indicates a quiet NaN (QNaN), and a value of ``0`` indicates a signaling NaN "
"(SNaN). In the following we will hence just call it the \"quiet bit\"."
msgstr ""

#: ../../../LangRef.rst:3967
msgid ""
"The representation bits of a floating-point value do not mutate arbitrarily; "
"in particular, if there is no floating-point operation being performed, NaN "
"signs, quiet bits, and payloads are preserved."
msgstr ""

#: ../../../LangRef.rst:3971
msgid ""
"For the purpose of this section, ``bitcast`` as well as the following "
"operations are not \"floating-point math operations\": ``fneg``, ``llvm."
"fabs``, and ``llvm.copysign``. These operations act directly on the "
"underlying bit representation and never change anything except possibly for "
"the sign bit."
msgstr ""

#: ../../../LangRef.rst:3976
msgid ""
"Floating-point math operations that return a NaN are an exception from the "
"general principle that LLVM implements IEEE-754 semantics. Unless specified "
"otherwise, the following rules apply whenever the IEEE-754 semantics say "
"that a NaN value is returned: the result has a non-deterministic sign; the "
"quiet bit and payload are non-deterministically chosen from the following "
"set of options:"
msgstr ""

#: ../../../LangRef.rst:3982
msgid ""
"The quiet bit is set and the payload is all-zero. (\"Preferred NaN\" case)"
msgstr ""

#: ../../../LangRef.rst:3983
msgid ""
"The quiet bit is set and the payload is copied from any input operand that "
"is a NaN. (\"Quieting NaN propagation\" case)"
msgstr ""

#: ../../../LangRef.rst:3985
msgid ""
"The quiet bit and payload are copied from any input operand that is a NaN. "
"(\"Unchanged NaN propagation\" case)"
msgstr ""

#: ../../../LangRef.rst:3987
msgid ""
"The quiet bit is set and the payload is picked from a target-specific set of "
"\"extra\" possible NaN payloads. The set can depend on the input operand "
"values. This set is empty on x86 and ARM, but can be non-empty on other "
"architectures. (For instance, on wasm, if any input NaN does not have the "
"preferred all-zero payload or any input NaN is an SNaN, then this set "
"contains all possible payloads; otherwise, it is empty. On SPARC, this set "
"consists of the all-one payload.)"
msgstr ""

#: ../../../LangRef.rst:3995
msgid ""
"In particular, if all input NaNs are quiet (or if there are no input NaNs), "
"then the output NaN is definitely quiet. Signaling NaN outputs can only "
"occur if they are provided as an input value. For example, \"fmul SNaN, "
"1.0\" may be simplified to SNaN rather than QNaN. Similarly, if all input "
"NaNs are preferred (or if there are no input NaNs) and the target does not "
"have any \"extra\" NaN payloads, then the output NaN is guaranteed to be "
"preferred."
msgstr ""

#: ../../../LangRef.rst:4002
msgid ""
"Floating-point math operations are allowed to treat all NaNs as if they were "
"quiet NaNs. For example, \"pow(1.0, SNaN)\" may be simplified to 1.0."
msgstr ""

#: ../../../LangRef.rst:4005
msgid ""
"Code that requires different behavior than this should use the :ref:"
"`Constrained Floating-Point Intrinsics <constrainedfp>`. In particular, "
"constrained intrinsics rule out the \"Unchanged NaN propagation\" case; they "
"are guaranteed to return a QNaN."
msgstr ""

#: ../../../LangRef.rst:4010
msgid ""
"Unfortunately, due to hard-or-impossible-to-fix issues, LLVM violates its "
"own specification on some architectures:"
msgstr ""

#: ../../../LangRef.rst:4013
msgid ""
"x86-32 without SSE2 enabled may convert floating-point values to x86_fp80 "
"and back when performing floating-point math operations; this can lead to "
"results with different precision than expected and it can alter NaN values. "
"Since optimizations can make contradicting assumptions, this can lead to "
"arbitrary miscompilations. See `issue #44218 <https://github.com/llvm/llvm-"
"project/issues/44218>`_."
msgstr ""

#: ../../../LangRef.rst:4019
msgid ""
"x86-32 (even with SSE2 enabled) may implicitly perform such a conversion on "
"values returned from a function for some calling conventions. See `issue "
"#66803 <https://github.com/llvm/llvm-project/issues/66803>`_."
msgstr ""

#: ../../../LangRef.rst:4022
msgid ""
"Older MIPS versions use the opposite polarity for the quiet/signaling bit, "
"and LLVM does not correctly represent this. See `issue #60796 <https://"
"github.com/llvm/llvm-project/issues/60796>`_."
msgstr ""

#: ../../../LangRef.rst:4029
msgid "Floating-Point Semantics"
msgstr ""

#: ../../../LangRef.rst:4031
msgid ""
"This section defines the semantics for core floating-point operations on "
"types that use a format specified by IEEE-754. These types are: ``half``, "
"``float``, ``double``, and ``fp128``, which correspond to the binary16, "
"binary32, binary64, and binary128 formats, respectively. The \"core\" "
"operations are those defined in section 5 of IEEE-754, which all have "
"corresponding LLVM operations."
msgstr ""

#: ../../../LangRef.rst:4037
msgid ""
"The value returned by those operations matches that of the corresponding "
"IEEE-754 operation executed in the :ref:`default LLVM floating-point "
"environment <floatenv>`, except that the behavior of NaN results is instead :"
"ref:`as specified here <floatnan>`. In particular, such a floating-point "
"instruction returning a non-NaN value is guaranteed to always return the "
"same bit-identical result on all machines and optimization levels."
msgstr ""

#: ../../../LangRef.rst:4044
msgid ""
"This means that optimizations and backends may not change the observed "
"bitwise result of these operations in any way (unless NaNs are returned), "
"and frontends can rely on these operations providing correctly rounded "
"results as described in the standard."
msgstr ""

#: ../../../LangRef.rst:4049
msgid ""
"(Note that this is only about the value returned by these operations; see "
"the :ref:`floating-point environment section <floatenv>` regarding flags and "
"exceptions.)"
msgstr ""

#: ../../../LangRef.rst:4053
msgid ""
"Various flags, attributes, and metadata can alter the behavior of these "
"operations and thus make them not bit-identical across machines and "
"optimization levels any more: most notably, the :ref:`fast-math flags "
"<fastmath>` as well as the :ref:`strictfp <strictfp>` and :ref:`denormal-fp-"
"math <denormal_fp_math>` attributes and :ref:`!fpmath metadata <fpmath-"
"metadata>`. See their corresponding documentation for details."
msgstr ""

#: ../../../LangRef.rst:4063
msgid "Fast-Math Flags"
msgstr ""

#: ../../../LangRef.rst:4065
msgid ""
"LLVM IR floating-point operations (:ref:`fneg <i_fneg>`, :ref:`fadd "
"<i_fadd>`, :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv "
"<i_fdiv>`, :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`, :ref:`fptrunc "
"<i_fptrunc>`, :ref:`fpext <i_fpext>`), and :ref:`phi <i_phi>`, :ref:`select "
"<i_select>`, or :ref:`call <i_call>` instructions that return floating-point "
"types may use the following flags to enable otherwise unsafe floating-point "
"transformations."
msgstr ""

#: ../../../LangRef.rst:4074
msgid "``fast``"
msgstr ""

#: ../../../LangRef.rst:4073
msgid ""
"This flag is a shorthand for specifying all fast-math flags at once, and "
"imparts no additional semantics from using all of them."
msgstr ""

#: ../../../LangRef.rst:4079
msgid "``nnan``"
msgstr ""

#: ../../../LangRef.rst:4077
msgid ""
"No NaNs - Allow optimizations to assume the arguments and result are not "
"NaN. If an argument is a nan, or the result would be a nan, it produces a :"
"ref:`poison value <poisonvalues>` instead."
msgstr ""

#: ../../../LangRef.rst:4084
msgid "``ninf``"
msgstr ""

#: ../../../LangRef.rst:4082
msgid ""
"No Infs - Allow optimizations to assume the arguments and result are not +/-"
"Inf. If an argument is +/-Inf, or the result would be +/-Inf, it produces a :"
"ref:`poison value <poisonvalues>` instead."
msgstr ""

#: ../../../LangRef.rst:4089
msgid "``nsz``"
msgstr ""

#: ../../../LangRef.rst:4087
msgid ""
"No Signed Zeros - Allow optimizations to treat the sign of a zero argument "
"or zero result as insignificant. This does not imply that -0.0 is poison and/"
"or guaranteed to not exist in the operation."
msgstr ""

#: ../../../LangRef.rst:4091
msgid ""
"Note: For :ref:`phi <i_phi>`, :ref:`select <i_select>`, and :ref:`call "
"<i_call>` instructions, the following return types are considered to be "
"floating-point types:"
msgstr ""

#: ../../../LangRef.rst:4097
msgid "Floating-point scalar or vector types"
msgstr ""

#: ../../../LangRef.rst:4098
msgid ""
"Array types (nested to any depth) of floating-point scalar or vector types"
msgstr ""

#: ../../../LangRef.rst:4099
msgid ""
"Homogeneous literal struct types of floating-point scalar or vector types"
msgstr ""

#: ../../../LangRef.rst:4102
msgid "Rewrite-based flags"
msgstr ""

#: ../../../LangRef.rst:4104
msgid ""
"The following flags have rewrite-based semantics. These flags allow "
"expressions, potentially containing multiple non-consecutive instructions, "
"to be rewritten into alternative instructions. When multiple instructions "
"are involved in an expression, it is necessary that all of the instructions "
"have the necessary rewrite-based flag present on them, and the rewritten "
"instructions will generally have the intersection of the flags present on "
"the input instruction."
msgstr ""

#: ../../../LangRef.rst:4111
msgid ""
"In the following example, the floating-point expression in the body of "
"``@orig`` has ``contract`` and ``reassoc`` in common, and thus if it is "
"rewritten into the expression in the body of ``@target``, all of the new "
"instructions get those two flags and only those flags as a result. Since the "
"``arcp`` is present on only one of the instructions in the expression, it is "
"not present in the transformed expression. Furthermore, this reassociation "
"here is only legal because both the instructions had the ``reassoc`` flag; "
"if only one had it, it would not be legal to make the transformation."
msgstr ""

#: ../../../LangRef.rst:4134
msgid ""
"These rules do not apply to the other fast-math flags. Whether or not a flag "
"like ``nnan`` is present on any or all of the rewritten instructions is "
"based on whether or not it is possible for said instruction to have a NaN "
"input or output, given the original flags."
msgstr ""

#: ../../../LangRef.rst:4145
msgid "``arcp``"
msgstr ""

#: ../../../LangRef.rst:4140
msgid ""
"Allows division to be treated as a multiplication by a reciprocal. "
"Specifically, this permits ``a / b`` to be considered equivalent to ``a * "
"(1.0 / b)`` (which may subsequently be susceptible to code motion), and it "
"also permits ``a / (b / c)`` to be considered equivalent to ``a * (c / b)``. "
"Both of these rewrites can be applied in either direction: ``a * (c / b)`` "
"can be rewritten into ``a / (b / c)``."
msgstr ""

#: ../../../LangRef.rst:4151
msgid "``contract``"
msgstr ""

#: ../../../LangRef.rst:4148
msgid ""
"Allow floating-point contraction (e.g. fusing a multiply followed by an "
"addition into a fused multiply-and-add). This does not enable reassociation "
"to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not "
"be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations."
msgstr ""

#: ../../../LangRef.rst:4158
msgid "``afn``"
msgstr ""

#: ../../../LangRef.rst:4156
msgid ""
"Approximate functions - Allow substitution of approximate calculations for "
"functions (sin, log, sqrt, etc). See floating-point intrinsic definitions "
"for places where this can apply to LLVM's intrinsic math functions."
msgstr ""

#: ../../../LangRef.rst:4163
msgid "``reassoc``"
msgstr ""

#: ../../../LangRef.rst:4161
msgid ""
"Allow algebraically equivalent transformations for floating-point "
"instructions such as reassociation transformations. This may dramatically "
"change results in floating-point."
msgstr ""

#: ../../../LangRef.rst:4168
msgid "Use-list Order Directives"
msgstr ""

#: ../../../LangRef.rst:4170
msgid ""
"Use-list directives encode the in-memory order of each use-list, allowing "
"the order to be recreated. ``<order-indexes>`` is a comma-separated list of "
"indexes that are assigned to the referenced value's uses. The referenced "
"value's use-list is immediately sorted by these indexes."
msgstr ""

#: ../../../LangRef.rst:4175
msgid ""
"Use-list directives may appear at function scope or global scope. They are "
"not instructions, and have no effect on the semantics of the IR. When "
"they're at function scope, they must appear after the terminator of the "
"final basic block."
msgstr ""

#: ../../../LangRef.rst:4179
msgid ""
"If basic blocks have their address taken via ``blockaddress()`` expressions, "
"``uselistorder_bb`` can be used to reorder their use-lists from outside "
"their function's scope."
msgstr ""

#: ../../../LangRef.rst:0 ../../../LangRef.rst:18738 ../../../LangRef.rst:18788
#: ../../../LangRef.rst:18837 ../../../LangRef.rst:18888
#: ../../../LangRef.rst:18939 ../../../LangRef.rst:18990
#: ../../../LangRef.rst:19100 ../../../LangRef.rst:19160
#: ../../../LangRef.rst:19219 ../../../LangRef.rst:19289
#: ../../../LangRef.rst:19356 ../../../LangRef.rst:19416
#: ../../../LangRef.rst:19478 ../../../LangRef.rst:19544
msgid "Examples"
msgstr ""

#: ../../../LangRef.rst:4214
msgid "Source Filename"
msgstr ""

#: ../../../LangRef.rst:4216
msgid ""
"The *source filename* string is set to the original module identifier, which "
"will be the name of the compiled source file when compiling from source "
"through the clang front end, for example. It is then preserved through the "
"IR and bitcode."
msgstr ""

#: ../../../LangRef.rst:4221
msgid ""
"This is currently necessary to generate a consistent unique global "
"identifier for local functions used in profile data, which prepends the "
"source file name to the local function name."
msgstr ""

#: ../../../LangRef.rst:4225
msgid "The syntax for the source file name is simply:"
msgstr ""

#: ../../../LangRef.rst:4234
msgid "Type System"
msgstr ""

#: ../../../LangRef.rst:4236
msgid ""
"The LLVM type system is one of the most important features of the "
"intermediate representation. Being typed enables a number of optimizations "
"to be performed on the intermediate representation directly, without having "
"to do extra analyses on the side before the transformation. A strong type "
"system makes it easier to read the generated code and enables novel analyses "
"and transformations that are not feasible to perform on normal three address "
"code representations."
msgstr ""

#: ../../../LangRef.rst:4247
msgid "Void Type"
msgstr ""

#: ../../../LangRef.rst:0 ../../../LangRef.rst:18717 ../../../LangRef.rst:18767
#: ../../../LangRef.rst:18816 ../../../LangRef.rst:18866
#: ../../../LangRef.rst:18913 ../../../LangRef.rst:18966
#: ../../../LangRef.rst:19069 ../../../LangRef.rst:19129
#: ../../../LangRef.rst:19188 ../../../LangRef.rst:19258
#: ../../../LangRef.rst:19325 ../../../LangRef.rst:19385
#: ../../../LangRef.rst:19445 ../../../LangRef.rst:19512
msgid "Overview"
msgstr ""

#: ../../../LangRef.rst:4252
msgid "The void type does not represent any value and has no size."
msgstr ""

#: ../../../LangRef.rst:4265
msgid "Function Type"
msgstr ""

#: ../../../LangRef.rst:4270
msgid ""
"The function type can be thought of as a function signature. It consists of "
"a return type and a list of formal parameter types. The return type of a "
"function type is a void type or first class type --- except for :ref:`label "
"<t_label>` and :ref:`metadata <t_metadata>` types."
msgstr ""

#: ../../../LangRef.rst:4281
msgid ""
"...where '``<parameter list>``' is a comma-separated list of type "
"specifiers. Optionally, the parameter list may include a type ``...``, which "
"indicates that the function takes a variable number of arguments. Variable "
"argument functions can access their arguments with the :ref:`variable "
"argument handling intrinsic <int_varargs>` functions. '``<returntype>``' is "
"any type except :ref:`label <t_label>` and :ref:`metadata <t_metadata>`."
msgstr ""

#: ../../../LangRef.rst:4291
msgid "``i32 (i32)``"
msgstr ""

#: ../../../LangRef.rst:4291
msgid "function taking an ``i32``, returning an ``i32``"
msgstr ""

#: ../../../LangRef.rst:4293
msgid "``i32 (ptr, ...)``"
msgstr ""

#: ../../../LangRef.rst:4293
msgid ""
"A vararg function that takes at least one :ref:`pointer <t_pointer>` "
"argument and returns an integer. This is the signature for ``printf`` in "
"LLVM."
msgstr ""

#: ../../../LangRef.rst:4295
msgid "``{i32, i32} (i32)``"
msgstr ""

#: ../../../LangRef.rst:4295
msgid ""
"A function taking an ``i32``, returning a :ref:`structure <t_struct>` "
"containing two ``i32`` values"
msgstr ""

#: ../../../LangRef.rst:4301
msgid "Opaque Structure Types"
msgstr ""

#: ../../../LangRef.rst:4305
msgid ""
"Opaque structure types are used to represent structure types that do not "
"have a body specified. This corresponds (for example) to the C notion of a "
"forward declared structure. They can be named (``%X``) or unnamed (``%52``)."
msgstr ""

#: ../../../LangRef.rst:4310
msgid ""
"It is not possible to create SSA values with an opaque structure type. In "
"practice, this largely limits their use to the value type of external "
"globals."
msgstr ""

#: ../../../LangRef.rst:4325
msgid "First Class Types"
msgstr ""

#: ../../../LangRef.rst:4327
msgid ""
"The :ref:`first class <t_firstclass>` types are perhaps the most important. "
"Values of these types are the only ones which can be produced by "
"instructions."
msgstr ""

#: ../../../LangRef.rst:4334
msgid "Single Value Types"
msgstr ""

#: ../../../LangRef.rst:4336
msgid ""
"These are the types that are valid in registers from CodeGen's perspective."
msgstr ""

#: ../../../LangRef.rst:4341
msgid "Integer Type"
msgstr ""

#: ../../../LangRef.rst:4345
msgid ""
"The integer type is a very simple type that simply specifies an arbitrary "
"bit width for the integer type desired. Any bit width from 1 bit to 2\\ :sup:"
"`23`\\ (about 8 million) can be specified."
msgstr ""

#: ../../../LangRef.rst:4355
msgid ""
"The number of bits the integer will occupy is specified by the ``N`` value."
msgstr ""

#: ../../../LangRef.rst:4359 ../../../LangRef.rst:7370
#: ../../../LangRef.rst:8209 ../../../LangRef.rst:11553
#: ../../../LangRef.rst:18426 ../../../LangRef.rst:18476
#: ../../../LangRef.rst:18527 ../../../LangRef.rst:18578
#: ../../../LangRef.rst:18629 ../../../LangRef.rst:18680
#: ../../../LangRef.rst:19677 ../../../LangRef.rst:20005
#: ../../../LangRef.rst:20083 ../../../LangRef.rst:21190
#: ../../../LangRef.rst:21232 ../../../LangRef.rst:21747
#: ../../../LangRef.rst:21794 ../../../LangRef.rst:21842
#: ../../../LangRef.rst:21890 ../../../LangRef.rst:21938
#: ../../../LangRef.rst:21987 ../../../LangRef.rst:22036
#: ../../../LangRef.rst:22085 ../../../LangRef.rst:22135
#: ../../../LangRef.rst:22183 ../../../LangRef.rst:22231
#: ../../../LangRef.rst:22279 ../../../LangRef.rst:22327
#: ../../../LangRef.rst:22376 ../../../LangRef.rst:22425
#: ../../../LangRef.rst:22473 ../../../LangRef.rst:22521
#: ../../../LangRef.rst:22569 ../../../LangRef.rst:22618
#: ../../../LangRef.rst:22667 ../../../LangRef.rst:22716
#: ../../../LangRef.rst:22766 ../../../LangRef.rst:22816
#: ../../../LangRef.rst:22865 ../../../LangRef.rst:22914
#: ../../../LangRef.rst:22963 ../../../LangRef.rst:23012
#: ../../../LangRef.rst:23061 ../../../LangRef.rst:23109
#: ../../../LangRef.rst:23157 ../../../LangRef.rst:23206
#: ../../../LangRef.rst:23255 ../../../LangRef.rst:23306
#: ../../../LangRef.rst:23360 ../../../LangRef.rst:23420
#: ../../../LangRef.rst:23476 ../../../LangRef.rst:23536
#: ../../../LangRef.rst:23592 ../../../LangRef.rst:23649
#: ../../../LangRef.rst:23705 ../../../LangRef.rst:23762
#: ../../../LangRef.rst:23819 ../../../LangRef.rst:23876
#: ../../../LangRef.rst:23933 ../../../LangRef.rst:24000
#: ../../../LangRef.rst:24067 ../../../LangRef.rst:24137
#: ../../../LangRef.rst:24207 ../../../LangRef.rst:24287
#: ../../../LangRef.rst:24345 ../../../LangRef.rst:24410
#: ../../../LangRef.rst:24469 ../../../LangRef.rst:24513
#: ../../../LangRef.rst:24606 ../../../LangRef.rst:24696
#: ../../../LangRef.rst:24749 ../../../LangRef.rst:24804
#: ../../../LangRef.rst:24865 ../../../LangRef.rst:24926
#: ../../../LangRef.rst:24984 ../../../LangRef.rst:25036
#: ../../../LangRef.rst:25088 ../../../LangRef.rst:25140
#: ../../../LangRef.rst:25196 ../../../LangRef.rst:25252
#: ../../../LangRef.rst:25308 ../../../LangRef.rst:25364
#: ../../../LangRef.rst:25420 ../../../LangRef.rst:25476
#: ../../../LangRef.rst:25533 ../../../LangRef.rst:25588
#: ../../../LangRef.rst:25646 ../../../LangRef.rst:25704
#: ../../../LangRef.rst:25751 ../../../LangRef.rst:25798
#: ../../../LangRef.rst:25845 ../../../LangRef.rst:25892
#: ../../../LangRef.rst:25939 ../../../LangRef.rst:25986
#: ../../../LangRef.rst:26033 ../../../LangRef.rst:26080
#: ../../../LangRef.rst:26126 ../../../LangRef.rst:26173
#: ../../../LangRef.rst:26220 ../../../LangRef.rst:26267
#: ../../../LangRef.rst:26316 ../../../LangRef.rst:26365
#: ../../../LangRef.rst:26462 ../../../LangRef.rst:26511
#: ../../../LangRef.rst:26560 ../../../LangRef.rst:26609
#: ../../../LangRef.rst:26657 ../../../LangRef.rst:26703
#: ../../../LangRef.rst:26747
msgid "Examples:"
msgstr ""

#: ../../../LangRef.rst:4362
msgid "``i1``"
msgstr ""

#: ../../../LangRef.rst:4362
msgid "a single-bit integer."
msgstr ""

#: ../../../LangRef.rst:4364
msgid "``i32``"
msgstr ""

#: ../../../LangRef.rst:4364
msgid "a 32-bit integer."
msgstr ""

#: ../../../LangRef.rst:4366
msgid "``i1942652``"
msgstr ""

#: ../../../LangRef.rst:4366
msgid "a really big integer of over 1 million bits."
msgstr ""

#: ../../../LangRef.rst:4372
msgid "Floating-Point Types"
msgstr ""

#: ../../../LangRef.rst:4377
msgid "Type"
msgstr ""

#: ../../../LangRef.rst:4378
msgid "Description"
msgstr ""

#: ../../../LangRef.rst:4380
msgid "``half``"
msgstr ""

#: ../../../LangRef.rst:4381
msgid "16-bit floating-point value (IEEE-754 binary16)"
msgstr ""

#: ../../../LangRef.rst:4383
msgid "``bfloat``"
msgstr ""

#: ../../../LangRef.rst:4384
msgid ""
"16-bit \"brain\" floating-point value (7-bit significand).  Provides the "
"same number of exponent bits as ``float``, so that it matches its dynamic "
"range, but with greatly reduced precision.  Used in Intel's AVX-512 BF16 "
"extensions and Arm's ARMv8.6-A extensions, among others."
msgstr ""

#: ../../../LangRef.rst:4389
msgid "``float``"
msgstr ""

#: ../../../LangRef.rst:4390
msgid "32-bit floating-point value (IEEE-754 binary32)"
msgstr ""

#: ../../../LangRef.rst:4392
msgid "``double``"
msgstr ""

#: ../../../LangRef.rst:4393
msgid "64-bit floating-point value (IEEE-754 binary64)"
msgstr ""

#: ../../../LangRef.rst:4395
msgid "``fp128``"
msgstr ""

#: ../../../LangRef.rst:4396
msgid "128-bit floating-point value (IEEE-754 binary128)"
msgstr ""

#: ../../../LangRef.rst:4398
msgid "``x86_fp80``"
msgstr ""

#: ../../../LangRef.rst:4399
msgid "80-bit floating-point value (X87)"
msgstr ""

#: ../../../LangRef.rst:4401
msgid "``ppc_fp128``"
msgstr ""

#: ../../../LangRef.rst:4402
msgid "128-bit floating-point value (two 64-bits)"
msgstr ""

#: ../../../LangRef.rst:4405
msgid "X86_amx Type"
msgstr ""

#: ../../../LangRef.rst:4409
msgid ""
"The x86_amx type represents a value held in an AMX tile register on an x86 "
"machine. The operations allowed on it are quite limited. Only a few "
"intrinsics are allowed: stride load and store, zero and dot product. No "
"instruction is allowed for this type. There are no arguments, arrays, "
"pointers, vectors or constants of this type."
msgstr ""

#: ../../../LangRef.rst:4426
msgid "Pointer Type"
msgstr ""

#: ../../../LangRef.rst:4430
msgid ""
"The pointer type ``ptr`` is used to specify memory locations. Pointers are "
"commonly used to reference objects in memory."
msgstr ""

#: ../../../LangRef.rst:4433
msgid ""
"Pointer types may have an optional address space attribute defining the "
"numbered address space where the pointed-to object resides. For example, "
"``ptr addrspace(5)`` is a pointer to address space 5. In addition to integer "
"constants, ``addrspace`` can also reference one of the address spaces "
"defined in the :ref:`datalayout string<langref_datalayout>`. "
"``addrspace(\"A\")`` will use the alloca address space, ``addrspace(\"G\")`` "
"the default globals address space and ``addrspace(\"P\")`` the program "
"address space."
msgstr ""

#: ../../../LangRef.rst:4442
msgid ""
"The representation of pointers can be different for each address space and "
"does not necessarily need to be a plain integer address (e.g. for :ref:`non-"
"integral pointers <nointptrtype>`). In addition to a representation bits "
"size, pointers in each address space also have an index size which defines "
"the bitwidth of indexing operations as well as the size of `integer "
"addresses` in this address space. For example, CHERI capabilities are twice "
"the size of the underlying addresses to accommodate for additional metadata "
"such as bounds and permissions: on a 32-bit system the bitwidth of the "
"pointer representation size is 64, but the underlying address width remains "
"32 bits."
msgstr ""

#: ../../../LangRef.rst:4452
msgid "The default address space is number zero."
msgstr ""

#: ../../../LangRef.rst:4454
msgid ""
"The semantics of non-zero address spaces are target-specific. Memory access "
"through a non-dereferenceable pointer is undefined behavior in any address "
"space. Pointers with the bit-value 0 are only assumed to be non-"
"dereferenceable in address space 0, unless the function is marked with the "
"``null_pointer_is_valid`` attribute. However, *volatile* access to any non-"
"dereferenceable address may have defined behavior (according to the target), "
"and in this case the attribute is not needed even for address 0."
msgstr ""

#: ../../../LangRef.rst:4463
msgid ""
"If an object can be proven accessible through a pointer with a different "
"address space, the access may be modified to use that address space. "
"Exceptions apply if the operation is ``volatile``."
msgstr ""

#: ../../../LangRef.rst:4467
msgid ""
"Prior to LLVM 15, pointer types also specified a pointee type, such as "
"``i8*``, ``[4 x i32]*`` or ``i32 (i32*)*``. In LLVM 15, such \"typed "
"pointers\" are still supported under non-default options. See the `opaque "
"pointers document <OpaquePointers.html>`__ for more information."
msgstr ""

#: ../../../LangRef.rst:4475
msgid "Target Extension Type"
msgstr ""

#: ../../../LangRef.rst:4479
msgid ""
"Target extension types represent types that must be preserved through "
"optimization, but are otherwise generally opaque to the compiler. They may "
"be used as function parameters or arguments, and in :ref:`phi <i_phi>` or :"
"ref:`select <i_select>` instructions. Some types may be also used in :ref:"
"`alloca <i_alloca>` instructions or as global values, and correspondingly it "
"is legal to use :ref:`load <i_load>` and :ref:`store <i_store>` instructions "
"on them. Full semantics for these types are defined by the target."
msgstr ""

#: ../../../LangRef.rst:4487
msgid ""
"The only constants that target extension types may have are "
"``zeroinitializer``, ``undef``, and ``poison``. Other possible values for "
"target extension types may arise from target-specific intrinsics and "
"functions."
msgstr ""

#: ../../../LangRef.rst:4491
msgid ""
"These types cannot be converted to other types. As such, it is not legal to "
"use them in :ref:`bitcast <i_bitcast>` instructions (as a source or target "
"type), nor is it legal to use them in :ref:`ptrtoint <i_ptrtoint>` or :ref:"
"`inttoptr <i_inttoptr>` instructions. Similarly, they are not legal to use "
"in an :ref:`icmp <i_icmp>` instruction."
msgstr ""

#: ../../../LangRef.rst:4497
msgid ""
"Target extension types have a name and optional type or integer parameters. "
"The meanings of name and parameters are defined by the target. When being "
"defined in LLVM IR, all of the type parameters must precede all of the "
"integer parameters."
msgstr ""

#: ../../../LangRef.rst:4501
msgid ""
"Specific target extension types are registered with LLVM as having specific "
"properties. These properties can be used to restrict the type from appearing "
"in certain contexts, such as being the type of a global variable or having a "
"``zeroinitializer`` constant be valid. A complete list of type properties "
"may be found in the documentation for ``llvm::TargetExtType::Property`` "
"(`doxygen <https://llvm.org/doxygen/classllvm_1_1TargetExtType.html>`_)."
msgstr ""

#: ../../../LangRef.rst:4522
msgid "Vector Type"
msgstr ""

#: ../../../LangRef.rst:4526
msgid ""
"A vector type is a simple derived type that represents a vector of elements. "
"Vector types are used when multiple primitive data are operated in parallel "
"using a single instruction (SIMD). A vector type requires a size (number of "
"elements), an underlying primitive data type, and a scalable property to "
"represent vectors where the exact hardware vector length is unknown at "
"compile time. Vector types are considered :ref:`first class <t_firstclass>`."
msgstr ""

#: ../../../LangRef.rst:0
msgid "Memory Layout"
msgstr ""

#: ../../../LangRef.rst:4536
msgid ""
"In general vector elements are laid out in memory in the same way as :ref:"
"`array types <t_array>`. Such an analogy works fine as long as the vector "
"elements are byte sized. However, when the elements of the vector aren't "
"byte sized it gets a bit more complicated. One way to describe the layout is "
"by describing what happens when a vector such as <N x iM> is bitcasted to an "
"integer type with N*M bits, and then following the rules for storing such an "
"integer to memory."
msgstr ""

#: ../../../LangRef.rst:4544
msgid ""
"A bitcast from a vector type to a scalar integer type will see the elements "
"being packed together (without padding). The order in which elements are "
"inserted in the integer depends on endianness. For little endian element "
"zero is put in the least significant bits of the integer, and for big endian "
"element zero is put in the most significant bits."
msgstr ""

#: ../../../LangRef.rst:4550
msgid ""
"Using a vector such as ``<i4 1, i4 2, i4 3, i4 5>`` as an example, together "
"with the analogy that we can replace a vector store by a bitcast followed by "
"an integer store, we get this for big endian:"
msgstr ""

#: ../../../LangRef.rst:4569
msgid "The same example for little endian:"
msgstr ""

#: ../../../LangRef.rst:4586
msgid ""
"When ``<N*M>`` isn't evenly divisible by the byte size the exact memory "
"layout is unspecified (just like it is for an integral type of the same "
"size). This is because different targets could put the padding at different "
"positions when the type size is smaller than the type's store size."
msgstr ""

#: ../../../LangRef.rst:4598
msgid ""
"The number of elements is a constant integer value larger than 0; "
"elementtype may be any integer, floating-point, pointer type, or a sized "
"target extension type that has the ``CanBeVectorElement`` property. Vectors "
"of size zero are not allowed. For scalable vectors, the total number of "
"elements is a constant multiple (called vscale) of the specified number of "
"elements; vscale is a positive integer that is unknown at compile time and "
"the same hardware-dependent constant for all scalable vectors at run time. "
"The size of a specific scalable vector type is thus constant within IR, even "
"if the exact size in bytes cannot be determined until run time."
msgstr ""

#: ../../../LangRef.rst:4611
msgid "``<4 x i32>``"
msgstr ""

#: ../../../LangRef.rst:4611
msgid "Vector of 4 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4613
msgid "``<8 x float>``"
msgstr ""

#: ../../../LangRef.rst:4613
msgid "Vector of 8 32-bit floating-point values."
msgstr ""

#: ../../../LangRef.rst:4615
msgid "``<2 x i64>``"
msgstr ""

#: ../../../LangRef.rst:4615
msgid "Vector of 2 64-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4617
msgid "``<4 x ptr>``"
msgstr ""

#: ../../../LangRef.rst:4617
msgid "Vector of 4 pointers"
msgstr ""

#: ../../../LangRef.rst:4619
msgid "``<vscale x 4 x i32>``"
msgstr ""

#: ../../../LangRef.rst:4619
msgid "Vector with a multiple of 4 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4625
msgid "Label Type"
msgstr ""

#: ../../../LangRef.rst:4629
msgid "The label type represents code labels."
msgstr ""

#: ../../../LangRef.rst:4640
msgid "Token Type"
msgstr ""

#: ../../../LangRef.rst:4644
msgid ""
"The token type is used when a value is associated with an instruction but "
"all uses of the value must not attempt to introspect or obscure it. As such, "
"it is not appropriate to have a :ref:`phi <i_phi>` or :ref:`select "
"<i_select>` of type token."
msgstr ""

#: ../../../LangRef.rst:4660
msgid "Metadata Type"
msgstr ""

#: ../../../LangRef.rst:4664
msgid ""
"The metadata type represents embedded metadata. No derived types may be "
"created from metadata except for :ref:`function <t_function>` arguments."
msgstr ""

#: ../../../LangRef.rst:4676
msgid "Aggregate Types"
msgstr ""

#: ../../../LangRef.rst:4678
msgid ""
"Aggregate Types are a subset of derived types that can contain multiple "
"member types. :ref:`Arrays <t_array>` and :ref:`structs <t_struct>` are "
"aggregate types. :ref:`Vectors <t_vector>` are not considered to be "
"aggregate types."
msgstr ""

#: ../../../LangRef.rst:4686
msgid "Array Type"
msgstr ""

#: ../../../LangRef.rst:4690
msgid ""
"The array type is a very simple derived type that arranges elements "
"sequentially in memory. The array type requires a size (number of elements) "
"and an underlying data type."
msgstr ""

#: ../../../LangRef.rst:4700
msgid ""
"The number of elements is a constant integer value; ``elementtype`` may be "
"any type with a size."
msgstr ""

#: ../../../LangRef.rst:4706
msgid "``[40 x i32]``"
msgstr ""

#: ../../../LangRef.rst:4706
msgid "Array of 40 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4708
msgid "``[41 x i32]``"
msgstr ""

#: ../../../LangRef.rst:4708
msgid "Array of 41 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4710
msgid "``[4 x i8]``"
msgstr ""

#: ../../../LangRef.rst:4710
msgid "Array of 4 8-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4713
msgid "Here are some examples of multidimensional arrays:"
msgstr ""

#: ../../../LangRef.rst:4716
msgid "``[3 x [4 x i32]]``"
msgstr ""

#: ../../../LangRef.rst:4716
msgid "3x4 array of 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4718
msgid "``[12 x [10 x float]]``"
msgstr ""

#: ../../../LangRef.rst:4718
msgid "12x10 array of single precision floating-point values."
msgstr ""

#: ../../../LangRef.rst:4720
msgid "``[2 x [3 x [4 x i16]]]``"
msgstr ""

#: ../../../LangRef.rst:4720
msgid "2x3x4 array of 16-bit integer values."
msgstr ""

#: ../../../LangRef.rst:4723
msgid ""
"There is no restriction on indexing beyond the end of the array implied by a "
"static type (though there are restrictions on indexing beyond the bounds of "
"an :ref:`allocated object<allocatedobjects>` in some cases). This means that "
"single-dimension 'variable sized array' addressing can be implemented in "
"LLVM with a zero length array type. An implementation of 'pascal style "
"arrays' in LLVM could use the type \"``{ i32, [0 x float]}``\", for example."
msgstr ""

#: ../../../LangRef.rst:4733
msgid "Structure Type"
msgstr ""

#: ../../../LangRef.rst:4737
msgid ""
"The structure type is used to represent a collection of data members "
"together in memory. The elements of a structure may be any type that has a "
"size."
msgstr ""

#: ../../../LangRef.rst:4741
msgid ""
"Structures in memory are accessed using '``load``' and '``store``' by "
"getting a pointer to a field with the '``getelementptr``' instruction. "
"Structures in registers are accessed using the '``extractvalue``' and "
"'``insertvalue``' instructions."
msgstr ""

#: ../../../LangRef.rst:4746
msgid ""
"Structures may optionally be \"packed\" structures, which indicate that the "
"alignment of the struct is one byte, and that there is no padding between "
"the elements. In non-packed structs, padding between field types is inserted "
"as defined by the DataLayout string in the module, which is required to "
"match what the underlying code generator expects."
msgstr ""

#: ../../../LangRef.rst:4752
msgid ""
"Structures can either be \"literal\" or \"identified\". A literal structure "
"is defined inline with other types (e.g. ``[2 x {i32, i32}]``) whereas "
"identified types are always defined at the top level with a name. Literal "
"types are uniqued by their contents and can never be recursive or opaque "
"since there is no way to write one. Identified types can be opaqued and are "
"never uniqued. Identified types must not be recursive."
msgstr ""

#: ../../../LangRef.rst:4769
msgid "``{ i32, i32, i32 }``"
msgstr ""

#: ../../../LangRef.rst:4769
msgid ""
"A triple of three ``i32`` values (this is a \"homogeneous\" struct as all "
"element types are the same)"
msgstr ""

#: ../../../LangRef.rst:4771
msgid "``{ float, ptr }``"
msgstr ""

#: ../../../LangRef.rst:4771
msgid ""
"A pair, where the first element is a ``float`` and the second element is a :"
"ref:`pointer <t_pointer>`."
msgstr ""

#: ../../../LangRef.rst:4773
msgid "``<{ i8, i32 }>``"
msgstr ""

#: ../../../LangRef.rst:4773
msgid "A packed struct known to be 5 bytes in size."
msgstr ""

#: ../../../LangRef.rst:4779
msgid "Constants"
msgstr ""

#: ../../../LangRef.rst:4781
msgid ""
"LLVM has several different basic types of constants. This section describes "
"them all and their syntax."
msgstr ""

#: ../../../LangRef.rst:4785
msgid "Simple Constants"
msgstr ""

#: ../../../LangRef.rst:4788
msgid "**Boolean constants**"
msgstr ""

#: ../../../LangRef.rst:4788
msgid ""
"The two strings '``true``' and '``false``' are both valid constants of the "
"``i1`` type."
msgstr ""

#: ../../../LangRef.rst:4800
msgid "**Integer constants**"
msgstr ""

#: ../../../LangRef.rst:4791
msgid ""
"Standard integers (such as '4') are constants of the :ref:`integer "
"<t_integer>` type. They can be either decimal or hexadecimal. Decimal "
"integers can be prefixed with - to represent negative integers, e.g. "
"'``-1234``'. Hexadecimal integers must be prefixed with either u or s to "
"indicate whether they are unsigned or signed respectively. e.g '``u0x8000``' "
"gives 32768, whilst '``s0x8000``' gives -32768."
msgstr ""

#: ../../../LangRef.rst:4799
msgid ""
"Note that hexadecimal integers are sign extended from the number of active "
"bits, i.e., the bit width minus the number of leading zeros. So "
"'``s0x0001``' of type '``i16``' will be -1, not 1."
msgstr ""

#: ../../../LangRef.rst:4808
msgid "**Floating-point constants**"
msgstr ""

#: ../../../LangRef.rst:4803
msgid ""
"Floating-point constants use standard decimal notation (e.g. 123.421), "
"exponential notation (e.g. 1.23421e+2), or a more precise hexadecimal "
"notation (see below). The assembler requires the exact decimal value of a "
"floating-point constant. For example, the assembler accepts 1.25 but rejects "
"1.3 because 1.3 is a repeating decimal in binary. Floating-point constants "
"must have a :ref:`floating-point <t_floating>` type."
msgstr ""

#: ../../../LangRef.rst:4811
msgid "**Null pointer constants**"
msgstr ""

#: ../../../LangRef.rst:4811
msgid ""
"The identifier '``null``' is recognized as a null pointer constant and must "
"be of :ref:`pointer type <t_pointer>`."
msgstr ""

#: ../../../LangRef.rst:4815
msgid "**Token constants**"
msgstr ""

#: ../../../LangRef.rst:4814
msgid ""
"The identifier '``none``' is recognized as an empty token constant and must "
"be of :ref:`token type <t_token>`."
msgstr ""

#: ../../../LangRef.rst:4817
msgid ""
"The one non-intuitive notation for constants is the hexadecimal form of "
"floating-point constants. For example, the form '``double    "
"0x432ff973cafa8000``' is equivalent to (but harder to read than) '``double "
"4.5e+15``'. The only time hexadecimal floating-point constants are required "
"(and the only time that they are generated by the disassembler) is when a "
"floating-point constant must be emitted but it cannot be represented as a "
"decimal floating-point number in a reasonable number of digits. For example, "
"NaN's, infinities, and other special values are represented in their IEEE "
"hexadecimal format so that assembly and disassembly do not cause any bits to "
"change in the constants."
msgstr ""

#: ../../../LangRef.rst:4828
msgid ""
"When using the hexadecimal form, constants of types bfloat, half, float, and "
"double are represented using the 16-digit form shown above (which matches "
"the IEEE754 representation for double); bfloat, half and float values must, "
"however, be exactly representable as bfloat, IEEE 754 half, and IEEE 754 "
"single precision respectively. Hexadecimal format is always used for long "
"double, and there are three forms of long double. The 80-bit format used by "
"x86 is represented as ``0xK`` followed by 20 hexadecimal digits. The 128-bit "
"format used by PowerPC (two adjacent doubles) is represented by ``0xM`` "
"followed by 32 hexadecimal digits. The IEEE 128-bit format is represented by "
"``0xL`` followed by 32 hexadecimal digits. Long doubles will only work if "
"they match the long double format on your target.  The IEEE 16-bit format "
"(half precision) is represented by ``0xH`` followed by 4 hexadecimal digits. "
"The bfloat 16-bit format is represented by ``0xR`` followed by 4 hexadecimal "
"digits. All hexadecimal formats are big-endian (sign bit at the left)."
msgstr ""

#: ../../../LangRef.rst:4843
msgid "There are no constants of type x86_amx."
msgstr ""

#: ../../../LangRef.rst:4848
msgid "Complex Constants"
msgstr ""

#: ../../../LangRef.rst:4850
msgid ""
"Complex constants are a (potentially recursive) combination of simple "
"constants and smaller complex constants."
msgstr ""

#: ../../../LangRef.rst:4859
msgid "**Structure constants**"
msgstr ""

#: ../../../LangRef.rst:4854
msgid ""
"Structure constants are represented with notation similar to structure type "
"definitions (a comma separated list of elements, surrounded by braces (``{}"
"``)). For example: \"``{ i32 4, float 17.0, ptr @G }``\", where \"``@G``\" "
"is declared as \"``@G = external global i32``\". Structure constants must "
"have :ref:`structure type <t_struct>`, and the number and types of elements "
"must match those specified by the type."
msgstr ""

#: ../../../LangRef.rst:4868
msgid "**Array constants**"
msgstr ""

#: ../../../LangRef.rst:4862
msgid ""
"Array constants are represented with notation similar to array type "
"definitions (a comma separated list of elements, surrounded by square "
"brackets (``[]``)). For example: \"``[ i32 42, i32 11, i32 74 ]``\". Array "
"constants must have :ref:`array type <t_array>`, and the number and types of "
"elements must match those specified by the type. As a special case, "
"character array constants may also be represented as a double-quoted string "
"using the ``c`` prefix. For example: \"``c\"Hello World\\0A\\00\"``\"."
msgstr ""

#: ../../../LangRef.rst:4880
msgid "**Vector constants**"
msgstr ""

#: ../../../LangRef.rst:4871
msgid ""
"Vector constants are represented with notation similar to vector type "
"definitions (a comma separated list of elements, surrounded by less-than/"
"greater-than's (``<>``)). For example: \"``< i32 42, i32 11, i32 74, i32 100 "
">``\". Vector constants must have :ref:`vector type <t_vector>`, and the "
"number and types of elements must match those specified by the type."
msgstr ""

#: ../../../LangRef.rst:4878
msgid ""
"When creating a vector whose elements have the same constant value, the "
"preferred syntax is ``splat (<Ty> Val)``. For example: \"``splat (i32 "
"11)``\". These vector constants must have :ref:`vector type <t_vector>` with "
"an element type that matches the ``splat`` operand."
msgstr ""

#: ../../../LangRef.rst:4886
msgid "**Zero initialization**"
msgstr ""

#: ../../../LangRef.rst:4883
msgid ""
"The string '``zeroinitializer``' can be used to zero initialize a value to "
"zero of *any* type, including scalar and :ref:`aggregate <t_aggregate>` "
"types. This is often used to avoid having to print large zero initializers "
"(e.g. for large arrays) and is always exactly equivalent to using explicit "
"zero initializers."
msgstr ""

#: ../../../LangRef.rst:4894
msgid "**Metadata node**"
msgstr ""

#: ../../../LangRef.rst:4889
msgid ""
"A metadata node is a constant tuple without types. For example: \"``!{!0, !{!"
"2, !0}, !\"test\"}``\". Metadata can reference constant values, for example: "
"\"``!{!0, i32 0, ptr @global, ptr @function, !\"str\"}``\". Unlike other "
"typed constants that are meant to be interpreted as part of the instruction "
"stream, metadata is a place to attach additional information such as debug "
"info."
msgstr ""

#: ../../../LangRef.rst:4897
msgid "Global Variable and Function Addresses"
msgstr ""

#: ../../../LangRef.rst:4899
msgid ""
"The addresses of :ref:`global variables <globalvars>` and :ref:`functions "
"<functionstructure>` are always implicitly valid (link-time) constants. "
"These constants are explicitly referenced when the :ref:`identifier for the "
"global <identifiers>` is used and always have :ref:`pointer <t_pointer>` "
"type. For example, the following is a legal LLVM file:"
msgstr ""

#: ../../../LangRef.rst:4915
msgid "Undefined Values"
msgstr ""

#: ../../../LangRef.rst:4917
msgid ""
"The string '``undef``' can be used anywhere a constant is expected, and "
"indicates that the user of the value may receive an unspecified bit-pattern. "
"Undefined values may be of any type (other than '``label``' or '``void``') "
"and be used anywhere a constant is permitted."
msgstr ""

#: ../../../LangRef.rst:4924
msgid ""
"A '``poison``' value (described in the next section) should be used instead "
"of '``undef``' whenever possible. Poison values are stronger than undef, and "
"enable more optimizations. Just the existence of '``undef``' blocks certain "
"optimizations (see the examples below)."
msgstr ""

#: ../../../LangRef.rst:4929
msgid ""
"Undefined values are useful because they indicate to the compiler that the "
"program is well defined no matter what value is used. This gives the "
"compiler more freedom to optimize. Here are some examples of (potentially "
"surprising) transformations that are valid (in pseudo IR):"
msgstr ""

#: ../../../LangRef.rst:4944
msgid ""
"This is safe because all of the output bits are affected by the undef bits. "
"Any output bit can have a zero or one depending on the input bits."
msgstr ""

#: ../../../LangRef.rst:4961
msgid ""
"These logical operations have bits that are not always affected by the "
"input. For example, if ``%X`` has a zero bit, then the output of the "
"'``and``' operation will always be a zero for that bit, no matter what the "
"corresponding bit from the '``undef``' is. As such, it is unsafe to optimize "
"or assume that the result of the '``and``' is '``undef``'. However, it is "
"safe to assume that all bits of the '``undef``' could be 0, and optimize the "
"'``and``' to 0. Likewise, it is safe to assume that all the bits of the "
"'``undef``' operand to the '``or``' could be set, allowing the '``or``' to "
"be folded to -1."
msgstr ""

#: ../../../LangRef.rst:4985
msgid ""
"This set of examples shows that undefined '``select``' conditions can go "
"*either way*, but they have to come from one of the two operands. In the "
"``%A`` example, if ``%X`` and ``%Y`` were both known to have a clear low "
"bit, then ``%A`` would have to have a cleared low bit. However, in the "
"``%C`` example, the optimizer is allowed to assume that the '``undef``' "
"operand could be the same as ``%Y`` if ``%Y`` is provably not '``poison``', "
"allowing the whole '``select``' to be eliminated. This is because "
"'``poison``' is stronger than '``undef``'."
msgstr ""

#: ../../../LangRef.rst:5013
msgid ""
"This example points out that two '``undef``' operands are not necessarily "
"the same. This can be surprising to people (and also matches C semantics) "
"where they assume that \"``X^X``\" is always zero, even if ``X`` is "
"undefined. This isn't true for a number of reasons, but the short answer is "
"that an '``undef``' \"variable\" can arbitrarily change its value over its "
"\"live range\". This is true because the variable doesn't actually *have a "
"live range*. Instead, the value is logically read from arbitrary registers "
"that happen to be around when needed, so the value is not necessarily "
"consistent over time. In fact, ``%A`` and ``%C`` need to have the same "
"semantics or the core LLVM \"replace all uses with\" concept would not hold."
msgstr ""

#: ../../../LangRef.rst:5025
msgid ""
"To ensure all uses of a given register observe the same value (even if "
"'``undef``'), the :ref:`freeze instruction <i_freeze>` can be used."
msgstr ""

#: ../../../LangRef.rst:5036
msgid ""
"These examples show the crucial difference between an *undefined value* and "
"*undefined behavior*. An undefined value (like '``undef``') is allowed to "
"have an arbitrary bit-pattern. This means that the ``%A`` operation can be "
"constant folded to '``0``', because the '``undef``' could be zero, and zero "
"divided by any value is zero. However, in the second example, we can make a "
"more aggressive assumption: because the ``undef`` is allowed to be an "
"arbitrary value, we are allowed to assume that it could be zero. Since a "
"divide by zero has *undefined behavior*, we are allowed to assume that the "
"operation does not execute at all. This allows us to delete the divide and "
"all code after it. Because the undefined operation \"can't happen\", the "
"optimizer can assume that it occurs in dead code."
msgstr ""

#: ../../../LangRef.rst:5057
msgid ""
"A store *of* an undefined value can be assumed to not have any effect; we "
"can assume that the value is overwritten with bits that happen to match what "
"was already there. This argument is only valid if the stored value is "
"provably not ``poison``. However, a store *to* an undefined location could "
"clobber arbitrary memory, therefore, it has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:5064
msgid ""
"Branching on an undefined value is undefined behavior. This explains "
"optimizations that depend on branch conditions to construct predicates, such "
"as Correlated Value Propagation and Global Value Numbering. In case of "
"switch instruction, the branch condition should be frozen, otherwise it is "
"undefined behavior."
msgstr ""

#: ../../../LangRef.rst:5094
msgid "Poison Values"
msgstr ""

#: ../../../LangRef.rst:5096
msgid ""
"A poison value is a result of an erroneous operation. In order to facilitate "
"speculative execution, many instructions do not invoke immediate undefined "
"behavior when provided with illegal operands, and return a poison value "
"instead. The string '``poison``' can be used anywhere a constant is "
"expected, and operations such as :ref:`add <i_add>` with the ``nsw`` flag "
"can produce a poison value."
msgstr ""

#: ../../../LangRef.rst:5104
msgid ""
"Most instructions return '``poison``' when one of their arguments is "
"'``poison``'. A notable exception is the :ref:`select instruction "
"<i_select>`. Propagation of poison can be stopped with the :ref:`freeze "
"instruction <i_freeze>`."
msgstr ""

#: ../../../LangRef.rst:5109
msgid ""
"It is correct to replace a poison value with an :ref:`undef value "
"<undefvalues>` or any value of the type."
msgstr ""

#: ../../../LangRef.rst:5112
msgid ""
"This means that immediate undefined behavior occurs if a poison value is "
"used as an instruction operand that has any values that trigger undefined "
"behavior. Notably this includes (but is not limited to):"
msgstr ""

#: ../../../LangRef.rst:5116
msgid ""
"The pointer operand of a :ref:`load <i_load>`, :ref:`store <i_store>` or any "
"other pointer dereferencing instruction (independent of address space)."
msgstr ""

#: ../../../LangRef.rst:5119
msgid ""
"The divisor operand of a ``udiv``, ``sdiv``, ``urem`` or ``srem`` "
"instruction."
msgstr ""

#: ../../../LangRef.rst:5121
msgid "The condition operand of a :ref:`br <i_br>` instruction."
msgstr ""

#: ../../../LangRef.rst:5122
msgid ""
"The callee operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>` "
"instruction."
msgstr ""

#: ../../../LangRef.rst:5124
msgid ""
"The parameter operand of a :ref:`call <i_call>` or :ref:`invoke <i_invoke>` "
"instruction, when the function or invoking call site has a ``noundef`` "
"attribute in the corresponding position."
msgstr ""

#: ../../../LangRef.rst:5127
msgid ""
"The operand of a :ref:`ret <i_ret>` instruction if the function or invoking "
"call site has a `noundef` attribute in the return value position."
msgstr ""

#: ../../../LangRef.rst:5130
msgid "Here are some examples:"
msgstr ""

#: ../../../LangRef.rst:5156
msgid "Well-Defined Values"
msgstr ""

#: ../../../LangRef.rst:5158
msgid ""
"Given a program execution, a value is *well defined* if the value does not "
"have an undef bit and is not poison in the execution. An aggregate value or "
"vector is well defined if its elements are well defined. The padding of an "
"aggregate isn't considered, since it isn't visible without storing it into "
"memory and loading it with a different type."
msgstr ""

#: ../../../LangRef.rst:5164
msgid ""
"A constant of a :ref:`single value <t_single_value>`, non-vector type is "
"well defined if it is neither '``undef``' constant nor '``poison``' "
"constant. The result of :ref:`freeze instruction <i_freeze>` is well defined "
"regardless of its operand."
msgstr ""

#: ../../../LangRef.rst:5172
msgid "Addresses of Basic Blocks"
msgstr ""

#: ../../../LangRef.rst:5174
msgid "``blockaddress(@function, %block)``"
msgstr ""

#: ../../../LangRef.rst:5176
msgid ""
"The '``blockaddress``' constant computes the address of the specified basic "
"block in the specified function."
msgstr ""

#: ../../../LangRef.rst:5179
msgid ""
"It always has a ``ptr addrspace(P)`` type, where ``P`` is the address space "
"of the function containing ``%block`` (usually ``addrspace(0)``)."
msgstr ""

#: ../../../LangRef.rst:5182
msgid "Taking the address of the entry block is illegal."
msgstr ""

#: ../../../LangRef.rst:5184
msgid ""
"This value only has defined behavior when used as an operand to the ':ref:"
"`indirectbr <i_indirectbr>`' or for comparisons against null. Pointer "
"equality tests between label addresses results in undefined behavior --- "
"though, again, comparison against null is ok, and no label is equal to the "
"null pointer. This may be passed around as an opaque pointer sized value as "
"long as the bits are not inspected. This allows ``ptrtoint`` and arithmetic "
"to be performed on these values so long as the original value is "
"reconstituted before the ``indirectbr`` instruction."
msgstr ""

#: ../../../LangRef.rst:5193
msgid ""
"Finally, some targets may provide defined semantics when using the value as "
"the operand to an inline assembly, but that is target specific."
msgstr ""

#: ../../../LangRef.rst:5199
msgid "DSO Local Equivalent"
msgstr ""

#: ../../../LangRef.rst:5201
msgid "``dso_local_equivalent @func``"
msgstr ""

#: ../../../LangRef.rst:5203
msgid ""
"A '``dso_local_equivalent``' constant represents a function which is "
"functionally equivalent to a given function, but is always defined in the "
"current linkage unit. The resulting pointer has the same type as the "
"underlying function. The resulting pointer is permitted, but not required, "
"to be different from a pointer to the function, and it may have different "
"values in different translation units."
msgstr ""

#: ../../../LangRef.rst:5210
msgid "The target function may not have ``extern_weak`` linkage."
msgstr ""

#: ../../../LangRef.rst:5212
msgid "``dso_local_equivalent`` can be implemented as such:"
msgstr ""

#: ../../../LangRef.rst:5214
msgid ""
"If the function has local linkage, hidden visibility, or is ``dso_local``, "
"``dso_local_equivalent`` can be implemented as simply a pointer to the "
"function."
msgstr ""

#: ../../../LangRef.rst:5217
msgid ""
"``dso_local_equivalent`` can be implemented with a stub that tail-calls the "
"function. Many targets support relocations that resolve at link time to "
"either a function or a stub for it, depending on whether the function is "
"defined within the linkage unit; LLVM will use this when available. (This is "
"commonly called a \"PLT stub\".) On other targets, the stub may need to be "
"emitted explicitly."
msgstr ""

#: ../../../LangRef.rst:5223
msgid ""
"This can be used wherever a ``dso_local`` instance of a function is needed "
"without needing to explicitly make the original function ``dso_local``. An "
"instance where this can be used is for static offset calculations between a "
"function and some other ``dso_local`` symbol. This is especially useful for "
"the Relative VTables C++ ABI, where dynamic relocations for function "
"pointers in VTables can be replaced with static relocations for offsets "
"between the VTable and virtual functions which may not be ``dso_local``."
msgstr ""

#: ../../../LangRef.rst:5231
msgid "This is currently only supported for ELF binary formats."
msgstr ""

#: ../../../LangRef.rst:5236
msgid "No CFI"
msgstr ""

#: ../../../LangRef.rst:5238
msgid "``no_cfi @func``"
msgstr ""

#: ../../../LangRef.rst:5240
msgid ""
"With `Control-Flow Integrity (CFI) <https://clang.llvm.org/docs/"
"ControlFlowIntegrity.html>`_, a '``no_cfi``' constant represents a function "
"reference that does not get replaced with a reference to the CFI jump table "
"in the ``LowerTypeTests`` pass. These constants may be useful in low-level "
"programs, such as operating system kernels, which need to refer to the "
"actual function body."
msgstr ""

#: ../../../LangRef.rst:5250
msgid "Pointer Authentication Constants"
msgstr ""

#: ../../../LangRef.rst:5252
msgid "``ptrauth (ptr CST, i32 KEY[, i64 DISC[, ptr ADDRDISC]?]?)``"
msgstr ""

#: ../../../LangRef.rst:5254
msgid ""
"A '``ptrauth``' constant represents a pointer with a cryptographic "
"authentication signature embedded into some bits, as described in the "
"`Pointer Authentication <PointerAuth.html>`__ document."
msgstr ""

#: ../../../LangRef.rst:5258
msgid ""
"A '``ptrauth``' constant is simply a constant equivalent to the ``llvm."
"ptrauth.sign`` intrinsic, potentially fed by a discriminator ``llvm.ptrauth."
"blend`` if needed."
msgstr ""

#: ../../../LangRef.rst:5262
msgid ""
"Its type is the same as the first argument.  An integer constant "
"discriminator and an address discriminator may be optionally specified.  "
"Otherwise, they have values ``i64 0`` and ``ptr null``."
msgstr ""

#: ../../../LangRef.rst:5266
msgid ""
"If the address discriminator is ``null`` then the expression is equivalent to"
msgstr ""

#: ../../../LangRef.rst:5273
msgid "Otherwise, the expression is equivalent to:"
msgstr ""

#: ../../../LangRef.rst:5284
msgid "Constant Expressions"
msgstr ""

#: ../../../LangRef.rst:5286
msgid ""
"Constant expressions are used to allow expressions involving other constants "
"to be used as constants. Constant expressions may be of any :ref:`first "
"class <t_firstclass>` type and may involve any LLVM operation that does not "
"have side effects (e.g. load and call are not supported). The following is "
"the syntax for constant expressions:"
msgstr ""

#: ../../../LangRef.rst:5292
msgid "``trunc (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:5293
msgid "Perform the :ref:`trunc operation <i_trunc>` on constants."
msgstr ""

#: ../../../LangRef.rst:5294
msgid "``ptrtoint (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:5295
msgid "Perform the :ref:`ptrtoint operation <i_ptrtoint>` on constants."
msgstr ""

#: ../../../LangRef.rst:5296
msgid "``ptrtoaddr (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:5297
msgid "Perform the :ref:`ptrtoaddr operation <i_ptrtoaddr>` on constants."
msgstr ""

#: ../../../LangRef.rst:5299
msgid "``inttoptr (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:5299
msgid ""
"Perform the :ref:`inttoptr operation <i_inttoptr>` on constants. This one is "
"*really* dangerous!"
msgstr ""

#: ../../../LangRef.rst:5303
msgid "``bitcast (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:5302
msgid ""
"Convert a constant, CST, to another TYPE. The constraints of the operands "
"are the same as those for the :ref:`bitcast instruction <i_bitcast>`."
msgstr ""

#: ../../../LangRef.rst:5307
msgid "``addrspacecast (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:5306
msgid ""
"Convert a constant pointer or constant vector of pointer, CST, to another "
"TYPE in a different address space. The constraints of the operands are the "
"same as those for the :ref:`addrspacecast instruction <i_addrspacecast>`."
msgstr ""

#: ../../../LangRef.rst:5314
msgid ""
"``getelementptr (TY, CSTPTR, IDX0, IDX1, ...)``, ``getelementptr inbounds "
"(TY, CSTPTR, IDX0, IDX1, ...)``"
msgstr ""

#: ../../../LangRef.rst:5310
msgid ""
"Perform the :ref:`getelementptr operation <i_getelementptr>` on constants. "
"As with the :ref:`getelementptr <i_getelementptr>` instruction, the index "
"list may have one or more indexes, which are required to make sense for the "
"type of \"pointer to TY\". These indexes may be implicitly sign-extended or "
"truncated to match the index size of CSTPTR's address space."
msgstr ""

#: ../../../LangRef.rst:5317
msgid "``extractelement (VAL, IDX)``"
msgstr ""

#: ../../../LangRef.rst:5317
msgid ""
"Perform the :ref:`extractelement operation <i_extractelement>` on constants."
msgstr ""

#: ../../../LangRef.rst:5320
msgid "``insertelement (VAL, ELT, IDX)``"
msgstr ""

#: ../../../LangRef.rst:5320
msgid ""
"Perform the :ref:`insertelement operation <i_insertelement>` on constants."
msgstr ""

#: ../../../LangRef.rst:5323
msgid "``shufflevector (VEC1, VEC2, IDXMASK)``"
msgstr ""

#: ../../../LangRef.rst:5323
msgid ""
"Perform the :ref:`shufflevector operation <i_shufflevector>` on constants."
msgstr ""

#: ../../../LangRef.rst:5325
msgid "``add (LHS, RHS)``"
msgstr ""

#: ../../../LangRef.rst:5326
msgid "Perform an addition on constants."
msgstr ""

#: ../../../LangRef.rst:5327
msgid "``sub (LHS, RHS)``"
msgstr ""

#: ../../../LangRef.rst:5328
msgid "Perform a subtraction on constants."
msgstr ""

#: ../../../LangRef.rst:5330
msgid "``xor (LHS, RHS)``"
msgstr ""

#: ../../../LangRef.rst:5330
msgid "Perform a bitwise xor on constants."
msgstr ""

#: ../../../LangRef.rst:5333
msgid "Other Values"
msgstr ""

#: ../../../LangRef.rst:5338
msgid "Inline Assembler Expressions"
msgstr ""

#: ../../../LangRef.rst:5340
msgid ""
"LLVM supports inline assembler expressions (as opposed to :ref:`Module-Level "
"Inline Assembly <moduleasm>`) through the use of a special value. This value "
"represents the inline assembler as a template string (containing the "
"instructions to emit), a list of operand constraints (stored as a string), a "
"flag that indicates whether or not the inline asm expression has side "
"effects, and a flag indicating whether the function containing the asm needs "
"to align its stack conservatively."
msgstr ""

#: ../../../LangRef.rst:5348
msgid ""
"The template string supports argument substitution of the operands using "
"\"``$``\" followed by a number, to indicate substitution of the given "
"register/memory location, as specified by the constraint string. \"``${NUM:"
"MODIFIER}``\" may also be used, where ``MODIFIER`` is a target-specific "
"annotation for how to print the operand (See :ref:`inline-asm-modifiers`)."
msgstr ""

#: ../../../LangRef.rst:5354
msgid ""
"A literal \"``$``\" may be included by using \"``$$``\" in the template. To "
"include other special characters into the output, the usual \"``\\XX``\" "
"escapes may be used, just as in other strings. Note that after template "
"substitution, the resulting assembly string is parsed by LLVM's integrated "
"assembler unless it is disabled -- even when emitting a ``.s`` file -- and "
"thus must contain assembly syntax known to LLVM."
msgstr ""

#: ../../../LangRef.rst:5361
msgid ""
"LLVM also supports a few more substitutions useful for writing inline "
"assembly:"
msgstr ""

#: ../../../LangRef.rst:5363
msgid ""
"``${:uid}``: Expands to a decimal integer unique to this inline assembly "
"blob. This substitution is useful when declaring a local label. Many "
"standard compiler optimizations, such as inlining, may duplicate an inline "
"asm blob. Adding a blob-unique identifier ensures that the two labels will "
"not conflict during assembly. This is used to implement `GCC's %= special "
"format string <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>`_."
msgstr ""

#: ../../../LangRef.rst:5369
msgid ""
"``${:comment}``: Expands to the comment character of the current target's "
"assembly dialect. This is usually ``#``, but many targets use other strings, "
"such as ``;``, ``//``, or ``!``."
msgstr ""

#: ../../../LangRef.rst:5372
msgid ""
"``${:private}``: Expands to the assembler private label prefix. Labels with "
"this prefix will not appear in the symbol table of the assembled object. "
"Typically the prefix is ``L``, but targets may use other strings. ``.L`` is "
"relatively popular."
msgstr ""

#: ../../../LangRef.rst:5377
msgid ""
"LLVM's support for inline asm is modeled closely on the requirements of "
"Clang's GCC-compatible inline-asm support. Thus, the feature-set and the "
"constraint and modifier codes listed here are similar or identical to those "
"in GCC's inline asm support. However, to be clear, the syntax of the "
"template and constraint strings described here is *not* the same as the "
"syntax accepted by GCC and Clang, and, while most constraint letters are "
"passed through as-is by Clang, some get translated to other codes when "
"converting from the C source to the LLVM assembly."
msgstr ""

#: ../../../LangRef.rst:5386
msgid "An example inline assembler expression is:"
msgstr ""

#: ../../../LangRef.rst:5392
msgid ""
"Inline assembler expressions may **only** be used as the callee operand of "
"a :ref:`call <i_call>` or an :ref:`invoke <i_invoke>` instruction. Thus, "
"typically we have:"
msgstr ""

#: ../../../LangRef.rst:5400
msgid ""
"Inline asms with side effects not visible in the constraint list must be "
"marked as having side effects. This is done through the use of the "
"'``sideeffect``' keyword, like so:"
msgstr ""

#: ../../../LangRef.rst:5408
msgid ""
"In some cases inline asms will contain code that will not work unless the "
"stack is aligned in some way, such as calls or SSE instructions on x86, yet "
"will not contain code that does that alignment within the asm. The compiler "
"should make conservative assumptions about what the asm might contain and "
"should generate its usual stack alignment code in the prologue if the "
"'``alignstack``' keyword is present:"
msgstr ""

#: ../../../LangRef.rst:5419
msgid ""
"Inline asms also support using non-standard assembly dialects. The assumed "
"dialect is ATT. When the '``inteldialect``' keyword is present, the inline "
"asm is using the Intel dialect. Currently, ATT and Intel are the only "
"supported dialects. An example is:"
msgstr ""

#: ../../../LangRef.rst:5428
msgid ""
"In the case that the inline asm might unwind the stack, the '``unwind``' "
"keyword must be used, so that the compiler emits unwinding information:"
msgstr ""

#: ../../../LangRef.rst:5436
msgid ""
"If the inline asm unwinds the stack and isn't marked with the '``unwind``' "
"keyword, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:5439
msgid ""
"If multiple keywords appear, the '``sideeffect``' keyword must come first, "
"the '``alignstack``' keyword second, the '``inteldialect``' keyword third, "
"and the '``unwind``' keyword last."
msgstr ""

#: ../../../LangRef.rst:5444
msgid "Inline Asm Constraint String"
msgstr ""

#: ../../../LangRef.rst:5446
msgid ""
"The constraint list is a comma-separated string, each element containing one "
"or more constraint codes."
msgstr ""

#: ../../../LangRef.rst:5449
msgid ""
"For each element in the constraint list an appropriate register or memory "
"operand will be chosen, and it will be made available to assembly template "
"string expansion as ``$0`` for the first constraint in the list, ``$1`` for "
"the second, etc."
msgstr ""

#: ../../../LangRef.rst:5454
msgid ""
"There are three different types of constraints, which are distinguished by a "
"prefix symbol in front of the constraint code: Output, Input, and Clobber. "
"The constraints must always be given in that order: outputs first, then "
"inputs, then clobbers. They cannot be intermingled."
msgstr ""

#: ../../../LangRef.rst:5459
msgid "There are also three different categories of constraint codes:"
msgstr ""

#: ../../../LangRef.rst:5461
msgid ""
"Register constraint. This is either a register class, or a fixed physical "
"register. This kind of constraint will allocate a register, and if "
"necessary, bitcast the argument or result to the appropriate type."
msgstr ""

#: ../../../LangRef.rst:5464
msgid ""
"Memory constraint. This kind of constraint is for use with an instruction "
"taking a memory operand. Different constraints allow for different "
"addressing modes used by the target."
msgstr ""

#: ../../../LangRef.rst:5467
msgid ""
"Immediate value constraint. This kind of constraint is for an integer or "
"other immediate value which can be rendered directly into an instruction. "
"The various target-specific constraints allow the selection of a value in "
"the proper range for the instruction you wish to use it with."
msgstr ""

#: ../../../LangRef.rst:5473
msgid "Output constraints"
msgstr ""

#: ../../../LangRef.rst:5475
msgid ""
"Output constraints are specified by an \"``=``\" prefix (e.g. \"``=r``\"). "
"This indicates that the assembly will write to this operand, and the operand "
"will then be made available as a return value of the ``asm`` expression. "
"Output constraints do not consume an argument from the call instruction. "
"(Except, see below about indirect outputs)."
msgstr ""

#: ../../../LangRef.rst:5481
msgid ""
"Normally, it is expected that no output locations are written to by the "
"assembly expression until *all* of the inputs have been read. As such, LLVM "
"may assign the same register to an output and an input. If this is not safe "
"(e.g. if the assembly contains two instructions, where the first writes to "
"one output, and the second reads an input and writes to a second output), "
"then the \"``&``\" modifier must be used (e.g. \"``=&r``\") to specify that "
"the output is an \"early-clobber\" output. Marking an output as \"early-"
"clobber\" ensures that LLVM will not use the same register for any inputs "
"(other than an input tied to this output)."
msgstr ""

#: ../../../LangRef.rst:5492
msgid "Input constraints"
msgstr ""

#: ../../../LangRef.rst:5494
msgid ""
"Input constraints do not have a prefix -- just the constraint codes. Each "
"input constraint will consume one argument from the call instruction. It is "
"not permitted for the asm to write to any input register or memory location "
"(unless that input is tied to an output). Note also that multiple inputs may "
"all be assigned to the same register, if LLVM can determine that they "
"necessarily all contain the same value."
msgstr ""

#: ../../../LangRef.rst:5501
msgid ""
"Instead of providing a Constraint Code, input constraints may also \"tie\" "
"themselves to an output constraint, by providing an integer as the "
"constraint string. Tied inputs still consume an argument from the call "
"instruction, and take up a position in the asm template numbering as is "
"usual -- they will simply be constrained to always use the same register as "
"the output they've been tied to. For example, a constraint string of "
"\"``=r,0``\" says to assign a register for output, and use that register as "
"an input as well (it being the 0'th constraint)."
msgstr ""

#: ../../../LangRef.rst:5510
msgid ""
"It is permitted to tie an input to an \"early-clobber\" output. In that "
"case, no *other* input may share the same register as the input tied to the "
"early-clobber (even when the other input has the same value)."
msgstr ""

#: ../../../LangRef.rst:5514
msgid ""
"You may only tie an input to an output which has a register constraint, not "
"a memory constraint. Only a single input may be tied to an output."
msgstr ""

#: ../../../LangRef.rst:5517
msgid ""
"There is also an \"interesting\" feature which deserves a bit of "
"explanation: if a register class constraint allocates a register which is "
"too small for the value type operand provided as input, the input value will "
"be split into multiple registers, and all of them passed to the inline asm."
msgstr ""

#: ../../../LangRef.rst:5522
msgid "However, this feature is often not as useful as you might think."
msgstr ""

#: ../../../LangRef.rst:5524
msgid ""
"Firstly, the registers are *not* guaranteed to be consecutive. So, on those "
"architectures that have instructions which operate on multiple consecutive "
"instructions, this is not an appropriate way to support them. (e.g. the 32-"
"bit SparcV8 has a 64-bit load, which instruction takes a single 32-bit "
"register. The hardware then loads into both the named register, and the next "
"register. This feature of inline asm would not be useful to support that.)"
msgstr ""

#: ../../../LangRef.rst:5531
msgid ""
"A few of the targets provide a template string modifier allowing explicit "
"access to the second register of a two-register operand (e.g. MIPS ``L``, "
"``M``, and ``D``). On such an architecture, you can actually access the "
"second allocated register (yet, still, not any subsequent ones). But, in "
"that case, you're still probably better off simply splitting the value into "
"two separate operands, for clarity. (e.g. see the description of the ``A`` "
"constraint on X86, which, despite existing only for use with this feature, "
"is not really a good idea to use)"
msgstr ""

#: ../../../LangRef.rst:5541
msgid "Indirect inputs and outputs"
msgstr ""

#: ../../../LangRef.rst:5543
msgid ""
"Indirect output or input constraints can be specified by the \"``*``\" "
"modifier (which goes after the \"``=``\" in case of an output). This "
"indicates that the asm will write to or read from the contents of an "
"*address* provided as an input argument. (Note that in this way, indirect "
"outputs act more like an *input* than an output: just like an input, they "
"consume an argument of the call expression, rather than producing a return "
"value. An indirect output constraint is an \"output\" only in that the asm "
"is expected to write to the contents of the input memory location, instead "
"of just read from it)."
msgstr ""

#: ../../../LangRef.rst:5552
msgid ""
"This is most typically used for memory constraint, e.g. \"``=*m``\", to pass "
"the address of a variable as a value."
msgstr ""

#: ../../../LangRef.rst:5555
msgid ""
"It is also possible to use an indirect *register* constraint, but only on "
"output (e.g. \"``=*r``\"). This will cause LLVM to allocate a register for "
"an output value normally, and then, separately emit a store to the address "
"provided as input, after the provided inline asm. (It's not clear what value "
"this functionality provides, compared to writing the store explicitly after "
"the asm statement, and it can only produce worse code, since it bypasses "
"many optimization passes. I would recommend not using it.)"
msgstr ""

#: ../../../LangRef.rst:5563
msgid ""
"Call arguments for indirect constraints must have pointer type and must "
"specify the :ref:`elementtype <attr_elementtype>` attribute to indicate the "
"pointer element type."
msgstr ""

#: ../../../LangRef.rst:5568
msgid "Clobber constraints"
msgstr ""

#: ../../../LangRef.rst:5570
msgid ""
"A clobber constraint is indicated by a \"``~``\" prefix. A clobber does not "
"consume an input operand, nor generate an output. Clobbers cannot use any of "
"the general constraint code letters -- they may use only explicit register "
"constraints, e.g. \"``~{eax}``\". The one exception is that a clobber string "
"of \"``~{memory}``\" indicates that the assembly writes to arbitrary "
"undeclared memory locations -- not only the memory pointed to by a declared "
"indirect output."
msgstr ""

#: ../../../LangRef.rst:5578
msgid ""
"Note that clobbering named registers that are also present in output "
"constraints is not legal."
msgstr ""

#: ../../../LangRef.rst:5582
msgid "Label constraints"
msgstr ""

#: ../../../LangRef.rst:5584
msgid ""
"A label constraint is indicated by a \"``!``\" prefix and typically used in "
"the form ``\"!i\"``. Instead of consuming call arguments, label constraints "
"consume indirect destination labels of ``callbr`` instructions."
msgstr ""

#: ../../../LangRef.rst:5588
msgid ""
"Label constraints can only be used in conjunction with ``callbr`` and the "
"number of label constraints must match the number of indirect destination "
"labels in the ``callbr`` instruction."
msgstr ""

#: ../../../LangRef.rst:5594
msgid "Constraint Codes"
msgstr ""

#: ../../../LangRef.rst:5595
msgid "After a potential prefix comes constraint code, or codes."
msgstr ""

#: ../../../LangRef.rst:5597
msgid ""
"A Constraint Code is either a single letter (e.g. \"``r``\"), a \"``^``\" "
"character followed by two letters (e.g. \"``^wc``\"), or \"``{``\" register-"
"name \"``}``\" (e.g. \"``{eax}``\")."
msgstr ""

#: ../../../LangRef.rst:5601
msgid ""
"The one and two letter constraint codes are typically chosen to be the same "
"as GCC's constraint codes."
msgstr ""

#: ../../../LangRef.rst:5604
msgid ""
"A single constraint may include one or more constraint codes in it, leaving "
"it up to LLVM to choose which one to use. This is included mainly for "
"compatibility with the translation of GCC inline asm coming from clang."
msgstr ""

#: ../../../LangRef.rst:5608
msgid ""
"There are two ways to specify alternatives, and either or both may be used "
"in an inline asm constraint list:"
msgstr ""

#: ../../../LangRef.rst:5611
msgid ""
"Append the codes to each other, making a constraint code set. E.g. "
"\"``im``\" or \"``{eax}m``\". This means \"choose any of the options in the "
"set\". The choice of constraint is made independently for each constraint in "
"the constraint list."
msgstr ""

#: ../../../LangRef.rst:5616
msgid ""
"Use \"``|``\" between constraint code sets, creating alternatives. Every "
"constraint in the constraint list must have the same number of alternative "
"sets. With this syntax, the same alternative in *all* of the items in the "
"constraint list will be chosen together."
msgstr ""

#: ../../../LangRef.rst:5621
msgid ""
"Putting those together, you might have a two operand constraint string like "
"``\"rm|r,ri|rm\"``. This indicates that if operand 0 is ``r`` or ``m``, then "
"operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand "
"1 may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type "
"m."
msgstr ""

#: ../../../LangRef.rst:5626
msgid ""
"However, the use of either of the alternatives features is *NOT* "
"recommended, as LLVM is not able to make an intelligent choice about which "
"one to use. (At the point it currently needs to choose, not enough "
"information is available to do so in a smart way.) Thus, it simply tries to "
"make a choice that's most likely to compile, not one that will be optimal "
"performance. (e.g., given \"``rm``\", it'll always choose to use memory, not "
"registers). And, if given multiple registers, or multiple register classes, "
"it will simply choose the first one. (In fact, it doesn't currently even "
"ensure explicitly specified physical registers are unique, so specifying "
"multiple physical registers as alternatives, like ``{r11}{r12},{r11}{r12}``, "
"will assign r11 to both operands, not at all what was intended.)"
msgstr ""

#: ../../../LangRef.rst:5639
msgid "Supported Constraint Code List"
msgstr ""

#: ../../../LangRef.rst:5641
msgid ""
"The constraint codes are, in general, expected to behave the same way they "
"do in GCC. LLVM's support is often implemented on an 'as-needed' basis, to "
"support C inline asm code which was supported by GCC. A mismatch in behavior "
"between LLVM and GCC likely indicates a bug in LLVM."
msgstr ""

#: ../../../LangRef.rst:5646
msgid "Some constraint codes are typically supported by all targets:"
msgstr ""

#: ../../../LangRef.rst:5648
msgid "``r``: A register in the target's general purpose register class."
msgstr ""

#: ../../../LangRef.rst:5649
msgid ""
"``m``: A memory address operand. It is target-specific what addressing modes "
"are supported, typical examples are register, or register + register offset, "
"or register + immediate offset (of some target-specific size)."
msgstr ""

#: ../../../LangRef.rst:5652
msgid ""
"``p``: An address operand. Similar to ``m``, but used by \"load address\" "
"type instructions without touching memory."
msgstr ""

#: ../../../LangRef.rst:5654
msgid ""
"``i``: An integer constant (of target-specific width). Allows either a "
"simple immediate, or a relocatable value."
msgstr ""

#: ../../../LangRef.rst:5656
msgid "``n``: An integer constant -- *not* including relocatable values."
msgstr ""

#: ../../../LangRef.rst:5657
msgid "``s``: A symbol or label reference with a constant offset."
msgstr ""

#: ../../../LangRef.rst:5658
msgid ""
"``X``: Allows an operand of any kind, no constraint whatsoever. Typically "
"useful to pass a label for an asm branch or call."
msgstr ""

#: ../../../LangRef.rst:5664
msgid "``{register-name}``: Requires exactly the named physical register."
msgstr ""

#: ../../../LangRef.rst:5666
msgid "Other constraints are target-specific:"
msgstr ""

#: ../../../LangRef.rst:5668 ../../../LangRef.rst:5982
msgid "AArch64:"
msgstr ""

#: ../../../LangRef.rst:5670
msgid ""
"``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate."
msgstr ""

#: ../../../LangRef.rst:5671
msgid ""
"``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction, i."
"e., 0 to 4095 with optional shift by 12."
msgstr ""

#: ../../../LangRef.rst:5673
msgid ""
"``J``: An immediate integer that, when negated, is valid for an ``ADD`` or "
"``SUB`` instruction, i.e., -1 to -4095 with optional left shift by 12."
msgstr ""

#: ../../../LangRef.rst:5675
msgid ""
"``K``: An immediate integer that is valid for the 'bitmask immediate 32' of "
"a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 32-bit "
"register."
msgstr ""

#: ../../../LangRef.rst:5677
msgid ""
"``L``: An immediate integer that is valid for the 'bitmask immediate 64' of "
"a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 64-bit "
"register."
msgstr ""

#: ../../../LangRef.rst:5679
msgid ""
"``M``: An immediate integer for use with the ``MOV`` assembly alias on a 32-"
"bit register. This is a superset of ``K``: in addition to the bitmask "
"immediate, also allows immediate integers which can be loaded with a single "
"``MOVZ`` or ``MOVL`` instruction."
msgstr ""

#: ../../../LangRef.rst:5683
msgid ""
"``N``: An immediate integer for use with the ``MOV`` assembly alias on a 64-"
"bit register. This is a superset of ``L``."
msgstr ""

#: ../../../LangRef.rst:5685
msgid ""
"``Q``: Memory address operand must be in a single register (no offsets). "
"(However, LLVM currently does this for the ``m`` constraint as well.)"
msgstr ""

#: ../../../LangRef.rst:5688
msgid "``r``: A 32 or 64-bit integer register (W* or X*)."
msgstr ""

#: ../../../LangRef.rst:5689
msgid ""
"``S``: A symbol or label reference with a constant offset. The generic ``s`` "
"is not supported."
msgstr ""

#: ../../../LangRef.rst:5691
msgid "``Uci``: Like r, but restricted to registers 8 to 11 inclusive."
msgstr ""

#: ../../../LangRef.rst:5692
msgid "``Ucj``: Like r, but restricted to registers 12 to 15 inclusive."
msgstr ""

#: ../../../LangRef.rst:5693
msgid ""
"``w``: A 32, 64, or 128-bit floating-point, SIMD or SVE vector register."
msgstr ""

#: ../../../LangRef.rst:5694
msgid "``x``: Like w, but restricted to registers 0 to 15 inclusive."
msgstr ""

#: ../../../LangRef.rst:5695
msgid ""
"``y``: Like w, but restricted to SVE vector registers Z0 to Z7 inclusive."
msgstr ""

#: ../../../LangRef.rst:5696
msgid "``Uph``: One of the upper eight SVE predicate registers (P8 to P15)"
msgstr ""

#: ../../../LangRef.rst:5697
msgid "``Upl``: One of the lower eight SVE predicate registers (P0 to P7)"
msgstr ""

#: ../../../LangRef.rst:5698
msgid "``Upa``: Any of the SVE predicate registers (P0 to P15)"
msgstr ""

#: ../../../LangRef.rst:5700 ../../../LangRef.rst:5991
msgid "AMDGPU:"
msgstr ""

#: ../../../LangRef.rst:5702 ../../../LangRef.rst:5850
msgid "``r``: A 32 or 64-bit integer register."
msgstr ""

#: ../../../LangRef.rst:5703
msgid "``s``: SGPR register or tuple"
msgstr ""

#: ../../../LangRef.rst:5704
msgid "``v``: VGPR register or tuple"
msgstr ""

#: ../../../LangRef.rst:5705
msgid "``a``: AGPR register or tuple. Only valid on gfx908+."
msgstr ""

#: ../../../LangRef.rst:5706
msgid "``VA``: VGPR or AGPR register or tuple. Only valid on gfx90a+."
msgstr ""

#: ../../../LangRef.rst:5707
msgid "``v[0-9]``: The 32-bit VGPR register, number 0-9."
msgstr ""

#: ../../../LangRef.rst:5708
msgid "``s[0-9]``: The 32-bit SGPR register, number 0-9."
msgstr ""

#: ../../../LangRef.rst:5709
msgid "``a[0-9]``: The 32-bit AGPR register, number 0-9."
msgstr ""

#: ../../../LangRef.rst:5710
msgid "``I``: An integer inline constant in the range from -16 to 64."
msgstr ""

#: ../../../LangRef.rst:5711
msgid "``J``: A 16-bit signed integer constant."
msgstr ""

#: ../../../LangRef.rst:5712
msgid "``A``: An integer or a floating-point inline constant."
msgstr ""

#: ../../../LangRef.rst:5713
msgid "``B``: A 32-bit signed integer constant."
msgstr ""

#: ../../../LangRef.rst:5714
msgid ""
"``C``: A 32-bit unsigned integer constant or an integer inline constant in "
"the range from -16 to 64."
msgstr ""

#: ../../../LangRef.rst:5715
msgid "``DA``: A 64-bit constant that can be split into two \"A\" constants."
msgstr ""

#: ../../../LangRef.rst:5716
msgid "``DB``: A 64-bit constant that can be split into two \"B\" constants."
msgstr ""

#: ../../../LangRef.rst:5718
msgid "All ARM modes:"
msgstr ""

#: ../../../LangRef.rst:5720
msgid ""
"``Q``, ``Um``, ``Un``, ``Uq``, ``Us``, ``Ut``, ``Uv``, ``Uy``: Memory "
"address operand. Treated the same as operand ``m``, at the moment."
msgstr ""

#: ../../../LangRef.rst:5722
msgid ""
"``Te``: An even general-purpose 32-bit integer register: ``r0,r2,...,r12,"
"r14``"
msgstr ""

#: ../../../LangRef.rst:5723
msgid ""
"``To``: An odd general-purpose 32-bit integer register: ``r1,r3,...,r11``"
msgstr ""

#: ../../../LangRef.rst:5725
msgid "ARM and ARM's Thumb2 mode:"
msgstr ""

#: ../../../LangRef.rst:5727
msgid "``j``: An immediate integer between 0 and 65535 (valid for ``MOVW``)"
msgstr ""

#: ../../../LangRef.rst:5728
msgid "``I``: An immediate integer valid for a data-processing instruction."
msgstr ""

#: ../../../LangRef.rst:5729
msgid "``J``: An immediate integer between -4095 and 4095."
msgstr ""

#: ../../../LangRef.rst:5730
msgid ""
"``K``: An immediate integer whose bitwise inverse is valid for a data-"
"processing instruction. (Can be used with template modifier \"``B``\" to "
"print the inverted value)."
msgstr ""

#: ../../../LangRef.rst:5733
msgid ""
"``L``: An immediate integer whose negation is valid for a data-processing "
"instruction. (Can be used with template modifier \"``n``\" to print the "
"negated value)."
msgstr ""

#: ../../../LangRef.rst:5736
msgid "``M``: A power of two or an integer between 0 and 32."
msgstr ""

#: ../../../LangRef.rst:5737
msgid "``N``: Invalid immediate constraint."
msgstr ""

#: ../../../LangRef.rst:5738
msgid "``O``: Invalid immediate constraint."
msgstr ""

#: ../../../LangRef.rst:5739
msgid "``r``: A general-purpose 32-bit integer register (``r0-r15``)."
msgstr ""

#: ../../../LangRef.rst:5740
msgid ""
"``l``: In Thumb2 mode, low 32-bit GPR registers (``r0-r7``). In ARM mode, "
"same as ``r``."
msgstr ""

#: ../../../LangRef.rst:5742
msgid ""
"``h``: In Thumb2 mode, a high 32-bit GPR register (``r8-r15``). In ARM mode, "
"invalid."
msgstr ""

#: ../../../LangRef.rst:5744 ../../../LangRef.rst:5764
msgid ""
"``w``: A 32, 64, or 128-bit floating-point/SIMD register in the ranges ``s0-"
"s31``, ``d0-d31``, or ``q0-q15``, respectively."
msgstr ""

#: ../../../LangRef.rst:5746 ../../../LangRef.rst:5766
msgid ""
"``t``: A 32, 64, or 128-bit floating-point/SIMD register in the ranges ``s0-"
"s31``, ``d0-d15``, or ``q0-q7``, respectively."
msgstr ""

#: ../../../LangRef.rst:5748 ../../../LangRef.rst:5768
msgid ""
"``x``: A 32, 64, or 128-bit floating-point/SIMD register in the ranges ``s0-"
"s15``, ``d0-d7``, or ``q0-q3``, respectively."
msgstr ""

#: ../../../LangRef.rst:5751
msgid "ARM's Thumb1 mode:"
msgstr ""

#: ../../../LangRef.rst:5753
msgid "``I``: An immediate integer between 0 and 255."
msgstr ""

#: ../../../LangRef.rst:5754
msgid "``J``: An immediate integer between -255 and -1."
msgstr ""

#: ../../../LangRef.rst:5755
msgid ""
"``K``: An immediate integer between 0 and 255, with optional left-shift by "
"some amount."
msgstr ""

#: ../../../LangRef.rst:5757
msgid "``L``: An immediate integer between -7 and 7."
msgstr ""

#: ../../../LangRef.rst:5758
msgid ""
"``M``: An immediate integer which is a multiple of 4 between 0 and 1020."
msgstr ""

#: ../../../LangRef.rst:5759
msgid "``N``: An immediate integer between 0 and 31."
msgstr ""

#: ../../../LangRef.rst:5760
msgid ""
"``O``: An immediate integer which is a multiple of 4 between -508 and 508."
msgstr ""

#: ../../../LangRef.rst:5761
msgid "``r``: A low 32-bit GPR register (``r0-r7``)."
msgstr ""

#: ../../../LangRef.rst:5762
msgid "``l``: A low 32-bit GPR register (``r0-r7``)."
msgstr ""

#: ../../../LangRef.rst:5763
msgid "``h``: A high GPR register (``r0-r7``)."
msgstr ""

#: ../../../LangRef.rst:5771 ../../../LangRef.rst:6024
msgid "Hexagon:"
msgstr ""

#: ../../../LangRef.rst:5773
msgid ""
"``o``, ``v``: A memory address operand, treated the same as constraint "
"``m``, at the moment."
msgstr ""

#: ../../../LangRef.rst:5775
msgid "``r``: A 32 or 64-bit register."
msgstr ""

#: ../../../LangRef.rst:5777 ../../../LangRef.rst:6035
msgid "LoongArch:"
msgstr ""

#: ../../../LangRef.rst:5779
msgid "``f``: A floating-point register (if available)."
msgstr ""

#: ../../../LangRef.rst:5780
msgid ""
"``k``: A memory operand whose address is formed by a base register and "
"(optionally scaled) index register."
msgstr ""

#: ../../../LangRef.rst:5782
msgid "``l``: A signed 16-bit constant."
msgstr ""

#: ../../../LangRef.rst:5783
msgid ""
"``m``: A memory operand whose address is formed by a base register and "
"offset that is suitable for use in instructions with the same addressing "
"mode as st.w and ld.w."
msgstr ""

#: ../../../LangRef.rst:5786
msgid ""
"``q``: A general-purpose register except for $r0 and $r1 (for the csrxchg "
"instruction)."
msgstr ""

#: ../../../LangRef.rst:5788
msgid "``I``: A signed 12-bit constant (for arithmetic instructions)."
msgstr ""

#: ../../../LangRef.rst:5789 ../../../LangRef.rst:5804
msgid "``J``: An immediate integer zero."
msgstr ""

#: ../../../LangRef.rst:5790
msgid "``K``: An unsigned 12-bit constant (for logic instructions)."
msgstr ""

#: ../../../LangRef.rst:5791
msgid ""
"``ZB``: An address that is held in a general-purpose register. The offset is "
"zero."
msgstr ""

#: ../../../LangRef.rst:5793
msgid ""
"``ZC``: A memory operand whose address is formed by a base register and "
"offset that is suitable for use in instructions with the same addressing "
"mode as ll.w and sc.w."
msgstr ""

#: ../../../LangRef.rst:5797 ../../../LangRef.rst:6041
msgid "MSP430:"
msgstr ""

#: ../../../LangRef.rst:5799
msgid "``r``: An 8 or 16-bit register."
msgstr ""

#: ../../../LangRef.rst:5801 ../../../LangRef.rst:6045
msgid "MIPS:"
msgstr ""

#: ../../../LangRef.rst:5803 ../../../LangRef.rst:5839
msgid "``I``: An immediate signed 16-bit integer."
msgstr ""

#: ../../../LangRef.rst:5805 ../../../LangRef.rst:5841
msgid "``K``: An immediate unsigned 16-bit integer."
msgstr ""

#: ../../../LangRef.rst:5806
msgid "``L``: An immediate 32-bit integer, where the lower 16 bits are 0."
msgstr ""

#: ../../../LangRef.rst:5807
msgid "``N``: An immediate integer between -65535 and -1."
msgstr ""

#: ../../../LangRef.rst:5808
msgid "``O``: An immediate signed 15-bit integer."
msgstr ""

#: ../../../LangRef.rst:5809
msgid "``P``: An immediate integer between 1 and 65535."
msgstr ""

#: ../../../LangRef.rst:5810
msgid ""
"``m``: A memory address operand. In MIPS-SE mode, allows a base address "
"register plus 16-bit immediate offset. In MIPS mode, just a base register."
msgstr ""

#: ../../../LangRef.rst:5812
msgid ""
"``R``: A memory address operand. In MIPS-SE mode, allows a base address "
"register plus a 9-bit signed offset. In MIPS mode, the same as constraint "
"``m``."
msgstr ""

#: ../../../LangRef.rst:5815
msgid ""
"``ZC``: A memory address operand, suitable for use in a ``pref``, ``ll``, or "
"``sc`` instruction on the given subtarget (details vary)."
msgstr ""

#: ../../../LangRef.rst:5817
msgid "``r``, ``d``,  ``y``: A 32 or 64-bit GPR register."
msgstr ""

#: ../../../LangRef.rst:5818
msgid ""
"``f``: A 32 or 64-bit FPU register (``F0-F31``), or a 128-bit MSA register "
"(``W0-W31``). In the case of MSA registers, it is recommended to use the "
"``w`` argument modifier for compatibility with GCC."
msgstr ""

#: ../../../LangRef.rst:5821
msgid ""
"``c``: A 32-bit or 64-bit GPR register suitable for indirect jump (always "
"``25``)."
msgstr ""

#: ../../../LangRef.rst:5823
msgid "``l``: The ``lo`` register, 32 or 64-bit."
msgstr ""

#: ../../../LangRef.rst:5824
msgid "``x``: Invalid."
msgstr ""

#: ../../../LangRef.rst:5826 ../../../LangRef.rst:6070
msgid "NVPTX:"
msgstr ""

#: ../../../LangRef.rst:5828
msgid "``b``: A 1-bit integer register."
msgstr ""

#: ../../../LangRef.rst:5829
msgid "``c`` or ``h``: A 16-bit integer register."
msgstr ""

#: ../../../LangRef.rst:5830 ../../../LangRef.rst:5882
#: ../../../LangRef.rst:5956
msgid "``r``: A 32-bit integer register."
msgstr ""

#: ../../../LangRef.rst:5831
msgid "``l`` or ``N``: A 64-bit integer register."
msgstr ""

#: ../../../LangRef.rst:5832
msgid "``q``: A 128-bit integer register."
msgstr ""

#: ../../../LangRef.rst:5833
msgid "``f``: A 32-bit float register."
msgstr ""

#: ../../../LangRef.rst:5834
msgid "``d``: A 64-bit float register."
msgstr ""

#: ../../../LangRef.rst:5837 ../../../LangRef.rst:6074
msgid "PowerPC:"
msgstr ""

#: ../../../LangRef.rst:5840
msgid "``J``: An immediate unsigned 16-bit integer, shifted left 16 bits."
msgstr ""

#: ../../../LangRef.rst:5842
msgid "``L``: An immediate signed 16-bit integer, shifted left 16 bits."
msgstr ""

#: ../../../LangRef.rst:5843
msgid "``M``: An immediate integer greater than 31."
msgstr ""

#: ../../../LangRef.rst:5844
msgid "``N``: An immediate integer that is an exact power of 2."
msgstr ""

#: ../../../LangRef.rst:5845
msgid "``O``: The immediate integer constant 0."
msgstr ""

#: ../../../LangRef.rst:5846
msgid ""
"``P``: An immediate integer constant whose negation is a signed 16-bit "
"constant."
msgstr ""

#: ../../../LangRef.rst:5848
msgid ""
"``es``, ``o``, ``Q``, ``Z``, ``Zy``: A memory address operand, currently "
"treated the same as ``m``."
msgstr ""

#: ../../../LangRef.rst:5851
msgid ""
"``b``: A 32 or 64-bit integer register, excluding ``R0`` (that is: ``R1-"
"R31``)."
msgstr ""

#: ../../../LangRef.rst:5853
msgid "``f``: A 32 or 64-bit float register (``F0-F31``),"
msgstr ""

#: ../../../LangRef.rst:5855
msgid "``v``: For ``4 x f32`` or ``4 x f64`` types, a 128-bit altivec vector"
msgstr ""

#: ../../../LangRef.rst:5855
msgid "register (``V0-V31``)."
msgstr ""

#: ../../../LangRef.rst:5857
msgid "``y``: Condition register (``CR0-CR7``)."
msgstr ""

#: ../../../LangRef.rst:5858
msgid "``wc``: An individual CR bit in a CR register."
msgstr ""

#: ../../../LangRef.rst:5859
msgid ""
"``wa``, ``wd``, ``wf``: Any 128-bit VSX vector register, from the full VSX "
"register set (overlapping both the floating-point and vector register files)."
msgstr ""

#: ../../../LangRef.rst:5861
msgid ""
"``ws``: A 32 or 64-bit floating-point register, from the full VSX register "
"set."
msgstr ""

#: ../../../LangRef.rst:5864 ../../../LangRef.rst:6092
msgid "RISC-V:"
msgstr ""

#: ../../../LangRef.rst:5866
msgid ""
"``A``: An address operand (using a general-purpose register, without an "
"offset)."
msgstr ""

#: ../../../LangRef.rst:5868
msgid "``I``: A 12-bit signed integer immediate operand."
msgstr ""

#: ../../../LangRef.rst:5869
msgid "``J``: A zero integer immediate operand."
msgstr ""

#: ../../../LangRef.rst:5870
msgid "``K``: A 5-bit unsigned integer immediate operand."
msgstr ""

#: ../../../LangRef.rst:5871
msgid ""
"``f``: A 32- or 64-bit floating-point register (requires F or D extension)."
msgstr ""

#: ../../../LangRef.rst:5872
msgid ""
"``r``: A 32- or 64-bit general-purpose register (depending on the platform "
"``XLEN``)."
msgstr ""

#: ../../../LangRef.rst:5874
msgid "``S``: Alias for ``s``."
msgstr ""

#: ../../../LangRef.rst:5875
msgid "``vd``: A vector register, excluding ``v0`` (requires V extension)."
msgstr ""

#: ../../../LangRef.rst:5876
msgid "``vm``: The vector register ``v0`` (requires V extension)."
msgstr ""

#: ../../../LangRef.rst:5877
msgid "``vr``: A vector register (requires V extension)."
msgstr ""

#: ../../../LangRef.rst:5879 ../../../LangRef.rst:6099
msgid "Sparc:"
msgstr ""

#: ../../../LangRef.rst:5881
msgid "``I``: An immediate 13-bit signed integer."
msgstr ""

#: ../../../LangRef.rst:5883
msgid ""
"``f``: Any floating-point register on SparcV8, or a floating-point register "
"in the \"low\" half of the registers on SparcV9."
msgstr ""

#: ../../../LangRef.rst:5885
msgid "``e``: Any floating-point register. (Same as ``f`` on SparcV8.)"
msgstr ""

#: ../../../LangRef.rst:5887 ../../../LangRef.rst:6105
msgid "SystemZ:"
msgstr ""

#: ../../../LangRef.rst:5889
msgid "``I``: An immediate unsigned 8-bit integer."
msgstr ""

#: ../../../LangRef.rst:5890
msgid "``J``: An immediate unsigned 12-bit integer."
msgstr ""

#: ../../../LangRef.rst:5891
msgid "``K``: An immediate signed 16-bit integer."
msgstr ""

#: ../../../LangRef.rst:5892
msgid "``L``: An immediate signed 20-bit integer."
msgstr ""

#: ../../../LangRef.rst:5893
msgid "``M``: An immediate integer 0x7fffffff."
msgstr ""

#: ../../../LangRef.rst:5894
msgid ""
"``Q``: A memory address operand with a base address and a 12-bit immediate "
"unsigned displacement."
msgstr ""

#: ../../../LangRef.rst:5896
msgid ""
"``R``: A memory address operand with a base address, a 12-bit immediate "
"unsigned displacement, and an index register."
msgstr ""

#: ../../../LangRef.rst:5898
msgid ""
"``S``: A memory address operand with a base address and a 20-bit immediate "
"signed displacement."
msgstr ""

#: ../../../LangRef.rst:5900
msgid ""
"``T``: A memory address operand with a base address, a 20-bit immediate "
"signed displacement, and an index register."
msgstr ""

#: ../../../LangRef.rst:5902
msgid "``r`` or ``d``: A 32, 64, or 128-bit integer register."
msgstr ""

#: ../../../LangRef.rst:5903
msgid ""
"``a``: A 32, 64, or 128-bit integer address register (excludes R0, which in "
"an address context evaluates as zero)."
msgstr ""

#: ../../../LangRef.rst:5905
msgid ""
"``h``: A 32-bit value in the high part of a 64bit data register (LLVM-"
"specific)"
msgstr ""

#: ../../../LangRef.rst:5907
msgid "``f``: A 16, 32, 64, or 128-bit floating-point register."
msgstr ""

#: ../../../LangRef.rst:5909 ../../../LangRef.rst:6110
msgid "X86:"
msgstr ""

#: ../../../LangRef.rst:5911
msgid "``I``: An immediate integer between 0 and 31."
msgstr ""

#: ../../../LangRef.rst:5912
msgid "``J``: An immediate integer between 0 and 64."
msgstr ""

#: ../../../LangRef.rst:5913
msgid "``K``: An immediate signed 8-bit integer."
msgstr ""

#: ../../../LangRef.rst:5914
msgid ""
"``L``: An immediate integer, 0xff or 0xffff or (in 64-bit mode only) "
"0xffffffff."
msgstr ""

#: ../../../LangRef.rst:5916
msgid "``M``: An immediate integer between 0 and 3."
msgstr ""

#: ../../../LangRef.rst:5917
msgid "``N``: An immediate unsigned 8-bit integer."
msgstr ""

#: ../../../LangRef.rst:5918
msgid "``O``: An immediate integer between 0 and 127."
msgstr ""

#: ../../../LangRef.rst:5919
msgid "``e``: An immediate 32-bit signed integer."
msgstr ""

#: ../../../LangRef.rst:5920
msgid "``Z``: An immediate 32-bit unsigned integer."
msgstr ""

#: ../../../LangRef.rst:5921
msgid ""
"``q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit "
"``l`` integer register. On X86-32, this is the ``a``, ``b``, ``c``, and "
"``d`` registers, and on X86-64, it is all of the integer registers. When "
"feature `egpr` and `inline-asm-use-gpr32` are both on, it will be extended "
"to gpr32."
msgstr ""

#: ../../../LangRef.rst:5925
msgid ""
"``Q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit "
"``h`` integer register. This is the ``a``, ``b``, ``c``, and ``d`` registers."
msgstr ""

#: ../../../LangRef.rst:5927
msgid ""
"``r`` or ``l``: An 8, 16, 32, or 64-bit integer register. When feature "
"`egpr` and `inline-asm-use-gpr32` are both on, it will be extended to gpr32."
msgstr ""

#: ../../../LangRef.rst:5929
msgid ""
"``R``: An 8, 16, 32, or 64-bit \"legacy\" integer register -- one which has "
"existed since i386, and can be accessed without the REX prefix."
msgstr ""

#: ../../../LangRef.rst:5931
msgid "``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register."
msgstr ""

#: ../../../LangRef.rst:5932
msgid "``y``: A 64-bit MMX register, if MMX is enabled."
msgstr ""

#: ../../../LangRef.rst:5933
msgid ""
"``v``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector "
"operand in a SSE register. If AVX is also enabled, can also be a 256-bit "
"vector operand in an AVX register. If AVX-512 is also enabled, can also be a "
"512-bit vector operand in an AVX512 register. Otherwise, an error."
msgstr ""

#: ../../../LangRef.rst:5937
msgid ""
"``Ws``: A symbolic reference with an optional constant addend or a label "
"reference."
msgstr ""

#: ../../../LangRef.rst:5939
msgid ""
"``x``: The same as ``v``, except that when AVX-512 is enabled, the ``x`` "
"code only allocates into the first 16 AVX-512 registers, while the ``v`` "
"code allocates into any of the 32 AVX-512 registers."
msgstr ""

#: ../../../LangRef.rst:5942
msgid "``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error."
msgstr ""

#: ../../../LangRef.rst:5943
msgid ""
"``A``: Special case: allocates EAX first, then EDX, for a single operand (in "
"32-bit mode, a 64-bit integer operand will get split into two registers). It "
"is not recommended to use this constraint, as in 64-bit mode, the 64-bit "
"operand will get allocated only to RAX -- if two 32-bit operands are needed, "
"you're better off splitting it yourself, before passing it to the asm "
"statement."
msgstr ""

#: ../../../LangRef.rst:5949
msgid ""
"``jr``: An 8, 16, 32, or 64-bit integer gpr16. It won't be extended to gpr32 "
"when feature `egpr` or `inline-asm-use-gpr32` is on."
msgstr ""

#: ../../../LangRef.rst:5951
msgid ""
"``jR``: An 8, 16, 32, or 64-bit integer gpr32 when feature `egpr`` is on. "
"Otherwise, same as ``r``."
msgstr ""

#: ../../../LangRef.rst:5954 ../../../LangRef.rst:6138
msgid "XCore:"
msgstr ""

#: ../../../LangRef.rst:5962
msgid "Asm template argument modifiers"
msgstr ""

#: ../../../LangRef.rst:5964
msgid ""
"In the asm template string, modifiers can be used on the operand reference, "
"like \"``${0:n}``\"."
msgstr ""

#: ../../../LangRef.rst:5967
msgid ""
"The modifiers are, in general, expected to behave the same way they do in "
"GCC. LLVM's support is often implemented on an 'as-needed' basis, to support "
"C inline asm code which was supported by GCC. A mismatch in behavior between "
"LLVM and GCC likely indicates a bug in LLVM."
msgstr ""

#: ../../../LangRef.rst:5972
msgid "Target-independent:"
msgstr ""

#: ../../../LangRef.rst:5974
msgid "``a``: Print a memory reference. Targets might customize the output."
msgstr ""

#: ../../../LangRef.rst:5975
msgid ""
"``c``: Print an immediate integer constant unadorned, without the target-"
"specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../../LangRef.rst:5977
msgid ""
"``n``: Negate and print immediate integer constant unadorned, without the "
"target-specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../../LangRef.rst:5979
msgid ""
"``l``: Print as an unadorned label, without the target-specific label "
"punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../../LangRef.rst:5984
msgid ""
"``w``: Print a GPR register with a ``w*`` name instead of ``x*`` name. E.g., "
"instead of ``x30``, print ``w30``."
msgstr ""

#: ../../../LangRef.rst:5986
msgid ""
"``x``: Print a GPR register with a ``x*`` name. (this is the default, "
"anyhow)."
msgstr ""

#: ../../../LangRef.rst:5987
msgid ""
"``b``, ``h``, ``s``, ``d``, ``q``: Print a floating-point/SIMD register with "
"a ``b*``, ``h*``, ``s*``, ``d*``, or ``q*`` name, rather than the default of "
"``v*``."
msgstr ""

#: ../../../LangRef.rst:5993 ../../../LangRef.rst:6072
#: ../../../LangRef.rst:6103
msgid "``r``: No effect."
msgstr ""

#: ../../../LangRef.rst:5995
msgid "ARM:"
msgstr ""

#: ../../../LangRef.rst:5997
msgid ""
"``a``: Print an operand as an address (with ``[`` and ``]`` surrounding a "
"register)."
msgstr ""

#: ../../../LangRef.rst:5999
msgid "``P``: No effect."
msgstr ""

#: ../../../LangRef.rst:6000
msgid "``q``: No effect."
msgstr ""

#: ../../../LangRef.rst:6001
msgid ""
"``y``: Print a VFP single-precision register as an indexed double (e.g. "
"print as ``d4[1]`` instead of ``s9``)"
msgstr ""

#: ../../../LangRef.rst:6003
msgid ""
"``B``: Bitwise invert and print an immediate integer constant without ``#`` "
"prefix."
msgstr ""

#: ../../../LangRef.rst:6005
msgid "``L``: Print the low 16-bits of an immediate integer constant."
msgstr ""

#: ../../../LangRef.rst:6006
msgid ""
"``M``: Print as a register set suitable for ldm/stm. Also prints *all* "
"register operands subsequent to the specified one (!), so use carefully."
msgstr ""

#: ../../../LangRef.rst:6008
msgid ""
"``Q``: Print the low-order register of a register-pair, or the low-order "
"register of a two-register operand."
msgstr ""

#: ../../../LangRef.rst:6010
msgid ""
"``R``: Print the high-order register of a register-pair, or the high-order "
"register of a two-register operand."
msgstr ""

#: ../../../LangRef.rst:6012
msgid ""
"``H``: Print the second register of a register-pair. (On a big-endian "
"system, ``H`` is equivalent to ``Q``, and on little-endian system, ``H`` is "
"equivalent to ``R``.)"
msgstr ""

#: ../../../LangRef.rst:6019
msgid "``e``: Print the low doubleword register of a NEON quad register."
msgstr ""

#: ../../../LangRef.rst:6020
msgid "``f``: Print the high doubleword register of a NEON quad register."
msgstr ""

#: ../../../LangRef.rst:6021
msgid ""
"``m``: Print the base register of a memory operand without the ``[`` and "
"``]`` adornment."
msgstr ""

#: ../../../LangRef.rst:6026 ../../../LangRef.rst:6076
msgid ""
"``L``: Print the second register of a two-register operand. Requires that it "
"has been allocated consecutively to the first."
msgstr ""

#: ../../../LangRef.rst:6032 ../../../LangRef.rst:6082
msgid ""
"``I``: Print the letter 'i' if the operand is an integer constant, otherwise "
"nothing. Used to print 'addi' vs 'add' instructions."
msgstr ""

#: ../../../LangRef.rst:6037
msgid "``u``: Print an LASX register."
msgstr ""

#: ../../../LangRef.rst:6038
msgid "``w``: Print an LSX register."
msgstr ""

#: ../../../LangRef.rst:6039
msgid ""
"``z``: Print $zero register if operand is zero, otherwise print it normally."
msgstr ""

#: ../../../LangRef.rst:6043 ../../../LangRef.rst:6140
msgid "No additional modifiers."
msgstr ""

#: ../../../LangRef.rst:6047
msgid "``X``: Print an immediate integer as hexadecimal"
msgstr ""

#: ../../../LangRef.rst:6048
msgid "``x``: Print the low 16 bits of an immediate integer as hexadecimal."
msgstr ""

#: ../../../LangRef.rst:6049
msgid "``d``: Print an immediate integer as decimal."
msgstr ""

#: ../../../LangRef.rst:6050
msgid "``m``: Subtract one and print an immediate integer as decimal."
msgstr ""

#: ../../../LangRef.rst:6051
msgid "``z``: Print $0 if an immediate zero, otherwise print normally."
msgstr ""

#: ../../../LangRef.rst:6052
msgid ""
"``L``: Print the low-order register of a two-register operand, or prints the "
"address of the low-order word of a double-word memory operand."
msgstr ""

#: ../../../LangRef.rst:6057
msgid ""
"``M``: Print the high-order register of a two-register operand, or prints "
"the address of the high-order word of a double-word memory operand."
msgstr ""

#: ../../../LangRef.rst:6062
msgid ""
"``D``: Print the second register of a two-register operand, or prints the "
"second word of a double-word memory operand. (On a big-endian system, ``D`` "
"is equivalent to ``L``, and on little-endian system, ``D`` is equivalent to "
"``M``.)"
msgstr ""

#: ../../../LangRef.rst:6066
msgid ""
"``w``: No effect. Provided for compatibility with GCC which requires this "
"modifier in order to print MSA registers (``W0-W31``) with the ``f`` "
"constraint."
msgstr ""

#: ../../../LangRef.rst:6084
msgid ""
"``y``: For a memory operand, prints formatter for a two-register X-form "
"instruction. (Currently always prints ``r0,OPERAND``)."
msgstr ""

#: ../../../LangRef.rst:6086
msgid ""
"``U``: Prints 'u' if the memory operand is an update form, and nothing "
"otherwise. (NOTE: LLVM does not support update form, so this will currently "
"always print nothing)"
msgstr ""

#: ../../../LangRef.rst:6089
msgid ""
"``X``: Prints 'x' if the memory operand is an indexed form. (NOTE: LLVM does "
"not support indexed form, so this will currently always print nothing)"
msgstr ""

#: ../../../LangRef.rst:6094
msgid ""
"``i``: Print the letter 'i' if the operand is not a register, otherwise "
"print nothing. Used to print 'addi' vs 'add' instructions, etc."
msgstr ""

#: ../../../LangRef.rst:6096
msgid ""
"``z``: Print the register ``zero`` if an immediate zero, otherwise print "
"normally."
msgstr ""

#: ../../../LangRef.rst:6101
msgid "``L``: Print the low-order register of a two-register operand."
msgstr ""

#: ../../../LangRef.rst:6102
msgid "``H``: Print the high-order register of a two-register operand."
msgstr ""

#: ../../../LangRef.rst:6107
msgid ""
"SystemZ implements only ``n``, and does *not* support any of the other "
"target-independent modifiers."
msgstr ""

#: ../../../LangRef.rst:6112
msgid ""
"``a``: Print a memory reference. This displays as ``sym(%rip)`` for x86-64. "
"i386 should only use this with the static relocation model."
msgstr ""

#: ../../../LangRef.rst:6114
msgid ""
"``c``: Print an unadorned integer or symbol name. (The latter is target-"
"specific behavior for this typically target-independent modifier)."
msgstr ""

#: ../../../LangRef.rst:6116
msgid "``A``: Print a register name with a '``*``' before it."
msgstr ""

#: ../../../LangRef.rst:6117
msgid ""
"``b``: Print an 8-bit register name (e.g. ``al``); do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:6119
msgid ""
"``h``: Print the upper 8-bit register name (e.g. ``ah``); do nothing on a "
"memory operand."
msgstr ""

#: ../../../LangRef.rst:6121
msgid ""
"``w``: Print the 16-bit register name (e.g. ``ax``); do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:6123
msgid ""
"``k``: Print the 32-bit register name (e.g. ``eax``); do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:6125
msgid ""
"``q``: Print the 64-bit register name (e.g. ``rax``), if 64-bit registers "
"are available, otherwise the 32-bit register name; do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:6127
msgid ""
"``n``: Negate and print an unadorned integer, or, for operands other than an "
"immediate integer (e.g. a relocatable symbol expression), print a '-' before "
"the operand. (The behavior for relocatable symbol expressions is a target-"
"specific behavior for this typically target-independent modifier)"
msgstr ""

#: ../../../LangRef.rst:6131
msgid "``H``: Print a memory reference with additional offset +8."
msgstr ""

#: ../../../LangRef.rst:6132
msgid "``p``: Print a raw symbol name (without syntax-specific prefixes)."
msgstr ""

#: ../../../LangRef.rst:6133
msgid ""
"``P``: Print a memory reference used as the argument of a call instruction "
"or used with explicit base reg and index reg as its offset. So it can not "
"use additional regs to present the memory reference. (E.g. omit ``(rip)``, "
"even though it's PC-relative.)"
msgstr ""

#: ../../../LangRef.rst:6144
msgid "Inline Asm Metadata"
msgstr ""

#: ../../../LangRef.rst:6146
msgid ""
"The call instructions that wrap inline asm nodes may have a \"``!srcloc``\" "
"MDNode attached to it that contains a list of constant integers. If present, "
"the code generator will use the integer as the location cookie value when "
"reporting errors through the ``LLVMContext`` error reporting mechanisms. "
"This allows a front-end to correlate backend errors that occur with inline "
"asm back to the source code that produced it. For example:"
msgstr ""

#: ../../../LangRef.rst:6160
msgid ""
"It is up to the front-end to make sense of the magic numbers it places in "
"the IR. If the MDNode contains multiple constants, the code generator will "
"use the one that corresponds to the line of the asm that the error occurs on."
msgstr ""

#: ../../../LangRef.rst:6168
msgid "Metadata"
msgstr ""

#: ../../../LangRef.rst:6170
msgid ""
"LLVM IR allows metadata to be attached to instructions and global objects in "
"the program that can convey extra information about the code to the "
"optimizers and code generator."
msgstr ""

#: ../../../LangRef.rst:6174
msgid ""
"There are two metadata primitives: strings and nodes. There are also "
"specialized nodes which have a distinguished name and a set of named "
"arguments."
msgstr ""

#: ../../../LangRef.rst:6180
msgid ""
"One example application of metadata is source-level debug information, which "
"is currently the only user of specialized nodes."
msgstr ""

#: ../../../LangRef.rst:6183
msgid "Metadata does not have a type, and is not a value."
msgstr ""

#: ../../../LangRef.rst:6185
msgid ""
"A value of non-\\ ``metadata`` type can be used in a metadata context using "
"the syntax '``<type> <value>``'."
msgstr ""

#: ../../../LangRef.rst:6188
msgid ""
"All other metadata is identified in syntax as starting with an exclamation "
"point ('``!``')."
msgstr ""

#: ../../../LangRef.rst:6191
msgid ""
"Metadata may be used in the following value contexts by using the "
"``metadata`` type:"
msgstr ""

#: ../../../LangRef.rst:6194
msgid ""
"Arguments to certain intrinsic functions, as described in their "
"specification."
msgstr ""

#: ../../../LangRef.rst:6195
msgid "Arguments to the ``catchpad``/``cleanuppad`` instructions."
msgstr ""

#: ../../../LangRef.rst:6199
msgid ""
"Metadata can be \"wrapped\" in a ``MetadataAsValue`` so it can be referenced "
"in a value context: ``MetadataAsValue`` is-a ``Value``."
msgstr ""

#: ../../../LangRef.rst:6202
msgid ""
"A typed value can be \"wrapped\" in ``ValueAsMetadata`` so it can be "
"referenced in a metadata context: ``ValueAsMetadata`` is-a ``Metadata``."
msgstr ""

#: ../../../LangRef.rst:6205
msgid ""
"There is no explicit syntax for a ``ValueAsMetadata``, and instead the fact "
"that a type identifier cannot begin with an exclamation point is used to "
"resolve ambiguity."
msgstr ""

#: ../../../LangRef.rst:6209
msgid ""
"A ``metadata`` type implies a ``MetadataAsValue``, and when followed with a "
"'``<type> <value>``' pair it wraps the typed value in a ``ValueAsMetadata``."
msgstr ""

#: ../../../LangRef.rst:6212
msgid ""
"For example, the first argument to this call is a "
"``MetadataAsValue(ValueAsMetadata(Value))``:"
msgstr ""

#: ../../../LangRef.rst:6219
msgid ""
"Whereas the first argument to this call is a ``MetadataAsValue(MDNode)``:"
msgstr ""

#: ../../../LangRef.rst:6225
msgid "The first element of this ``MDTuple`` is a ``MDNode``:"
msgstr ""

#: ../../../LangRef.rst:6231
msgid ""
"And the first element of this ``MDTuple`` is a ``ValueAsMetadata(Value)``:"
msgstr ""

#: ../../../LangRef.rst:6240
msgid "Metadata Strings (``MDString``)"
msgstr ""

#: ../../../LangRef.rst:6245
msgid ""
"A metadata string is a string surrounded by double quotes. It can contain "
"any character by escaping non-printable characters with \"``\\xx``\" where "
"\"``xx``\" is the two digit hex code. For example: \"``!\"test\\00\"``\"."
msgstr ""

#: ../../../LangRef.rst:6252
msgid "A metadata string is metadata, but is not a metadata node."
msgstr ""

#: ../../../LangRef.rst:6257
msgid "Metadata Nodes (``MDNode``)"
msgstr ""

#: ../../../LangRef.rst:6262
msgid ""
"Metadata tuples are represented with notation similar to structure "
"constants: a comma separated list of elements, surrounded by braces and "
"preceded by an exclamation point. Metadata nodes can have any values as "
"their operand. For example:"
msgstr ""

#: ../../../LangRef.rst:6271
msgid ""
"Metadata nodes that aren't uniqued use the ``distinct`` keyword. For example:"
msgstr ""

#: ../../../LangRef.rst:6277
msgid ""
"``distinct`` nodes are useful when nodes shouldn't be merged based on their "
"content. They can also occur when transformations cause uniquing collisions "
"when metadata operands change."
msgstr ""

#: ../../../LangRef.rst:6281
msgid ""
"A :ref:`named metadata <namedmetadatastructure>` is a collection of metadata "
"nodes, which can be looked up in the module symbol table. For example:"
msgstr ""

#: ../../../LangRef.rst:6289
msgid ""
"Metadata can be used as function arguments. Here the ``llvm.dbg.value`` "
"intrinsic is using three metadata arguments:"
msgstr ""

#: ../../../LangRef.rst:6302
msgid ""
"Metadata can be attached to an instruction. Here metadata ``!21`` is "
"attached to the ``add`` instruction using the ``!dbg`` identifier:"
msgstr ""

#: ../../../LangRef.rst:6309
msgid ""
"Instructions may not have multiple metadata attachments with the same "
"identifier."
msgstr ""

#: ../../../LangRef.rst:6312
msgid ""
"Metadata can also be attached to a function or a global variable. Here "
"metadata ``!22`` is attached to the ``f1`` and ``f2`` functions, and the "
"globals ``g1`` and ``g2`` using the ``!dbg`` identifier:"
msgstr ""

#: ../../../LangRef.rst:6326
msgid ""
"Unlike instructions, global objects (functions and global variables) may "
"have multiple metadata attachments with the same identifier."
msgstr ""

#: ../../../LangRef.rst:6329
msgid ""
"A transformation is required to drop any metadata attachment that it does "
"not recognize or cannot preserve. Currently there is an exception for "
"metadata attachment to globals for ``!func_sanitize``, ``!type``, ``!"
"absolute_symbol`` and ``!associated`` which can't be unconditionally dropped "
"unless the global is itself deleted."
msgstr ""

#: ../../../LangRef.rst:6335
msgid ""
"Metadata attached to a module using named metadata may not be dropped, with "
"the exception of debug metadata (named metadata with the name ``!llvm.dbg."
"*``)."
msgstr ""

#: ../../../LangRef.rst:6338
msgid ""
"More information about specific metadata nodes recognized by the optimizers "
"and code generator is found below."
msgstr ""

#: ../../../LangRef.rst:6344
msgid "Specialized Metadata Nodes"
msgstr ""

#: ../../../LangRef.rst:6346
msgid ""
"Specialized metadata nodes are custom data structures in metadata (as "
"opposed to generic tuples). Their fields are labelled, and can be specified "
"in any order."
msgstr ""

#: ../../../LangRef.rst:6350
msgid ""
"These aren't inherently debug info centric, but currently all the "
"specialized metadata nodes are related to debug info."
msgstr ""

#: ../../../LangRef.rst:6356
msgid "DICompileUnit"
msgstr ""

#: ../../../LangRef.rst:6358
msgid ""
"``DICompileUnit`` nodes represent a compile unit. The ``enums:``, "
"``retainedTypes:``, ``globals:``, ``imports:`` and ``macros:`` fields are "
"tuples containing the debug info to be emitted along with the compile unit, "
"regardless of code optimizations (some nodes are only emitted if there are "
"references to them from instructions). The ``debugInfoForProfiling:`` field "
"is a boolean indicating whether or not line-table discriminators are updated "
"to provide more-accurate debug info for profiling results."
msgstr ""

#: ../../../LangRef.rst:6374
msgid ""
"Compile unit descriptors provide the root scope for objects declared in a "
"specific compilation unit. File descriptors are defined using this scope.  "
"These descriptors are collected by a named metadata node ``!llvm.dbg.cu``. "
"They keep track of global variables, type information, and imported entities "
"(declarations and namespaces)."
msgstr ""

#: ../../../LangRef.rst:6383
msgid "DIFile"
msgstr ""

#: ../../../LangRef.rst:6385
msgid ""
"``DIFile`` nodes represent files. The ``filename:`` can include slashes."
msgstr ""

#: ../../../LangRef.rst:6393
msgid ""
"Files are sometimes used in ``scope:`` fields, and are the only valid target "
"for ``file:`` fields."
msgstr ""

#: ../../../LangRef.rst:6396
msgid ""
"The ``checksum:`` and ``checksumkind:`` fields are optional. If one of these "
"fields is present, then the other is required to be present as well. Valid "
"values for ``checksumkind:`` field are: {CSK_MD5, CSK_SHA1, CSK_SHA256}"
msgstr ""

#: ../../../LangRef.rst:6403
msgid "DIBasicType"
msgstr ""

#: ../../../LangRef.rst:6405
msgid ""
"``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` "
"and ``float``. ``tag:`` defaults to ``DW_TAG_base_type``."
msgstr ""

#: ../../../LangRef.rst:6414
msgid ""
"The ``encoding:`` describes the details of the type. Usually it's one of the "
"following:"
msgstr ""

#: ../../../LangRef.rst:6430
msgid "DIFixedPointType"
msgstr ""

#: ../../../LangRef.rst:6432
msgid ""
"``DIFixedPointType`` nodes represent fixed-point types.  A fixed-point type "
"is conceptually an integer with a scale factor. ``DIFixedPointType`` is "
"derived from ``DIBasicType`` and inherits its attributes.  However, only "
"certain encodings are accepted:"
msgstr ""

#: ../../../LangRef.rst:6442
msgid ""
"There are three kinds of fixed-point type: binary, where the scale factor is "
"a power of 2; decimal, where the scale factor is a power of 10; and "
"rational, where the scale factor is an arbitrary rational number."
msgstr ""

#: ../../../LangRef.rst:6459
msgid "DISubroutineType"
msgstr ""

#: ../../../LangRef.rst:6461
msgid ""
"``DISubroutineType`` nodes represent subroutine types. Their ``types:`` "
"field refers to a tuple; the first operand is the return type, while the "
"rest are the types of the formal arguments in order. If the first operand is "
"``null``, that represents a function with no return value (such as ``void "
"foo() {}`` in C++)."
msgstr ""

#: ../../../LangRef.rst:6475
msgid "DIDerivedType"
msgstr ""

#: ../../../LangRef.rst:6477
msgid ""
"``DIDerivedType`` nodes represent types derived from other types, such as "
"qualified types."
msgstr ""

#: ../../../LangRef.rst:6487 ../../../LangRef.rst:6552
msgid "The following ``tag:`` values are valid:"
msgstr ""

#: ../../../LangRef.rst:6506
msgid ""
"``DW_TAG_member`` is used to define a member of a :ref:`composite type "
"<DICompositeType>`. The type of the member is the ``baseType:``. The "
"``offset:`` is the member's bit offset.  If the composite type has an ODR "
"``identifier:`` and does not set ``flags: DIFwdDecl``, then the member is "
"uniqued based only on its ``name:`` and ``scope:``."
msgstr ""

#: ../../../LangRef.rst:6512
msgid ""
"``DW_TAG_inheritance`` and ``DW_TAG_friend`` are used in the ``elements:`` "
"field of :ref:`composite types <DICompositeType>` to describe parents and "
"friends."
msgstr ""

#: ../../../LangRef.rst:6516
msgid "``DW_TAG_typedef`` is used to provide a name for the ``baseType:``."
msgstr ""

#: ../../../LangRef.rst:6518
msgid ""
"``DW_TAG_pointer_type``, ``DW_TAG_reference_type``, ``DW_TAG_const_type``, "
"``DW_TAG_volatile_type``, ``DW_TAG_restrict_type``, ``DW_TAG_atomic_type`` "
"and ``DW_TAG_immutable_type`` are used to qualify the ``baseType:``."
msgstr ""

#: ../../../LangRef.rst:6522
msgid "Note that the ``void *`` type is expressed as a type derived from NULL."
msgstr ""

#: ../../../LangRef.rst:6527
msgid "DICompositeType"
msgstr ""

#: ../../../LangRef.rst:6529
msgid ""
"``DICompositeType`` nodes represent types composed of other types, like "
"structures and unions. ``elements:`` points to a tuple of the composed types."
msgstr ""

#: ../../../LangRef.rst:6532
msgid ""
"If the source language supports ODR, the ``identifier:`` field gives the "
"unique identifier used for type merging between modules.  When specified, :"
"ref:`subprogram declarations <DISubprogramDeclaration>` and :ref:`member "
"derived types <DIDerivedTypeMember>` that reference the ODR-type in their "
"``scope:`` change uniquing rules."
msgstr ""

#: ../../../LangRef.rst:6538
msgid ""
"For a given ``identifier:``, there should only be a single composite type "
"that does not have  ``flags: DIFlagFwdDecl`` set.  LLVM tools that link "
"modules together will unique such definitions at parse time via the "
"``identifier:`` field, even if the nodes are ``distinct``."
msgstr ""

#: ../../../LangRef.rst:6564
msgid ""
"For ``DW_TAG_array_type``, the ``elements:`` should be :ref:`subrange "
"descriptors <DISubrange>` or :ref:`subrange descriptors <DISubrangeType>`, "
"each representing the range of subscripts at that level of indexing. The "
"``DIFlagVector`` flag to ``flags:`` indicates that an array type is a native "
"packed vector. The optional ``dataLocation`` is a ``DIExpression`` that "
"describes how to get from an object's address to the actual raw data, if "
"they aren't equivalent. This is only supported for array types, particularly "
"to describe Fortran arrays, which have an array descriptor in addition to "
"the array data. Alternatively it can also be ``DIVariable`` which has the "
"address of the actual raw data. The Fortran language supports pointer arrays "
"which can be attached to actual arrays, this attachment between pointer and "
"pointee is called association.  The optional ``associated`` is a "
"``DIExpression`` that describes whether the pointer array is currently "
"associated.  The optional ``allocated`` is a ``DIExpression`` that describes "
"whether the allocatable array is currently allocated.  The optional ``rank`` "
"is a ``DIExpression`` that describes the rank (number of dimensions) of "
"Fortran assumed rank array (rank is known at runtime).  The optional "
"``bitStride`` is an unsigned constant that describes the number of bits "
"occupied by an element of the array; this is only needed if it differs from "
"the element type's natural size, and is normally used for packed arrays."
msgstr ""

#: ../../../LangRef.rst:6587
msgid ""
"For ``DW_TAG_enumeration_type``, the ``elements:`` should be :ref:"
"`enumerator descriptors <DIEnumerator>`, each representing the definition of "
"an enumeration value for the set. All enumeration type descriptors are "
"collected in the ``enums:`` field of the :ref:`compile unit <DICompileUnit>`."
msgstr ""

#: ../../../LangRef.rst:6592
msgid ""
"For ``DW_TAG_structure_type``, ``DW_TAG_class_type``, and "
"``DW_TAG_union_type``, the ``elements:`` should be :ref:`derived types "
"<DIDerivedType>` with ``tag: DW_TAG_member``, ``tag: DW_TAG_inheritance``, "
"or ``tag: DW_TAG_friend``; or :ref:`subprograms <DISubprogram>` with "
"``isDefinition: false``."
msgstr ""

#: ../../../LangRef.rst:6598
msgid ""
"``DW_TAG_variant_part`` introduces a variant part of a structure type. This "
"should have a discriminant, a member that is used to decide which elements "
"are active.  The elements of the variant part should each be a "
"``DW_TAG_member``; if a member has a non-null ``ExtraData``, then it is a "
"``ConstantInt`` or ``ConstantDataArray`` indicating the values of the "
"discriminant member that cause the activation of this branch.  A member "
"itself may be of composite type with tag ``DW_TAG_variant``; in this case "
"the members of that composite type are inlined into the current one."
msgstr ""

#: ../../../LangRef.rst:6611
msgid "DISubrange"
msgstr ""

#: ../../../LangRef.rst:6613
msgid ""
"``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants of :"
"ref:`DICompositeType`."
msgstr ""

#: ../../../LangRef.rst:6616
msgid "``count: -1`` indicates an empty array."
msgstr ""

#: ../../../LangRef.rst:6617
msgid "``count: !10`` describes the count with a :ref:`DILocalVariable`."
msgstr ""

#: ../../../LangRef.rst:6618
msgid "``count: !12`` describes the count with a :ref:`DIGlobalVariable`."
msgstr ""

#: ../../../LangRef.rst:6643
msgid "DISubrangeType"
msgstr ""

#: ../../../LangRef.rst:6645
msgid ""
"``DISubrangeType`` is similar to ``DISubrange``, but it is also a "
"``DIType``.  It may be used as the type of an object, but could also be used "
"as an array index."
msgstr ""

#: ../../../LangRef.rst:6649
msgid ""
"Like ``DISubrange``, it can hold a lower bound and count, or a lower bound "
"and upper bound.  A ``DISubrangeType`` refers to the underlying type of "
"which it is a subrange; this type can be an integer type or an enumeration "
"type."
msgstr ""

#: ../../../LangRef.rst:6654
msgid ""
"A ``DISubrangeType`` may also have a stride -- unlike ``DISubrange``, this "
"stride is a bit stride.  The stride is only useful when a ``DISubrangeType`` "
"is used as an array index type."
msgstr ""

#: ../../../LangRef.rst:6658
msgid ""
"Finally, ``DISubrangeType`` may have a bias.  In Ada, a program can request "
"that a subrange value be stored in the minimum number of bits required.  In "
"this situation, the stored value is biased by the lower bound -- e.g., a "
"range ``-7 .. 0`` may take 3 bits in memory, and the value -5 would be "
"stored as 2 (a bias of -7)."
msgstr ""

#: ../../../LangRef.rst:6687
msgid "DIEnumerator"
msgstr ""

#: ../../../LangRef.rst:6689
msgid ""
"``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type`` "
"variants of :ref:`DICompositeType`."
msgstr ""

#: ../../../LangRef.rst:6699
msgid "DITemplateTypeParameter"
msgstr ""

#: ../../../LangRef.rst:6701
msgid ""
"``DITemplateTypeParameter`` nodes represent type parameters to generic "
"source language constructs. They are used (optionally) in :ref:"
"`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` fields."
msgstr ""

#: ../../../LangRef.rst:6710
msgid "DITemplateValueParameter"
msgstr ""

#: ../../../LangRef.rst:6712
msgid ""
"``DITemplateValueParameter`` nodes represent value parameters to generic "
"source language constructs. ``tag:`` defaults to "
"``DW_TAG_template_value_parameter``, but if specified can also be set to "
"``DW_TAG_GNU_template_template_param`` or "
"``DW_TAG_GNU_template_param_pack``. They are used (optionally) in :ref:"
"`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` fields."
msgstr ""

#: ../../../LangRef.rst:6723
msgid "DINamespace"
msgstr ""

#: ../../../LangRef.rst:6725
msgid "``DINamespace`` nodes represent namespaces in the source language."
msgstr ""

#: ../../../LangRef.rst:6734
msgid "DIGlobalVariable"
msgstr ""

#: ../../../LangRef.rst:6736
msgid ""
"``DIGlobalVariable`` nodes represent global variables in the source language."
msgstr ""

#: ../../../LangRef.rst:6748
msgid "DIGlobalVariableExpression"
msgstr ""

#: ../../../LangRef.rst:6750
msgid ""
"``DIGlobalVariableExpression`` nodes tie a :ref:`DIGlobalVariable` together "
"with a :ref:`DIExpression`."
msgstr ""

#: ../../../LangRef.rst:6768
msgid ""
"All global variable expressions should be referenced by the `globals:` field "
"of a :ref:`compile unit <DICompileUnit>`."
msgstr ""

#: ../../../LangRef.rst:6774
msgid "DISubprogram"
msgstr ""

#: ../../../LangRef.rst:6776
msgid ""
"``DISubprogram`` nodes represent functions from the source language. A "
"distinct ``DISubprogram`` may be attached to a function definition using ``!"
"dbg`` metadata. A unique ``DISubprogram`` may be attached to a function "
"declaration used for call site debug info. The ``retainedNodes:`` field is a "
"list of :ref:`variables <DILocalVariable>` and :ref:`labels <DILabel>` that "
"must be retained, even if their IR counterparts are optimized out of the IR. "
"The ``type:`` field must point at an :ref:`DISubroutineType`."
msgstr ""

#: ../../../LangRef.rst:6786
msgid ""
"When ``spFlags: DISPFlagDefinition`` is not present, subprograms describe a "
"declaration in the type tree as opposed to a definition of a function. In "
"this case, the ``declaration`` field must be empty. If the scope is a "
"composite type with an ODR ``identifier:`` and that does not set ``flags: "
"DIFwdDecl``, then the subprogram declaration is uniqued based only on its "
"``linkageName:`` and ``scope:``."
msgstr ""

#: ../../../LangRef.rst:6812
msgid "DILexicalBlock"
msgstr ""

#: ../../../LangRef.rst:6814
msgid ""
"``DILexicalBlock`` nodes describe nested blocks within a :ref:`subprogram "
"<DISubprogram>`. The line number and column numbers are used to distinguish "
"two lexical blocks at same depth. They are valid targets for ``scope:`` "
"fields."
msgstr ""

#: ../../../LangRef.rst:6823
msgid ""
"Usually lexical blocks are ``distinct`` to prevent node merging based on "
"operands."
msgstr ""

#: ../../../LangRef.rst:6829
msgid "DILexicalBlockFile"
msgstr ""

#: ../../../LangRef.rst:6831
msgid ""
"``DILexicalBlockFile`` nodes are used to discriminate between sections of a :"
"ref:`lexical block <DILexicalBlock>`. The ``file:`` field can be changed to "
"indicate textual inclusion, or the ``discriminator:`` field can be used to "
"discriminate between control flow within a single block in the source "
"language."
msgstr ""

#: ../../../LangRef.rst:6845
msgid "DILocation"
msgstr ""

#: ../../../LangRef.rst:6847
msgid ""
"``DILocation`` nodes represent source debug locations. The ``scope:`` field "
"is mandatory, and points at an :ref:`DILexicalBlockFile`, an :ref:"
"`DILexicalBlock`, or an :ref:`DISubprogram`."
msgstr ""

#: ../../../LangRef.rst:6858
msgid "DILocalVariable"
msgstr ""

#: ../../../LangRef.rst:6860
msgid ""
"``DILocalVariable`` nodes represent local variables in the source language. "
"If the ``arg:`` field is set to non-zero, then this variable is a subprogram "
"parameter, and it will be included in the ``retainedNodes:`` field of its :"
"ref:`DISubprogram`."
msgstr ""

#: ../../../LangRef.rst:6874
msgid "DIExpression"
msgstr ""

#: ../../../LangRef.rst:6876
msgid ""
"``DIExpression`` nodes represent expressions that are inspired by the DWARF "
"expression language. They are used in :ref:`debug records <debug_records>` "
"(such as ``#dbg_declare`` and ``#dbg_value``) to describe how the referenced "
"LLVM variable relates to the source language variable."
msgstr ""

#: ../../../LangRef.rst:6881
msgid "See :ref:`diexpression` for details."
msgstr ""

#: ../../../LangRef.rst:6885
msgid ""
"``DIExpression``\\s are always printed and parsed inline; they can never be "
"referenced by an ID (e.g. ``!1``)."
msgstr ""

#: ../../../LangRef.rst:6888
msgid "Some examples of expressions:"
msgstr ""

#: ../../../LangRef.rst:6901
msgid "DIAssignID"
msgstr ""

#: ../../../LangRef.rst:6903
msgid ""
"``DIAssignID`` nodes have no operands and are always distinct. They are used "
"to link together (:ref:`#dbg_assign records <debugrecords>`) and "
"instructions that store in IR. See `Debug Info Assignment Tracking "
"<AssignmentTracking.html>`_ for more info."
msgstr ""

#: ../../../LangRef.rst:6916
msgid "DIArgList"
msgstr ""

#: ../../../LangRef.rst:6924
msgid ""
"``DIArgList`` nodes hold a list of constant or SSA value references. These "
"are used in :ref:`debug records <debugrecords>` in combination with a "
"``DIExpression`` that uses the ``DW_OP_LLVM_arg`` operator. Because a "
"``DIArgList`` may refer to local values within a function, it must only be "
"used as a function argument, must always be inlined, and cannot appear in "
"named metadata."
msgstr ""

#: ../../../LangRef.rst:6939
msgid "DIFlags"
msgstr ""

#: ../../../LangRef.rst:6941
msgid "These flags encode various properties of DINodes."
msgstr ""

#: ../../../LangRef.rst:6943
msgid ""
"The `ExportSymbols` flag marks a class, struct or union whose members may be "
"referenced as if they were defined in the containing class or union. This "
"flag is used to decide whether the ``DW_AT_export_symbols`` can be used for "
"the structure type."
msgstr ""

#: ../../../LangRef.rst:6949
msgid "DIObjCProperty"
msgstr ""

#: ../../../LangRef.rst:6951
msgid "``DIObjCProperty`` nodes represent Objective-C property nodes."
msgstr ""

#: ../../../LangRef.rst:6959
msgid "DIImportedEntity"
msgstr ""

#: ../../../LangRef.rst:6961
msgid ""
"``DIImportedEntity`` nodes represent entities (such as modules) imported "
"into a compile unit. The ``elements`` field is a list of renamed entities "
"(such as variables and subprograms) in the imported entity (such as module)."
msgstr ""

#: ../../../LangRef.rst:6974
msgid "DIMacro"
msgstr ""

#: ../../../LangRef.rst:6976
msgid ""
"``DIMacro`` nodes represent definition or undefinition of a macro "
"identifiers. The ``name:`` field is the macro identifier, followed by macro "
"parameters when defining a function-like macro, and the ``value`` field is "
"the token-string used to expand the macro identifier."
msgstr ""

#: ../../../LangRef.rst:6988
msgid "DIMacroFile"
msgstr ""

#: ../../../LangRef.rst:6990
msgid ""
"``DIMacroFile`` nodes represent inclusion of source files. The ``nodes:`` "
"field is a list of ``DIMacro`` and ``DIMacroFile`` nodes that appear in the "
"included source file."
msgstr ""

#: ../../../LangRef.rst:7002
msgid "DILabel"
msgstr ""

#: ../../../LangRef.rst:7004
msgid ""
"``DILabel`` nodes represent labels within a :ref:`DISubprogram`. The ``scope:"
"`` field must be one of either a :ref:`DILexicalBlockFile`, a :ref:"
"`DILexicalBlock`, or a :ref:`DISubprogram`. The ``name:`` field is the label "
"identifier. The ``file:`` field is the :ref:`DIFile` the label is present "
"in. The ``line:`` and ``column:`` field are the source line and column "
"within the file where the label is declared."
msgstr ""

#: ../../../LangRef.rst:7011
msgid ""
"Furthermore, a label can be marked as artificial, i.e., compiler-generated, "
"using ``isArtificial:``. Such artificial labels are generated, e.g., by the "
"``CoroSplit`` pass. In addition, the ``CoroSplit`` pass also uses the "
"``coroSuspendIdx:`` field to identify the coroutine suspend points."
msgstr ""

#: ../../../LangRef.rst:7016
msgid ""
"``scope:``, ``name:``, ``file:`` and ``line:`` are mandatory. The remaining "
"fields are optional."
msgstr ""

#: ../../../LangRef.rst:7025
msgid "DICommonBlock"
msgstr ""

#: ../../../LangRef.rst:7027
msgid ""
"``DICommonBlock`` nodes represent Fortran common blocks. The ``scope:`` "
"field is mandatory and points to a :ref:`DILexicalBlockFile`, a :ref:"
"`DILexicalBlock`, or a :ref:`DISubprogram`. The ``declaration:``, ``name:``, "
"``file:``, and ``line:`` fields are optional."
msgstr ""

#: ../../../LangRef.rst:7033
msgid "DIModule"
msgstr ""

#: ../../../LangRef.rst:7035
msgid ""
"``DIModule`` nodes represent a source language module, for example, a Clang "
"module, or a Fortran module. The ``scope:`` field is mandatory and points to "
"a :ref:`DILexicalBlockFile`, a :ref:`DILexicalBlock`, or a :ref:"
"`DISubprogram`. The ``name:`` field is mandatory. The ``configMacros:``, "
"``includePath:``, ``apinotes:``, ``file:``, ``line:``, and ``isDecl:`` "
"fields are optional."
msgstr ""

#: ../../../LangRef.rst:7042
msgid "DIStringType"
msgstr ""

#: ../../../LangRef.rst:7044
msgid ""
"``DIStringType`` nodes represent a Fortran ``CHARACTER(n)`` type, with a "
"dynamic length and location encoded as an expression. The ``tag:`` field is "
"optional and defaults to ``DW_TAG_string_type``. The ``name:``, "
"``stringLength:``, ``stringLengthExpression``, ``stringLocationExpression:"
"``, ``size:``, ``align:``, and ``encoding:`` fields are optional."
msgstr ""

#: ../../../LangRef.rst:7050
msgid ""
"If not present, the ``size:`` and ``align:`` fields default to the value "
"zero."
msgstr ""

#: ../../../LangRef.rst:7052
msgid ""
"The length in bits of the string is specified by the first of the following "
"fields present:"
msgstr ""

#: ../../../LangRef.rst:7055
msgid ""
"``stringLength:``, which points to a ``DIVariable`` whose value is the "
"string length in bits."
msgstr ""

#: ../../../LangRef.rst:7057
msgid ""
"``stringLengthExpression:``, which points to a ``DIExpression`` which "
"computes the length in bits."
msgstr ""

#: ../../../LangRef.rst:7059
msgid "``size``, which contains the literal length in bits."
msgstr ""

#: ../../../LangRef.rst:7061
msgid ""
"The ``stringLocationExpression:`` points to a ``DIExpression`` which "
"describes the \"data location\" of the string object, if present."
msgstr ""

#: ../../../LangRef.rst:7065
msgid "'``tbaa``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7067
msgid ""
"In LLVM IR, memory does not have types, so LLVM's own type system is not "
"suitable for doing type based alias analysis (TBAA). Instead, metadata is "
"added to the IR to describe a type system of a higher level language. This "
"can be used to implement C/C++ strict type aliasing rules, but it can also "
"be used to implement custom alias analysis behavior for other languages."
msgstr ""

#: ../../../LangRef.rst:7073
msgid ""
"This description of LLVM's TBAA system is broken into two parts: :ref:"
"`Semantics<tbaa_node_semantics>` talks about high level issues, and :ref:"
"`Representation<tbaa_node_representation>` talks about the metadata encoding "
"of various entities."
msgstr ""

#: ../../../LangRef.rst:7078
msgid ""
"It is always possible to trace any TBAA node to a \"root\" TBAA node "
"(details in the :ref:`Representation<tbaa_node_representation>` section).  "
"TBAA nodes with different roots have an unknown aliasing relationship, and "
"LLVM conservatively infers ``MayAlias`` between them.  The rules mentioned "
"in this section only pertain to TBAA nodes living under the same root."
msgstr ""

#: ../../../LangRef.rst:7087
msgid "Semantics"
msgstr ""

#: ../../../LangRef.rst:7089
msgid ""
"The TBAA metadata system, referred to as \"struct path TBAA\" (not to be "
"confused with ``tbaa.struct``), consists of the following high level "
"concepts: *Type Descriptors*, further subdivided into scalar type "
"descriptors and struct type descriptors; and *Access Tags*."
msgstr ""

#: ../../../LangRef.rst:7094
msgid ""
"**Type descriptors** describe the type system of the higher level language "
"being compiled.  **Scalar type descriptors** describe types that do not "
"contain other types.  Each scalar type has a parent type, which must also be "
"a scalar type or the TBAA root.  Via this parent relation, scalar types "
"within a TBAA root form a tree.  **Struct type descriptors** denote types "
"that contain a sequence of other type descriptors, at known offsets.  These "
"contained type descriptors can either be struct type descriptors themselves "
"or scalar type descriptors."
msgstr ""

#: ../../../LangRef.rst:7103
msgid ""
"**Access tags** are metadata nodes attached to load and store instructions. "
"Access tags use type descriptors to describe the *location* being accessed "
"in terms of the type system of the higher level language.  Access tags are "
"tuples consisting of a base type, an access type and an offset.  The base "
"type is a scalar type descriptor or a struct type descriptor, the access "
"type is a scalar type descriptor, and the offset is a constant integer."
msgstr ""

#: ../../../LangRef.rst:7110
msgid ""
"The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two things:"
msgstr ""

#: ../../../LangRef.rst:7113
msgid ""
"If ``BaseTy`` is a struct type, the tag describes a memory access (load or "
"store) of a value of type ``AccessTy`` contained in the struct type "
"``BaseTy`` at offset ``Offset``."
msgstr ""

#: ../../../LangRef.rst:7117
msgid ""
"If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and "
"``AccessTy`` must be the same; and the access tag describes a scalar access "
"with scalar type ``AccessTy``."
msgstr ""

#: ../../../LangRef.rst:7121
msgid ""
"We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)`` "
"tuples this way:"
msgstr ""

#: ../../../LangRef.rst:7124
msgid ""
"If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is "
"``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as "
"described in the TBAA metadata.  ``ImmediateParent(BaseTy, Offset)`` is "
"undefined if ``Offset`` is non-zero."
msgstr ""

#: ../../../LangRef.rst:7129
msgid ""
"If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)`` is "
"``(NewTy, NewOffset)`` where ``NewTy`` is the type contained in ``BaseTy`` "
"at offset ``Offset`` and ``NewOffset`` is ``Offset`` adjusted to be relative "
"within that inner type."
msgstr ""

#: ../../../LangRef.rst:7134
msgid ""
"A memory access with an access tag ``(BaseTy1, AccessTy1, Offset1)`` aliases "
"a memory access with an access tag ``(BaseTy2, AccessTy2, Offset2)`` if "
"either ``(BaseTy1, Offset1)`` is reachable from ``(Base2, Offset2)`` via the "
"``Parent`` relation or vice versa. If memory accesses alias even though they "
"are noalias according to ``!tbaa`` metadata, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:7141
msgid ""
"As a concrete example, the type descriptor graph for the following program"
msgstr ""

#: ../../../LangRef.rst:7163
msgid ""
"is (note that in C and C++, ``char`` can be used to access any arbitrary "
"type):"
msgstr ""

#: ../../../LangRef.rst:7178
msgid ""
"with (e.g.) ``ImmediateParent(OuterStructTy, 12)`` = ``(InnerStructTy, 0)``, "
"``ImmediateParent(InnerStructTy, 0)`` = ``(IntScalarTy, 0)``, and "
"``ImmediateParent(IntScalarTy, 0)`` = ``(CharScalarTy, 0)``."
msgstr ""

#: ../../../LangRef.rst:7185
msgid "Representation"
msgstr ""

#: ../../../LangRef.rst:7187
msgid ""
"The root node of a TBAA type hierarchy is an ``MDNode`` with 0 operands or "
"with exactly one ``MDString`` operand."
msgstr ""

#: ../../../LangRef.rst:7190
msgid ""
"Scalar type descriptors are represented as an ``MDNode`` s with two "
"operands.  The first operand is an ``MDString`` denoting the name of the "
"struct type.  LLVM does not assign meaning to the value of this operand, it "
"only cares about it being an ``MDString``.  The second operand is an "
"``MDNode`` which points to the parent for said scalar type descriptor, which "
"is either another scalar type descriptor or the TBAA root.  Scalar type "
"descriptors can have an optional third argument, but that must be the "
"constant integer zero."
msgstr ""

#: ../../../LangRef.rst:7199
msgid ""
"Struct type descriptors are represented as ``MDNode`` s with an odd number "
"of operands greater than 1.  The first operand is an ``MDString`` denoting "
"the name of the struct type.  Like in scalar type descriptors the actual "
"value of this name operand is irrelevant to LLVM.  After the name operand, "
"the struct type descriptors have a sequence of alternating ``MDNode`` and "
"``ConstantInt`` operands.  With N starting from 1, the 2N - 1 th operand, an "
"``MDNode``, denotes a contained field, and the 2N th operand, a "
"``ConstantInt``, is the offset of the said contained field.  The offsets "
"must be in non-decreasing order."
msgstr ""

#: ../../../LangRef.rst:7209
msgid ""
"Access tags are represented as ``MDNode`` s with either 3 or 4 operands. The "
"first operand is an ``MDNode`` pointing to the node representing the base "
"type.  The second operand is an ``MDNode`` pointing to the node representing "
"the access type.  The third operand is a ``ConstantInt`` that states the "
"offset of the access.  If a fourth field is present, it must be a "
"``ConstantInt`` valued at 0 or 1.  If it is 1 then the access tag states "
"that the location being accessed is \"constant\" (meaning "
"``pointsToConstantMemory`` should return true; see `other useful "
"AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_).  The TBAA root of "
"the access type and the base type of an access tag must be the same, and "
"that is the TBAA root of the access tag."
msgstr ""

#: ../../../LangRef.rst:7222
msgid "'``tbaa.struct``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7224
msgid ""
"The :ref:`llvm.memcpy <int_memcpy>` is often used to implement aggregate "
"assignment operations in C and similar languages, however it is defined to "
"copy a contiguous region of memory, which is more than strictly necessary "
"for aggregate types which contain holes due to padding. Also, it doesn't "
"contain any TBAA information about the fields of the aggregate."
msgstr ""

#: ../../../LangRef.rst:7231
msgid ""
"``!tbaa.struct`` metadata can describe which memory subregions in a memcpy "
"are padding and what the TBAA tags of the struct are."
msgstr ""

#: ../../../LangRef.rst:7234
msgid ""
"The current metadata format is very simple. ``!tbaa.struct`` metadata nodes "
"are a list of operands which are in conceptual groups of three. For each "
"group of three, the first operand gives the byte offset of a field in bytes, "
"the second gives its size in bytes, and the third gives its tbaa tag. e.g.:"
msgstr ""

#: ../../../LangRef.rst:7244
msgid ""
"This describes a struct with two fields. The first is at offset 0 bytes with "
"size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes and has "
"size 4 bytes and has tbaa tag !2."
msgstr ""

#: ../../../LangRef.rst:7248
msgid ""
"Note that the fields need not be contiguous. In this example, there is a 4 "
"byte gap between the two fields. This gap represents padding which does not "
"carry useful data and need not be preserved."
msgstr ""

#: ../../../LangRef.rst:7253
msgid "'``noalias``' and '``alias.scope``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7255
msgid ""
"``noalias`` and ``alias.scope`` metadata provide the ability to specify "
"generic noalias memory-access sets. This means that some collection of "
"memory access instructions (loads, stores, memory-accessing calls, etc.) "
"that carry ``noalias`` metadata can specifically be specified not to alias "
"with some other collection of memory access instructions that carry ``alias."
"scope`` metadata. If accesses from different collections alias, the behavior "
"is undefined. Each type of metadata specifies a list of scopes where each "
"scope has an id and a domain."
msgstr ""

#: ../../../LangRef.rst:7263
msgid ""
"When evaluating an aliasing query, if for some domain, the set of scopes "
"with that domain in one instruction's ``alias.scope`` list is a subset of "
"(or equal to) the set of scopes for that domain in another instruction's "
"``noalias`` list, then the two memory accesses are assumed not to alias."
msgstr ""

#: ../../../LangRef.rst:7269
msgid ""
"Because scopes in one domain don't affect scopes in other domains, separate "
"domains can be used to compose multiple independent noalias sets.  This is "
"used for example during inlining.  As the noalias function parameters are "
"turned into noalias scope metadata, a new domain is used every time the "
"function is inlined."
msgstr ""

#: ../../../LangRef.rst:7275
msgid ""
"The metadata identifying each domain is itself a list containing one or two "
"entries. The first entry is the name of the domain. Note that if the name is "
"a string then it can be combined across functions and translation units. A "
"self-reference can be used to create globally unique domain names. A "
"descriptive string may optionally be provided as a second list entry."
msgstr ""

#: ../../../LangRef.rst:7281
msgid ""
"The metadata identifying each scope is also itself a list containing two or "
"three entries. The first entry is the name of the scope. Note that if the "
"name is a string then it can be combined across functions and translation "
"units. A self-reference can be used to create globally unique scope names. A "
"metadata reference to the scope's domain is the second entry. A descriptive "
"string may optionally be provided as a third list entry."
msgstr ""

#: ../../../LangRef.rst:7288
msgid "For example,"
msgstr ""

#: ../../../LangRef.rst:7324
msgid "'``fpmath``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7326
msgid ""
"``fpmath`` metadata may be attached to any instruction of floating-point "
"type. It can be used to express the maximum acceptable error in the result "
"of that instruction, in ULPs, thus potentially allowing the compiler to use "
"a more efficient but less accurate method of computing it. ULP is defined as "
"follows:"
msgstr ""

#: ../../../LangRef.rst:7332
msgid ""
"If ``x`` is a real number that lies between two finite consecutive floating-"
"point numbers ``a`` and ``b``, without being equal to one of them, then "
"``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the distance between the two "
"non-equal finite floating-point numbers nearest ``x``. Moreover, "
"``ulp(NaN)`` is ``NaN``."
msgstr ""

#: ../../../LangRef.rst:7338
msgid ""
"The metadata node shall consist of a single positive float type number "
"representing the maximum relative error, for example:"
msgstr ""

#: ../../../LangRef.rst:7348
msgid "'``range``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7350
msgid ""
"``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` "
"of integer or vector of integer types. It expresses the possible ranges the "
"loaded value or the value returned by the called function at this call site "
"is in. If the loaded or returned value is not in the specified range, a "
"poison value is returned instead. The ranges are represented with a "
"flattened list of integers. The loaded value or the value returned is known "
"to be in the union of the ranges defined by each consecutive pair. Each pair "
"has the following properties:"
msgstr ""

#: ../../../LangRef.rst:7358
msgid "The type must match the scalar type of the instruction."
msgstr ""

#: ../../../LangRef.rst:7362
msgid ""
"The range should not represent the full or empty set. That is, ``a!=b``."
msgstr ""

#: ../../../LangRef.rst:7365
msgid ""
"In addition, the pairs must be in signed order of the lower bound and they "
"must be non-contiguous."
msgstr ""

#: ../../../LangRef.rst:7368
msgid "For vector-typed instructions, the range is applied element-wise."
msgstr ""

#: ../../../LangRef.rst:7387
msgid "'``absolute_symbol``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7389
msgid ""
"``absolute_symbol`` metadata may be attached to a global variable "
"declaration. It marks the declaration as a reference to an absolute symbol, "
"which causes the backend to use absolute relocations for the symbol even in "
"position independent code, and expresses the possible ranges that the global "
"variable's *address* (not its value) is in, in the same format as ``range`` "
"metadata, with the extension that the pair ``all-ones,all-ones`` may be used "
"to represent the full set."
msgstr ""

#: ../../../LangRef.rst:7397
msgid "Example (assuming 64-bit pointers):"
msgstr ""

#: ../../../LangRef.rst:7409
msgid "'``callees``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7411
msgid ""
"``callees`` metadata may be attached to indirect call sites. If ``callees`` "
"metadata is attached to a call site, and any callee is not among the set of "
"functions provided by the metadata, the behavior is undefined. The intent of "
"this metadata is to facilitate optimizations such as indirect-call "
"promotion. For example, in the code below, the call instruction may only "
"target the ``add`` or ``sub`` functions:"
msgstr ""

#: ../../../LangRef.rst:7426
msgid "'``callback``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7428
msgid ""
"``callback`` metadata may be attached to a function declaration, or "
"definition. (Call sites are excluded only due to the lack of a use case.) "
"For ease of exposition, we'll refer to the function annotated with metadata "
"as a broker function. The metadata describes how the arguments of a call to "
"the broker are in turn passed to the callback function specified by the "
"metadata. Thus, the ``callback`` metadata provides a partial description of "
"a call site inside the broker function with regards to the arguments of a "
"call to the broker. The only semantic restriction on the broker function "
"itself is that it is not allowed to inspect or modify arguments referenced "
"in the ``callback`` metadata as pass-through to the callback function."
msgstr ""

#: ../../../LangRef.rst:7439
msgid ""
"The broker is not required to actually invoke the callback function at "
"runtime. However, the assumptions about not inspecting or modifying "
"arguments that would be passed to the specified callback function still "
"hold, even if the callback function is not dynamically invoked. The broker "
"is allowed to invoke the callback function more than once per invocation of "
"the broker. The broker is also allowed to invoke (directly or indirectly) "
"the function passed as a callback through another use. Finally, the broker "
"is also allowed to relay the callback callee invocation to a different "
"thread."
msgstr ""

#: ../../../LangRef.rst:7448
msgid ""
"The metadata is structured as follows: At the outer level, ``callback`` "
"metadata is a list of ``callback`` encodings. Each encoding starts with a "
"constant ``i64`` which describes the argument position of the callback "
"function in the call to the broker. The following elements, except the last, "
"describe what arguments are passed to the callback function. Each element is "
"again an ``i64`` constant identifying the argument of the broker that is "
"passed through, or ``i64 -1`` to indicate an unknown or inspected argument. "
"The order in which they are listed has to be the same in which they are "
"passed to the callback callee. The last element of the encoding is a boolean "
"which specifies how variadic arguments of the broker are handled. If it is "
"true, all variadic arguments of the broker are passed through to the "
"callback function *after* the arguments encoded explicitly before."
msgstr ""

#: ../../../LangRef.rst:7461
msgid ""
"In the code below, the ``pthread_create`` function is marked as a broker "
"through the ``!callback !1`` metadata. In the example, there is only one "
"callback encoding, namely ``!2``, associated with the broker. This encoding "
"identifies the callback function as the second argument of the broker (``i64 "
"2``) and the sole argument of the callback function as the third one of the "
"broker function (``i64 3``)."
msgstr ""

#: ../../../LangRef.rst:7480
msgid ""
"Another example is shown below. The callback callee is the second argument "
"of the ``__kmpc_fork_call`` function (``i64 2``). The callee is given two "
"unknown values (each identified by a ``i64 -1``) and afterwards all variadic "
"arguments that are passed to the ``__kmpc_fork_call`` call (due to the final "
"``i1 true``)."
msgstr ""

#: ../../../LangRef.rst:7499
msgid "'``exclude``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7501
msgid ""
"``exclude`` metadata may be attached to a global variable to signify that "
"its section should not be included in the final executable or shared "
"library. This option is only valid for global variables with an explicit "
"section targeting ELF or COFF. This is done using the ``SHF_EXCLUDE`` flag "
"on ELF targets and the ``IMAGE_SCN_LNK_REMOVE`` and "
"``IMAGE_SCN_MEM_DISCARDABLE`` flags for COFF targets. Additionally, this "
"metadata is only used as a flag, so the associated node must be empty. The "
"explicit section should not conflict with any other sections that the user "
"does not want removed after linking."
msgstr ""

#: ../../../LangRef.rst:7518
msgid "'``unpredictable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7520
msgid ""
"``unpredictable`` metadata may be attached to any branch or switch "
"instruction. It can be used to express the unpredictability of control flow. "
"Similar to the ``llvm.expect`` intrinsic, it may be used to alter "
"optimizations related to compare and branch instructions. The metadata is "
"treated as a boolean value; if it exists, it signals that the branch or "
"switch that it is attached to is completely unpredictable."
msgstr ""

#: ../../../LangRef.rst:7530
msgid "'``dereferenceable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7532
msgid ""
"The existence of the ``!dereferenceable`` metadata on the instruction tells "
"the optimizer that the value loaded is known to be dereferenceable, "
"otherwise the behavior is undefined. The number of bytes known to be "
"dereferenceable is specified by the integer value in the metadata node. This "
"is analogous to the ''dereferenceable'' attribute on parameters and return "
"values."
msgstr ""

#: ../../../LangRef.rst:7542
msgid "'``dereferenceable_or_null``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7544
msgid ""
"The existence of the ``!dereferenceable_or_null`` metadata on the "
"instruction tells the optimizer that the value loaded is known to be either "
"dereferenceable or null, otherwise the behavior is undefined. The number of "
"bytes known to be dereferenceable is specified by the integer value in the "
"metadata node. This is analogous to the ''dereferenceable_or_null'' "
"attribute on parameters and return values."
msgstr ""

#: ../../../LangRef.rst:7552
msgid "'``captures``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7554
msgid ""
"The ``!captures`` metadata can only be applied to ``store`` instructions "
"with a pointer-typed value operand. It restricts the capturing behavior of "
"the store value operand in the same way the ``captures(...)`` attribute "
"would do on a call. See the :ref:`pointer capture section <pointercapture>` "
"for a detailed discussion of capture semantics."
msgstr ""

#: ../../../LangRef.rst:7560
msgid ""
"The ``!captures`` metadata accepts a non-empty list of strings from the same "
"set as the :ref:`captures attribute <captures_attr>`: ``!\"address\"``, ``!"
"\"address_is_null\"``, ``!\"provenance\"`` and ``!\"read_provenance\"``. ``!"
"\"none\"`` is not supported."
msgstr ""

#: ../../../LangRef.rst:7565
msgid ""
"For example ``store ptr %x, ptr %y, !captures !{!\"address\"}`` indicates "
"that the copy of pointer ``%x`` stored to location ``%y`` will only be used "
"to inspect its integral address value, and not dereferenced. Dereferencing "
"the pointer would result in undefined behavior."
msgstr ""

#: ../../../LangRef.rst:7570
msgid ""
"Similarly ``store ptr %x, ptr %y, !captures !{!\"address\", !"
"\"read_provenance\"}`` indicates that while reads through the stored pointer "
"are allowed, writes would result in undefined behavior."
msgstr ""

#: ../../../LangRef.rst:7574
msgid ""
"The ``!captures`` attribute makes no statement about other uses of ``%x``, "
"or uses of the stored-to memory location after it has been overwritten with "
"a different value."
msgstr ""

#: ../../../LangRef.rst:7581
msgid "'``llvm.loop``'"
msgstr ""

#: ../../../LangRef.rst:7583
msgid ""
"It is sometimes useful to attach information to loop constructs. Currently, "
"loop metadata is implemented as metadata attached to the branch instruction "
"in the loop latch block. The loop metadata node is a list of other metadata "
"nodes, each representing a property of the loop. Usually, the first item of "
"the property node is a string. For example, the ``llvm.loop.unroll.count`` "
"suggests an unroll factor to the loop unroller:"
msgstr ""

#: ../../../LangRef.rst:7599
msgid ""
"For legacy reasons, the first item of a loop metadata node must be a "
"reference to itself. Before the advent of the 'distinct' keyword, this "
"forced the preservation of otherwise identical metadata nodes. Since the "
"loop-metadata node can be attached to multiple nodes, the 'distinct' keyword "
"has become unnecessary."
msgstr ""

#: ../../../LangRef.rst:7605
msgid ""
"Prior to the property nodes, one or two ``DILocation`` (debug location) "
"nodes can be present in the list. The first, if present, identifies the "
"source-code location where the loop begins. The second, if present, "
"identifies the source-code location where the loop ends."
msgstr ""

#: ../../../LangRef.rst:7610
msgid ""
"Loop metadata nodes cannot be used as unique identifiers. They are neither "
"persistent for the same loop through transformations nor necessarily unique "
"to just one loop."
msgstr ""

#: ../../../LangRef.rst:7615
msgid "'``llvm.loop.disable_nonforced``'"
msgstr ""

#: ../../../LangRef.rst:7617
msgid ""
"This metadata disables all optional loop transformations unless explicitly "
"instructed using other transformation metadata such as ``llvm.loop.unroll."
"enable``. That is, no heuristic will try to determine whether a "
"transformation is profitable. The purpose is to avoid that the loop is "
"transformed to a different loop before an explicitly requested (forced) "
"transformation is applied. For instance, loop fusion can make other "
"transformations impossible. Mandatory loop canonicalizations such as loop "
"rotation are still applied."
msgstr ""

#: ../../../LangRef.rst:7626
msgid ""
"It is recommended to use this metadata in addition to any ``llvm.loop.*`` "
"transformation directive. Also, any loop should have at most one directive "
"applied to it (and a sequence of transformations built using followup-"
"attributes). Otherwise, which transformation will be applied depends on "
"implementation details such as the pass pipeline order."
msgstr ""

#: ../../../LangRef.rst:7632
msgid "See :ref:`transformation-metadata` for details."
msgstr ""

#: ../../../LangRef.rst:7635
msgid "'``llvm.loop.vectorize``' and '``llvm.loop.interleave``'"
msgstr ""

#: ../../../LangRef.rst:7637
msgid ""
"Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` "
"are used to control per-loop vectorization and interleaving parameters such "
"as vectorization width and interleave count. These metadata should be used "
"in conjunction with ``llvm.loop`` loop identification metadata. The ``llvm."
"loop.vectorize`` and ``llvm.loop.interleave`` metadata are only optimization "
"hints and the optimizer will only interleave and vectorize loops if it "
"believes it is safe to do so. The ``llvm.loop.parallel_accesses`` metadata "
"which contains information about loop-carried memory dependencies can be "
"helpful in determining the safety of these transformations."
msgstr ""

#: ../../../LangRef.rst:7648
msgid "'``llvm.loop.interleave.count``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7650
msgid ""
"This metadata suggests an interleave count to the loop interleaver. The "
"first operand is the string ``llvm.loop.interleave.count`` and the second "
"operand is an integer specifying the interleave count. For example:"
msgstr ""

#: ../../../LangRef.rst:7659
msgid ""
"Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving "
"multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to "
"0 then the interleave count will be determined automatically."
msgstr ""

#: ../../../LangRef.rst:7664
msgid "'``llvm.loop.vectorize.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7666
msgid ""
"This metadata selectively enables or disables vectorization for the loop. "
"The first operand is the string ``llvm.loop.vectorize.enable`` and the "
"second operand is a bit. If the bit operand value is 1 vectorization is "
"enabled. A value of 0 disables vectorization:"
msgstr ""

#: ../../../LangRef.rst:7677
msgid "'``llvm.loop.vectorize.predicate.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7679
msgid ""
"This metadata selectively enables or disables creating predicated "
"instructions for the loop, which can enable folding of the scalar epilogue "
"loop into the main loop. The first operand is the string ``llvm.loop."
"vectorize.predicate.enable`` and the second operand is a bit. If the bit "
"operand value is 1 vectorization is enabled. A value of 0 disables "
"vectorization:"
msgstr ""

#: ../../../LangRef.rst:7692
msgid "'``llvm.loop.vectorize.scalable.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7694
msgid ""
"This metadata selectively enables or disables scalable vectorization for the "
"loop, and only has any effect if vectorization for the loop is already "
"enabled. The first operand is the string ``llvm.loop.vectorize.scalable."
"enable`` and the second operand is a bit. If the bit operand value is 1 "
"scalable vectorization is enabled, whereas a value of 0 reverts to the "
"default fixed width vectorization:"
msgstr ""

#: ../../../LangRef.rst:7707
msgid "'``llvm.loop.vectorize.width``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7709
msgid ""
"This metadata sets the target width of the vectorizer. The first operand is "
"the string ``llvm.loop.vectorize.width`` and the second operand is an "
"integer specifying the width. For example:"
msgstr ""

#: ../../../LangRef.rst:7717
msgid ""
"Note that setting ``llvm.loop.vectorize.width`` to 1 disables vectorization "
"of the loop. If ``llvm.loop.vectorize.width`` is set to 0 or if the loop "
"does not have this metadata the width will be determined automatically."
msgstr ""

#: ../../../LangRef.rst:7723
msgid "'``llvm.loop.vectorize.followup_vectorized``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7725
msgid ""
"This metadata defines which loop attributes the vectorized loop will have. "
"See :ref:`transformation-metadata` for details."
msgstr ""

#: ../../../LangRef.rst:7729
msgid "'``llvm.loop.vectorize.followup_epilogue``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7731
msgid ""
"This metadata defines which loop attributes the epilogue will have. The "
"epilogue is not vectorized and is executed when either the vectorized loop "
"is not known to preserve semantics (because e.g., it processes two arrays "
"that are found to alias by a runtime check) or for the last iterations that "
"do not fill a complete set of vector lanes. See :ref:`Transformation "
"Metadata <transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7739
msgid "'``llvm.loop.vectorize.followup_all``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7741
msgid ""
"Attributes in the metadata will be added to both the vectorized and epilogue "
"loop. See :ref:`Transformation Metadata <transformation-metadata>` for "
"details."
msgstr ""

#: ../../../LangRef.rst:7746
msgid "'``llvm.loop.unroll``'"
msgstr ""

#: ../../../LangRef.rst:7748
msgid ""
"Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling optimization "
"hints such as the unroll factor. ``llvm.loop.unroll`` metadata should be "
"used in conjunction with ``llvm.loop`` loop identification metadata. The "
"``llvm.loop.unroll`` metadata are only optimization hints and the unrolling "
"will only be performed if the optimizer believes it is safe to do so."
msgstr ""

#: ../../../LangRef.rst:7756
msgid "'``llvm.loop.unroll.count``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7758
msgid ""
"This metadata suggests an unroll factor to the loop unroller. The first "
"operand is the string ``llvm.loop.unroll.count`` and the second operand is a "
"positive integer specifying the unroll factor. For example:"
msgstr ""

#: ../../../LangRef.rst:7767
msgid ""
"If the trip count of the loop is less than the unroll count the loop will be "
"partially unrolled."
msgstr ""

#: ../../../LangRef.rst:7771
msgid "'``llvm.loop.unroll.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7773
msgid ""
"This metadata disables loop unrolling. The metadata has a single operand "
"which is the string ``llvm.loop.unroll.disable``. For example:"
msgstr ""

#: ../../../LangRef.rst:7781
msgid "'``llvm.loop.unroll.runtime.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7783
msgid ""
"This metadata disables runtime loop unrolling. The metadata has a single "
"operand which is the string ``llvm.loop.unroll.runtime.disable``. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:7791
msgid "'``llvm.loop.unroll.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7793
msgid ""
"This metadata suggests that the loop should be fully unrolled if the trip "
"count is known at compile time and partially unrolled if the trip count is "
"not known at compile time. The metadata has a single operand which is the "
"string ``llvm.loop.unroll.enable``.  For example:"
msgstr ""

#: ../../../LangRef.rst:7803
msgid "'``llvm.loop.unroll.full``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7805
msgid ""
"This metadata suggests that the loop should be unrolled fully. The metadata "
"has a single operand which is the string ``llvm.loop.unroll.full``. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:7814
msgid "'``llvm.loop.unroll.followup``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7816
msgid ""
"This metadata defines which loop attributes the unrolled loop will have. "
"See :ref:`Transformation Metadata <transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7820
msgid "'``llvm.loop.unroll.followup_remainder``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7822
msgid ""
"This metadata defines which loop attributes the remainder loop after partial/"
"runtime unrolling will have. See :ref:`Transformation Metadata "
"<transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7827
msgid "'``llvm.loop.unroll_and_jam``'"
msgstr ""

#: ../../../LangRef.rst:7829
msgid ""
"This metadata is treated very similarly to the ``llvm.loop.unroll`` metadata "
"above, but affect the unroll and jam pass. In addition any loop with ``llvm."
"loop.unroll`` metadata but no ``llvm.loop.unroll_and_jam`` metadata will "
"disable unroll and jam (so ``llvm.loop.unroll`` metadata will be left to the "
"unroller, plus ``llvm.loop.unroll.disable`` metadata will disable unroll and "
"jam too.)"
msgstr ""

#: ../../../LangRef.rst:7836
msgid ""
"The metadata for unroll and jam otherwise is the same as for ``unroll``. "
"``llvm.loop.unroll_and_jam.enable``, ``llvm.loop.unroll_and_jam.disable`` "
"and ``llvm.loop.unroll_and_jam.count`` do the same as for unroll. ``llvm."
"loop.unroll_and_jam.full`` is not supported. Again these are only hints and "
"the normal safety checks will still be performed."
msgstr ""

#: ../../../LangRef.rst:7843
msgid "'``llvm.loop.unroll_and_jam.count``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7845
msgid ""
"This metadata suggests an unroll and jam factor to use, similarly to ``llvm."
"loop.unroll.count``. The first operand is the string ``llvm.loop."
"unroll_and_jam.count`` and the second operand is a positive integer "
"specifying the unroll factor. For example:"
msgstr ""

#: ../../../LangRef.rst:7854
msgid ""
"If the trip count of the loop is less than the unroll count the loop will be "
"partially unroll and jammed."
msgstr ""

#: ../../../LangRef.rst:7858
msgid "'``llvm.loop.unroll_and_jam.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7860
msgid ""
"This metadata disables loop unroll and jamming. The metadata has a single "
"operand which is the string ``llvm.loop.unroll_and_jam.disable``. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:7868
msgid "'``llvm.loop.unroll_and_jam.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7870
msgid ""
"This metadata suggests that the loop should be fully unroll and jammed if "
"the trip count is known at compile time and partially unrolled if the trip "
"count is not known at compile time. The metadata has a single operand which "
"is the string ``llvm.loop.unroll_and_jam.enable``.  For example:"
msgstr ""

#: ../../../LangRef.rst:7880
msgid "'``llvm.loop.unroll_and_jam.followup_outer``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7882
msgid ""
"This metadata defines which loop attributes the outer unrolled loop will "
"have. See :ref:`Transformation Metadata <transformation-metadata>` for "
"details."
msgstr ""

#: ../../../LangRef.rst:7887
msgid "'``llvm.loop.unroll_and_jam.followup_inner``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7889
msgid ""
"This metadata defines which loop attributes the inner jammed loop will have. "
"See :ref:`Transformation Metadata <transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7894
msgid "'``llvm.loop.unroll_and_jam.followup_remainder_outer``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7896
msgid ""
"This metadata defines which attributes the epilogue of the outer loop will "
"have. This loop is usually unrolled, meaning there is no such loop. This "
"attribute will be ignored in this case. See :ref:`Transformation Metadata "
"<transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7902
msgid "'``llvm.loop.unroll_and_jam.followup_remainder_inner``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7904
msgid ""
"This metadata defines which attributes the inner loop of the epilogue will "
"have. The outer epilogue will usually be unrolled, meaning there can be "
"multiple inner remainder loops. See :ref:`Transformation Metadata "
"<transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7910
msgid "'``llvm.loop.unroll_and_jam.followup_all``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7912
msgid ""
"Attributes specified in the metadata is added to all ``llvm.loop."
"unroll_and_jam.*`` loops. See :ref:`Transformation Metadata <transformation-"
"metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7917
msgid "'``llvm.loop.licm_versioning.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7919
msgid ""
"This metadata indicates that the loop should not be versioned for the "
"purpose of enabling loop-invariant code motion (LICM). The metadata has a "
"single operand which is the string ``llvm.loop.licm_versioning.disable``. "
"For example:"
msgstr ""

#: ../../../LangRef.rst:7928
msgid "'``llvm.loop.distribute.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7930
msgid ""
"Loop distribution allows splitting a loop into multiple loops.  Currently, "
"this is only performed if the entire loop cannot be vectorized due to unsafe "
"memory dependencies.  The transformation will attempt to isolate the unsafe "
"dependencies into their own loop."
msgstr ""

#: ../../../LangRef.rst:7935
msgid ""
"This metadata can be used to selectively enable or disable distribution of "
"the loop.  The first operand is the string ``llvm.loop.distribute.enable`` "
"and the second operand is a bit. If the bit operand value is 1 distribution "
"is enabled. A value of 0 disables distribution:"
msgstr ""

#: ../../../LangRef.rst:7945
msgid ""
"This metadata should be used in conjunction with ``llvm.loop`` loop "
"identification metadata."
msgstr ""

#: ../../../LangRef.rst:7949
msgid "'``llvm.loop.distribute.followup_coincident``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7951
msgid ""
"This metadata defines which attributes extracted loops with no cyclic "
"dependencies will have (i.e., can be vectorized). See :ref:`Transformation "
"Metadata <transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7956
msgid "'``llvm.loop.distribute.followup_sequential``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7958
msgid ""
"This metadata defines which attributes the isolated loops with unsafe memory "
"dependencies will have. See :ref:`Transformation Metadata <transformation-"
"metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7963
msgid "'``llvm.loop.distribute.followup_fallback``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7965
msgid ""
"If loop versioning is necessary, this metadata defined the attributes the "
"non-distributed fallback version will have. See :ref:`Transformation "
"Metadata <transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7970
msgid "'``llvm.loop.distribute.followup_all``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7972
msgid ""
"The attributes in this metadata are added to all followup loops of the loop "
"distribution pass. See :ref:`Transformation Metadata <transformation-"
"metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7977
msgid "'``llvm.loop.isdistributed``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7979
msgid ""
"If a loop was successfully processed by the loop distribution pass, this "
"metadata is added (i.e., has been distributed).  See :ref:`Transformation "
"Metadata <transformation-metadata>` for details."
msgstr ""

#: ../../../LangRef.rst:7984
msgid "'``llvm.loop.estimated_trip_count``' Metadata"
msgstr ""

#: ../../../LangRef.rst:7986
msgid ""
"This metadata records an estimated trip count for the loop.  The first "
"operand is the string ``llvm.loop.estimated_trip_count``.  The second "
"operand is an integer constant of type ``i32`` or smaller specifying the "
"estimate.  For example:"
msgstr ""

#: ../../../LangRef.rst:7996
msgid "Purpose"
msgstr ""

#: ../../../LangRef.rst:7998
msgid ""
"A loop's estimated trip count is an estimate of the average number of loop "
"iterations (specifically, the number of times the loop's header executes) "
"each time execution reaches the loop.  It is usually only an estimate based "
"on, for example, profile data.  The actual number of iterations might vary "
"widely."
msgstr ""

#: ../../../LangRef.rst:8003
msgid ""
"The estimated trip count serves as a parameter for various loop "
"transformations and typically helps estimate transformation cost.  For "
"example, it can help determine how many iterations to peel or how "
"aggressively to unroll."
msgstr ""

#: ../../../LangRef.rst:8008
msgid "Initialization and Maintenance"
msgstr ""

#: ../../../LangRef.rst:8010
msgid ""
"Passes should interact with estimated trip counts always via ``llvm::"
"getLoopEstimatedTripCount`` and ``llvm::setLoopEstimatedTripCount``."
msgstr ""

#: ../../../LangRef.rst:8013
msgid ""
"When the ``llvm.loop.estimated_trip_count`` metadata is not present on a "
"loop, ``llvm::getLoopEstimatedTripCount`` estimates the loop's trip count "
"from the loop's ``branch_weights`` metadata under the assumption that the "
"latter still accurately encodes the program's original profile data.  "
"However, as passes transform existing loops and create new loops, they must "
"be free to update and create ``branch_weights`` metadata in a way that "
"maintains accurate block frequencies.  Trip counts estimated from this new "
"``branch_weights`` metadata are not necessarily useful to the passes that "
"consume estimated trip counts."
msgstr ""

#: ../../../LangRef.rst:8022
msgid ""
"For this reason, when a pass transforms or creates loops, the pass should "
"separately estimate new trip counts based on the estimated trip counts that "
"``llvm::getLoopEstimatedTripCount`` returns at the start of the pass, and "
"the pass should record the new estimates by calling ``llvm::"
"setLoopEstimatedTripCount``, which creates or updates ``llvm.loop."
"estimated_trip_count`` metadata.  Once this metadata is present on a loop, "
"``llvm::getLoopEstimatedTripCount`` returns its value instead of estimating "
"the trip count from the loop's ``branch_weights`` metadata."
msgstr ""

#: ../../../LangRef.rst:8032
msgid "'``llvm.licm.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8034
msgid ""
"This metadata indicates that loop-invariant code motion (LICM) should not be "
"performed on this loop. The metadata has a single operand which is the "
"string ``llvm.licm.disable``. For example:"
msgstr ""

#: ../../../LangRef.rst:8042
msgid ""
"Note that although it operates per loop it isn't given the ``llvm.loop`` "
"prefix as it is not affected by the ``llvm.loop.disable_nonforced`` metadata."
msgstr ""

#: ../../../LangRef.rst:8046
msgid "'``llvm.access.group``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8048
msgid ""
"``llvm.access.group`` metadata can be attached to any instruction that "
"potentially accesses memory. It can point to a single distinct metadata "
"node, which we call access group. This node represents all memory access "
"instructions referring to it via ``llvm.access.group``. When an instruction "
"belongs to multiple access groups, it can also point to a list of accesses "
"groups, illustrated by the following example."
msgstr ""

#: ../../../LangRef.rst:8063
msgid ""
"It is illegal for the list node to be empty since it might be confused with "
"an access group."
msgstr ""

#: ../../../LangRef.rst:8066
msgid ""
"The access group metadata node must be 'distinct' to avoid collapsing "
"multiple access groups by content. An access group metadata node must always "
"be empty which can be used to distinguish an access group metadata node from "
"a list of access groups. Being empty avoids the situation that the content "
"must be updated which, because metadata is immutable by design, would "
"required finding and updating all references to the access group node."
msgstr ""

#: ../../../LangRef.rst:8074
msgid ""
"The access group can be used to refer to a memory access instruction without "
"pointing to it directly (which is not possible in global metadata). "
"Currently, the only metadata making use of it is ``llvm.loop."
"parallel_accesses``."
msgstr ""

#: ../../../LangRef.rst:8080
msgid "'``llvm.loop.parallel_accesses``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8082
msgid ""
"The ``llvm.loop.parallel_accesses`` metadata refers to one or more access "
"group metadata nodes (see ``llvm.access.group``). It denotes that no loop-"
"carried memory dependence exist between it and other instructions in the "
"loop with this metadata."
msgstr ""

#: ../../../LangRef.rst:8087
msgid ""
"Let ``m1`` and ``m2`` be two instructions that both have the ``llvm.access."
"group`` metadata to the access group ``g1``, respectively ``g2`` (which "
"might be identical). If a loop contains both access groups in its ``llvm."
"loop.parallel_accesses`` metadata, then the compiler can assume that there "
"is no dependency between ``m1`` and ``m2`` carried by this loop. "
"Instructions that belong to multiple access groups are considered having "
"this property if at least one of the access groups matches the ``llvm.loop."
"parallel_accesses`` list."
msgstr ""

#: ../../../LangRef.rst:8096
msgid ""
"If all memory-accessing instructions in a loop have ``llvm.access.group`` "
"metadata that each refer to one of the access groups of a loop's ``llvm.loop."
"parallel_accesses`` metadata, then the loop has no loop carried memory "
"dependencies and is considered to be a parallel loop. If there is a loop-"
"carried dependency, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:8103
msgid ""
"Note that if not all memory access instructions belong to an access group "
"referred to by ``llvm.loop.parallel_accesses``, then the loop must not be "
"considered trivially parallel. Additional memory dependence analysis is "
"required to make that determination. As a fail-safe mechanism, this causes "
"loops that were originally parallel to be considered sequential (if "
"optimization passes that are unaware of the parallel semantics insert new "
"memory instructions into the loop body)."
msgstr ""

#: ../../../LangRef.rst:8111
msgid ""
"Example of a loop that is considered parallel due to its correct use of both "
"``llvm.access.group`` and ``llvm.loop.parallel_accesses`` metadata types."
msgstr ""

#: ../../../LangRef.rst:8130
msgid "It is also possible to have nested parallel loops:"
msgstr ""

#: ../../../LangRef.rst:8164
msgid "'``llvm.loop.mustprogress``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8166
msgid ""
"The ``llvm.loop.mustprogress`` metadata indicates that this loop is required "
"to terminate, unwind, or interact with the environment in an observable way "
"e.g. via a volatile memory access, I/O, or other synchronization. If such a "
"loop is not found to interact with the environment in an observable way, the "
"loop may be removed. This corresponds to the ``mustprogress`` function "
"attribute."
msgstr ""

#: ../../../LangRef.rst:8173
msgid "'``irr_loop``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8175
msgid ""
"``irr_loop`` metadata may be attached to the terminator instruction of a "
"basic block that's an irreducible loop header (note that an irreducible loop "
"has more than once header basic blocks.) If ``irr_loop`` metadata is "
"attached to the terminator instruction of a basic block that is not really "
"an irreducible loop header, the behavior is undefined. The intent of this "
"metadata is to improve the accuracy of the block frequency propagation. For "
"example, in the code below, the block ``header0`` may have a loop header "
"weight (relative to the other headers of the irreducible loop) of 100:"
msgstr ""

#: ../../../LangRef.rst:8193
msgid "Irreducible loop header weights are typically based on profile data."
msgstr ""

#: ../../../LangRef.rst:8198
msgid "'``invariant.group``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8200
msgid ""
"The experimental ``invariant.group`` metadata may be attached to ``load``/"
"``store`` instructions referencing a single metadata with no entries. The "
"existence of the ``invariant.group`` metadata on the instruction tells the "
"optimizer that every ``load`` and ``store`` to the same pointer operand can "
"be assumed to load or store the same value (but see the ``llvm.launder."
"invariant.group`` intrinsic which affects when two pointers are considered "
"the same). Pointers returned by bitcast or getelementptr with only zero "
"indices are considered the same."
msgstr ""

#: ../../../LangRef.rst:8239
msgid ""
"The ``invariant.group`` metadata must be dropped when replacing one pointer "
"by another based on aliasing information. This is because ``invariant."
"group`` is tied to the SSA value of the pointer operand."
msgstr ""

#: ../../../LangRef.rst:8249
msgid ""
"Note that this is an experimental feature, which means that its semantics "
"might change in the future."
msgstr ""

#: ../../../LangRef.rst:8253
msgid "'``type``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8255
msgid "See :doc:`TypeMetadata`."
msgstr ""

#: ../../../LangRef.rst:8258
msgid "'``callee_type``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8260
msgid "See :doc:`CalleeTypeMetadata`."
msgstr ""

#: ../../../LangRef.rst:8263
msgid "'``associated``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8265
msgid ""
"The ``associated`` metadata may be attached to a global variable definition "
"with a single argument that references a global object (optionally through "
"an alias)."
msgstr ""

#: ../../../LangRef.rst:8268
msgid ""
"This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which "
"prevents discarding of the global variable in linker GC unless the "
"referenced object is also discarded. The linker support for this feature is "
"spotty. For best compatibility, globals carrying this metadata should:"
msgstr ""

#: ../../../LangRef.rst:8273
msgid "Be in ``@llvm.compiler.used``."
msgstr ""

#: ../../../LangRef.rst:8274
msgid ""
"If the referenced global variable is in a comdat, be in the same comdat."
msgstr ""

#: ../../../LangRef.rst:8276
msgid ""
"``!associated`` can not express a many-to-one relationship. A global "
"variable with the metadata should generally not be referenced by a function: "
"the function may be inlined into other functions, leading to more references "
"to the metadata. Ideally we would want to keep metadata alive as long as any "
"inline location is alive, but this many-to-one relationship is not "
"representable. Moreover, if the metadata is retained while the function is "
"discarded, the linker will report an error of a relocation referencing a "
"discarded section."
msgstr ""

#: ../../../LangRef.rst:8284
msgid ""
"The metadata is often used with an explicit section consisting of valid C "
"identifiers so that the runtime can find the metadata section with linker-"
"defined encapsulation symbols ``__start_<section_name>`` and "
"``__stop_<section_name>``."
msgstr ""

#: ../../../LangRef.rst:8289
msgid "It does not have any effect on non-ELF targets."
msgstr ""

#: ../../../LangRef.rst:8291 ../../../LangRef.rst:8377
#: ../../../LangRef.rst:8402 ../../../LangRef.rst:8423
#: ../../../LangRef.rst:8452 ../../../LangRef.rst:8494
#: ../../../LangRef.rst:8523 ../../../LangRef.rst:8563
#: ../../../LangRef.rst:8976 ../../../LangRef.rst:8994
#: ../../../LangRef.rst:9135 ../../../LangRef.rst:9267
#: ../../../LangRef.rst:9494 ../../../LangRef.rst:9541
#: ../../../LangRef.rst:9601 ../../../LangRef.rst:9664
#: ../../../LangRef.rst:9762 ../../../LangRef.rst:9864
#: ../../../LangRef.rst:9909 ../../../LangRef.rst:9962
#: ../../../LangRef.rst:10013 ../../../LangRef.rst:10063
#: ../../../LangRef.rst:10141 ../../../LangRef.rst:10205
#: ../../../LangRef.rst:10246 ../../../LangRef.rst:10300
#: ../../../LangRef.rst:10342 ../../../LangRef.rst:10398
#: ../../../LangRef.rst:10439 ../../../LangRef.rst:10487
#: ../../../LangRef.rst:10536 ../../../LangRef.rst:10577
#: ../../../LangRef.rst:10623 ../../../LangRef.rst:10682
#: ../../../LangRef.rst:10733 ../../../LangRef.rst:10794
#: ../../../LangRef.rst:10845 ../../../LangRef.rst:10897
#: ../../../LangRef.rst:10951 ../../../LangRef.rst:11009
#: ../../../LangRef.rst:11061 ../../../LangRef.rst:11118
#: ../../../LangRef.rst:11164 ../../../LangRef.rst:11221
#: ../../../LangRef.rst:11280 ../../../LangRef.rst:11323
#: ../../../LangRef.rst:11413 ../../../LangRef.rst:11646
#: ../../../LangRef.rst:11708 ../../../LangRef.rst:11790
#: ../../../LangRef.rst:11911 ../../../LangRef.rst:12116
#: ../../../LangRef.rst:12231 ../../../LangRef.rst:12281
#: ../../../LangRef.rst:12327 ../../../LangRef.rst:12382
#: ../../../LangRef.rst:12433 ../../../LangRef.rst:12474
#: ../../../LangRef.rst:12516 ../../../LangRef.rst:12566
#: ../../../LangRef.rst:12610 ../../../LangRef.rst:12658
#: ../../../LangRef.rst:12709 ../../../LangRef.rst:12773
#: ../../../LangRef.rst:12830 ../../../LangRef.rst:12889
#: ../../../LangRef.rst:12990 ../../../LangRef.rst:13104
#: ../../../LangRef.rst:13164 ../../../LangRef.rst:13223
#: ../../../LangRef.rst:13274 ../../../LangRef.rst:13497
#: ../../../LangRef.rst:13563 ../../../LangRef.rst:13640
#: ../../../LangRef.rst:13713 ../../../LangRef.rst:13783
#: ../../../LangRef.rst:15515 ../../../LangRef.rst:18303
#: ../../../LangRef.rst:18351 ../../../LangRef.rst:21291
#: ../../../LangRef.rst:21344 ../../../LangRef.rst:21637
#: ../../../LangRef.rst:21694 ../../../LangRef.rst:30640
#: ../../../LangRef.rst:30700
msgid "Example:"
msgstr ""

#: ../../../LangRef.rst:8302
msgid "'``prof``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8304
msgid ""
"The ``prof`` metadata is used to record profile data in the IR. The first "
"operand of the metadata node indicates the profile metadata type. There are "
"currently 3 types: :ref:`branch_weights<prof_node_branch_weights>`, :ref:"
"`function_entry_count<prof_node_function_entry_count>`, and :ref:"
"`VP<prof_node_VP>`."
msgstr ""

#: ../../../LangRef.rst:8314
msgid "branch_weights"
msgstr ""

#: ../../../LangRef.rst:8316
msgid ""
"Branch weight metadata attached to a branch, select, switch or call "
"instruction represents the likeliness of the associated branch being taken. "
"For more information, see :doc:`BranchWeightMetadata`."
msgstr ""

#: ../../../LangRef.rst:8323
msgid "function_entry_count"
msgstr ""

#: ../../../LangRef.rst:8325
msgid ""
"Function entry count metadata can be attached to function definitions to "
"record the number of times the function is called. Used with BFI "
"information, it is also used to derive the basic block profile count. For "
"more information, see :doc:`BranchWeightMetadata`."
msgstr ""

#: ../../../LangRef.rst:8333
msgid "VP"
msgstr ""

#: ../../../LangRef.rst:8335
msgid ""
"VP (value profile) metadata can be attached to instructions that have value "
"profile information. Currently this is indirect calls (where it records the "
"hottest callees) and calls to memory intrinsics, such as memcpy, memmove, "
"and memset (where it records the hottest byte lengths)."
msgstr ""

#: ../../../LangRef.rst:8340
msgid ""
"Each VP metadata node contains \"VP\" string, then a ``uint32_t`` value for "
"the value profiling kind, a ``uint64_t`` value for the total number of times "
"the instruction is executed, followed by ``uint64_t`` value and execution "
"count pairs. The value profiling kind is 0 for indirect call targets and 1 "
"for memory operations. For indirect call targets, each profile value is a "
"hash of the callee function name, and for memory operations each value is "
"the byte length."
msgstr ""

#: ../../../LangRef.rst:8348
msgid ""
"Note that the value counts do not need to add up to the total count listed "
"in the third operand (in practice only the top hottest values are tracked "
"and reported)."
msgstr ""

#: ../../../LangRef.rst:8352
msgid "Indirect call example:"
msgstr ""

#: ../../../LangRef.rst:8359
msgid ""
"Note that the VP type is 0 (the second operand), which indicates this is an "
"indirect call value profile data. The third operand indicates that the "
"indirect call executed 1600 times. The 4th and 6th operands give the hashes "
"of the 2 hottest target functions' names (this is the same hash used to "
"represent function names in the profile database), and the 5th and 7th "
"operands give the execution count that each of the respective prior target "
"functions was called."
msgstr ""

#: ../../../LangRef.rst:8370
msgid "'``annotation``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8372
msgid ""
"The ``annotation`` metadata can be used to attach a tuple of annotation "
"strings or a tuple of a tuple of annotation strings to any instruction. This "
"metadata does not impact the semantics of the program and may only be used "
"to provide additional insight about the program and transformations to users."
msgstr ""

#: ../../../LangRef.rst:8384
msgid "Embedding tuple of strings example:"
msgstr ""

#: ../../../LangRef.rst:8393
msgid "'``func_sanitize``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8395
msgid ""
"The ``func_sanitize`` metadata is used to attach two values for the function "
"sanitizer instrumentation. The first value is the ubsan function signature. "
"The second value is the address of the proxy variable which stores the "
"address of the RTTI descriptor. If :ref:`prologue <prologuedata>` and "
"'``func_sanitize``' are used at the same time, :ref:`prologue "
"<prologuedata>` is emitted before '``func_sanitize``' in the output."
msgstr ""

#: ../../../LangRef.rst:8415
msgid "'``kcfi_type``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8417
msgid ""
"The ``kcfi_type`` metadata can be used to attach a type identifier to "
"functions that can be called indirectly. The type data is emitted before the "
"function entry in the assembly. Indirect calls with the :ref:`kcfi operand "
"bundle<ob_kcfi>` will emit a check that compares the type identifier to the "
"metadata."
msgstr ""

#: ../../../LangRef.rst:8432
msgid ""
"Clang emits ``kcfi_type`` metadata nodes for address-taken functions with ``-"
"fsanitize=kcfi``."
msgstr ""

#: ../../../LangRef.rst:8436
msgid "'``pcsections``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8438
msgid ""
"The ``pcsections`` metadata can be attached to instructions and functions, "
"for which addresses, viz. program counters (PCs), are to be emitted in "
"specially encoded binary sections. More details can be found in the `PC "
"Sections Metadata <PCSectionsMetadata.html>`_ documentation."
msgstr ""

#: ../../../LangRef.rst:8446
msgid "'``memprof``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8448
msgid ""
"The ``memprof`` metadata is used to record memory profile data on heap "
"allocation calls. Multiple context-sensitive profiles can be represented "
"with a single ``memprof`` metadata attachment."
msgstr ""

#: ../../../LangRef.rst:8464
msgid ""
"Each operand in the ``memprof`` metadata attachment describes the profiled "
"behavior of memory allocated by the associated allocation for a given "
"context. In the above example, there were 2 profiled contexts, one "
"allocating memory that was typically cold and one allocating memory that was "
"typically not cold."
msgstr ""

#: ../../../LangRef.rst:8469
msgid ""
"The format of the metadata describing a context specific profile (e.g. ``!"
"1`` and ``!3`` above) requires a first operand that is a metadata node "
"describing the context, followed by a list of string metadata tags "
"describing the profile behavior (e.g. ``cold`` and ``notcold``) above. The "
"metadata nodes describing the context (e.g. ``!2`` and ``!4`` above) are "
"unique ids corresponding to callsites, which can be matched to associated IR "
"calls via :ref:`callsite metadata<md_callsite>`. In practice these ids are "
"formed via a hash of the callsite's debug info, and the associated call may "
"be in a different module. The contexts are listed in order from leaf-most "
"call (the allocation itself) to the outermost callsite context required for "
"uniquely identifying the described profile behavior (note this may not be "
"the top of the profiled call stack)."
msgstr ""

#: ../../../LangRef.rst:8485
msgid "'``callsite``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8487
msgid ""
"The ``callsite`` metadata is used to identify callsites involved in memory "
"profile contexts described in :ref:`memprof metadata<md_memprof>`."
msgstr ""

#: ../../../LangRef.rst:8490
msgid ""
"It is attached both to the profile allocation calls (see the example in :ref:"
"`memprof metadata<md_memprof>`), as well as to other callsites in profiled "
"contexts described in heap allocation ``memprof`` metadata."
msgstr ""

#: ../../../LangRef.rst:8501
msgid ""
"Each operand in the ``callsite`` metadata attachment is a unique id "
"corresponding to a callsite (possibly inlined). In practice these ids are "
"formed via a hash of the callsite's debug info. If the call was not inlined "
"into any callers it will contain a single operand (id). If it was inlined it "
"will contain a list of ids, including the ids of the callsites in the full "
"inline sequence, in order from the leaf-most call's id to the outermost "
"inlined call."
msgstr ""

#: ../../../LangRef.rst:8511
msgid "'``noalias.addrspace``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8513
msgid ""
"The ``noalias.addrspace`` metadata is used to identify memory operations "
"which cannot access objects allocated in a range of address spaces. It is "
"attached to memory instructions, including :ref:`atomicrmw <i_atomicrmw>`, :"
"ref:`cmpxchg <i_cmpxchg>`, and :ref:`call <i_call>` instructions."
msgstr ""

#: ../../../LangRef.rst:8519
msgid ""
"This follows the same form as :ref:`range metadata <range-metadata>`, except "
"the field entries must be of type `i32`. The interpretation is the same "
"numeric address spaces as applied to IR values."
msgstr ""

#: ../../../LangRef.rst:8539
msgid ""
"This is intended for use on targets with a notion of generic address spaces, "
"which at runtime resolve to different physical memory spaces. The "
"interpretation of the address space values is target specific. The behavior "
"is undefined if the runtime memory address does resolve to an object defined "
"in one of the indicated address spaces."
msgstr ""

#: ../../../LangRef.rst:8546
msgid "'``mmra``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8548
msgid ""
"The ``mmra`` metadata represents target-defined properties on instructions "
"that can be used to selectively relax constraints placed by the memory model."
msgstr ""

#: ../../../LangRef.rst:8551
msgid ""
"Refer to :doc:`MemoryModelRelaxationAnnotations` for more information on how "
"this metadata affects the memory model of a given target."
msgstr ""

#: ../../../LangRef.rst:8554
msgid ""
"It is attached to memory instructions such as: :ref:`atomicrmw "
"<i_atomicrmw>`, :ref:`cmpxchg <i_cmpxchg>`, :ref:`load <i_load>`, :ref:"
"`store <i_store>`, :ref:`fence <i_fence>` and :ref:`call <i_call>` "
"instructions that read or write memory."
msgstr ""

#: ../../../LangRef.rst:8559
msgid ""
"The metadata is structured as pairs of strings: a prefix, and suffix that "
"form a MMRA \"tag\". The ``!mmra`` operand can either point to a pair of "
"metadata strings, or a tuple containing multiple pairs of metadata strings."
msgstr ""

#: ../../../LangRef.rst:8578
msgid "'``nofree``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8580
msgid ""
"The ``nofree`` metadata indicates the memory pointed by the pointer will not "
"be freed after the attached instruction."
msgstr ""

#: ../../../LangRef.rst:8584
msgid "'``alloc_token``' Metadata"
msgstr ""

#: ../../../LangRef.rst:8586
msgid ""
"The ``alloc_token`` metadata may be attached to calls to memory allocation "
"functions, and contains richer semantic information about the type of the "
"allocation. This information is consumed by the ``alloc-token`` pass to "
"instrument such calls with allocation token IDs."
msgstr ""

#: ../../../LangRef.rst:8591
msgid ""
"The metadata contains: string with the type of an allocation, and a boolean "
"denoting if the type contains a pointer."
msgstr ""

#: ../../../LangRef.rst:8601
msgid "Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:8603
msgid ""
"Information about the module as a whole is difficult to convey to LLVM's "
"subsystems. The LLVM IR isn't sufficient to transmit this information. The "
"``llvm.module.flags`` named metadata exists in order to facilitate this. "
"These flags are in the form of key / value pairs --- much like a dictionary "
"--- making it easy for any subsystem that cares about a flag to look it up."
msgstr ""

#: ../../../LangRef.rst:8610
msgid ""
"The ``llvm.module.flags`` metadata contains a list of metadata triplets. "
"Each triplet has the following form:"
msgstr ""

#: ../../../LangRef.rst:8613
msgid ""
"The first element is a *behavior* flag, which specifies the behavior when "
"two (or more) modules are merged together, and it encounters two (or more) "
"metadata with the same ID. The supported behaviors are described below."
msgstr ""

#: ../../../LangRef.rst:8617
msgid ""
"The second element is a metadata string that is a unique ID for the "
"metadata. Each module may only have one flag entry for each unique ID (not "
"including entries with the **Require** behavior)."
msgstr ""

#: ../../../LangRef.rst:8620
msgid "The third element is the value of the flag."
msgstr ""

#: ../../../LangRef.rst:8622
msgid ""
"When two (or more) modules are merged together, the resulting ``llvm.module."
"flags`` metadata is the union of the modules' flags. That is, for each "
"unique metadata ID string, there will be exactly one entry in the merged "
"modules ``llvm.module.flags`` metadata table, and the value for that entry "
"will be determined by the merge behavior flag, as described below. The only "
"exception is that entries with the *Require* behavior are always preserved."
msgstr ""

#: ../../../LangRef.rst:8629
msgid "The following behaviors are supported:"
msgstr ""

#: ../../../LangRef.rst:8635 ../../../LangRef.rst:8765
#: ../../../LangRef.rst:8816
msgid "Value"
msgstr ""

#: ../../../LangRef.rst:8636
msgid "Behavior"
msgstr ""

#: ../../../LangRef.rst:8641
msgid "**Error**"
msgstr ""

#: ../../../LangRef.rst:8640
msgid ""
"Emits an error if two values disagree, otherwise the resulting value is that "
"of the operands."
msgstr ""

#: ../../../LangRef.rst:8649
msgid "**Warning**"
msgstr ""

#: ../../../LangRef.rst:8645
msgid ""
"Emits a warning if two values disagree. The result value will be the operand "
"for the flag from the first module being linked, unless the other module "
"uses **Min** or **Max**, in which case the result will be **Min** (with the "
"min value) or **Max** (with the max value), respectively."
msgstr ""

#: ../../../LangRef.rst:8659
msgid "**Require**"
msgstr ""

#: ../../../LangRef.rst:8653
msgid ""
"Adds a requirement that another module flag be present and have a specified "
"value after linking is performed. The value must be a metadata pair, where "
"the first element of the pair is the ID of the module flag to be restricted, "
"and the second element of the pair is the value the module flag should be "
"restricted to. This behavior can be used to restrict the allowable results "
"(via triggering of an error) of linking IDs with the **Override** behavior."
msgstr ""

#: ../../../LangRef.rst:8665
msgid "**Override**"
msgstr ""

#: ../../../LangRef.rst:8663
msgid ""
"Uses the specified value, regardless of the behavior or value of the other "
"module. If both modules specify **Override**, but the values differ, an "
"error will be emitted."
msgstr ""

#: ../../../LangRef.rst:8667 ../../../LangRef.rst:29651
msgid "5"
msgstr ""

#: ../../../LangRef.rst:8669
msgid "**Append**"
msgstr ""

#: ../../../LangRef.rst:8669
msgid "Appends the two values, which are required to be metadata nodes."
msgstr ""

#: ../../../LangRef.rst:8671 ../../../LangRef.rst:29653
msgid "6"
msgstr ""

#: ../../../LangRef.rst:8675
msgid "**AppendUnique**"
msgstr ""

#: ../../../LangRef.rst:8673
msgid ""
"Appends the two values, which are required to be metadata nodes. However, "
"duplicate entries in the second list are dropped during the append operation."
msgstr ""

#: ../../../LangRef.rst:8677 ../../../LangRef.rst:29655
msgid "7"
msgstr ""

#: ../../../LangRef.rst:8679
msgid "**Max**"
msgstr ""

#: ../../../LangRef.rst:8679
msgid "Takes the max of the two values, which are required to be integers."
msgstr ""

#: ../../../LangRef.rst:8683
msgid "**Min**"
msgstr ""

#: ../../../LangRef.rst:8683
msgid ""
"Takes the min of the two values, which are required to be non-negative "
"integers. An absent module flag is treated as having the value 0."
msgstr ""

#: ../../../LangRef.rst:8686
msgid ""
"It is an error for a particular unique flag ID to have multiple behaviors, "
"except in the case of **Require** (which adds restrictions on another "
"metadata value) or **Override**."
msgstr ""

#: ../../../LangRef.rst:8690
msgid "An example of module flags:"
msgstr ""

#: ../../../LangRef.rst:8704
msgid ""
"Metadata ``!0`` has the ID ``!\"foo\"`` and the value '1'. The behavior if "
"two or more ``!\"foo\"`` flags are seen is to emit an error if their values "
"are not equal."
msgstr ""

#: ../../../LangRef.rst:8708
msgid ""
"Metadata ``!1`` has the ID ``!\"bar\"`` and the value '37'. The behavior if "
"two or more ``!\"bar\"`` flags are seen is to use the value '37'."
msgstr ""

#: ../../../LangRef.rst:8712
msgid ""
"Metadata ``!2`` has the ID ``!\"qux\"`` and the value '42'. The behavior if "
"two or more ``!\"qux\"`` flags are seen is to emit a warning if their values "
"are not equal."
msgstr ""

#: ../../../LangRef.rst:8716
msgid "Metadata ``!3`` has the ID ``!\"qux\"`` and the value:"
msgstr ""

#: ../../../LangRef.rst:8722
msgid ""
"The behavior is to emit an error if the ``llvm.module.flags`` does not "
"contain a flag with the ID ``!\"foo\"`` that has the value '1' after linking "
"is performed."
msgstr ""

#: ../../../LangRef.rst:8727
msgid "Synthesized Functions Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:8729
msgid ""
"These metadata specify the default attributes synthesized functions should "
"have. These metadata are currently respected by a few instrumentation "
"passes, such as sanitizers."
msgstr ""

#: ../../../LangRef.rst:8733
msgid ""
"These metadata correspond to a few function attributes with significant code "
"generation behaviors. Function attributes with just optimization purposes "
"should not be listed because the performance impact of these synthesized "
"functions is small."
msgstr ""

#: ../../../LangRef.rst:8738
msgid ""
"\"frame-pointer\": **Max**. The value can be 0, 1, or 2. A synthesized "
"function will get the \"frame-pointer\" function attribute, with value being "
"\"none\", \"non-leaf\", or \"all\", respectively."
msgstr ""

#: ../../../LangRef.rst:8741
msgid ""
"\"function_return_thunk_extern\": The synthesized function will get the "
"``fn_return_thunk_extern`` function attribute."
msgstr ""

#: ../../../LangRef.rst:8743
msgid ""
"\"uwtable\": **Max**. The value can be 0, 1, or 2. If the value is 1, a "
"synthesized function will get the ``uwtable(sync)`` function attribute, if "
"the value is 2, a synthesized function will get the ``uwtable(async)`` "
"function attribute."
msgstr ""

#: ../../../LangRef.rst:8748
msgid "Objective-C Garbage Collection Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:8750
msgid ""
"On the Mach-O platform, Objective-C stores metadata about garbage collection "
"in a special section called \"image info\". The metadata consists of a "
"version number and a bitmask specifying what types of garbage collection are "
"supported (if any) by the file. If two or more modules are linked together "
"their garbage collection metadata needs to be merged rather than appended "
"together."
msgstr ""

#: ../../../LangRef.rst:8757
msgid ""
"The Objective-C garbage collection module flags metadata consists of the "
"following key-value pairs:"
msgstr ""

#: ../../../LangRef.rst:8764 ../../../LangRef.rst:8815
msgid "Key"
msgstr ""

#: ../../../LangRef.rst:8767
msgid "``Objective-C Version``"
msgstr ""

#: ../../../LangRef.rst:8768
msgid ""
"**[Required]** --- The Objective-C ABI version. Valid values are 1 and 2."
msgstr ""

#: ../../../LangRef.rst:8770
msgid "``Objective-C Image Info Version``"
msgstr ""

#: ../../../LangRef.rst:8771
msgid ""
"**[Required]** --- The version of the image info section. Currently always 0."
msgstr ""

#: ../../../LangRef.rst:8774
msgid "``Objective-C Image Info Section``"
msgstr ""

#: ../../../LangRef.rst:8775
msgid ""
"**[Required]** --- The section to place the metadata. Valid values are "
"``\"__OBJC, __image_info, regular\"`` for Objective-C ABI version 1, and "
"``\"__DATA,__objc_imageinfo, regular, no_dead_strip\"`` for Objective-C ABI "
"version 2."
msgstr ""

#: ../../../LangRef.rst:8780
msgid "``Objective-C Garbage Collection``"
msgstr ""

#: ../../../LangRef.rst:8781
msgid ""
"**[Required]** --- Specifies whether garbage collection is supported or not. "
"Valid values are 0, for no garbage collection, and 2, for garbage collection "
"supported."
msgstr ""

#: ../../../LangRef.rst:8785
msgid "``Objective-C GC Only``"
msgstr ""

#: ../../../LangRef.rst:8786
msgid ""
"**[Optional]** --- Specifies that only garbage collection is supported. If "
"present, its value must be 6. This flag requires that the ``Objective-C "
"Garbage Collection`` flag have the value 2."
msgstr ""

#: ../../../LangRef.rst:8790
msgid "Some important flag interactions:"
msgstr ""

#: ../../../LangRef.rst:8792
msgid ""
"If a module with ``Objective-C Garbage Collection`` set to 0 is merged with "
"a module with ``Objective-C Garbage Collection`` set to 2, then the "
"resulting module has the ``Objective-C Garbage Collection`` flag set to 0."
msgstr ""

#: ../../../LangRef.rst:8796
msgid ""
"A module with ``Objective-C Garbage Collection`` set to 0 cannot be merged "
"with a module with ``Objective-C GC Only`` set to 6."
msgstr ""

#: ../../../LangRef.rst:8800
msgid "C type width Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:8802
msgid ""
"The ARM backend emits a section into each generated object file describing "
"the options that it was compiled with (in a compiler-independent way) to "
"prevent linking incompatible objects, and to allow automatic library "
"selection. Some of these options are not visible at the IR level, namely "
"wchar_t width and enum width."
msgstr ""

#: ../../../LangRef.rst:8808
msgid ""
"To pass this information to the backend, these options are encoded in module "
"flags metadata, using the following key-value pairs:"
msgstr ""

#: ../../../LangRef.rst:8818
msgid "short_wchar"
msgstr ""

#: ../../../LangRef.rst:8819
msgid "0 --- sizeof(wchar_t) == 4"
msgstr ""

#: ../../../LangRef.rst:8820
msgid "1 --- sizeof(wchar_t) == 2"
msgstr ""

#: ../../../LangRef.rst:8822
msgid "short_enum"
msgstr ""

#: ../../../LangRef.rst:8823
msgid "0 --- Enums are at least as large as an ``int``."
msgstr ""

#: ../../../LangRef.rst:8824
msgid ""
"1 --- Enums are stored in the smallest integer type which can represent all "
"of its values."
msgstr ""

#: ../../../LangRef.rst:8827
msgid ""
"For example, the following metadata section specifies that the module was "
"compiled with a ``wchar_t`` width of 4 bytes, and the underlying type of an "
"enum is the smallest type which can represent all of its values::"
msgstr ""

#: ../../../LangRef.rst:8836
msgid "Stack Alignment Metadata"
msgstr ""

#: ../../../LangRef.rst:8838
msgid ""
"Changes the default stack alignment from the target ABI's implicit default "
"stack alignment. Takes an i32 value in bytes. It is considered an error to "
"link two modules together with different values for this metadata."
msgstr ""

#: ../../../LangRef.rst:8844
msgid ""
"!llvm.module.flags = !{!0} !0 = !{i32 1, !\"override-stack-alignment\", i32 "
"8}"
msgstr ""

#: ../../../LangRef.rst:8847
msgid "This will change the stack alignment to 8B."
msgstr ""

#: ../../../LangRef.rst:8850
msgid "Embedded Objects Names Metadata"
msgstr ""

#: ../../../LangRef.rst:8852
msgid ""
"Offloading compilations need to embed device code into the host section "
"table to create a fat binary. This metadata node references each global that "
"will be embedded in the module. The primary use for this is to make "
"referencing these globals more efficient in the IR. The metadata references "
"nodes containing pointers to the global to be embedded followed by the "
"section name it will be stored at::"
msgstr ""

#: ../../../LangRef.rst:8863
msgid "Automatic Linker Flags Named Metadata"
msgstr ""

#: ../../../LangRef.rst:8865
msgid ""
"Some targets support embedding of flags to the linker inside individual "
"object files. Typically this is used in conjunction with language extensions "
"which allow source files to contain linker command-line options, and have "
"these automatically be transmitted to the linker via object files."
msgstr ""

#: ../../../LangRef.rst:8870
msgid ""
"These flags are encoded in the IR using named metadata with the name ``!llvm."
"linker.options``. Each operand is expected to be a metadata node which "
"should be a list of other metadata nodes, each of which should be a list of "
"metadata strings defining linker options."
msgstr ""

#: ../../../LangRef.rst:8875
msgid ""
"For example, the following metadata section specifies two separate sets of "
"linker options, presumably to link against ``libz`` and the ``Cocoa`` "
"framework::"
msgstr ""

#: ../../../LangRef.rst:8883
msgid ""
"The metadata encoding as lists of lists of options, as opposed to a "
"collapsed list of options, is chosen so that the IR encoding can use "
"multiple option strings to specify e.g., a single library, while still "
"having that specifier be preserved as an atomic element that can be "
"recognized by a target-specific assembly writer or object file emitter."
msgstr ""

#: ../../../LangRef.rst:8889
msgid ""
"Each individual option is required to be either a valid option for the "
"target's linker, or an option that is reserved by the target-specific "
"assembly writer or object file emitter. No other aspect of these options is "
"defined by the IR."
msgstr ""

#: ../../../LangRef.rst:8894
msgid "Dependent Libs Named Metadata"
msgstr ""

#: ../../../LangRef.rst:8896
msgid ""
"Some targets support embedding of strings into object files to indicate a "
"set of libraries to add to the link. Typically this is used in conjunction "
"with language extensions which allow source files to explicitly declare the "
"libraries they depend on, and have these automatically be transmitted to the "
"linker via object files."
msgstr ""

#: ../../../LangRef.rst:8902
msgid ""
"The list is encoded in the IR using named metadata with the name ``!llvm."
"dependent-libraries``. Each operand is expected to be a metadata node which "
"should contain a single string operand."
msgstr ""

#: ../../../LangRef.rst:8906
msgid ""
"For example, the following metadata section contains two library specifiers::"
msgstr ""

#: ../../../LangRef.rst:8912
msgid ""
"Each library specifier will be handled independently by the consuming "
"linker. The effect of the library specifiers are defined by the consuming "
"linker."
msgstr ""

#: ../../../LangRef.rst:8916
msgid "'``llvm.errno.tbaa``' Named Metadata"
msgstr ""

#: ../../../LangRef.rst:8918
msgid ""
"The module-level ``!llvm.errno.tbaa`` metadata specifies the TBAA nodes used "
"for accessing ``errno``. These nodes are guaranteed to represent int-"
"compatible accesses according to C/C++ strict aliasing rules. This should "
"let LLVM alias analyses to reason about aliasing with ``errno`` when calling "
"library functions that may set ``errno``, allowing optimizations such as "
"store-to-load forwarding across such routines."
msgstr ""

#: ../../../LangRef.rst:8925
msgid ""
"For example, the following is a valid metadata specifying the TBAA "
"information for an integer access::"
msgstr ""

#: ../../../LangRef.rst:8934
msgid ""
"Multiple TBAA operands are allowed to support merging of modules that may "
"use different TBAA hierarchies (e.g., when mixing C and C++)."
msgstr ""

#: ../../../LangRef.rst:8940
msgid "ThinLTO Summary"
msgstr ""

#: ../../../LangRef.rst:8942
msgid ""
"Compiling with `ThinLTO <https://clang.llvm.org/docs/ThinLTO.html>`_ causes "
"the building of a compact summary of the module that is emitted into the "
"bitcode. The summary is emitted into the LLVM assembly and identified in "
"syntax by a caret ('``^``')."
msgstr ""

#: ../../../LangRef.rst:8947
msgid ""
"The summary is parsed into a bitcode output, along with the Module IR, via "
"the \"``llvm-as``\" tool. Tools that parse the Module IR for the purposes of "
"optimization (e.g. \"``clang -x ir``\" and \"``opt``\"), will ignore the "
"summary entries (just as they currently ignore summary entries in a bitcode "
"input file)."
msgstr ""

#: ../../../LangRef.rst:8953
msgid ""
"Eventually, the summary will be parsed into a ModuleSummaryIndex object "
"under the same conditions where summary index is currently built from "
"bitcode. Specifically, tools that test the Thin Link portion of a ThinLTO "
"compile (i.e., llvm-lto and llvm-lto2), or when parsing a combined index for "
"a distributed ThinLTO backend via clang's \"``-fthinlto-index=<>``\" flag "
"(this part is not yet implemented, use llvm-as to create a bitcode object "
"before feeding into thin link tools for now)."
msgstr ""

#: ../../../LangRef.rst:8961
msgid ""
"There are currently 3 types of summary entries in the LLVM assembly: :ref:"
"`module paths<module_path_summary>`, :ref:`global values<gv_summary>`, and :"
"ref:`type identifiers<typeid_summary>`."
msgstr ""

#: ../../../LangRef.rst:8969
msgid "Module Path Summary Entry"
msgstr ""

#: ../../../LangRef.rst:8971
msgid ""
"Each module path summary entry lists a module containing global values "
"included in the summary. For a single IR module there will be one such "
"entry, but in a combined summary index produced during the thin link, there "
"will be one module path entry per linked module with summary."
msgstr ""

#: ../../../LangRef.rst:8982
msgid ""
"The ``path`` field is a string path to the bitcode file, and the ``hash`` "
"field is the 160-bit SHA-1 hash of the IR bitcode contents, used for "
"incremental builds and caching."
msgstr ""

#: ../../../LangRef.rst:8989
msgid "Global Value Summary Entry"
msgstr ""

#: ../../../LangRef.rst:8991
msgid ""
"Each global value summary entry corresponds to a global value defined or "
"referenced by a summarized module."
msgstr ""

#: ../../../LangRef.rst:9000
msgid ""
"For declarations, there will not be a summary list. For definitions, a "
"global value will contain a list of summaries, one per module containing a "
"definition. There can be multiple entries in a combined summary index for "
"symbols with weak linkage."
msgstr ""

#: ../../../LangRef.rst:9005
msgid ""
"Each ``Summary`` format will depend on whether the global value is a :ref:"
"`function<function_summary>`, :ref:`variable<variable_summary>`, or :ref:"
"`alias<alias_summary>`."
msgstr ""

#: ../../../LangRef.rst:9012
msgid "Function Summary"
msgstr ""

#: ../../../LangRef.rst:9014
msgid ""
"If the global value is a function, the ``Summary`` entry will look like:"
msgstr ""

#: ../../../LangRef.rst:9020
msgid ""
"The ``module`` field includes the summary entry id for the module containing "
"this definition, and the ``flags`` field contains information such as the "
"linkage type, a flag indicating whether it is legal to import the "
"definition, whether it is globally live and whether the linker resolved it "
"to a local definition (the latter two are populated during the thin link). "
"The ``insts`` field contains the number of IR instructions in the function. "
"Finally, there are several optional fields: :ref:"
"`FuncFlags<funcflags_summary>`, :ref:`Calls<calls_summary>`, :ref:"
"`TypeIdInfo<typeidinfo_summary>`, :ref:`Params<params_summary>`, :ref:"
"`Refs<refs_summary>`."
msgstr ""

#: ../../../LangRef.rst:9033
msgid "Global Variable Summary"
msgstr ""

#: ../../../LangRef.rst:9035
msgid ""
"If the global value is a variable, the ``Summary`` entry will look like:"
msgstr ""

#: ../../../LangRef.rst:9041
msgid ""
"The variable entry contains a subset of the fields in a :ref:`function "
"summary <function_summary>`, see the descriptions there."
msgstr ""

#: ../../../LangRef.rst:9047
msgid "Alias Summary"
msgstr ""

#: ../../../LangRef.rst:9049
msgid "If the global value is an alias, the ``Summary`` entry will look like:"
msgstr ""

#: ../../../LangRef.rst:9055
msgid ""
"The ``module`` and ``flags`` fields are as described for a :ref:`function "
"summary <function_summary>`. The ``aliasee`` field contains a reference to "
"the global value summary entry of the aliasee."
msgstr ""

#: ../../../LangRef.rst:9062
msgid "Function Flags"
msgstr ""

#: ../../../LangRef.rst:9064
msgid "The optional ``FuncFlags`` field looks like:"
msgstr ""

#: ../../../LangRef.rst:9070
msgid ""
"If unspecified, flags are assumed to hold the conservative ``false`` value "
"of ``0``."
msgstr ""

#: ../../../LangRef.rst:9076
msgid "Calls"
msgstr ""

#: ../../../LangRef.rst:9078
msgid "The optional ``Calls`` field looks like:"
msgstr ""

#: ../../../LangRef.rst:9084
msgid "where each ``Callee`` looks like:"
msgstr ""

#: ../../../LangRef.rst:9090
msgid ""
"The ``callee`` refers to the summary entry id of the callee. At most one of "
"``hotness`` (which can take the values ``Unknown``, ``Cold``, ``None``, "
"``Hot``, and ``Critical``), and ``relbf`` (which holds the integer branch "
"frequency relative to the entry frequency, scaled down by 2^8) may be "
"specified. The defaults are ``Unknown`` and ``0``, respectively."
msgstr ""

#: ../../../LangRef.rst:9099
msgid "Params"
msgstr ""

#: ../../../LangRef.rst:9101
msgid "The optional ``Params`` is used by ``StackSafety`` and looks like:"
msgstr ""

#: ../../../LangRef.rst:9107
msgid ""
"where each ``Param`` describes pointer parameter access inside of the "
"function and looks like:"
msgstr ""

#: ../../../LangRef.rst:9114
msgid ""
"where the first ``param`` is the number of the parameter it describes, "
"``offset`` is the inclusive range of offsets from the pointer parameter to "
"bytes which can be accessed by the function. This range does not include "
"accesses by function calls from ``calls`` list."
msgstr ""

#: ../../../LangRef.rst:9119
msgid ""
"where each ``Callee`` describes how parameter is forwarded into other "
"functions and looks like:"
msgstr ""

#: ../../../LangRef.rst:9126
msgid ""
"The ``callee`` refers to the summary entry id of the callee,  ``param`` is "
"the number of the callee parameter which points into the callers parameter "
"with offset known to be inside of the ``offset`` range. ``calls`` will be "
"consumed and removed by thin link stage to update ``Param::offset`` so it "
"covers all accesses possible by ``calls``."
msgstr ""

#: ../../../LangRef.rst:9132
msgid ""
"Pointer parameter without corresponding ``Param`` is considered unsafe and "
"we assume that access with any offset is possible."
msgstr ""

#: ../../../LangRef.rst:9137
msgid "If we have the following function:"
msgstr ""

#: ../../../LangRef.rst:9151
msgid "We can expect the record like this:"
msgstr ""

#: ../../../LangRef.rst:9157
msgid ""
"The function may access just 8 bytes of the parameter %0 . ``calls`` is "
"empty, so the parameter is either not used for function calls or ``offset`` "
"already covers all accesses from nested function calls. Parameter %1 "
"escapes, so access is unknown. The function itself can access just a single "
"byte of the parameter %2. Additional access is possible inside of the "
"``@bar`` or ``^3``. The function adds signed offset to the pointer and "
"passes the result as the argument %1 into ``^3``. This record itself does "
"not tell us how ``^3`` will access the parameter. Parameter %3 is not a "
"pointer."
msgstr ""

#: ../../../LangRef.rst:9170
msgid "Refs"
msgstr ""

#: ../../../LangRef.rst:9172
msgid "The optional ``Refs`` field looks like:"
msgstr ""

#: ../../../LangRef.rst:9178
msgid ""
"where each ``Ref`` contains a reference to the summary id of the referenced "
"value (e.g. ``^1``)."
msgstr ""

#: ../../../LangRef.rst:9184
msgid "TypeIdInfo"
msgstr ""

#: ../../../LangRef.rst:9186
msgid ""
"The optional ``TypeIdInfo`` field, used for `Control Flow Integrity <https://"
"clang.llvm.org/docs/ControlFlowIntegrity.html>`_, looks like:"
msgstr ""

#: ../../../LangRef.rst:9194
msgid "These optional fields have the following forms:"
msgstr ""

#: ../../../LangRef.rst:9197
msgid "TypeTests"
msgstr ""

#: ../../../LangRef.rst:9203
msgid ""
"Where each ``TypeIdRef`` refers to a :ref:`type id<typeid_summary>` by "
"summary id or ``GUID``."
msgstr ""

#: ../../../LangRef.rst:9207
msgid "TypeTestAssumeVCalls"
msgstr ""

#: ../../../LangRef.rst:9213
msgid "Where each VFuncId has the format:"
msgstr ""

#: ../../../LangRef.rst:9219
msgid ""
"Where each ``TypeIdRef`` refers to a :ref:`type id<typeid_summary>` by "
"summary id or ``GUID`` preceded by a ``guid:`` tag."
msgstr ""

#: ../../../LangRef.rst:9223
msgid "TypeCheckedLoadVCalls"
msgstr ""

#: ../../../LangRef.rst:9229
msgid ""
"Where each VFuncId has the format described for ``TypeTestAssumeVCalls``."
msgstr ""

#: ../../../LangRef.rst:9232
msgid "TypeTestAssumeConstVCalls"
msgstr ""

#: ../../../LangRef.rst:9238
msgid "Where each ConstVCall has the format:"
msgstr ""

#: ../../../LangRef.rst:9244
msgid ""
"and where each VFuncId has the format described for "
"``TypeTestAssumeVCalls``, and each Arg is an integer argument number."
msgstr ""

#: ../../../LangRef.rst:9248
msgid "TypeCheckedLoadConstVCalls"
msgstr ""

#: ../../../LangRef.rst:9254
msgid ""
"Where each ConstVCall has the format described for "
"``TypeTestAssumeConstVCalls``."
msgstr ""

#: ../../../LangRef.rst:9260
msgid "Type ID Summary Entry"
msgstr ""

#: ../../../LangRef.rst:9262
msgid ""
"Each type id summary entry corresponds to a type identifier resolution which "
"is generated during the LTO link portion of the compile when building with "
"`Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity."
"html>`_, so these are only present in a combined summary index."
msgstr ""

#: ../../../LangRef.rst:9273
msgid ""
"The ``typeTestRes`` gives the type test resolution ``kind`` (which may be "
"``unsat``, ``byteArray``, ``inline``, ``single``, or ``allOnes``), and the "
"``size-1`` bit width. It is followed by optional flags, which default to 0, "
"and an optional WpdResolutions (whole program devirtualization resolution) "
"field that looks like:"
msgstr ""

#: ../../../LangRef.rst:9283
msgid ""
"where each entry is a mapping from the given byte offset to the whole-"
"program devirtualization resolution WpdRes, that has one of the following "
"formats:"
msgstr ""

#: ../../../LangRef.rst:9292
msgid ""
"Additionally, each wpdRes has an optional ``resByArg`` field, which "
"describes the resolutions for calls with all constant integer arguments:"
msgstr ""

#: ../../../LangRef.rst:9299
msgid "where ResByArg is:"
msgstr ""

#: ../../../LangRef.rst:9305
msgid ""
"Where the ``kind`` can be ``Indir``, ``UniformRetVal``, ``UniqueRetVal`` or "
"``VirtualConstProp``. The ``info`` field is only used if the kind is "
"``UniformRetVal`` (indicates the uniform return value), or ``UniqueRetVal`` "
"(holds the return value associated with the unique vtable (0 or 1)). The "
"``byte`` and ``bit`` fields are only used if the target does not support the "
"use of absolute symbols to store constants."
msgstr ""

#: ../../../LangRef.rst:9315
msgid "Intrinsic Global Variables"
msgstr ""

#: ../../../LangRef.rst:9317
msgid ""
"LLVM has a number of \"magic\" global variables that contain data that "
"affect code generation or other IR semantics. These are documented here. All "
"globals of this sort should have a section specified as \"``llvm."
"metadata``\". This section and all globals that start with \"``llvm.``\" are "
"reserved for use by LLVM."
msgstr ""

#: ../../../LangRef.rst:9326
msgid "The '``llvm.used``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:9328
msgid ""
"The ``@llvm.used`` global is an array which has :ref:`appending linkage "
"<linkage_appending>`. This array contains a list of pointers to named global "
"variables, functions and aliases which may optionally have a pointer cast "
"formed of bitcast or getelementptr. For example, a legal use of it is:"
msgstr ""

#: ../../../LangRef.rst:9344
msgid ""
"If a symbol appears in the ``@llvm.used`` list, then the compiler, "
"assembler, and linker are required to treat the symbol as if there is a "
"reference to the symbol that it cannot see (which is why they have to be "
"named). For example, if a variable has internal linkage and no references "
"other than that from the ``@llvm.used`` list, it cannot be deleted. This is "
"commonly used to represent references from inline asms and other things the "
"compiler cannot \"see\", and corresponds to \"``attribute((used))``\" in GNU "
"C."
msgstr ""

#: ../../../LangRef.rst:9352
msgid ""
"On some targets, the code generator must emit a directive to the assembler "
"or object file to prevent the assembler and linker from removing the symbol."
msgstr ""

#: ../../../LangRef.rst:9359
msgid "The '``llvm.compiler.used``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:9361
msgid ""
"The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used`` "
"directive, except that it only prevents the compiler from touching the "
"symbol. On targets that support it, this allows an intelligent linker to "
"optimize references to the symbol without being impeded as it would be by "
"``@llvm.used``."
msgstr ""

#: ../../../LangRef.rst:9367
msgid ""
"This is a rare construct that should only be used in rare circumstances, and "
"should not be exposed to source languages."
msgstr ""

#: ../../../LangRef.rst:9373
msgid "The '``llvm.global_ctors``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:9380
msgid ""
"The ``@llvm.global_ctors`` array contains a list of constructor functions, "
"priorities, and an associated global or function. The functions referenced "
"by this array will be called in ascending order of priority (i.e., lowest "
"first) when the module is loaded. The order of functions with the same "
"priority is not defined."
msgstr ""

#: ../../../LangRef.rst:9386
msgid ""
"If the third field is non-null, and points to a global variable or function, "
"the initializer function will only run if the associated data from the "
"current module is not discarded. On ELF the referenced global variable or "
"function must be in a comdat."
msgstr ""

#: ../../../LangRef.rst:9394
msgid "The '``llvm.global_dtors``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:9401
msgid ""
"The ``@llvm.global_dtors`` array contains a list of destructor functions, "
"priorities, and an associated global or function. The functions referenced "
"by this array will be called in descending order of priority (i.e., highest "
"first) when the module is unloaded. The order of functions with the same "
"priority is not defined."
msgstr ""

#: ../../../LangRef.rst:9407
msgid ""
"If the third field is non-null, and points to a global variable or function, "
"the destructor function will only run if the associated data from the "
"current module is not discarded. On ELF the referenced global variable or "
"function must be in a comdat."
msgstr ""

#: ../../../LangRef.rst:9413
msgid "Instruction Reference"
msgstr ""

#: ../../../LangRef.rst:9415
msgid ""
"The LLVM instruction set consists of several different classifications of "
"instructions: :ref:`terminator instructions <terminators>`, :ref:`binary "
"instructions <binaryops>`, :ref:`bitwise binary instructions <bitwiseops>`, :"
"ref:`memory instructions <memoryops>`, and :ref:`other instructions "
"<otherops>`. There are also :ref:`debug records <debugrecords>`, which are "
"not instructions themselves but are printed interleaved with instructions to "
"describe changes in the state of the program's debug information at each "
"position in the program's execution."
msgstr ""

#: ../../../LangRef.rst:9427
msgid "Terminator Instructions"
msgstr ""

#: ../../../LangRef.rst:9429
msgid ""
"As mentioned :ref:`previously <functionstructure>`, every basic block in a "
"program ends with a \"Terminator\" instruction, which indicates which block "
"should be executed after the current block is finished. These terminator "
"instructions typically yield a '``void``' value: they produce control flow, "
"not values (the one exception being the ':ref:`invoke <i_invoke>`' "
"instruction)."
msgstr ""

#: ../../../LangRef.rst:9436
msgid ""
"The terminator instructions are: ':ref:`ret <i_ret>`', ':ref:`br <i_br>`', ':"
"ref:`switch <i_switch>`', ':ref:`indirectbr <i_indirectbr>`', ':ref:`invoke "
"<i_invoke>`', ':ref:`callbr <i_callbr>`' ':ref:`resume <i_resume>`', ':ref:"
"`catchswitch <i_catchswitch>`', ':ref:`catchret <i_catchret>`', ':ref:"
"`cleanupret <i_cleanupret>`', and ':ref:`unreachable <i_unreachable>`'."
msgstr ""

#: ../../../LangRef.rst:9448
msgid "'``ret``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9451 ../../../LangRef.rst:9508
#: ../../../LangRef.rst:9559 ../../../LangRef.rst:9623
#: ../../../LangRef.rst:9676 ../../../LangRef.rst:9777
#: ../../../LangRef.rst:9882 ../../../LangRef.rst:9921
#: ../../../LangRef.rst:9977 ../../../LangRef.rst:10025
#: ../../../LangRef.rst:10076 ../../../LangRef.rst:10111
#: ../../../LangRef.rst:10166 ../../../LangRef.rst:10217
#: ../../../LangRef.rst:10258 ../../../LangRef.rst:10313
#: ../../../LangRef.rst:10355 ../../../LangRef.rst:10410
#: ../../../LangRef.rst:10451 ../../../LangRef.rst:10499
#: ../../../LangRef.rst:10548 ../../../LangRef.rst:10589
#: ../../../LangRef.rst:10635 ../../../LangRef.rst:10694
#: ../../../LangRef.rst:10756 ../../../LangRef.rst:10811
#: ../../../LangRef.rst:10862 ../../../LangRef.rst:10914
#: ../../../LangRef.rst:10965 ../../../LangRef.rst:11023
#: ../../../LangRef.rst:11086 ../../../LangRef.rst:11130
#: ../../../LangRef.rst:11176 ../../../LangRef.rst:11246
#: ../../../LangRef.rst:11292 ../../../LangRef.rst:11347
#: ../../../LangRef.rst:11428 ../../../LangRef.rst:11567
#: ../../../LangRef.rst:11660 ../../../LangRef.rst:11722
#: ../../../LangRef.rst:11815 ../../../LangRef.rst:11923
#: ../../../LangRef.rst:12194 ../../../LangRef.rst:12246
#: ../../../LangRef.rst:12298 ../../../LangRef.rst:12341
#: ../../../LangRef.rst:12395 ../../../LangRef.rst:12444
#: ../../../LangRef.rst:12486 ../../../LangRef.rst:12528
#: ../../../LangRef.rst:12580 ../../../LangRef.rst:12623
#: ../../../LangRef.rst:12672 ../../../LangRef.rst:12725
#: ../../../LangRef.rst:12788 ../../../LangRef.rst:12845
#: ../../../LangRef.rst:12911 ../../../LangRef.rst:13007
#: ../../../LangRef.rst:13119 ../../../LangRef.rst:13179
#: ../../../LangRef.rst:13238 ../../../LangRef.rst:13308
#: ../../../LangRef.rst:13526 ../../../LangRef.rst:13577
#: ../../../LangRef.rst:13661 ../../../LangRef.rst:13729
#: ../../../LangRef.rst:13935 ../../../LangRef.rst:13968
#: ../../../LangRef.rst:14002 ../../../LangRef.rst:14060
#: ../../../LangRef.rst:14095 ../../../LangRef.rst:14131
#: ../../../LangRef.rst:14168 ../../../LangRef.rst:14264
#: ../../../LangRef.rst:14304 ../../../LangRef.rst:14364
#: ../../../LangRef.rst:14402 ../../../LangRef.rst:14450
#: ../../../LangRef.rst:14488 ../../../LangRef.rst:14514
#: ../../../LangRef.rst:14535 ../../../LangRef.rst:14572
#: ../../../LangRef.rst:14595 ../../../LangRef.rst:14645
#: ../../../LangRef.rst:14671 ../../../LangRef.rst:14711
#: ../../../LangRef.rst:14761 ../../../LangRef.rst:14796
#: ../../../LangRef.rst:14824 ../../../LangRef.rst:14866
#: ../../../LangRef.rst:14903 ../../../LangRef.rst:14936
#: ../../../LangRef.rst:14967 ../../../LangRef.rst:14994
#: ../../../LangRef.rst:15027 ../../../LangRef.rst:15090
#: ../../../LangRef.rst:15120 ../../../LangRef.rst:15174
#: ../../../LangRef.rst:15201 ../../../LangRef.rst:15229
#: ../../../LangRef.rst:15278 ../../../LangRef.rst:15317
#: ../../../LangRef.rst:15365 ../../../LangRef.rst:15394
#: ../../../LangRef.rst:15441 ../../../LangRef.rst:15480
#: ../../../LangRef.rst:15546 ../../../LangRef.rst:15589
#: ../../../LangRef.rst:15620 ../../../LangRef.rst:15651
#: ../../../LangRef.rst:15682 ../../../LangRef.rst:15712
#: ../../../LangRef.rst:15741 ../../../LangRef.rst:15770
#: ../../../LangRef.rst:15829 ../../../LangRef.rst:15886
#: ../../../LangRef.rst:15947 ../../../LangRef.rst:16005
#: ../../../LangRef.rst:16067 ../../../LangRef.rst:16124
#: ../../../LangRef.rst:16162 ../../../LangRef.rst:16205
#: ../../../LangRef.rst:16244 ../../../LangRef.rst:16281
#: ../../../LangRef.rst:16318 ../../../LangRef.rst:16355
#: ../../../LangRef.rst:16392 ../../../LangRef.rst:16429
#: ../../../LangRef.rst:16467 ../../../LangRef.rst:16504
#: ../../../LangRef.rst:16541 ../../../LangRef.rst:16579
#: ../../../LangRef.rst:16622 ../../../LangRef.rst:16668
#: ../../../LangRef.rst:16727 ../../../LangRef.rst:16767
#: ../../../LangRef.rst:16807 ../../../LangRef.rst:16847
#: ../../../LangRef.rst:16886 ../../../LangRef.rst:16929
#: ../../../LangRef.rst:16985 ../../../LangRef.rst:17025
#: ../../../LangRef.rst:17066 ../../../LangRef.rst:17106
#: ../../../LangRef.rst:17145 ../../../LangRef.rst:17276
#: ../../../LangRef.rst:17336 ../../../LangRef.rst:17396
#: ../../../LangRef.rst:17436 ../../../LangRef.rst:17476
#: ../../../LangRef.rst:17524 ../../../LangRef.rst:17573
#: ../../../LangRef.rst:17614 ../../../LangRef.rst:17651
#: ../../../LangRef.rst:17689 ../../../LangRef.rst:17727
#: ../../../LangRef.rst:17770 ../../../LangRef.rst:17812
#: ../../../LangRef.rst:17850 ../../../LangRef.rst:17888
#: ../../../LangRef.rst:17933 ../../../LangRef.rst:17972
#: ../../../LangRef.rst:18019 ../../../LangRef.rst:18065
#: ../../../LangRef.rst:18098 ../../../LangRef.rst:18136
#: ../../../LangRef.rst:18176 ../../../LangRef.rst:18222
#: ../../../LangRef.rst:18270 ../../../LangRef.rst:18318
#: ../../../LangRef.rst:18388 ../../../LangRef.rst:18439
#: ../../../LangRef.rst:18489 ../../../LangRef.rst:18540
#: ../../../LangRef.rst:18591 ../../../LangRef.rst:18642
#: ../../../LangRef.rst:19567 ../../../LangRef.rst:19638
#: ../../../LangRef.rst:19701 ../../../LangRef.rst:19737
#: ../../../LangRef.rst:19775 ../../../LangRef.rst:19813
#: ../../../LangRef.rst:19852 ../../../LangRef.rst:19892
#: ../../../LangRef.rst:19941 ../../../LangRef.rst:19965
#: ../../../LangRef.rst:20019 ../../../LangRef.rst:20043
#: ../../../LangRef.rst:20096 ../../../LangRef.rst:20119
#: ../../../LangRef.rst:20142 ../../../LangRef.rst:20165
#: ../../../LangRef.rst:20188 ../../../LangRef.rst:20211
#: ../../../LangRef.rst:20234 ../../../LangRef.rst:20257
#: ../../../LangRef.rst:20285 ../../../LangRef.rst:20314
#: ../../../LangRef.rst:20343 ../../../LangRef.rst:20370
#: ../../../LangRef.rst:20416 ../../../LangRef.rst:20461
#: ../../../LangRef.rst:20489 ../../../LangRef.rst:20530
#: ../../../LangRef.rst:20569 ../../../LangRef.rst:20608
#: ../../../LangRef.rst:20685 ../../../LangRef.rst:20743
#: ../../../LangRef.rst:20878 ../../../LangRef.rst:20958
#: ../../../LangRef.rst:21008 ../../../LangRef.rst:21034
#: ../../../LangRef.rst:21064 ../../../LangRef.rst:21105
#: ../../../LangRef.rst:21163 ../../../LangRef.rst:21203
#: ../../../LangRef.rst:21252 ../../../LangRef.rst:21304
#: ../../../LangRef.rst:21364 ../../../LangRef.rst:21464
#: ../../../LangRef.rst:21514 ../../../LangRef.rst:21596
#: ../../../LangRef.rst:21654 ../../../LangRef.rst:21716
#: ../../../LangRef.rst:21763 ../../../LangRef.rst:21812
#: ../../../LangRef.rst:21859 ../../../LangRef.rst:21907
#: ../../../LangRef.rst:21956 ../../../LangRef.rst:22005
#: ../../../LangRef.rst:22053 ../../../LangRef.rst:22103
#: ../../../LangRef.rst:22152 ../../../LangRef.rst:22200
#: ../../../LangRef.rst:22248 ../../../LangRef.rst:22296
#: ../../../LangRef.rst:22343 ../../../LangRef.rst:22394
#: ../../../LangRef.rst:22442 ../../../LangRef.rst:22490
#: ../../../LangRef.rst:22538 ../../../LangRef.rst:22586
#: ../../../LangRef.rst:22635 ../../../LangRef.rst:22684
#: ../../../LangRef.rst:22733 ../../../LangRef.rst:22783
#: ../../../LangRef.rst:22833 ../../../LangRef.rst:22882
#: ../../../LangRef.rst:22931 ../../../LangRef.rst:22980
#: ../../../LangRef.rst:23029 ../../../LangRef.rst:23078
#: ../../../LangRef.rst:23126 ../../../LangRef.rst:23174
#: ../../../LangRef.rst:23223 ../../../LangRef.rst:23272
#: ../../../LangRef.rst:23323 ../../../LangRef.rst:23379
#: ../../../LangRef.rst:23438 ../../../LangRef.rst:23494
#: ../../../LangRef.rst:23554 ../../../LangRef.rst:23611
#: ../../../LangRef.rst:23667 ../../../LangRef.rst:23724
#: ../../../LangRef.rst:23781 ../../../LangRef.rst:23838
#: ../../../LangRef.rst:23895 ../../../LangRef.rst:23952
#: ../../../LangRef.rst:24019 ../../../LangRef.rst:24086
#: ../../../LangRef.rst:24156 ../../../LangRef.rst:24226
#: ../../../LangRef.rst:24301 ../../../LangRef.rst:24360
#: ../../../LangRef.rst:24425 ../../../LangRef.rst:24484
#: ../../../LangRef.rst:24531 ../../../LangRef.rst:24566
#: ../../../LangRef.rst:24622 ../../../LangRef.rst:24708
#: ../../../LangRef.rst:24765 ../../../LangRef.rst:24824
#: ../../../LangRef.rst:24885 ../../../LangRef.rst:24942
#: ../../../LangRef.rst:25000 ../../../LangRef.rst:25053
#: ../../../LangRef.rst:25105 ../../../LangRef.rst:25157
#: ../../../LangRef.rst:25213 ../../../LangRef.rst:25269
#: ../../../LangRef.rst:25325 ../../../LangRef.rst:25381
#: ../../../LangRef.rst:25437 ../../../LangRef.rst:25493
#: ../../../LangRef.rst:25550 ../../../LangRef.rst:25605
#: ../../../LangRef.rst:25663 ../../../LangRef.rst:25720
#: ../../../LangRef.rst:25767 ../../../LangRef.rst:25814
#: ../../../LangRef.rst:25861 ../../../LangRef.rst:25908
#: ../../../LangRef.rst:25955 ../../../LangRef.rst:26002
#: ../../../LangRef.rst:26049 ../../../LangRef.rst:26096
#: ../../../LangRef.rst:26143 ../../../LangRef.rst:26190
#: ../../../LangRef.rst:26237 ../../../LangRef.rst:26284
#: ../../../LangRef.rst:26333 ../../../LangRef.rst:26382
#: ../../../LangRef.rst:26430 ../../../LangRef.rst:26479
#: ../../../LangRef.rst:26528 ../../../LangRef.rst:26577
#: ../../../LangRef.rst:26626 ../../../LangRef.rst:26672
#: ../../../LangRef.rst:26717 ../../../LangRef.rst:26767
#: ../../../LangRef.rst:26812 ../../../LangRef.rst:26863
#: ../../../LangRef.rst:26916 ../../../LangRef.rst:26972
#: ../../../LangRef.rst:27033 ../../../LangRef.rst:27099
#: ../../../LangRef.rst:27140 ../../../LangRef.rst:27172
#: ../../../LangRef.rst:27204 ../../../LangRef.rst:27235
#: ../../../LangRef.rst:27271 ../../../LangRef.rst:27415
#: ../../../LangRef.rst:27452 ../../../LangRef.rst:27489
#: ../../../LangRef.rst:27526 ../../../LangRef.rst:27563
#: ../../../LangRef.rst:27602 ../../../LangRef.rst:27638
#: ../../../LangRef.rst:27671 ../../../LangRef.rst:27704
#: ../../../LangRef.rst:27740 ../../../LangRef.rst:27776
#: ../../../LangRef.rst:27812 ../../../LangRef.rst:27847
#: ../../../LangRef.rst:27962 ../../../LangRef.rst:28039
#: ../../../LangRef.rst:28076 ../../../LangRef.rst:28113
#: ../../../LangRef.rst:28152 ../../../LangRef.rst:28193
#: ../../../LangRef.rst:28229 ../../../LangRef.rst:28265
#: ../../../LangRef.rst:28300 ../../../LangRef.rst:28336
#: ../../../LangRef.rst:28372 ../../../LangRef.rst:28407
#: ../../../LangRef.rst:28443 ../../../LangRef.rst:28479
#: ../../../LangRef.rst:28515 ../../../LangRef.rst:28550
#: ../../../LangRef.rst:28585 ../../../LangRef.rst:28621
#: ../../../LangRef.rst:28657 ../../../LangRef.rst:28692
#: ../../../LangRef.rst:28727 ../../../LangRef.rst:28766
#: ../../../LangRef.rst:28814 ../../../LangRef.rst:28862
#: ../../../LangRef.rst:28902 ../../../LangRef.rst:28934
#: ../../../LangRef.rst:28966 ../../../LangRef.rst:28998
#: ../../../LangRef.rst:29030 ../../../LangRef.rst:29063
#: ../../../LangRef.rst:29096 ../../../LangRef.rst:29129
#: ../../../LangRef.rst:29165 ../../../LangRef.rst:29204
#: ../../../LangRef.rst:29243 ../../../LangRef.rst:29278
#: ../../../LangRef.rst:29362 ../../../LangRef.rst:29397
#: ../../../LangRef.rst:29428 ../../../LangRef.rst:29452
#: ../../../LangRef.rst:29481 ../../../LangRef.rst:29505
#: ../../../LangRef.rst:29538 ../../../LangRef.rst:29571
#: ../../../LangRef.rst:29608 ../../../LangRef.rst:29690
#: ../../../LangRef.rst:29720 ../../../LangRef.rst:29759
#: ../../../LangRef.rst:29799 ../../../LangRef.rst:29822
#: ../../../LangRef.rst:29851 ../../../LangRef.rst:29880
#: ../../../LangRef.rst:29909 ../../../LangRef.rst:29945
#: ../../../LangRef.rst:29980 ../../../LangRef.rst:30029
#: ../../../LangRef.rst:30061 ../../../LangRef.rst:30097
#: ../../../LangRef.rst:30143 ../../../LangRef.rst:30170
#: ../../../LangRef.rst:30195 ../../../LangRef.rst:30250
#: ../../../LangRef.rst:30272 ../../../LangRef.rst:30308
#: ../../../LangRef.rst:30337 ../../../LangRef.rst:30412
#: ../../../LangRef.rst:30465 ../../../LangRef.rst:30603
#: ../../../LangRef.rst:30661 ../../../LangRef.rst:30718
#: ../../../LangRef.rst:30745 ../../../LangRef.rst:30775
#: ../../../LangRef.rst:30819 ../../../LangRef.rst:30868
#: ../../../LangRef.rst:30893 ../../../LangRef.rst:30920
#: ../../../LangRef.rst:30970 ../../../LangRef.rst:31044
#: ../../../LangRef.rst:31125 ../../../LangRef.rst:31203
#: ../../../LangRef.rst:31217 ../../../LangRef.rst:31231
#: ../../../LangRef.rst:31245 ../../../LangRef.rst:31259
#: ../../../LangRef.rst:31273 ../../../LangRef.rst:31287
#: ../../../LangRef.rst:31301 ../../../LangRef.rst:31315
#: ../../../LangRef.rst:31329 ../../../LangRef.rst:31343
#: ../../../LangRef.rst:31357 ../../../LangRef.rst:31371
#: ../../../LangRef.rst:31385 ../../../LangRef.rst:31399
#: ../../../LangRef.rst:31413 ../../../LangRef.rst:31427
#: ../../../LangRef.rst:31441 ../../../LangRef.rst:31465
#: ../../../LangRef.rst:31507 ../../../LangRef.rst:31538
msgid "Syntax:"
msgstr ""

#: ../../../LangRef.rst:9459 ../../../LangRef.rst:9516
#: ../../../LangRef.rst:9566 ../../../LangRef.rst:9630
#: ../../../LangRef.rst:9684 ../../../LangRef.rst:9785
#: ../../../LangRef.rst:9889 ../../../LangRef.rst:9929
#: ../../../LangRef.rst:9984 ../../../LangRef.rst:10033
#: ../../../LangRef.rst:10083 ../../../LangRef.rst:10118
#: ../../../LangRef.rst:10176 ../../../LangRef.rst:10224
#: ../../../LangRef.rst:10268 ../../../LangRef.rst:10320
#: ../../../LangRef.rst:10365 ../../../LangRef.rst:10417
#: ../../../LangRef.rst:10459 ../../../LangRef.rst:10507
#: ../../../LangRef.rst:10555 ../../../LangRef.rst:10596
#: ../../../LangRef.rst:10642 ../../../LangRef.rst:10701
#: ../../../LangRef.rst:10766 ../../../LangRef.rst:10819
#: ../../../LangRef.rst:10870 ../../../LangRef.rst:10921
#: ../../../LangRef.rst:10973 ../../../LangRef.rst:11030
#: ../../../LangRef.rst:11094 ../../../LangRef.rst:11138
#: ../../../LangRef.rst:11184 ../../../LangRef.rst:11253
#: ../../../LangRef.rst:11299 ../../../LangRef.rst:11354
#: ../../../LangRef.rst:11440 ../../../LangRef.rst:11577
#: ../../../LangRef.rst:11667 ../../../LangRef.rst:11729
#: ../../../LangRef.rst:11822 ../../../LangRef.rst:11935
#: ../../../LangRef.rst:12204 ../../../LangRef.rst:12253
#: ../../../LangRef.rst:12305 ../../../LangRef.rst:12348
#: ../../../LangRef.rst:12402 ../../../LangRef.rst:12451
#: ../../../LangRef.rst:12493 ../../../LangRef.rst:12535
#: ../../../LangRef.rst:12587 ../../../LangRef.rst:12630
#: ../../../LangRef.rst:12679 ../../../LangRef.rst:12732
#: ../../../LangRef.rst:12795 ../../../LangRef.rst:12852
#: ../../../LangRef.rst:12919 ../../../LangRef.rst:13014
#: ../../../LangRef.rst:13126 ../../../LangRef.rst:13188
#: ../../../LangRef.rst:13245 ../../../LangRef.rst:13316
#: ../../../LangRef.rst:13533 ../../../LangRef.rst:13588
#: ../../../LangRef.rst:13668 ../../../LangRef.rst:13736
#: ../../../LangRef.rst:13943 ../../../LangRef.rst:13976
#: ../../../LangRef.rst:14010 ../../../LangRef.rst:14067
#: ../../../LangRef.rst:14102 ../../../LangRef.rst:14138
#: ../../../LangRef.rst:14180 ../../../LangRef.rst:14272
#: ../../../LangRef.rst:14314 ../../../LangRef.rst:14374
#: ../../../LangRef.rst:14412 ../../../LangRef.rst:14457
#: ../../../LangRef.rst:14495 ../../../LangRef.rst:14521
#: ../../../LangRef.rst:14542 ../../../LangRef.rst:14579
#: ../../../LangRef.rst:14603 ../../../LangRef.rst:14653
#: ../../../LangRef.rst:14679 ../../../LangRef.rst:14724
#: ../../../LangRef.rst:14769 ../../../LangRef.rst:14804
#: ../../../LangRef.rst:14832 ../../../LangRef.rst:14873
#: ../../../LangRef.rst:14910 ../../../LangRef.rst:14943
#: ../../../LangRef.rst:14974 ../../../LangRef.rst:15001
#: ../../../LangRef.rst:15035 ../../../LangRef.rst:15099
#: ../../../LangRef.rst:15129 ../../../LangRef.rst:15182
#: ../../../LangRef.rst:15209 ../../../LangRef.rst:15238
#: ../../../LangRef.rst:15286 ../../../LangRef.rst:15326
#: ../../../LangRef.rst:15373 ../../../LangRef.rst:15401
#: ../../../LangRef.rst:15448 ../../../LangRef.rst:15487
#: ../../../LangRef.rst:15557 ../../../LangRef.rst:15600
#: ../../../LangRef.rst:15631 ../../../LangRef.rst:15662
#: ../../../LangRef.rst:15693 ../../../LangRef.rst:15723
#: ../../../LangRef.rst:15752 ../../../LangRef.rst:15784
#: ../../../LangRef.rst:15843 ../../../LangRef.rst:15900
#: ../../../LangRef.rst:15961 ../../../LangRef.rst:16019
#: ../../../LangRef.rst:16079 ../../../LangRef.rst:16139
#: ../../../LangRef.rst:16180 ../../../LangRef.rst:16220
#: ../../../LangRef.rst:16259 ../../../LangRef.rst:16296
#: ../../../LangRef.rst:16333 ../../../LangRef.rst:16370
#: ../../../LangRef.rst:16407 ../../../LangRef.rst:16444
#: ../../../LangRef.rst:16482 ../../../LangRef.rst:16519
#: ../../../LangRef.rst:16556 ../../../LangRef.rst:16595
#: ../../../LangRef.rst:16638 ../../../LangRef.rst:16683
#: ../../../LangRef.rst:16742 ../../../LangRef.rst:16782
#: ../../../LangRef.rst:16822 ../../../LangRef.rst:16862
#: ../../../LangRef.rst:16902 ../../../LangRef.rst:16945
#: ../../../LangRef.rst:17000 ../../../LangRef.rst:17040
#: ../../../LangRef.rst:17081 ../../../LangRef.rst:17121
#: ../../../LangRef.rst:17160 ../../../LangRef.rst:17291
#: ../../../LangRef.rst:17351 ../../../LangRef.rst:17411
#: ../../../LangRef.rst:17451 ../../../LangRef.rst:17491
#: ../../../LangRef.rst:17539 ../../../LangRef.rst:17588
#: ../../../LangRef.rst:17629 ../../../LangRef.rst:17666
#: ../../../LangRef.rst:17704 ../../../LangRef.rst:17742
#: ../../../LangRef.rst:17785 ../../../LangRef.rst:17827
#: ../../../LangRef.rst:17865 ../../../LangRef.rst:17909
#: ../../../LangRef.rst:17947 ../../../LangRef.rst:17993
#: ../../../LangRef.rst:18034 ../../../LangRef.rst:18078
#: ../../../LangRef.rst:18111 ../../../LangRef.rst:18152
#: ../../../LangRef.rst:18188 ../../../LangRef.rst:18234
#: ../../../LangRef.rst:18283 ../../../LangRef.rst:18331
#: ../../../LangRef.rst:18401 ../../../LangRef.rst:18452
#: ../../../LangRef.rst:18502 ../../../LangRef.rst:18553
#: ../../../LangRef.rst:18604 ../../../LangRef.rst:18655
#: ../../../LangRef.rst:19575 ../../../LangRef.rst:19646
#: ../../../LangRef.rst:19711 ../../../LangRef.rst:19747
#: ../../../LangRef.rst:19785 ../../../LangRef.rst:19823
#: ../../../LangRef.rst:19862 ../../../LangRef.rst:19902
#: ../../../LangRef.rst:19949 ../../../LangRef.rst:19973
#: ../../../LangRef.rst:20027 ../../../LangRef.rst:20051
#: ../../../LangRef.rst:20103 ../../../LangRef.rst:20126
#: ../../../LangRef.rst:20149 ../../../LangRef.rst:20172
#: ../../../LangRef.rst:20195 ../../../LangRef.rst:20218
#: ../../../LangRef.rst:20241 ../../../LangRef.rst:20265
#: ../../../LangRef.rst:20294 ../../../LangRef.rst:20323
#: ../../../LangRef.rst:20352 ../../../LangRef.rst:20386
#: ../../../LangRef.rst:20432 ../../../LangRef.rst:20470
#: ../../../LangRef.rst:20501 ../../../LangRef.rst:20542
#: ../../../LangRef.rst:20579 ../../../LangRef.rst:20617
#: ../../../LangRef.rst:20694 ../../../LangRef.rst:20754
#: ../../../LangRef.rst:20889 ../../../LangRef.rst:20968
#: ../../../LangRef.rst:21016 ../../../LangRef.rst:21042
#: ../../../LangRef.rst:21073 ../../../LangRef.rst:21113
#: ../../../LangRef.rst:21171 ../../../LangRef.rst:21211
#: ../../../LangRef.rst:21265 ../../../LangRef.rst:21317
#: ../../../LangRef.rst:21372 ../../../LangRef.rst:21471
#: ../../../LangRef.rst:21521 ../../../LangRef.rst:21605
#: ../../../LangRef.rst:21663 ../../../LangRef.rst:21726
#: ../../../LangRef.rst:21773 ../../../LangRef.rst:21822
#: ../../../LangRef.rst:21869 ../../../LangRef.rst:21917
#: ../../../LangRef.rst:21966 ../../../LangRef.rst:22015
#: ../../../LangRef.rst:22063 ../../../LangRef.rst:22113
#: ../../../LangRef.rst:22162 ../../../LangRef.rst:22210
#: ../../../LangRef.rst:22258 ../../../LangRef.rst:22306
#: ../../../LangRef.rst:22353 ../../../LangRef.rst:22404
#: ../../../LangRef.rst:22452 ../../../LangRef.rst:22500
#: ../../../LangRef.rst:22548 ../../../LangRef.rst:22596
#: ../../../LangRef.rst:22645 ../../../LangRef.rst:22694
#: ../../../LangRef.rst:22743 ../../../LangRef.rst:22793
#: ../../../LangRef.rst:22843 ../../../LangRef.rst:22892
#: ../../../LangRef.rst:22941 ../../../LangRef.rst:22990
#: ../../../LangRef.rst:23039 ../../../LangRef.rst:23088
#: ../../../LangRef.rst:23136 ../../../LangRef.rst:23184
#: ../../../LangRef.rst:23233 ../../../LangRef.rst:23282
#: ../../../LangRef.rst:23332 ../../../LangRef.rst:23388
#: ../../../LangRef.rst:23447 ../../../LangRef.rst:23503
#: ../../../LangRef.rst:23563 ../../../LangRef.rst:23620
#: ../../../LangRef.rst:23676 ../../../LangRef.rst:23733
#: ../../../LangRef.rst:23790 ../../../LangRef.rst:23847
#: ../../../LangRef.rst:23904 ../../../LangRef.rst:23961
#: ../../../LangRef.rst:24028 ../../../LangRef.rst:24095
#: ../../../LangRef.rst:24165 ../../../LangRef.rst:24238
#: ../../../LangRef.rst:24313 ../../../LangRef.rst:24372
#: ../../../LangRef.rst:24434 ../../../LangRef.rst:24493
#: ../../../LangRef.rst:24540 ../../../LangRef.rst:24577
#: ../../../LangRef.rst:24633 ../../../LangRef.rst:24719
#: ../../../LangRef.rst:24774 ../../../LangRef.rst:24833
#: ../../../LangRef.rst:24896 ../../../LangRef.rst:24953
#: ../../../LangRef.rst:25009 ../../../LangRef.rst:25062
#: ../../../LangRef.rst:25114 ../../../LangRef.rst:25166
#: ../../../LangRef.rst:25222 ../../../LangRef.rst:25279
#: ../../../LangRef.rst:25335 ../../../LangRef.rst:25391
#: ../../../LangRef.rst:25447 ../../../LangRef.rst:25503
#: ../../../LangRef.rst:25560 ../../../LangRef.rst:25615
#: ../../../LangRef.rst:25673 ../../../LangRef.rst:25730
#: ../../../LangRef.rst:25777 ../../../LangRef.rst:25824
#: ../../../LangRef.rst:25871 ../../../LangRef.rst:25918
#: ../../../LangRef.rst:25965 ../../../LangRef.rst:26012
#: ../../../LangRef.rst:26059 ../../../LangRef.rst:26106
#: ../../../LangRef.rst:26153 ../../../LangRef.rst:26200
#: ../../../LangRef.rst:26247 ../../../LangRef.rst:26294
#: ../../../LangRef.rst:26343 ../../../LangRef.rst:26393
#: ../../../LangRef.rst:26440 ../../../LangRef.rst:26489
#: ../../../LangRef.rst:26538 ../../../LangRef.rst:26587
#: ../../../LangRef.rst:26636 ../../../LangRef.rst:26682
#: ../../../LangRef.rst:26726 ../../../LangRef.rst:26778
#: ../../../LangRef.rst:26823 ../../../LangRef.rst:26873
#: ../../../LangRef.rst:26926 ../../../LangRef.rst:26981
#: ../../../LangRef.rst:27042 ../../../LangRef.rst:27106
#: ../../../LangRef.rst:27147 ../../../LangRef.rst:27181
#: ../../../LangRef.rst:27213 ../../../LangRef.rst:27245
#: ../../../LangRef.rst:27281 ../../../LangRef.rst:27425
#: ../../../LangRef.rst:27462 ../../../LangRef.rst:27499
#: ../../../LangRef.rst:27536 ../../../LangRef.rst:27573
#: ../../../LangRef.rst:27612 ../../../LangRef.rst:27647
#: ../../../LangRef.rst:27680 ../../../LangRef.rst:27714
#: ../../../LangRef.rst:27750 ../../../LangRef.rst:27786
#: ../../../LangRef.rst:27821 ../../../LangRef.rst:27861
#: ../../../LangRef.rst:27973 ../../../LangRef.rst:28049
#: ../../../LangRef.rst:28086 ../../../LangRef.rst:28123
#: ../../../LangRef.rst:28162 ../../../LangRef.rst:28203
#: ../../../LangRef.rst:28239 ../../../LangRef.rst:28275
#: ../../../LangRef.rst:28310 ../../../LangRef.rst:28346
#: ../../../LangRef.rst:28382 ../../../LangRef.rst:28418
#: ../../../LangRef.rst:28453 ../../../LangRef.rst:28489
#: ../../../LangRef.rst:28525 ../../../LangRef.rst:28560
#: ../../../LangRef.rst:28595 ../../../LangRef.rst:28631
#: ../../../LangRef.rst:28667 ../../../LangRef.rst:28702
#: ../../../LangRef.rst:28737 ../../../LangRef.rst:28776
#: ../../../LangRef.rst:28824 ../../../LangRef.rst:28872
#: ../../../LangRef.rst:28911 ../../../LangRef.rst:28943
#: ../../../LangRef.rst:28975 ../../../LangRef.rst:29007
#: ../../../LangRef.rst:29039 ../../../LangRef.rst:29072
#: ../../../LangRef.rst:29105 ../../../LangRef.rst:29138
#: ../../../LangRef.rst:29174 ../../../LangRef.rst:29213
#: ../../../LangRef.rst:29252 ../../../LangRef.rst:29286
#: ../../../LangRef.rst:29369 ../../../LangRef.rst:29404
#: ../../../LangRef.rst:29435 ../../../LangRef.rst:29459
#: ../../../LangRef.rst:29488 ../../../LangRef.rst:29515
#: ../../../LangRef.rst:29547 ../../../LangRef.rst:29578
#: ../../../LangRef.rst:29616 ../../../LangRef.rst:29697
#: ../../../LangRef.rst:29733 ../../../LangRef.rst:29773
#: ../../../LangRef.rst:29829 ../../../LangRef.rst:29858
#: ../../../LangRef.rst:29887 ../../../LangRef.rst:29916
#: ../../../LangRef.rst:29952 ../../../LangRef.rst:29988
#: ../../../LangRef.rst:30041 ../../../LangRef.rst:30073
#: ../../../LangRef.rst:30104 ../../../LangRef.rst:30155
#: ../../../LangRef.rst:30184 ../../../LangRef.rst:30211
#: ../../../LangRef.rst:30257 ../../../LangRef.rst:30280
#: ../../../LangRef.rst:30315 ../../../LangRef.rst:30344
#: ../../../LangRef.rst:30419 ../../../LangRef.rst:30472
#: ../../../LangRef.rst:30610 ../../../LangRef.rst:30668
#: ../../../LangRef.rst:30725 ../../../LangRef.rst:30752
#: ../../../LangRef.rst:30786 ../../../LangRef.rst:30833
#: ../../../LangRef.rst:30901 ../../../LangRef.rst:30927
#: ../../../LangRef.rst:30988 ../../../LangRef.rst:31062
#: ../../../LangRef.rst:31143 ../../../LangRef.rst:31474
#: ../../../LangRef.rst:31515 ../../../LangRef.rst:31547
msgid "Overview:"
msgstr ""

#: ../../../LangRef.rst:9461
msgid ""
"The '``ret``' instruction is used to return control flow (and optionally a "
"value) from a function back to the caller."
msgstr ""

#: ../../../LangRef.rst:9464
msgid ""
"There are two forms of the '``ret``' instruction: one that returns a value "
"and then causes control flow, and one that just causes control flow to occur."
msgstr ""

#: ../../../LangRef.rst:9469 ../../../LangRef.rst:9524
#: ../../../LangRef.rst:9574 ../../../LangRef.rst:9638
#: ../../../LangRef.rst:9706 ../../../LangRef.rst:9811
#: ../../../LangRef.rst:9895 ../../../LangRef.rst:9936
#: ../../../LangRef.rst:9991 ../../../LangRef.rst:10040
#: ../../../LangRef.rst:10123 ../../../LangRef.rst:10181
#: ../../../LangRef.rst:10229 ../../../LangRef.rst:10276
#: ../../../LangRef.rst:10325 ../../../LangRef.rst:10370
#: ../../../LangRef.rst:10422 ../../../LangRef.rst:10464
#: ../../../LangRef.rst:10512 ../../../LangRef.rst:10560
#: ../../../LangRef.rst:10602 ../../../LangRef.rst:10650
#: ../../../LangRef.rst:10713 ../../../LangRef.rst:10772
#: ../../../LangRef.rst:10825 ../../../LangRef.rst:10877
#: ../../../LangRef.rst:10927 ../../../LangRef.rst:10979
#: ../../../LangRef.rst:11037 ../../../LangRef.rst:11100
#: ../../../LangRef.rst:11144 ../../../LangRef.rst:11191
#: ../../../LangRef.rst:11259 ../../../LangRef.rst:11305
#: ../../../LangRef.rst:11362 ../../../LangRef.rst:11445
#: ../../../LangRef.rst:11582 ../../../LangRef.rst:11673
#: ../../../LangRef.rst:11736 ../../../LangRef.rst:11827
#: ../../../LangRef.rst:11943 ../../../LangRef.rst:12209
#: ../../../LangRef.rst:12262 ../../../LangRef.rst:12310
#: ../../../LangRef.rst:12353 ../../../LangRef.rst:12408
#: ../../../LangRef.rst:12457 ../../../LangRef.rst:12499
#: ../../../LangRef.rst:12545 ../../../LangRef.rst:12593
#: ../../../LangRef.rst:12636 ../../../LangRef.rst:12688
#: ../../../LangRef.rst:12738 ../../../LangRef.rst:12801
#: ../../../LangRef.rst:12858 ../../../LangRef.rst:12926
#: ../../../LangRef.rst:13027 ../../../LangRef.rst:13132
#: ../../../LangRef.rst:13194 ../../../LangRef.rst:13251
#: ../../../LangRef.rst:13321 ../../../LangRef.rst:13540
#: ../../../LangRef.rst:13598 ../../../LangRef.rst:13676
#: ../../../LangRef.rst:13752 ../../../LangRef.rst:13949
#: ../../../LangRef.rst:13982 ../../../LangRef.rst:14016
#: ../../../LangRef.rst:14073 ../../../LangRef.rst:14109
#: ../../../LangRef.rst:14145 ../../../LangRef.rst:14464
#: ../../../LangRef.rst:14548 ../../../LangRef.rst:14611
#: ../../../LangRef.rst:14881 ../../../LangRef.rst:14922
#: ../../../LangRef.rst:15043 ../../../LangRef.rst:15106
#: ../../../LangRef.rst:15137 ../../../LangRef.rst:15188
#: ../../../LangRef.rst:15215 ../../../LangRef.rst:15246
#: ../../../LangRef.rst:15292 ../../../LangRef.rst:15336
#: ../../../LangRef.rst:15563 ../../../LangRef.rst:15607
#: ../../../LangRef.rst:15638 ../../../LangRef.rst:15669
#: ../../../LangRef.rst:15700 ../../../LangRef.rst:15729
#: ../../../LangRef.rst:15758 ../../../LangRef.rst:15794
#: ../../../LangRef.rst:15854 ../../../LangRef.rst:15912
#: ../../../LangRef.rst:15971 ../../../LangRef.rst:16029
#: ../../../LangRef.rst:16087 ../../../LangRef.rst:16144
#: ../../../LangRef.rst:16188 ../../../LangRef.rst:16225
#: ../../../LangRef.rst:16264 ../../../LangRef.rst:16301
#: ../../../LangRef.rst:16338 ../../../LangRef.rst:16375
#: ../../../LangRef.rst:16412 ../../../LangRef.rst:16450
#: ../../../LangRef.rst:16487 ../../../LangRef.rst:16524
#: ../../../LangRef.rst:16561 ../../../LangRef.rst:16600
#: ../../../LangRef.rst:16643 ../../../LangRef.rst:16689
#: ../../../LangRef.rst:16748 ../../../LangRef.rst:16788
#: ../../../LangRef.rst:16828 ../../../LangRef.rst:16868
#: ../../../LangRef.rst:16907 ../../../LangRef.rst:16950
#: ../../../LangRef.rst:17006 ../../../LangRef.rst:17046
#: ../../../LangRef.rst:17087 ../../../LangRef.rst:17126
#: ../../../LangRef.rst:17166 ../../../LangRef.rst:17298
#: ../../../LangRef.rst:17358 ../../../LangRef.rst:17418
#: ../../../LangRef.rst:17458 ../../../LangRef.rst:17498
#: ../../../LangRef.rst:17546 ../../../LangRef.rst:17594
#: ../../../LangRef.rst:17634 ../../../LangRef.rst:17671
#: ../../../LangRef.rst:17710 ../../../LangRef.rst:17749
#: ../../../LangRef.rst:17791 ../../../LangRef.rst:17833
#: ../../../LangRef.rst:17872 ../../../LangRef.rst:17916
#: ../../../LangRef.rst:17953 ../../../LangRef.rst:18000
#: ../../../LangRef.rst:18040 ../../../LangRef.rst:18158
#: ../../../LangRef.rst:18194 ../../../LangRef.rst:18240
#: ../../../LangRef.rst:18295 ../../../LangRef.rst:18343
#: ../../../LangRef.rst:18408 ../../../LangRef.rst:18459
#: ../../../LangRef.rst:18509 ../../../LangRef.rst:18560
#: ../../../LangRef.rst:18611 ../../../LangRef.rst:18662
#: ../../../LangRef.rst:19655 ../../../LangRef.rst:19719
#: ../../../LangRef.rst:19758 ../../../LangRef.rst:19794
#: ../../../LangRef.rst:19832 ../../../LangRef.rst:19869
#: ../../../LangRef.rst:19913 ../../../LangRef.rst:19956
#: ../../../LangRef.rst:19996 ../../../LangRef.rst:20034
#: ../../../LangRef.rst:20074 ../../../LangRef.rst:20110
#: ../../../LangRef.rst:20133 ../../../LangRef.rst:20156
#: ../../../LangRef.rst:20179 ../../../LangRef.rst:20202
#: ../../../LangRef.rst:20225 ../../../LangRef.rst:20248
#: ../../../LangRef.rst:20276 ../../../LangRef.rst:20305
#: ../../../LangRef.rst:20334 ../../../LangRef.rst:20363
#: ../../../LangRef.rst:20397 ../../../LangRef.rst:20443
#: ../../../LangRef.rst:20481 ../../../LangRef.rst:20521
#: ../../../LangRef.rst:20561 ../../../LangRef.rst:20585
#: ../../../LangRef.rst:20643 ../../../LangRef.rst:20676
#: ../../../LangRef.rst:20701 ../../../LangRef.rst:20761
#: ../../../LangRef.rst:20813 ../../../LangRef.rst:20851
#: ../../../LangRef.rst:20910 ../../../LangRef.rst:20973
#: ../../../LangRef.rst:21022 ../../../LangRef.rst:21049
#: ../../../LangRef.rst:21085 ../../../LangRef.rst:21125
#: ../../../LangRef.rst:21177 ../../../LangRef.rst:21218
#: ../../../LangRef.rst:21271 ../../../LangRef.rst:21323
#: ../../../LangRef.rst:21379 ../../../LangRef.rst:21477
#: ../../../LangRef.rst:21527 ../../../LangRef.rst:21611
#: ../../../LangRef.rst:21669 ../../../LangRef.rst:21732
#: ../../../LangRef.rst:21779 ../../../LangRef.rst:21828
#: ../../../LangRef.rst:21875 ../../../LangRef.rst:21923
#: ../../../LangRef.rst:21972 ../../../LangRef.rst:22021
#: ../../../LangRef.rst:22069 ../../../LangRef.rst:22119
#: ../../../LangRef.rst:22168 ../../../LangRef.rst:22216
#: ../../../LangRef.rst:22264 ../../../LangRef.rst:22312
#: ../../../LangRef.rst:22359 ../../../LangRef.rst:22410
#: ../../../LangRef.rst:22458 ../../../LangRef.rst:22506
#: ../../../LangRef.rst:22554 ../../../LangRef.rst:22602
#: ../../../LangRef.rst:22651 ../../../LangRef.rst:22700
#: ../../../LangRef.rst:22749 ../../../LangRef.rst:22799
#: ../../../LangRef.rst:22849 ../../../LangRef.rst:22898
#: ../../../LangRef.rst:22947 ../../../LangRef.rst:22996
#: ../../../LangRef.rst:23045 ../../../LangRef.rst:23094
#: ../../../LangRef.rst:23142 ../../../LangRef.rst:23190
#: ../../../LangRef.rst:23239 ../../../LangRef.rst:23290
#: ../../../LangRef.rst:23338 ../../../LangRef.rst:23394
#: ../../../LangRef.rst:23454 ../../../LangRef.rst:23510
#: ../../../LangRef.rst:23570 ../../../LangRef.rst:23627
#: ../../../LangRef.rst:23683 ../../../LangRef.rst:23740
#: ../../../LangRef.rst:23797 ../../../LangRef.rst:23854
#: ../../../LangRef.rst:23911 ../../../LangRef.rst:23968
#: ../../../LangRef.rst:24035 ../../../LangRef.rst:24102
#: ../../../LangRef.rst:24172 ../../../LangRef.rst:24244
#: ../../../LangRef.rst:24325 ../../../LangRef.rst:24389
#: ../../../LangRef.rst:24440 ../../../LangRef.rst:24499
#: ../../../LangRef.rst:24546 ../../../LangRef.rst:24583
#: ../../../LangRef.rst:24640 ../../../LangRef.rst:24725
#: ../../../LangRef.rst:24780 ../../../LangRef.rst:24840
#: ../../../LangRef.rst:24902 ../../../LangRef.rst:24959
#: ../../../LangRef.rst:25016 ../../../LangRef.rst:25069
#: ../../../LangRef.rst:25121 ../../../LangRef.rst:25173
#: ../../../LangRef.rst:25229 ../../../LangRef.rst:25287
#: ../../../LangRef.rst:25343 ../../../LangRef.rst:25399
#: ../../../LangRef.rst:25455 ../../../LangRef.rst:25510
#: ../../../LangRef.rst:25567 ../../../LangRef.rst:25623
#: ../../../LangRef.rst:25681 ../../../LangRef.rst:25736
#: ../../../LangRef.rst:25783 ../../../LangRef.rst:25830
#: ../../../LangRef.rst:25877 ../../../LangRef.rst:25924
#: ../../../LangRef.rst:25971 ../../../LangRef.rst:26018
#: ../../../LangRef.rst:26065 ../../../LangRef.rst:26112
#: ../../../LangRef.rst:26159 ../../../LangRef.rst:26206
#: ../../../LangRef.rst:26253 ../../../LangRef.rst:26300
#: ../../../LangRef.rst:26349 ../../../LangRef.rst:26400
#: ../../../LangRef.rst:26446 ../../../LangRef.rst:26495
#: ../../../LangRef.rst:26544 ../../../LangRef.rst:26593
#: ../../../LangRef.rst:26642 ../../../LangRef.rst:26688
#: ../../../LangRef.rst:26731 ../../../LangRef.rst:26784
#: ../../../LangRef.rst:26828 ../../../LangRef.rst:26879
#: ../../../LangRef.rst:26931 ../../../LangRef.rst:26987
#: ../../../LangRef.rst:27047 ../../../LangRef.rst:27112
#: ../../../LangRef.rst:27153 ../../../LangRef.rst:27187
#: ../../../LangRef.rst:27219 ../../../LangRef.rst:27255
#: ../../../LangRef.rst:27290 ../../../LangRef.rst:27432
#: ../../../LangRef.rst:27469 ../../../LangRef.rst:27506
#: ../../../LangRef.rst:27543 ../../../LangRef.rst:27580
#: ../../../LangRef.rst:27618 ../../../LangRef.rst:27653
#: ../../../LangRef.rst:27686 ../../../LangRef.rst:27720
#: ../../../LangRef.rst:27756 ../../../LangRef.rst:27792
#: ../../../LangRef.rst:27827 ../../../LangRef.rst:27879
#: ../../../LangRef.rst:27982 ../../../LangRef.rst:28056
#: ../../../LangRef.rst:28092 ../../../LangRef.rst:28132
#: ../../../LangRef.rst:28168 ../../../LangRef.rst:28209
#: ../../../LangRef.rst:28245 ../../../LangRef.rst:28281
#: ../../../LangRef.rst:28316 ../../../LangRef.rst:28352
#: ../../../LangRef.rst:28388 ../../../LangRef.rst:28424
#: ../../../LangRef.rst:28459 ../../../LangRef.rst:28495
#: ../../../LangRef.rst:28531 ../../../LangRef.rst:28566
#: ../../../LangRef.rst:28602 ../../../LangRef.rst:28637
#: ../../../LangRef.rst:28673 ../../../LangRef.rst:28708
#: ../../../LangRef.rst:28744 ../../../LangRef.rst:28785
#: ../../../LangRef.rst:28833 ../../../LangRef.rst:28880
#: ../../../LangRef.rst:28917 ../../../LangRef.rst:28949
#: ../../../LangRef.rst:28981 ../../../LangRef.rst:29013
#: ../../../LangRef.rst:29045 ../../../LangRef.rst:29078
#: ../../../LangRef.rst:29111 ../../../LangRef.rst:29146
#: ../../../LangRef.rst:29184 ../../../LangRef.rst:29223
#: ../../../LangRef.rst:29259 ../../../LangRef.rst:29295
#: ../../../LangRef.rst:29409 ../../../LangRef.rst:29464
#: ../../../LangRef.rst:29521 ../../../LangRef.rst:29553
#: ../../../LangRef.rst:29584 ../../../LangRef.rst:29629
#: ../../../LangRef.rst:29702 ../../../LangRef.rst:29738
#: ../../../LangRef.rst:29778 ../../../LangRef.rst:29812
#: ../../../LangRef.rst:29834 ../../../LangRef.rst:29863
#: ../../../LangRef.rst:29892 ../../../LangRef.rst:29923
#: ../../../LangRef.rst:29961 ../../../LangRef.rst:29997
#: ../../../LangRef.rst:30047 ../../../LangRef.rst:30080
#: ../../../LangRef.rst:30114 ../../../LangRef.rst:30150
#: ../../../LangRef.rst:30178 ../../../LangRef.rst:30203
#: ../../../LangRef.rst:30289 ../../../LangRef.rst:30323
#: ../../../LangRef.rst:30359 ../../../LangRef.rst:30492
#: ../../../LangRef.rst:30621 ../../../LangRef.rst:30679
#: ../../../LangRef.rst:30761 ../../../LangRef.rst:30826
#: ../../../LangRef.rst:30875 ../../../LangRef.rst:30936
#: ../../../LangRef.rst:30997 ../../../LangRef.rst:31072
#: ../../../LangRef.rst:31152 ../../../LangRef.rst:31487
#: ../../../LangRef.rst:31525 ../../../LangRef.rst:31557
msgid "Arguments:"
msgstr ""

#: ../../../LangRef.rst:9471
msgid ""
"The '``ret``' instruction optionally accepts a single argument, the return "
"value. The type of the return value must be a ':ref:`first class "
"<t_firstclass>`' type."
msgstr ""

#: ../../../LangRef.rst:9475
msgid ""
"A function is not :ref:`well formed <wellformed>` if it has a non-void "
"return type and contains a '``ret``' instruction with no return value or a "
"return value with a type that does not match its type, or if it has a void "
"return type and contains a '``ret``' instruction with a return value."
msgstr ""

#: ../../../LangRef.rst:9482 ../../../LangRef.rst:9531
#: ../../../LangRef.rst:9582 ../../../LangRef.rst:9649
#: ../../../LangRef.rst:9744 ../../../LangRef.rst:9849
#: ../../../LangRef.rst:9902 ../../../LangRef.rst:9951
#: ../../../LangRef.rst:9999 ../../../LangRef.rst:10055
#: ../../../LangRef.rst:10091 ../../../LangRef.rst:10130
#: ../../../LangRef.rst:10188 ../../../LangRef.rst:10236
#: ../../../LangRef.rst:10283 ../../../LangRef.rst:10332
#: ../../../LangRef.rst:10377 ../../../LangRef.rst:10429
#: ../../../LangRef.rst:10471 ../../../LangRef.rst:10519
#: ../../../LangRef.rst:10567 ../../../LangRef.rst:10609
#: ../../../LangRef.rst:10657 ../../../LangRef.rst:10720
#: ../../../LangRef.rst:10779 ../../../LangRef.rst:10832
#: ../../../LangRef.rst:10884 ../../../LangRef.rst:10934
#: ../../../LangRef.rst:10986 ../../../LangRef.rst:11044
#: ../../../LangRef.rst:11108 ../../../LangRef.rst:11154
#: ../../../LangRef.rst:11201 ../../../LangRef.rst:11274
#: ../../../LangRef.rst:11316 ../../../LangRef.rst:11386
#: ../../../LangRef.rst:11538 ../../../LangRef.rst:11631
#: ../../../LangRef.rst:11680 ../../../LangRef.rst:11771
#: ../../../LangRef.rst:11880 ../../../LangRef.rst:12000
#: ../../../LangRef.rst:12218 ../../../LangRef.rst:12270
#: ../../../LangRef.rst:12318 ../../../LangRef.rst:12361
#: ../../../LangRef.rst:12415 ../../../LangRef.rst:12466
#: ../../../LangRef.rst:12508 ../../../LangRef.rst:12554
#: ../../../LangRef.rst:12602 ../../../LangRef.rst:12644
#: ../../../LangRef.rst:12697 ../../../LangRef.rst:12760
#: ../../../LangRef.rst:12813 ../../../LangRef.rst:12865
#: ../../../LangRef.rst:12950 ../../../LangRef.rst:13058
#: ../../../LangRef.rst:13157 ../../../LangRef.rst:13210
#: ../../../LangRef.rst:13256 ../../../LangRef.rst:13478
#: ../../../LangRef.rst:13548 ../../../LangRef.rst:13612
#: ../../../LangRef.rst:13693 ../../../LangRef.rst:13758
#: ../../../LangRef.rst:13954 ../../../LangRef.rst:13987
#: ../../../LangRef.rst:14023 ../../../LangRef.rst:14081
#: ../../../LangRef.rst:14117 ../../../LangRef.rst:14153
#: ../../../LangRef.rst:14249 ../../../LangRef.rst:14289
#: ../../../LangRef.rst:14343 ../../../LangRef.rst:14385
#: ../../../LangRef.rst:14424 ../../../LangRef.rst:14472
#: ../../../LangRef.rst:14502 ../../../LangRef.rst:14527
#: ../../../LangRef.rst:14556 ../../../LangRef.rst:14586
#: ../../../LangRef.rst:14631 ../../../LangRef.rst:14659
#: ../../../LangRef.rst:14686 ../../../LangRef.rst:14732
#: ../../../LangRef.rst:14778 ../../../LangRef.rst:14814
#: ../../../LangRef.rst:14843 ../../../LangRef.rst:14892
#: ../../../LangRef.rst:14927 ../../../LangRef.rst:14953
#: ../../../LangRef.rst:14983 ../../../LangRef.rst:15009
#: ../../../LangRef.rst:15059 ../../../LangRef.rst:15113
#: ../../../LangRef.rst:15146 ../../../LangRef.rst:15193
#: ../../../LangRef.rst:15220 ../../../LangRef.rst:15266
#: ../../../LangRef.rst:15305 ../../../LangRef.rst:15353
#: ../../../LangRef.rst:15379 ../../../LangRef.rst:15408
#: ../../../LangRef.rst:15454 ../../../LangRef.rst:15493
#: ../../../LangRef.rst:15575 ../../../LangRef.rst:15809
#: ../../../LangRef.rst:15869 ../../../LangRef.rst:15927
#: ../../../LangRef.rst:15986 ../../../LangRef.rst:16044
#: ../../../LangRef.rst:16103 ../../../LangRef.rst:16149
#: ../../../LangRef.rst:16194 ../../../LangRef.rst:16230
#: ../../../LangRef.rst:16269 ../../../LangRef.rst:16306
#: ../../../LangRef.rst:16343 ../../../LangRef.rst:16380
#: ../../../LangRef.rst:16417 ../../../LangRef.rst:16455
#: ../../../LangRef.rst:16492 ../../../LangRef.rst:16529
#: ../../../LangRef.rst:16566 ../../../LangRef.rst:16607
#: ../../../LangRef.rst:16650 ../../../LangRef.rst:16696
#: ../../../LangRef.rst:16753 ../../../LangRef.rst:16793
#: ../../../LangRef.rst:16833 ../../../LangRef.rst:16873
#: ../../../LangRef.rst:16915 ../../../LangRef.rst:16959
#: ../../../LangRef.rst:17011 ../../../LangRef.rst:17051
#: ../../../LangRef.rst:17092 ../../../LangRef.rst:17131
#: ../../../LangRef.rst:17172 ../../../LangRef.rst:17304
#: ../../../LangRef.rst:17364 ../../../LangRef.rst:17424
#: ../../../LangRef.rst:17464 ../../../LangRef.rst:17504
#: ../../../LangRef.rst:17552 ../../../LangRef.rst:17600
#: ../../../LangRef.rst:17640 ../../../LangRef.rst:17677
#: ../../../LangRef.rst:17716 ../../../LangRef.rst:17755
#: ../../../LangRef.rst:17797 ../../../LangRef.rst:17839
#: ../../../LangRef.rst:17877 ../../../LangRef.rst:17922
#: ../../../LangRef.rst:17959 ../../../LangRef.rst:18006
#: ../../../LangRef.rst:18046 ../../../LangRef.rst:18085
#: ../../../LangRef.rst:18118 ../../../LangRef.rst:18165
#: ../../../LangRef.rst:18208 ../../../LangRef.rst:18254
#: ../../../LangRef.rst:18417 ../../../LangRef.rst:18468
#: ../../../LangRef.rst:18518 ../../../LangRef.rst:18569
#: ../../../LangRef.rst:18620 ../../../LangRef.rst:18671
#: ../../../LangRef.rst:18730 ../../../LangRef.rst:18780
#: ../../../LangRef.rst:18829 ../../../LangRef.rst:18879
#: ../../../LangRef.rst:18931 ../../../LangRef.rst:18983
#: ../../../LangRef.rst:19085 ../../../LangRef.rst:19145
#: ../../../LangRef.rst:19203 ../../../LangRef.rst:19273
#: ../../../LangRef.rst:19341 ../../../LangRef.rst:19401
#: ../../../LangRef.rst:19460 ../../../LangRef.rst:19527
#: ../../../LangRef.rst:19661 ../../../LangRef.rst:19725
#: ../../../LangRef.rst:19764 ../../../LangRef.rst:19800
#: ../../../LangRef.rst:19838 ../../../LangRef.rst:19876
#: ../../../LangRef.rst:19919 ../../../LangRef.rst:20598
#: ../../../LangRef.rst:20709 ../../../LangRef.rst:20769
#: ../../../LangRef.rst:20821 ../../../LangRef.rst:20861
#: ../../../LangRef.rst:20920 ../../../LangRef.rst:20984
#: ../../../LangRef.rst:21183 ../../../LangRef.rst:21224
#: ../../../LangRef.rst:21278 ../../../LangRef.rst:21330
#: ../../../LangRef.rst:21390 ../../../LangRef.rst:21493
#: ../../../LangRef.rst:21534 ../../../LangRef.rst:21626
#: ../../../LangRef.rst:21684 ../../../LangRef.rst:21740
#: ../../../LangRef.rst:21787 ../../../LangRef.rst:21836
#: ../../../LangRef.rst:21883 ../../../LangRef.rst:21931
#: ../../../LangRef.rst:21980 ../../../LangRef.rst:22029
#: ../../../LangRef.rst:22077 ../../../LangRef.rst:22127
#: ../../../LangRef.rst:22176 ../../../LangRef.rst:22224
#: ../../../LangRef.rst:22272 ../../../LangRef.rst:22320
#: ../../../LangRef.rst:22370 ../../../LangRef.rst:22418
#: ../../../LangRef.rst:22466 ../../../LangRef.rst:22514
#: ../../../LangRef.rst:22562 ../../../LangRef.rst:22610
#: ../../../LangRef.rst:22659 ../../../LangRef.rst:22708
#: ../../../LangRef.rst:22757 ../../../LangRef.rst:22807
#: ../../../LangRef.rst:22857 ../../../LangRef.rst:22906
#: ../../../LangRef.rst:22955 ../../../LangRef.rst:23004
#: ../../../LangRef.rst:23053 ../../../LangRef.rst:23102
#: ../../../LangRef.rst:23150 ../../../LangRef.rst:23198
#: ../../../LangRef.rst:23247 ../../../LangRef.rst:23298
#: ../../../LangRef.rst:23348 ../../../LangRef.rst:23405
#: ../../../LangRef.rst:23464 ../../../LangRef.rst:23521
#: ../../../LangRef.rst:23580 ../../../LangRef.rst:23637
#: ../../../LangRef.rst:23693 ../../../LangRef.rst:23750
#: ../../../LangRef.rst:23807 ../../../LangRef.rst:23864
#: ../../../LangRef.rst:23921 ../../../LangRef.rst:23979
#: ../../../LangRef.rst:24046 ../../../LangRef.rst:24113
#: ../../../LangRef.rst:24183 ../../../LangRef.rst:24250
#: ../../../LangRef.rst:24331 ../../../LangRef.rst:24395
#: ../../../LangRef.rst:24453 ../../../LangRef.rst:24506
#: ../../../LangRef.rst:24554 ../../../LangRef.rst:24594
#: ../../../LangRef.rst:24651 ../../../LangRef.rst:24737
#: ../../../LangRef.rst:24792 ../../../LangRef.rst:24853
#: ../../../LangRef.rst:24914 ../../../LangRef.rst:24971
#: ../../../LangRef.rst:25026 ../../../LangRef.rst:25079
#: ../../../LangRef.rst:25131 ../../../LangRef.rst:25185
#: ../../../LangRef.rst:25241 ../../../LangRef.rst:25298
#: ../../../LangRef.rst:25354 ../../../LangRef.rst:25410
#: ../../../LangRef.rst:25466 ../../../LangRef.rst:25520
#: ../../../LangRef.rst:25577 ../../../LangRef.rst:25637
#: ../../../LangRef.rst:25695 ../../../LangRef.rst:25744
#: ../../../LangRef.rst:25791 ../../../LangRef.rst:25838
#: ../../../LangRef.rst:25885 ../../../LangRef.rst:25932
#: ../../../LangRef.rst:25979 ../../../LangRef.rst:26026
#: ../../../LangRef.rst:26073 ../../../LangRef.rst:26119
#: ../../../LangRef.rst:26167 ../../../LangRef.rst:26214
#: ../../../LangRef.rst:26261 ../../../LangRef.rst:26310
#: ../../../LangRef.rst:26359 ../../../LangRef.rst:26416
#: ../../../LangRef.rst:26454 ../../../LangRef.rst:26503
#: ../../../LangRef.rst:26552 ../../../LangRef.rst:26601
#: ../../../LangRef.rst:26650 ../../../LangRef.rst:26696
#: ../../../LangRef.rst:26741 ../../../LangRef.rst:26789
#: ../../../LangRef.rst:26834 ../../../LangRef.rst:26884
#: ../../../LangRef.rst:26936 ../../../LangRef.rst:26995
#: ../../../LangRef.rst:27055 ../../../LangRef.rst:27118
#: ../../../LangRef.rst:27159 ../../../LangRef.rst:27194
#: ../../../LangRef.rst:27227 ../../../LangRef.rst:27261
#: ../../../LangRef.rst:27296 ../../../LangRef.rst:27442
#: ../../../LangRef.rst:27479 ../../../LangRef.rst:27516
#: ../../../LangRef.rst:27553 ../../../LangRef.rst:27592
#: ../../../LangRef.rst:27628 ../../../LangRef.rst:27662
#: ../../../LangRef.rst:27695 ../../../LangRef.rst:27730
#: ../../../LangRef.rst:27766 ../../../LangRef.rst:27803
#: ../../../LangRef.rst:27837 ../../../LangRef.rst:27912
#: ../../../LangRef.rst:27992 ../../../LangRef.rst:28065
#: ../../../LangRef.rst:28102 ../../../LangRef.rst:28142
#: ../../../LangRef.rst:28180 ../../../LangRef.rst:28218
#: ../../../LangRef.rst:28254 ../../../LangRef.rst:28290
#: ../../../LangRef.rst:28325 ../../../LangRef.rst:28361
#: ../../../LangRef.rst:28397 ../../../LangRef.rst:28433
#: ../../../LangRef.rst:28468 ../../../LangRef.rst:28504
#: ../../../LangRef.rst:28540 ../../../LangRef.rst:28575
#: ../../../LangRef.rst:28611 ../../../LangRef.rst:28647
#: ../../../LangRef.rst:28682 ../../../LangRef.rst:28717
#: ../../../LangRef.rst:28753 ../../../LangRef.rst:28796
#: ../../../LangRef.rst:28844 ../../../LangRef.rst:28889
#: ../../../LangRef.rst:28925 ../../../LangRef.rst:28957
#: ../../../LangRef.rst:28989 ../../../LangRef.rst:29021
#: ../../../LangRef.rst:29053 ../../../LangRef.rst:29086
#: ../../../LangRef.rst:29119 ../../../LangRef.rst:29154
#: ../../../LangRef.rst:29194 ../../../LangRef.rst:29233
#: ../../../LangRef.rst:29267 ../../../LangRef.rst:29302
#: ../../../LangRef.rst:29374 ../../../LangRef.rst:29415
#: ../../../LangRef.rst:29441 ../../../LangRef.rst:29470
#: ../../../LangRef.rst:29493 ../../../LangRef.rst:29526
#: ../../../LangRef.rst:29559 ../../../LangRef.rst:29589
#: ../../../LangRef.rst:29663 ../../../LangRef.rst:29709
#: ../../../LangRef.rst:29746 ../../../LangRef.rst:29786
#: ../../../LangRef.rst:29839 ../../../LangRef.rst:29868
#: ../../../LangRef.rst:29897 ../../../LangRef.rst:29931
#: ../../../LangRef.rst:29966 ../../../LangRef.rst:30019
#: ../../../LangRef.rst:30053 ../../../LangRef.rst:30087
#: ../../../LangRef.rst:30120 ../../../LangRef.rst:30296
#: ../../../LangRef.rst:30328 ../../../LangRef.rst:30365
#: ../../../LangRef.rst:30497 ../../../LangRef.rst:30626
#: ../../../LangRef.rst:30685 ../../../LangRef.rst:30766
#: ../../../LangRef.rst:30793 ../../../LangRef.rst:30841
#: ../../../LangRef.rst:30881 ../../../LangRef.rst:30907
#: ../../../LangRef.rst:30944 ../../../LangRef.rst:31012
#: ../../../LangRef.rst:31089 ../../../LangRef.rst:31167
#: ../../../LangRef.rst:31498 ../../../LangRef.rst:31530
#: ../../../LangRef.rst:31567
msgid "Semantics:"
msgstr ""

#: ../../../LangRef.rst:9484
msgid ""
"When the '``ret``' instruction is executed, control flow returns back to the "
"calling function's context. If the caller is a \":ref:`call <i_call>`\" "
"instruction, execution continues at the instruction after the call. If the "
"caller was an \":ref:`invoke <i_invoke>`\" instruction, execution continues "
"at the beginning of the \"normal\" destination block. If the instruction "
"returns a value, that value shall set the call or invoke instruction's "
"return value."
msgstr ""

#: ../../../LangRef.rst:9505
msgid "'``br``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9518
msgid ""
"The '``br``' instruction is used to cause control flow to transfer to a "
"different basic block in the current function. There are two forms of this "
"instruction, corresponding to a conditional branch and an unconditional "
"branch."
msgstr ""

#: ../../../LangRef.rst:9526
msgid ""
"The conditional branch form of the '``br``' instruction takes a single "
"'``i1``' value and two '``label``' values. The unconditional form of the "
"'``br``' instruction takes a single '``label``' value as a target."
msgstr ""

#: ../../../LangRef.rst:9533
msgid ""
"Upon execution of a conditional '``br``' instruction, the '``i1``' argument "
"is evaluated. If the value is ``true``, control flows to the '``iftrue``' "
"``label`` argument. If \"cond\" is ``false``, control flows to the "
"'``iffalse``' ``label`` argument. If '``cond``' is ``poison`` or ``undef``, "
"this instruction has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:9556
msgid "'``switch``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9568
msgid ""
"The '``switch``' instruction is used to transfer control flow to one of "
"several different places. It is a generalization of the '``br``' "
"instruction, allowing a branch to occur to one of many possible destinations."
msgstr ""

#: ../../../LangRef.rst:9576
msgid ""
"The '``switch``' instruction uses three parameters: an integer comparison "
"value '``value``', a default '``label``' destination, and an array of pairs "
"of comparison value constants and '``label``'s. The table is not allowed to "
"contain duplicate constant entries."
msgstr ""

#: ../../../LangRef.rst:9584
msgid ""
"The ``switch`` instruction specifies a table of values and destinations. "
"When the '``switch``' instruction is executed, this table is searched for "
"the given value. If the value is found, control flow is transferred to the "
"corresponding destination; otherwise, control flow is transferred to the "
"default destination. If '``value``' is ``poison`` or ``undef``, this "
"instruction has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:9593 ../../../LangRef.rst:9659
msgid "Implementation:"
msgstr ""

#: ../../../LangRef.rst:9595
msgid ""
"Depending on properties of the target machine and the particular ``switch`` "
"instruction, this instruction may be code generated in different ways. For "
"example, it could be generated as a series of chained conditional branches "
"or with a lookup table."
msgstr ""

#: ../../../LangRef.rst:9620
msgid "'``indirectbr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9632
msgid ""
"The '``indirectbr``' instruction implements an indirect branch to a label "
"within the current function, whose address is specified by \"``address``\". "
"Address must be derived from a :ref:`blockaddress <blockaddress>` constant."
msgstr ""

#: ../../../LangRef.rst:9640
msgid ""
"The '``address``' argument is the address of the label to jump to. The rest "
"of the arguments indicate the full set of possible destinations that the "
"address may point to. Blocks are allowed to occur multiple times in the "
"destination list, though this isn't particularly useful."
msgstr ""

#: ../../../LangRef.rst:9645
msgid ""
"This destination list is required so that dataflow analysis has an accurate "
"understanding of the CFG."
msgstr ""

#: ../../../LangRef.rst:9651
msgid ""
"Control transfers to the block specified in the address argument. All "
"possible destination blocks must be listed in the label list, otherwise this "
"instruction has undefined behavior. This implies that jumps to labels "
"defined in other functions have undefined behavior as well. If '``address``' "
"is ``poison`` or ``undef``, this instruction has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:9661
msgid "This is typically implemented with a jump through a register."
msgstr ""

#: ../../../LangRef.rst:9673
msgid "'``invoke``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9686
msgid ""
"The '``invoke``' instruction causes control to transfer to a specified "
"function, with the possibility of control flow transfer to either the "
"'``normal``' label or the '``exception``' label. If the callee function "
"returns with the \"``ret``\" instruction, control flow will return to the "
"\"normal\" label. If the callee (or any indirect callees) returns via the \":"
"ref:`resume <i_resume>`\" instruction or other exception handling mechanism, "
"control is interrupted and continued at the dynamically nearest "
"\"exception\" label."
msgstr ""

#: ../../../LangRef.rst:9695
msgid ""
"The '``exception``' label is a `landing pad <ExceptionHandling."
"html#overview>`_ for the exception. As such, '``exception``' label is "
"required to have the \":ref:`landingpad <i_landingpad>`\" instruction, which "
"contains the information about the behavior of the program after unwinding "
"happens, as its first non-PHI instruction. The restrictions on the "
"\"``landingpad``\" instruction's tightly couples it to the \"``invoke``\" "
"instruction, so that the important information contained within the "
"\"``landingpad``\" instruction can't be lost through normal code motion."
msgstr ""

#: ../../../LangRef.rst:9708 ../../../LangRef.rst:9813
#: ../../../LangRef.rst:13323
msgid "This instruction requires several arguments:"
msgstr ""

#: ../../../LangRef.rst:9710 ../../../LangRef.rst:9815
msgid ""
"The optional \"cconv\" marker indicates which :ref:`calling convention "
"<callingconv>` the call should use. If none is specified, the call defaults "
"to using C calling conventions."
msgstr ""

#: ../../../LangRef.rst:9713 ../../../LangRef.rst:9818
#: ../../../LangRef.rst:13452
msgid ""
"The optional :ref:`Parameter Attributes <paramattrs>` list for return "
"values. Only '``zeroext``', '``signext``', '``noext``', and '``inreg``' "
"attributes are valid here."
msgstr ""

#: ../../../LangRef.rst:9716 ../../../LangRef.rst:9821
#: ../../../LangRef.rst:13455
msgid ""
"The optional addrspace attribute can be used to indicate the address space "
"of the called function. If it is not specified, the program address space "
"from the :ref:`datalayout string<langref_datalayout>` will be used."
msgstr ""

#: ../../../LangRef.rst:9719 ../../../LangRef.rst:13458
msgid ""
"'``ty``': the type of the call instruction itself which is also the type of "
"the return value. Functions that return no value are marked ``void``. The "
"signature is computed based on the return type and argument types."
msgstr ""

#: ../../../LangRef.rst:9723
msgid ""
"'``fnty``': shall be the signature of the function being invoked. The "
"argument types must match the types implied by this signature. This is only "
"required if the signature specifies a varargs type."
msgstr ""

#: ../../../LangRef.rst:9726
msgid ""
"'``fnptrval``': An LLVM value containing a pointer to a function to be "
"invoked. In most cases, this is a direct function invocation, but indirect "
"``invoke``'s are just as possible, calling an arbitrary pointer to function "
"value."
msgstr ""

#: ../../../LangRef.rst:9730 ../../../LangRef.rst:9835
#: ../../../LangRef.rst:13469
msgid ""
"'``function args``': argument list whose types match the function signature "
"argument types and parameter attributes. All arguments must be of :ref:"
"`first class <t_firstclass>` type. If the function signature indicates the "
"function accepts a variable number of arguments, the extra arguments can be "
"specified."
msgstr ""

#: ../../../LangRef.rst:9735
msgid ""
"'``normal label``': the label reached when the called function executes a "
"'``ret``' instruction."
msgstr ""

#: ../../../LangRef.rst:9737
msgid ""
"'``exception label``': the label reached when a callee returns via the :ref:"
"`resume <i_resume>` instruction or other exception handling mechanism."
msgstr ""

#: ../../../LangRef.rst:9740 ../../../LangRef.rst:9845
#: ../../../LangRef.rst:13474
msgid "The optional :ref:`function attributes <fnattrs>` list."
msgstr ""

#: ../../../LangRef.rst:9741 ../../../LangRef.rst:9846
#: ../../../LangRef.rst:13475
msgid "The optional :ref:`operand bundles <opbundles>` list."
msgstr ""

#: ../../../LangRef.rst:9746
msgid ""
"This instruction is designed to operate as a standard '``call``' instruction "
"in most regards. The primary difference is that it establishes an "
"association with a label, which is used by the runtime library to unwind the "
"stack."
msgstr ""

#: ../../../LangRef.rst:9751
msgid ""
"This instruction is used in languages with destructors to ensure that proper "
"cleanup is performed in the case of either a ``longjmp`` or a thrown "
"exception. Additionally, this is important for implementation of '``catch``' "
"clauses in high-level languages that support them."
msgstr ""

#: ../../../LangRef.rst:9756
msgid ""
"For the purposes of the SSA form, the definition of the value returned by "
"the '``invoke``' instruction is deemed to occur on the edge from the current "
"block to the \"normal\" label. If the callee unwinds then no return value is "
"available."
msgstr ""

#: ../../../LangRef.rst:9774
msgid "'``callbr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9787
msgid ""
"The '``callbr``' instruction causes control to transfer to a specified "
"function, with the possibility of control flow transfer to either the "
"'``fallthrough``' label or one of the '``indirect``' labels."
msgstr ""

#: ../../../LangRef.rst:9791
msgid ""
"This instruction should only be used to implement the \"goto\" feature of "
"gcc style inline assembly. Any other usage is an error in the IR verifier."
msgstr ""

#: ../../../LangRef.rst:9794
msgid ""
"Note that in order to support outputs along indirect edges, LLVM may need to "
"split critical edges, which may require synthesizing a replacement block for "
"the ``indirect labels``. Therefore, the address of a label as seen by "
"another ``callbr`` instruction, or for a :ref:`blockaddress <blockaddress>` "
"constant, may not be equal to the address provided for the same block to "
"this instruction's ``indirect labels`` operand. The assembly code may only "
"transfer control to addresses provided via this instruction's ``indirect "
"labels``."
msgstr ""

#: ../../../LangRef.rst:9802
msgid ""
"On target architectures that implement branch target enforcement by "
"requiring indirect (register-controlled) branch instructions to jump only to "
"locations marked by a special instruction (such as AArch64 ``bti``), the "
"called code is expected not to use such an indirect branch to transfer "
"control to the locations in ``indirect labels``. Therefore, including a "
"label in the ``indirect labels`` of a ``callbr`` does not require the "
"compiler to put a ``bti`` or equivalent instruction at the label."
msgstr ""

#: ../../../LangRef.rst:9824
msgid ""
"'``ty``': the type of the call instruction itself which is also the type of "
"the return value. Functions that return no value are marked ``void``.  The "
"signature is computed based on the return type and argument types."
msgstr ""

#: ../../../LangRef.rst:9828 ../../../LangRef.rst:13462
msgid ""
"'``fnty``': shall be the signature of the function being called. The "
"argument types must match the types implied by this signature. This is only "
"required if the signature specifies a varargs type."
msgstr ""

#: ../../../LangRef.rst:9831
msgid ""
"'``fnptrval``': An LLVM value containing a pointer to a function to be "
"called. In most cases, this is a direct function call, but other "
"``callbr``'s are just as possible, calling an arbitrary pointer to function "
"value."
msgstr ""

#: ../../../LangRef.rst:9840
msgid ""
"'``fallthrough label``': the label reached when the inline assembly's "
"execution exits the bottom."
msgstr ""

#: ../../../LangRef.rst:9842
msgid ""
"'``indirect labels``': the labels reached when a callee transfers control to "
"a location other than the '``fallthrough label``'. Label constraints refer "
"to these destinations."
msgstr ""

#: ../../../LangRef.rst:9851
msgid ""
"This instruction is designed to operate as a standard '``call``' instruction "
"in most regards. The primary difference is that it establishes an "
"association with additional labels to define where control flow goes after "
"the call."
msgstr ""

#: ../../../LangRef.rst:9856
msgid ""
"The output values of a '``callbr``' instruction are available both in the "
"the '``fallthrough``' block, and any '``indirect``' blocks(s)."
msgstr ""

#: ../../../LangRef.rst:9859
msgid ""
"The only use of this today is to implement the \"goto\" feature of gcc "
"inline assembly where additional labels can be provided as locations for the "
"inline assembly to jump to."
msgstr ""

#: ../../../LangRef.rst:9879
msgid "'``resume``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9891
msgid ""
"The '``resume``' instruction is a terminator instruction that has no "
"successors."
msgstr ""

#: ../../../LangRef.rst:9897
msgid ""
"The '``resume``' instruction requires one argument, which must have the same "
"type as the result of any '``landingpad``' instruction in the same function."
msgstr ""

#: ../../../LangRef.rst:9904
msgid ""
"The '``resume``' instruction resumes propagation of an existing (in-flight) "
"exception whose unwinding was interrupted with a :ref:`landingpad "
"<i_landingpad>` instruction."
msgstr ""

#: ../../../LangRef.rst:9918
msgid "'``catchswitch``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9931
msgid ""
"The '``catchswitch``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to describe the set of possible "
"catch handlers that may be executed by the :ref:`EH personality routine "
"<personalityfn>`."
msgstr ""

#: ../../../LangRef.rst:9938
msgid ""
"The ``parent`` argument is the token of the funclet that contains the "
"``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet, "
"this operand may be the token ``none``."
msgstr ""

#: ../../../LangRef.rst:9942
msgid ""
"The ``default`` argument is the label of another basic block beginning with "
"either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind "
"destination must be a legal target with respect to the ``parent`` links, as "
"described in the `exception handling documentation\\ <ExceptionHandling."
"html#wineh-constraints>`_."
msgstr ""

#: ../../../LangRef.rst:9947
msgid ""
"The ``handlers`` are a nonempty list of successor blocks that each begin "
"with a :ref:`catchpad <i_catchpad>` instruction."
msgstr ""

#: ../../../LangRef.rst:9953
msgid ""
"Executing this instruction transfers control to one of the successors in "
"``handlers``, if appropriate, or continues to unwind via the unwind label if "
"present."
msgstr ""

#: ../../../LangRef.rst:9957
msgid ""
"The ``catchswitch`` is both a terminator and a \"pad\" instruction, meaning "
"that it must be both the first non-phi instruction and last instruction in "
"the basic block. Therefore, it must be the only non-phi instruction in the "
"block."
msgstr ""

#: ../../../LangRef.rst:9974
msgid "'``catchret``' Instruction"
msgstr ""

#: ../../../LangRef.rst:9986
msgid ""
"The '``catchret``' instruction is a terminator instruction that has a single "
"successor."
msgstr ""

#: ../../../LangRef.rst:9993
msgid ""
"The first argument to a '``catchret``' indicates which ``catchpad`` it "
"exits.  It must be a :ref:`catchpad <i_catchpad>`. The second argument to a "
"'``catchret``' specifies where control will transfer to next."
msgstr ""

#: ../../../LangRef.rst:10001
msgid ""
"The '``catchret``' instruction ends an existing (in-flight) exception whose "
"unwinding was interrupted with a :ref:`catchpad <i_catchpad>` instruction.  "
"The :ref:`personality function <personalityfn>` gets a chance to execute "
"arbitrary code to, for example, destroy the active exception.  Control then "
"transfers to ``normal``."
msgstr ""

#: ../../../LangRef.rst:10007
msgid ""
"The ``token`` argument must be a token produced by a ``catchpad`` "
"instruction. If the specified ``catchpad`` is not the most-recently-entered "
"not-yet-exited funclet pad (as described in the `EH documentation\\ "
"<ExceptionHandling.html#wineh-constraints>`_), the ``catchret``'s behavior "
"is undefined."
msgstr ""

#: ../../../LangRef.rst:10022
msgid "'``cleanupret``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10035
msgid ""
"The '``cleanupret``' instruction is a terminator instruction that has an "
"optional successor."
msgstr ""

#: ../../../LangRef.rst:10042
msgid ""
"The '``cleanupret``' instruction requires one argument, which indicates "
"which ``cleanuppad`` it exits, and must be a :ref:`cleanuppad "
"<i_cleanuppad>`. If the specified ``cleanuppad`` is not the most-recently-"
"entered not-yet-exited funclet pad (as described in the `EH documentation\\ "
"<ExceptionHandling.html#wineh-constraints>`_), the ``cleanupret``'s behavior "
"is undefined."
msgstr ""

#: ../../../LangRef.rst:10048
msgid ""
"The '``cleanupret``' instruction also has an optional successor, "
"``continue``, which must be the label of another basic block beginning with "
"either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind "
"destination must be a legal target with respect to the ``parent`` links, as "
"described in the `exception handling documentation\\ <ExceptionHandling."
"html#wineh-constraints>`_."
msgstr ""

#: ../../../LangRef.rst:10057
msgid ""
"The '``cleanupret``' instruction indicates to the :ref:`personality function "
"<personalityfn>` that one :ref:`cleanuppad <i_cleanuppad>` it transferred "
"control to has ended. It transfers control to ``continue`` or unwinds out of "
"the function."
msgstr ""

#: ../../../LangRef.rst:10073
msgid "'``unreachable``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10085
msgid ""
"The '``unreachable``' instruction has no defined semantics. This instruction "
"is used to inform the optimizer that a particular portion of the code is not "
"reachable. This can be used to indicate that the code after a no-return "
"function cannot be reached, and other facts."
msgstr ""

#: ../../../LangRef.rst:10093
msgid "The '``unreachable``' instruction has no defined semantics."
msgstr ""

#: ../../../LangRef.rst:10098
msgid "Unary Operations"
msgstr ""

#: ../../../LangRef.rst:10100
msgid ""
"Unary operators require a single operand, execute an operation on it, and "
"produce a single value. The operand might represent multiple data, as is the "
"case with the :ref:`vector <t_vector>` data type. The result value has the "
"same type as its operand."
msgstr ""

#: ../../../LangRef.rst:10108
msgid "'``fneg``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10120
msgid "The '``fneg``' instruction returns the negation of its operand."
msgstr ""

#: ../../../LangRef.rst:10125
msgid ""
"The argument to the '``fneg``' instruction must be a :ref:`floating-point "
"<t_floating>` or :ref:`vector <t_vector>` of floating-point values."
msgstr ""

#: ../../../LangRef.rst:10132
msgid ""
"The value produced is a copy of the operand with its sign bit flipped. The "
"value is otherwise completely identical; in particular, if the input is a "
"NaN, then the quiet/signaling bit and payload are perfectly preserved."
msgstr ""

#: ../../../LangRef.rst:10136
msgid ""
"This instruction can also take any number of :ref:`fast-math flags "
"<fastmath>`, which are optimization hints to enable otherwise unsafe "
"floating-point optimizations:"
msgstr ""

#: ../../../LangRef.rst:10150
msgid "Binary Operations"
msgstr ""

#: ../../../LangRef.rst:10152
msgid ""
"Binary operators are used to do most of the computation in a program. They "
"require two operands of the same type, execute an operation on them, and "
"produce a single value. The operands might represent multiple data, as is "
"the case with the :ref:`vector <t_vector>` data type. The result value has "
"the same type as its operands."
msgstr ""

#: ../../../LangRef.rst:10158
msgid "There are several different binary operators:"
msgstr ""

#: ../../../LangRef.rst:10163
msgid "'``add``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10178
msgid "The '``add``' instruction returns the sum of its two operands."
msgstr ""

#: ../../../LangRef.rst:10183
msgid ""
"The two arguments to the '``add``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10190
msgid "The value produced is the integer sum of the two operands."
msgstr ""

#: ../../../LangRef.rst:10192
msgid ""
"If the sum has unsigned overflow, the result returned is the mathematical "
"result modulo 2\\ :sup:`n`\\ , where n is the bit width of the result."
msgstr ""

#: ../../../LangRef.rst:10196 ../../../LangRef.rst:10291
msgid ""
"Because LLVM integers use a two's complement representation, this "
"instruction is appropriate for both signed and unsigned integers."
msgstr ""

#: ../../../LangRef.rst:10199
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", "
"respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result "
"value of the ``add`` is a :ref:`poison value <poisonvalues>` if unsigned and/"
"or signed overflow, respectively, occurs."
msgstr ""

#: ../../../LangRef.rst:10214
msgid "'``fadd``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10226
msgid "The '``fadd``' instruction returns the sum of its two operands."
msgstr ""

#: ../../../LangRef.rst:10231
msgid ""
"The two arguments to the '``fadd``' instruction must be :ref:`floating-point "
"<t_floating>` or :ref:`vector <t_vector>` of floating-point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:10238
msgid ""
"The value produced is the floating-point sum of the two operands. This "
"instruction is assumed to execute in the default :ref:`floating-point "
"environment <floatenv>`. This instruction can also take any number of :ref:"
"`fast-math flags <fastmath>`, which are optimization hints to enable "
"otherwise unsafe floating-point optimizations:"
msgstr ""

#: ../../../LangRef.rst:10255
msgid "'``sub``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10270
msgid "The '``sub``' instruction returns the difference of its two operands."
msgstr ""

#: ../../../LangRef.rst:10272
msgid ""
"Note that the '``sub``' instruction is used to represent the '``neg``' "
"instruction present in most other intermediate representations."
msgstr ""

#: ../../../LangRef.rst:10278
msgid ""
"The two arguments to the '``sub``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10285
msgid "The value produced is the integer difference of the two operands."
msgstr ""

#: ../../../LangRef.rst:10287
msgid ""
"If the difference has unsigned overflow, the result returned is the "
"mathematical result modulo 2\\ :sup:`n`\\ , where n is the bit width of the "
"result."
msgstr ""

#: ../../../LangRef.rst:10294
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", "
"respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result "
"value of the ``sub`` is a :ref:`poison value <poisonvalues>` if unsigned and/"
"or signed overflow, respectively, occurs."
msgstr ""

#: ../../../LangRef.rst:10310
msgid "'``fsub``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10322
msgid "The '``fsub``' instruction returns the difference of its two operands."
msgstr ""

#: ../../../LangRef.rst:10327
msgid ""
"The two arguments to the '``fsub``' instruction must be :ref:`floating-point "
"<t_floating>` or :ref:`vector <t_vector>` of floating-point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:10334
msgid ""
"The value produced is the floating-point difference of the two operands. "
"This instruction is assumed to execute in the default :ref:`floating-point "
"environment <floatenv>`. This instruction can also take any number of :ref:"
"`fast-math flags <fastmath>`, which are optimization hints to enable "
"otherwise unsafe floating-point optimizations:"
msgstr ""

#: ../../../LangRef.rst:10352
msgid "'``mul``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10367
msgid "The '``mul``' instruction returns the product of its two operands."
msgstr ""

#: ../../../LangRef.rst:10372
msgid ""
"The two arguments to the '``mul``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10379
msgid "The value produced is the integer product of the two operands."
msgstr ""

#: ../../../LangRef.rst:10381
msgid ""
"If the result of the multiplication has unsigned overflow, the result "
"returned is the mathematical result modulo 2\\ :sup:`n`\\ , where n is the "
"bit width of the result."
msgstr ""

#: ../../../LangRef.rst:10385
msgid ""
"Because LLVM integers use a two's complement representation, and the result "
"is the same width as the operands, this instruction returns the correct "
"result for both signed and unsigned integers. If a full product (e.g. "
"``i32`` * ``i32`` -> ``i64``) is needed, the operands should be sign-"
"extended or zero-extended as appropriate to the width of the full product."
msgstr ""

#: ../../../LangRef.rst:10392
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", "
"respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result "
"value of the ``mul`` is a :ref:`poison value <poisonvalues>` if unsigned and/"
"or signed overflow, respectively, occurs."
msgstr ""

#: ../../../LangRef.rst:10407
msgid "'``fmul``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10419
msgid "The '``fmul``' instruction returns the product of its two operands."
msgstr ""

#: ../../../LangRef.rst:10424
msgid ""
"The two arguments to the '``fmul``' instruction must be :ref:`floating-point "
"<t_floating>` or :ref:`vector <t_vector>` of floating-point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:10431
msgid ""
"The value produced is the floating-point product of the two operands. This "
"instruction is assumed to execute in the default :ref:`floating-point "
"environment <floatenv>`. This instruction can also take any number of :ref:"
"`fast-math flags <fastmath>`, which are optimization hints to enable "
"otherwise unsafe floating-point optimizations:"
msgstr ""

#: ../../../LangRef.rst:10448
msgid "'``udiv``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10461
msgid "The '``udiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../../LangRef.rst:10466
msgid ""
"The two arguments to the '``udiv``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10473
msgid ""
"The value produced is the unsigned integer quotient of the two operands."
msgstr ""

#: ../../../LangRef.rst:10475
msgid ""
"Note that unsigned integer division and signed integer division are distinct "
"operations; for signed integer division, use '``sdiv``'."
msgstr ""

#: ../../../LangRef.rst:10478
msgid ""
"Division by zero is undefined behavior. For vectors, if any element of the "
"divisor is zero, the operation has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:10482
msgid ""
"If the ``exact`` keyword is present, the result value of the ``udiv`` is a :"
"ref:`poison value <poisonvalues>` if %op1 is not a multiple of %op2 (as "
"such, \"((a udiv exact b) mul b) == a\")."
msgstr ""

#: ../../../LangRef.rst:10496
msgid "'``sdiv``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10509
msgid "The '``sdiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../../LangRef.rst:10514
msgid ""
"The two arguments to the '``sdiv``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10521
msgid ""
"The value produced is the signed integer quotient of the two operands "
"rounded towards zero."
msgstr ""

#: ../../../LangRef.rst:10524
msgid ""
"Note that signed integer division and unsigned integer division are distinct "
"operations; for unsigned integer division, use '``udiv``'."
msgstr ""

#: ../../../LangRef.rst:10527
msgid ""
"Division by zero is undefined behavior. For vectors, if any element of the "
"divisor is zero, the operation has undefined behavior. Overflow also leads "
"to undefined behavior; this is a rare case, but can occur, for example, by "
"doing a 32-bit division of -2147483648 by -1."
msgstr ""

#: ../../../LangRef.rst:10532
msgid ""
"If the ``exact`` keyword is present, the result value of the ``sdiv`` is a :"
"ref:`poison value <poisonvalues>` if the result would be rounded."
msgstr ""

#: ../../../LangRef.rst:10545
msgid "'``fdiv``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10557
msgid "The '``fdiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../../LangRef.rst:10562
msgid ""
"The two arguments to the '``fdiv``' instruction must be :ref:`floating-point "
"<t_floating>` or :ref:`vector <t_vector>` of floating-point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:10569
msgid ""
"The value produced is the floating-point quotient of the two operands. This "
"instruction is assumed to execute in the default :ref:`floating-point "
"environment <floatenv>`. This instruction can also take any number of :ref:"
"`fast-math flags <fastmath>`, which are optimization hints to enable "
"otherwise unsafe floating-point optimizations:"
msgstr ""

#: ../../../LangRef.rst:10586
msgid "'``urem``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10598
msgid ""
"The '``urem``' instruction returns the remainder from the unsigned division "
"of its two arguments."
msgstr ""

#: ../../../LangRef.rst:10604
msgid ""
"The two arguments to the '``urem``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10611
msgid ""
"This instruction returns the unsigned integer *remainder* of a division. "
"This instruction always performs an unsigned division to get the remainder."
msgstr ""

#: ../../../LangRef.rst:10615
msgid ""
"Note that unsigned integer remainder and signed integer remainder are "
"distinct operations; for signed integer remainder, use '``srem``'."
msgstr ""

#: ../../../LangRef.rst:10618
msgid ""
"Taking the remainder of a division by zero is undefined behavior. For "
"vectors, if any element of the divisor is zero, the operation has undefined "
"behavior."
msgstr ""

#: ../../../LangRef.rst:10632
msgid "'``srem``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10644
msgid ""
"The '``srem``' instruction returns the remainder from the signed division of "
"its two operands. This instruction can also take :ref:`vector <t_vector>` "
"versions of the values in which case the elements must be integers."
msgstr ""

#: ../../../LangRef.rst:10652
msgid ""
"The two arguments to the '``srem``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10659
msgid ""
"This instruction returns the *remainder* of a division (where the result is "
"either zero or has the same sign as the dividend, ``op1``), not the *modulo* "
"operator (where the result is either zero or has the same sign as the "
"divisor, ``op2``) of a value. For more information about the difference, see "
"`The Math Forum <http://mathforum.org/dr.math/problems/anne.4.28.99.html>`_. "
"For a table of how this is implemented in various languages, please see "
"`Wikipedia: modulo operation <http://en.wikipedia.org/wiki/"
"Modulo_operation>`_."
msgstr ""

#: ../../../LangRef.rst:10669
msgid ""
"Note that signed integer remainder and unsigned integer remainder are "
"distinct operations; for unsigned integer remainder, use '``urem``'."
msgstr ""

#: ../../../LangRef.rst:10672
msgid ""
"Taking the remainder of a division by zero is undefined behavior. For "
"vectors, if any element of the divisor is zero, the operation has undefined "
"behavior. Overflow also leads to undefined behavior; this is a rare case, "
"but can occur, for example, by taking the remainder of a 32-bit division of "
"-2147483648 by -1. (The remainder doesn't actually overflow, but this rule "
"lets srem be implemented using instructions that return both the result of "
"the division and the remainder.)"
msgstr ""

#: ../../../LangRef.rst:10691
msgid "'``frem``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10703
msgid ""
"The '``frem``' instruction returns the remainder from the division of its "
"two operands."
msgstr ""

#: ../../../LangRef.rst:10708
msgid ""
"The instruction is implemented as a call to libm's '``fmod``' for some "
"targets, and using the instruction may thus require linking libm."
msgstr ""

#: ../../../LangRef.rst:10715
msgid ""
"The two arguments to the '``frem``' instruction must be :ref:`floating-point "
"<t_floating>` or :ref:`vector <t_vector>` of floating-point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:10722
msgid ""
"The value produced is the floating-point remainder of the two operands. This "
"is the same output as a libm '``fmod``' function, but without any "
"possibility of setting ``errno``. The remainder has the same sign as the "
"dividend. This instruction is assumed to execute in the default :ref:"
"`floating-point environment <floatenv>`. This instruction can also take any "
"number of :ref:`fast-math flags <fastmath>`, which are optimization hints to "
"enable otherwise unsafe floating-point optimizations:"
msgstr ""

#: ../../../LangRef.rst:10742
msgid "Bitwise Binary Operations"
msgstr ""

#: ../../../LangRef.rst:10744
msgid ""
"Bitwise binary operators are used to do various forms of bit-twiddling in a "
"program. They are generally very efficient instructions and can commonly be "
"strength reduced from other instructions. They require two operands of the "
"same type, execute an operation on them, and produce a single value. The "
"resulting value is the same type as its operands."
msgstr ""

#: ../../../LangRef.rst:10753
msgid "'``shl``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10768
msgid ""
"The '``shl``' instruction returns the first operand shifted to the left a "
"specified number of bits."
msgstr ""

#: ../../../LangRef.rst:10774
msgid ""
"Both arguments to the '``shl``' instruction must be the same :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is "
"treated as an unsigned value."
msgstr ""

#: ../../../LangRef.rst:10781
msgid ""
"The value produced is ``op1`` \\* 2\\ :sup:`op2` mod 2\\ :sup:`n`, where "
"``n`` is the width of the result. If ``op2`` is (statically or dynamically) "
"equal to or larger than the number of bits in ``op1``, this instruction "
"returns a :ref:`poison value <poisonvalues>`. If the arguments are vectors, "
"each vector element of ``op1`` is shifted by the corresponding shift amount "
"in ``op2``."
msgstr ""

#: ../../../LangRef.rst:10788
msgid ""
"If the ``nuw`` keyword is present, then the shift produces a poison value if "
"it shifts out any non-zero bits. If the ``nsw`` keyword is present, then the "
"shift produces a poison value if it shifts out any bits that disagree with "
"the resultant sign bit."
msgstr ""

#: ../../../LangRef.rst:10808
msgid "'``lshr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10821
msgid ""
"The '``lshr``' instruction (logical shift right) returns the first operand "
"shifted to the right a specified number of bits with zero fill."
msgstr ""

#: ../../../LangRef.rst:10827
msgid ""
"Both arguments to the '``lshr``' instruction must be the same :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is "
"treated as an unsigned value."
msgstr ""

#: ../../../LangRef.rst:10834
msgid ""
"This instruction always performs a logical shift right operation. The most "
"significant bits of the result will be filled with zero bits after the "
"shift. If ``op2`` is (statically or dynamically) equal to or larger than the "
"number of bits in ``op1``, this instruction returns a :ref:`poison value "
"<poisonvalues>`. If the arguments are vectors, each vector element of "
"``op1`` is shifted by the corresponding shift amount in ``op2``."
msgstr ""

#: ../../../LangRef.rst:10841
msgid ""
"If the ``exact`` keyword is present, the result value of the ``lshr`` is a "
"poison value if any of the bits shifted out are non-zero."
msgstr ""

#: ../../../LangRef.rst:10859
msgid "'``ashr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10872
msgid ""
"The '``ashr``' instruction (arithmetic shift right) returns the first "
"operand shifted to the right a specified number of bits with sign extension."
msgstr ""

#: ../../../LangRef.rst:10879
msgid ""
"Both arguments to the '``ashr``' instruction must be the same :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is "
"treated as an unsigned value."
msgstr ""

#: ../../../LangRef.rst:10886
msgid ""
"This instruction always performs an arithmetic shift right operation, The "
"most significant bits of the result will be filled with the sign bit of "
"``op1``. If ``op2`` is (statically or dynamically) equal to or larger than "
"the number of bits in ``op1``, this instruction returns a :ref:`poison value "
"<poisonvalues>`. If the arguments are vectors, each vector element of "
"``op1`` is shifted by the corresponding shift amount in ``op2``."
msgstr ""

#: ../../../LangRef.rst:10893
msgid ""
"If the ``exact`` keyword is present, the result value of the ``ashr`` is a "
"poison value if any of the bits shifted out are non-zero."
msgstr ""

#: ../../../LangRef.rst:10911
msgid "'``and``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10923
msgid ""
"The '``and``' instruction returns the bitwise logical and of its two "
"operands."
msgstr ""

#: ../../../LangRef.rst:10929
msgid ""
"The two arguments to the '``and``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10936
msgid "The truth table used for the '``and``' instruction is:"
msgstr ""

#: ../../../LangRef.rst:10939 ../../../LangRef.rst:10991
#: ../../../LangRef.rst:11049
msgid "In0"
msgstr ""

#: ../../../LangRef.rst:10939 ../../../LangRef.rst:10991
#: ../../../LangRef.rst:11049
msgid "In1"
msgstr ""

#: ../../../LangRef.rst:10939 ../../../LangRef.rst:10991
#: ../../../LangRef.rst:11049
msgid "Out"
msgstr ""

#: ../../../LangRef.rst:10941 ../../../LangRef.rst:10943
#: ../../../LangRef.rst:10945 ../../../LangRef.rst:10993
#: ../../../LangRef.rst:10995 ../../../LangRef.rst:10997
#: ../../../LangRef.rst:11051 ../../../LangRef.rst:11053
#: ../../../LangRef.rst:11055 ../../../LangRef.rst:11057
#: ../../../LangRef.rst:14229 ../../../LangRef.rst:29641
msgid "0"
msgstr ""

#: ../../../LangRef.rst:10962
msgid "'``or``' Instruction"
msgstr ""

#: ../../../LangRef.rst:10975
msgid ""
"The '``or``' instruction returns the bitwise logical inclusive or of its two "
"operands."
msgstr ""

#: ../../../LangRef.rst:10981
msgid ""
"The two arguments to the '``or``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:10988
msgid "The truth table used for the '``or``' instruction is:"
msgstr ""

#: ../../../LangRef.rst:11002
msgid ""
"``disjoint`` means that for each bit, that bit is zero in at least one of "
"the inputs. This allows the Or to be treated as an Add since no carry can "
"occur from any bit. If the disjoint keyword is present, the result value of "
"the ``or`` is a :ref:`poison value <poisonvalues>` if both inputs have a one "
"in the same bit position. For vectors, only the element containing the bit "
"is poison."
msgstr ""

#: ../../../LangRef.rst:11020
msgid "'``xor``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11032
msgid ""
"The '``xor``' instruction returns the bitwise logical exclusive or of its "
"two operands. The ``xor`` is used to implement the \"one's complement\" "
"operation, which is the \"~\" operator in C."
msgstr ""

#: ../../../LangRef.rst:11039
msgid ""
"The two arguments to the '``xor``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:11046
msgid "The truth table used for the '``xor``' instruction is:"
msgstr ""

#: ../../../LangRef.rst:11071
msgid "Vector Operations"
msgstr ""

#: ../../../LangRef.rst:11073
msgid ""
"LLVM supports several instructions to represent vector operations in a "
"target-independent manner. These instructions cover the element-access and "
"vector-specific operations needed to process vectors effectively. While LLVM "
"does directly support these vector operations, many sophisticated algorithms "
"will want to use target-specific intrinsics to take full advantage of a "
"specific target."
msgstr ""

#: ../../../LangRef.rst:11083
msgid "'``extractelement``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11096
msgid ""
"The '``extractelement``' instruction extracts a single scalar element from a "
"vector at a specified index."
msgstr ""

#: ../../../LangRef.rst:11102
msgid ""
"The first operand of an '``extractelement``' instruction is a value of :ref:"
"`vector <t_vector>` type. The second operand is an index indicating the "
"position from which to extract the element. The index may be a variable of "
"any integer type, and will be treated as an unsigned integer."
msgstr ""

#: ../../../LangRef.rst:11110
msgid ""
"The result is a scalar of the same type as the element type of ``val``. Its "
"value is the value at position ``idx`` of ``val``. If ``idx`` exceeds the "
"length of ``val`` for a fixed-length vector, the result is a :ref:`poison "
"value <poisonvalues>`. For a scalable vector, if the value of ``idx`` "
"exceeds the runtime length of the vector, the result is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:11127
msgid "'``insertelement``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11140
msgid ""
"The '``insertelement``' instruction inserts a scalar element into a vector "
"at a specified index."
msgstr ""

#: ../../../LangRef.rst:11146
msgid ""
"The first operand of an '``insertelement``' instruction is a value of :ref:"
"`vector <t_vector>` type. The second operand is a scalar value whose type "
"must equal the element type of the first operand. The third operand is an "
"index indicating the position at which to insert the value. The index may be "
"a variable of any integer type, and will be treated as an unsigned integer."
msgstr ""

#: ../../../LangRef.rst:11156
msgid ""
"The result is a vector of the same type as ``val``. Its element values are "
"those of ``val`` except at position ``idx``, where it gets the value "
"``elt``. If ``idx`` exceeds the length of ``val`` for a fixed-length vector, "
"the result is a :ref:`poison value <poisonvalues>`. For a scalable vector, "
"if the value of ``idx`` exceeds the runtime length of the vector, the result "
"is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:11173
msgid "'``shufflevector``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11186
msgid ""
"The '``shufflevector``' instruction constructs a permutation of elements "
"from two input vectors, returning a vector with the same element type as the "
"input and length that is the same as the shuffle mask."
msgstr ""

#: ../../../LangRef.rst:11193
msgid ""
"The first two operands of a '``shufflevector``' instruction are vectors with "
"the same type. The third argument is a shuffle mask vector constant whose "
"element type is ``i32``. The mask vector elements must be constant integers "
"or ``poison`` values. The result of the instruction is a vector whose length "
"is the same as the shuffle mask and whose element type is the same as the "
"element type of the first two operands."
msgstr ""

#: ../../../LangRef.rst:11203
msgid ""
"The elements of the two input vectors are numbered from left to right across "
"both of the vectors. For each element of the result vector, the shuffle mask "
"selects an element from one of the input vectors to copy to the result. Non-"
"negative elements in the mask represent an index into the concatenated pair "
"of input vectors."
msgstr ""

#: ../../../LangRef.rst:11209
msgid ""
"A ``poison`` element in the mask vector specifies that the resulting element "
"is ``poison``. For backwards-compatibility reasons, LLVM temporarily also "
"accepts ``undef`` mask elements, which will be interpreted the same way as "
"``poison`` elements. If the shuffle mask selects an ``undef`` element from "
"one of the input vectors, the resulting element is ``undef``."
msgstr ""

#: ../../../LangRef.rst:11216
msgid ""
"For scalable vectors, the only valid mask values at present are "
"``zeroinitializer``, ``undef`` and ``poison``, since we cannot write all "
"indices as literals for a vector with a length unknown at compile time."
msgstr ""

#: ../../../LangRef.rst:11235
msgid "Aggregate Operations"
msgstr ""

#: ../../../LangRef.rst:11237
msgid ""
"LLVM supports several instructions for working with :ref:`aggregate "
"<t_aggregate>` values."
msgstr ""

#: ../../../LangRef.rst:11243
msgid "'``extractvalue``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11255
msgid ""
"The '``extractvalue``' instruction extracts the value of a member field from "
"an :ref:`aggregate <t_aggregate>` value."
msgstr ""

#: ../../../LangRef.rst:11261
msgid ""
"The first operand of an '``extractvalue``' instruction is a value of :ref:"
"`struct <t_struct>` or :ref:`array <t_array>` type. The other operands are "
"constant indices to specify which value to extract in a similar manner as "
"indices in a '``getelementptr``' instruction."
msgstr ""

#: ../../../LangRef.rst:11266
msgid "The major differences to ``getelementptr`` indexing are:"
msgstr ""

#: ../../../LangRef.rst:11268
msgid ""
"Since the value being indexed is not a pointer, the first index is omitted "
"and assumed to be zero."
msgstr ""

#: ../../../LangRef.rst:11270
msgid "At least one index must be specified."
msgstr ""

#: ../../../LangRef.rst:11271
msgid "Not only struct indices but also array indices must be in bounds."
msgstr ""

#: ../../../LangRef.rst:11276
msgid ""
"The result is the value at the position in the aggregate specified by the "
"index operands."
msgstr ""

#: ../../../LangRef.rst:11289
msgid "'``insertvalue``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11301
msgid ""
"The '``insertvalue``' instruction inserts a value into a member field in an :"
"ref:`aggregate <t_aggregate>` value."
msgstr ""

#: ../../../LangRef.rst:11307
msgid ""
"The first operand of an '``insertvalue``' instruction is a value of :ref:"
"`struct <t_struct>` or :ref:`array <t_array>` type. The second operand is a "
"first-class value to insert. The following operands are constant indices "
"indicating the position at which to insert the value in a similar manner as "
"indices in a '``extractvalue``' instruction. The value to insert must have "
"the same type as the value identified by the indices."
msgstr ""

#: ../../../LangRef.rst:11318
msgid ""
"The result is an aggregate of the same type as ``val``. Its value is that of "
"``val`` except that the value at the position specified by the indices is "
"that of ``elt``."
msgstr ""

#: ../../../LangRef.rst:11334
msgid "Memory Access and Addressing Operations"
msgstr ""

#: ../../../LangRef.rst:11336
msgid ""
"A key design point of an SSA-based representation is how it represents "
"memory. In LLVM, no memory locations are in SSA form, which makes things "
"very simple. This section describes how to read, write, and allocate memory "
"in LLVM."
msgstr ""

#: ../../../LangRef.rst:11344
msgid "'``alloca``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11356
msgid ""
"The '``alloca``' instruction allocates memory on the stack frame of the "
"currently executing function, to be automatically released when this "
"function returns to its caller. If the address space is not explicitly "
"specified, the default address space 0 is used."
msgstr ""

#: ../../../LangRef.rst:11364
msgid ""
"The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements`` bytes "
"of memory on the runtime stack, returning a pointer of the appropriate type "
"to the program. If \"NumElements\" is specified, it is the number of "
"elements allocated, otherwise \"NumElements\" is defaulted to be one."
msgstr ""

#: ../../../LangRef.rst:11370
msgid ""
"If a constant alignment is specified, the value result of the allocation is "
"guaranteed to be aligned to at least that boundary. The alignment may not be "
"greater than ``1 << 32``."
msgstr ""

#: ../../../LangRef.rst:11374
msgid ""
"The alignment is only optional when parsing textual IR; for in-memory IR, it "
"is always present. If not specified, the target can choose to align the "
"allocation on any convenient boundary compatible with the type."
msgstr ""

#: ../../../LangRef.rst:11378
msgid "'``type``' may be any sized type."
msgstr ""

#: ../../../LangRef.rst:11380
msgid ""
"Structs containing scalable vectors cannot be used in allocas unless all "
"fields are the same scalable vector type (e.g. ``{<vscale x 2 x i32>, "
"<vscale x 2 x i32>}`` contains the same type while ``{<vscale x 2 x i32>, "
"<vscale x 2 x i64>}`` doesn't)."
msgstr ""

#: ../../../LangRef.rst:11388
msgid ""
"Memory is allocated; a pointer is returned. The allocated memory is "
"uninitialized, and loading from uninitialized memory produces an undefined "
"value. The operation itself is undefined if there is insufficient stack "
"space for the allocation.'``alloca``'d memory is automatically released when "
"the function returns. The '``alloca``' instruction is commonly used to "
"represent automatic variables that must have an address available. When the "
"function returns (either with the ``ret`` or ``resume`` instructions), the "
"memory is reclaimed. Allocating zero bytes is legal, but the returned "
"pointer may not be unique. The order in which memory is allocated (ie., "
"which way the stack grows) is not specified."
msgstr ""

#: ../../../LangRef.rst:11399
msgid ""
"Note that '``alloca``' outside of the alloca address space from the :ref:"
"`datalayout string<langref_datalayout>` is meaningful only if the target has "
"assigned it a semantics. For targets that specify a non-zero alloca address "
"space in the :ref:`datalayout string<langref_datalayout>`, the alloca "
"address space needs to be explicitly specified in the instruction if it is "
"to be used."
msgstr ""

#: ../../../LangRef.rst:11406
msgid ""
"If the returned pointer is used by :ref:`llvm.lifetime.start "
"<int_lifestart>`, the returned object is initially dead. See :ref:`llvm."
"lifetime.start <int_lifestart>` and :ref:`llvm.lifetime.end <int_lifeend>` "
"for the precise semantics of lifetime-manipulating intrinsics."
msgstr ""

#: ../../../LangRef.rst:11425
msgid "'``load``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11442
msgid "The '``load``' instruction is used to read from memory."
msgstr ""

#: ../../../LangRef.rst:11447
msgid ""
"The argument to the ``load`` instruction specifies the memory address from "
"which to load. The type specified must be a :ref:`first class "
"<t_firstclass>` type of known size (i.e., not containing an :ref:`opaque "
"structural type <t_opaque>`). If the ``load`` is marked as ``volatile``, "
"then the optimizer is not allowed to modify the number or order of execution "
"of this ``load`` with other :ref:`volatile operations <volatile>`."
msgstr ""

#: ../../../LangRef.rst:11454
msgid ""
"If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering "
"<ordering>` and optional ``syncscope(\"<target-scope>\")`` argument. The "
"``release`` and ``acq_rel`` orderings are not valid on ``load`` "
"instructions. Atomic loads produce :ref:`defined <memmodel>` results when "
"they may see multiple atomic stores. The type of the pointee must be an "
"integer, pointer, or floating-point type whose bit width is a power of two "
"greater than or equal to eight. ``align`` must be explicitly specified on "
"atomic loads. Note: if the alignment is not greater or equal to the size of "
"the `<value>` type, the atomic operation is likely to require a lock and "
"have poor performance. ``!nontemporal`` does not have any defined semantics "
"for atomic loads."
msgstr ""

#: ../../../LangRef.rst:11466
msgid ""
"The optional constant ``align`` argument specifies the alignment of the "
"operation (that is, the alignment of the memory address). It is the "
"responsibility of the code emitter to ensure that the alignment information "
"is correct. Overestimating the alignment results in undefined behavior. "
"Underestimating the alignment may produce less efficient code. An alignment "
"of 1 is always safe. The maximum possible alignment is ``1 << 32``. An "
"alignment value higher than the size of the loaded type does *not* imply "
"(without target specific knowledge) that memory up to the alignment value "
"bytes can be safely loaded without trapping."
msgstr ""

#: ../../../LangRef.rst:11476 ../../../LangRef.rst:11615
msgid ""
"The alignment is only optional when parsing textual IR; for in-memory IR, it "
"is always present. An omitted ``align`` argument means that the operation "
"has the ABI alignment for the target."
msgstr ""

#: ../../../LangRef.rst:11480 ../../../LangRef.rst:11619
msgid ""
"The optional ``!nontemporal`` metadata must reference a single metadata name "
"``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry "
"of value 1. The existence of the ``!nontemporal`` metadata on the "
"instruction tells the optimizer and code generator that this load is not "
"expected to be reused in the cache. The code generator may select special "
"instructions to save cache bandwidth, such as the ``MOVNT`` instruction on "
"x86."
msgstr ""

#: ../../../LangRef.rst:11488
msgid ""
"The optional ``!invariant.load`` metadata must reference a single metadata "
"name ``<empty_node>`` corresponding to a metadata node with no entries. If a "
"load instruction tagged with the ``!invariant.load`` metadata is executed, "
"the memory location referenced by the load has to contain the same value at "
"all points in the program where the memory location is dereferenceable; "
"otherwise, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:11498
msgid ""
"The optional ``!invariant.group`` metadata must reference a single metadata "
"name"
msgstr ""

#: ../../../LangRef.rst:11497
msgid ""
"``<empty_node>`` corresponding to a metadata node with no entries. See "
"``invariant.group`` metadata :ref:`invariant.group <md_invariant.group>`."
msgstr ""

#: ../../../LangRef.rst:11500
msgid ""
"The optional ``!nonnull`` metadata must reference a single metadata name "
"``<empty_node>`` corresponding to a metadata node with no entries. The "
"existence of the ``!nonnull`` metadata on the instruction tells the "
"optimizer that the value loaded is known to never be null. If the value is "
"null at runtime, a poison value is returned instead.  This is analogous to "
"the ``nonnull`` attribute on parameters and return values. This metadata can "
"only be applied to loads of a pointer type."
msgstr ""

#: ../../../LangRef.rst:11508
msgid ""
"The optional ``!dereferenceable`` metadata must reference a single metadata "
"name ``<deref_bytes_node>`` corresponding to a metadata node with one "
"``i64`` entry. See ``dereferenceable`` metadata :ref:`dereferenceable "
"<md_dereferenceable>`."
msgstr ""

#: ../../../LangRef.rst:11513
msgid ""
"The optional ``!dereferenceable_or_null`` metadata must reference a single "
"metadata name ``<deref_bytes_node>`` corresponding to a metadata node with "
"one ``i64`` entry. See ``dereferenceable_or_null`` metadata :ref:"
"`dereferenceable_or_null <md_dereferenceable_or_null>`."
msgstr ""

#: ../../../LangRef.rst:11519
msgid ""
"The optional ``!align`` metadata must reference a single metadata name "
"``<align_node>`` corresponding to a metadata node with one ``i64`` entry. "
"The existence of the ``!align`` metadata on the instruction tells the "
"optimizer that the value loaded is known to be aligned to a boundary "
"specified by the integer value in the metadata node. The alignment must be a "
"power of 2. This is analogous to the ''align'' attribute on parameters and "
"return values. This metadata can only be applied to loads of a pointer type. "
"If the returned value is not appropriately aligned at runtime, a poison "
"value is returned instead."
msgstr ""

#: ../../../LangRef.rst:11529
msgid ""
"The optional ``!noundef`` metadata must reference a single metadata name "
"``<empty_node>`` corresponding to a node with no entries. The existence of "
"``!noundef`` metadata on the instruction tells the optimizer that the value "
"loaded is known to be :ref:`well defined <welldefinedvalues>`. If the value "
"isn't well defined, the behavior is undefined. If the ``!noundef`` metadata "
"is combined with poison-generating metadata like ``!nonnull``, violation of "
"that metadata constraint will also result in undefined behavior."
msgstr ""

#: ../../../LangRef.rst:11540
msgid ""
"The location of memory pointed to is loaded. If the value being loaded is of "
"scalar type then the number of bytes read does not exceed the minimum number "
"of bytes needed to hold all bits of the type. For example, loading an "
"``i24`` reads at most three bytes. When loading a value of a type like "
"``i20`` with a size that is not an integral number of bytes, the result is "
"undefined if the value was not originally written using a store of the same "
"type. If the value being loaded is of aggregate type, the bytes that "
"correspond to padding may be accessed but are ignored, because it is "
"impossible to observe padding from the loaded aggregate value. If "
"``<pointer>`` is not a well-defined value, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:11564
msgid "'``store``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11579
msgid "The '``store``' instruction is used to write to memory."
msgstr ""

#: ../../../LangRef.rst:11584
msgid ""
"There are two arguments to the ``store`` instruction: a value to store and "
"an address at which to store it. The type of the ``<pointer>`` operand must "
"be a pointer to the :ref:`first class <t_firstclass>` type of the "
"``<value>`` operand. If the ``store`` is marked as ``volatile``, then the "
"optimizer is not allowed to modify the number or order of execution of this "
"``store`` with other :ref:`volatile operations <volatile>`.  Only values of :"
"ref:`first class <t_firstclass>` types of known size (i.e., not containing "
"an :ref:`opaque structural type <t_opaque>`) can be stored."
msgstr ""

#: ../../../LangRef.rst:11593
msgid ""
"If the ``store`` is marked as ``atomic``, it takes an extra :ref:`ordering "
"<ordering>` and optional ``syncscope(\"<target-scope>\")`` argument. The "
"``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` "
"instructions. Atomic loads produce :ref:`defined <memmodel>` results when "
"they may see multiple atomic stores. The type of the pointee must be an "
"integer, pointer, or floating-point type whose bit width is a power of two "
"greater than or equal to eight. ``align`` must be explicitly specified on "
"atomic stores. Note: if the alignment is not greater or equal to the size of "
"the `<value>` type, the atomic operation is likely to require a lock and "
"have poor performance. ``!nontemporal`` does not have any defined semantics "
"for atomic stores."
msgstr ""

#: ../../../LangRef.rst:11605
msgid ""
"The optional constant ``align`` argument specifies the alignment of the "
"operation (that is, the alignment of the memory address). It is the "
"responsibility of the code emitter to ensure that the alignment information "
"is correct. Overestimating the alignment results in undefined behavior. "
"Underestimating the alignment may produce less efficient code. An alignment "
"of 1 is always safe. The maximum possible alignment is ``1 << 32``.  An "
"alignment value higher than the size of the stored type does *not* imply "
"(without target specific knowledge) that memory up to the alignment value "
"bytes can be safely loaded without trapping."
msgstr ""

#: ../../../LangRef.rst:11627
msgid ""
"The optional ``!invariant.group`` metadata must reference a single metadata "
"name ``<empty_node>``. See ``invariant.group`` metadata."
msgstr ""

#: ../../../LangRef.rst:11633
msgid ""
"The contents of memory are updated to contain ``<value>`` at the location "
"specified by the ``<pointer>`` operand. If ``<value>`` is of scalar type "
"then the number of bytes written does not exceed the minimum number of bytes "
"needed to hold all bits of the type. For example, storing an ``i24`` writes "
"at most three bytes. When writing a value of a type like ``i20`` with a size "
"that is not an integral number of bytes, it is unspecified what happens to "
"the extra bits that do not belong to the type, but they will typically be "
"overwritten. If ``<value>`` is of aggregate type, padding is filled with :"
"ref:`undef <undefvalues>`. If ``<pointer>`` is not a well-defined value, the "
"behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:11657
msgid "'``fence``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11669
msgid ""
"The '``fence``' instruction is used to introduce happens-before edges "
"between operations."
msgstr ""

#: ../../../LangRef.rst:11675
msgid ""
"'``fence``' instructions take an :ref:`ordering <ordering>` argument which "
"defines what *synchronizes-with* edges they add. They can only be given "
"``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings."
msgstr ""

#: ../../../LangRef.rst:11682
msgid ""
"A fence A which has (at least) ``release`` ordering semantics *synchronizes "
"with* a fence B with (at least) ``acquire`` ordering semantics if and only "
"if there exist atomic operations X and Y, both operating on some atomic "
"object M, such that A is sequenced before X, X modifies M (either directly "
"or through some side effect of a sequence headed by X), Y is sequenced "
"before B, and Y observes M. This provides a *happens-before* dependency "
"between A and B. Rather than an explicit ``fence``, one (but not both) of "
"the atomic operations X or Y might provide a ``release`` or ``acquire`` "
"(resp.) ordering constraint and still *synchronize-with* the explicit "
"``fence`` and establish the *happens-before* edge."
msgstr ""

#: ../../../LangRef.rst:11694
msgid ""
"A ``fence`` which has ``seq_cst`` ordering, in addition to having both "
"``acquire`` and ``release`` semantics specified above, participates in the "
"global program order of other ``seq_cst`` operations and/or fences. "
"Furthermore, the global ordering created by a ``seq_cst`` fence must be "
"compatible with the individual total orders of ``monotonic`` (or stronger) "
"memory accesses occurring before and after such a fence. The exact semantics "
"of this interaction are somewhat complicated, see the C++ standard's "
"`[atomics.order] <https://wg21.link/atomics.order>`_ section for more "
"details."
msgstr ""

#: ../../../LangRef.rst:11704
msgid ""
"A ``fence`` instruction can also take an optional \":ref:`syncscope "
"<syncscope>`\" argument."
msgstr ""

#: ../../../LangRef.rst:11719
msgid "'``cmpxchg``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11731
msgid ""
"The '``cmpxchg``' instruction is used to atomically modify memory. It loads "
"a value in memory and compares it to a given value. If they are equal, it "
"tries to store a new value into the memory."
msgstr ""

#: ../../../LangRef.rst:11738
msgid ""
"There are three arguments to the '``cmpxchg``' instruction: an address to "
"operate on, a value to compare to the value currently be at that address, "
"and a new value to place at that address if the compared values are equal. "
"The type of '<cmp>' must be an integer or pointer type whose bit width is a "
"power of two greater than or equal to eight. '<cmp>' and '<new>' must have "
"the same type, and the type of '<pointer>' must be a pointer to that type. "
"If the ``cmpxchg`` is marked as ``volatile``, then the optimizer is not "
"allowed to modify the number or order of execution of this ``cmpxchg`` with "
"other :ref:`volatile operations <volatile>`."
msgstr ""

#: ../../../LangRef.rst:11749
msgid ""
"The success and failure :ref:`ordering <ordering>` arguments specify how "
"this ``cmpxchg`` synchronizes with other atomic operations. Both ordering "
"parameters must be at least ``monotonic``, the failure ordering cannot be "
"either ``release`` or ``acq_rel``."
msgstr ""

#: ../../../LangRef.rst:11754
msgid ""
"A ``cmpxchg`` instruction can also take an optional \":ref:`syncscope "
"<syncscope>`\" argument."
msgstr ""

#: ../../../LangRef.rst:11757 ../../../LangRef.rst:11866
msgid ""
"Note: if the alignment is not greater or equal to the size of the `<value>` "
"type, the atomic operation is likely to require a lock and have poor "
"performance."
msgstr ""

#: ../../../LangRef.rst:11761 ../../../LangRef.rst:11870
msgid ""
"The alignment is only optional when parsing textual IR; for in-memory IR, it "
"is always present. If unspecified, the alignment is assumed to be equal to "
"the size of the '<value>' type. Note that this default alignment assumption "
"is different from the alignment used for the load/store instructions when "
"align isn't specified."
msgstr ""

#: ../../../LangRef.rst:11767
msgid ""
"The pointer passed into cmpxchg must have alignment greater than or equal to "
"the size in memory of the operand."
msgstr ""

#: ../../../LangRef.rst:11773
msgid ""
"The contents of memory at the location specified by the '``<pointer>``' "
"operand is read and compared to '``<cmp>``'; if the values are equal, "
"'``<new>``' is written to the location. The original value at the location "
"is returned, together with a flag indicating success (true) or failure "
"(false)."
msgstr ""

#: ../../../LangRef.rst:11778
msgid ""
"If the cmpxchg operation is marked as ``weak`` then a spurious failure is "
"permitted: the operation may not write ``<new>`` even if the comparison "
"matched."
msgstr ""

#: ../../../LangRef.rst:11782
msgid ""
"If the cmpxchg operation is strong (the default), the i1 value is 1 if and "
"only if the value loaded equals ``cmp``."
msgstr ""

#: ../../../LangRef.rst:11785
msgid ""
"A successful ``cmpxchg`` is a read-modify-write instruction for the purpose "
"of identifying release sequences. A failed ``cmpxchg`` is equivalent to an "
"atomic load with an ordering parameter determined the second ordering "
"parameter."
msgstr ""

#: ../../../LangRef.rst:11812
msgid "'``atomicrmw``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11824
msgid "The '``atomicrmw``' instruction is used to atomically modify memory."
msgstr ""

#: ../../../LangRef.rst:11829
msgid ""
"There are three arguments to the '``atomicrmw``' instruction: an operation "
"to apply, an address whose value to modify, an argument to the operation. "
"The operation must be one of the following keywords:"
msgstr ""

#: ../../../LangRef.rst:11833
msgid "xchg"
msgstr ""

#: ../../../LangRef.rst:11834
msgid "add"
msgstr ""

#: ../../../LangRef.rst:11836
msgid "and"
msgstr ""

#: ../../../LangRef.rst:11837
msgid "nand"
msgstr ""

#: ../../../LangRef.rst:11838
msgid "or"
msgstr ""

#: ../../../LangRef.rst:11839
msgid "xor"
msgstr ""

#: ../../../LangRef.rst:11840
msgid "max"
msgstr ""

#: ../../../LangRef.rst:11841
msgid "min"
msgstr ""

#: ../../../LangRef.rst:11842
msgid "umax"
msgstr ""

#: ../../../LangRef.rst:11843
msgid "umin"
msgstr ""

#: ../../../LangRef.rst:11844
msgid "fadd"
msgstr ""

#: ../../../LangRef.rst:11845
msgid "fsub"
msgstr ""

#: ../../../LangRef.rst:11846
msgid "fmax"
msgstr ""

#: ../../../LangRef.rst:11847
msgid "fmin"
msgstr ""

#: ../../../LangRef.rst:11848
msgid "fmaximum"
msgstr ""

#: ../../../LangRef.rst:11849
msgid "fminimum"
msgstr ""

#: ../../../LangRef.rst:11850
msgid "uinc_wrap"
msgstr ""

#: ../../../LangRef.rst:11851
msgid "udec_wrap"
msgstr ""

#: ../../../LangRef.rst:11852
msgid "usub_cond"
msgstr ""

#: ../../../LangRef.rst:11853
msgid "usub_sat"
msgstr ""

#: ../../../LangRef.rst:11855
msgid ""
"For most of these operations, the type of '<value>' must be an integer type "
"whose bit width is a power of two greater than or equal to eight. For xchg, "
"this may also be a floating point or a pointer type with the same size "
"constraints as integers.  For fadd/fsub/fmax/fmin/fmaximum/fminimum, this "
"must be a floating-point or fixed vector of floating-point type.  The type "
"of the '``<pointer>``' operand must be a pointer to that type. If the "
"``atomicrmw`` is marked as ``volatile``, then the optimizer is not allowed "
"to modify the number or order of execution of this ``atomicrmw`` with other :"
"ref:`volatile operations <volatile>`."
msgstr ""

#: ../../../LangRef.rst:11876
msgid ""
"An ``atomicrmw`` instruction can also take an optional \":ref:`syncscope "
"<syncscope>`\" argument."
msgstr ""

#: ../../../LangRef.rst:11882
msgid ""
"The contents of memory at the location specified by the '``<pointer>``' "
"operand are atomically read, modified, and written back. The original value "
"at the location is returned. The modification is specified by the operation "
"argument:"
msgstr ""

#: ../../../LangRef.rst:11887
msgid "xchg: ``*ptr = val``"
msgstr ""

#: ../../../LangRef.rst:11888
msgid "add: ``*ptr = *ptr + val``"
msgstr ""

#: ../../../LangRef.rst:11889
msgid "sub: ``*ptr = *ptr - val``"
msgstr ""

#: ../../../LangRef.rst:11890
msgid "and: ``*ptr = *ptr & val``"
msgstr ""

#: ../../../LangRef.rst:11891
msgid "nand: ``*ptr = ~(*ptr & val)``"
msgstr ""

#: ../../../LangRef.rst:11892
msgid "or: ``*ptr = *ptr | val``"
msgstr ""

#: ../../../LangRef.rst:11893
msgid "xor: ``*ptr = *ptr ^ val``"
msgstr ""

#: ../../../LangRef.rst:11894
msgid "max: ``*ptr = *ptr > val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../../LangRef.rst:11895
msgid "min: ``*ptr = *ptr < val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../../LangRef.rst:11896
msgid "umax: ``*ptr = *ptr > val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../../LangRef.rst:11897
msgid "umin: ``*ptr = *ptr < val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../../LangRef.rst:11898
msgid "fadd: ``*ptr = *ptr + val`` (using floating point arithmetic)"
msgstr ""

#: ../../../LangRef.rst:11899
msgid "fsub: ``*ptr = *ptr - val`` (using floating point arithmetic)"
msgstr ""

#: ../../../LangRef.rst:11900
msgid ""
"fmax: ``*ptr = maxnum(*ptr, val)`` (match the `llvm.maxnum.*` intrinsic)"
msgstr ""

#: ../../../LangRef.rst:11901
msgid ""
"fmin: ``*ptr = minnum(*ptr, val)`` (match the `llvm.minnum.*` intrinsic)"
msgstr ""

#: ../../../LangRef.rst:11902
msgid ""
"fmaximum: ``*ptr = maximum(*ptr, val)`` (match the `llvm.maximum.*` "
"intrinsic)"
msgstr ""

#: ../../../LangRef.rst:11903
msgid ""
"fminimum: ``*ptr = minimum(*ptr, val)`` (match the `llvm.minimum.*` "
"intrinsic)"
msgstr ""

#: ../../../LangRef.rst:11904
msgid ""
"uinc_wrap: ``*ptr = (*ptr u>= val) ? 0 : (*ptr + 1)`` (increment value with "
"wraparound to zero when incremented above input value)"
msgstr ""

#: ../../../LangRef.rst:11905
msgid ""
"udec_wrap: ``*ptr = ((*ptr == 0) || (*ptr u> val)) ? val : (*ptr - 1)`` "
"(decrement with wraparound to input value when decremented below zero)."
msgstr ""

#: ../../../LangRef.rst:11906
msgid ""
"usub_cond: ``*ptr = (*ptr u>= val) ? *ptr - val : *ptr`` (subtract only if "
"no unsigned overflow)."
msgstr ""

#: ../../../LangRef.rst:11907
msgid ""
"usub_sat: ``*ptr = (*ptr u>= val) ? *ptr - val : 0`` (subtract with unsigned "
"clamping to zero)."
msgstr ""

#: ../../../LangRef.rst:11920
msgid "'``getelementptr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:11937
msgid ""
"The '``getelementptr``' instruction is used to get the address of a "
"subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs "
"address calculation only and does not access memory. The instruction can "
"also be used to calculate a vector of such addresses."
msgstr ""

#: ../../../LangRef.rst:11945
msgid ""
"The first argument is always a type used as the basis for the calculations. "
"The second argument is always a pointer or a vector of pointers, and is the "
"base address to start from. The remaining arguments are indices that "
"indicate which of the elements of the aggregate object are indexed. The "
"interpretation of each index is dependent on the type being indexed into. "
"The first index always indexes the pointer value given as the second "
"argument, the second index indexes a value of the type pointed to (not "
"necessarily the value directly pointed to, since the first index can be non-"
"zero), etc. The first type indexed into must be a pointer value, subsequent "
"types can be arrays, vectors, and structs. Note that subsequent types being "
"indexed into can never be pointers, since that would require loading the "
"pointer before continuing calculation."
msgstr ""

#: ../../../LangRef.rst:11958
msgid ""
"The type of each index argument depends on the type it is indexing into. "
"When indexing into a (optionally packed) structure, only ``i32`` integer "
"**constants** are allowed (when using a vector of indices they must all be "
"the **same** ``i32`` integer constant). When indexing into an array, pointer "
"or vector, integers of any width are allowed, and they are not required to "
"be constant. These integers are treated as signed values where relevant."
msgstr ""

#: ../../../LangRef.rst:11966
msgid ""
"For example, let's consider a C code fragment and how it gets compiled to "
"LLVM:"
msgstr ""

#: ../../../LangRef.rst:11986
msgid "The LLVM code generated by Clang is approximately:"
msgstr ""

#: ../../../LangRef.rst:12002
msgid ""
"In the example above, the first index is indexing into the '``%struct.ST*``' "
"type, which is a pointer, yielding a '``%struct.ST``' = '``{ i32, double, "
"%struct.RT }``' type, a structure. The second index indexes into the third "
"element of the structure, yielding a '``%struct.RT``' = '``{ i8 , [10 x [20 "
"x i32]], i8 }``' type, another structure. The third index indexes into the "
"second element of the structure, yielding a '``[10 x [20 x i32]]``' type, an "
"array. The two dimensions of the array are subscripted into, yielding an "
"'``i32``' type. The '``getelementptr``' instruction returns a pointer to "
"this element."
msgstr ""

#: ../../../LangRef.rst:12013
msgid ""
"Note that it is perfectly legal to index partially through a structure, "
"returning a pointer to an inner element. Because of this, the LLVM code for "
"the given testcase is equivalent to:"
msgstr ""

#: ../../../LangRef.rst:12028
msgid ""
"The indices are first converted to offsets in the pointer's index type. If "
"the currently indexed type is a struct type, the struct offset corresponding "
"to the index is sign-extended or truncated to the pointer index type. "
"Otherwise, the index itself is sign-extended or truncated, and then "
"multiplied by the type allocation size (that is, the size rounded up to the "
"ABI alignment) of the currently indexed type."
msgstr ""

#: ../../../LangRef.rst:12035
msgid ""
"The offsets are then added to the low bits of the base address up to the "
"index type width, with silently-wrapping two's complement arithmetic. If the "
"pointer size is larger than the index size, this means that the bits outside "
"the index type width will not be affected."
msgstr ""

#: ../../../LangRef.rst:12040
msgid ""
"The result value of the ``getelementptr`` may be outside the object pointed "
"to by the base pointer. The result value may not necessarily be used to "
"access memory though, even if it happens to point into allocated storage. "
"See the :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more "
"information."
msgstr ""

#: ../../../LangRef.rst:12046
msgid ""
"The ``getelementptr`` instruction may have a number of attributes that "
"impose additional rules. If any of the rules are violated, the result value "
"is a :ref:`poison value <poisonvalues>`. In cases where the base is a vector "
"of pointers, the attributes apply to each computation element-wise."
msgstr ""

#: ../../../LangRef.rst:12051
msgid "For ``nusw`` (no unsigned signed wrap):"
msgstr ""

#: ../../../LangRef.rst:12053
msgid ""
"If the type of an index is larger than the pointer index type, the "
"truncation to the pointer index type preserves the signed value (``trunc "
"nsw``)."
msgstr ""

#: ../../../LangRef.rst:12056
msgid ""
"The multiplication of an index by the type size does not wrap the pointer "
"index type in a signed sense (``mul nsw``)."
msgstr ""

#: ../../../LangRef.rst:12058
msgid ""
"The successive addition of each offset (without adding the base address) "
"does not wrap the pointer index type in a signed sense (``add nsw``)."
msgstr ""

#: ../../../LangRef.rst:12060
msgid ""
"The successive addition of the current address, truncated to the pointer "
"index type and interpreted as an unsigned number, and each offset, "
"interpreted as a signed number, does not wrap the pointer index type."
msgstr ""

#: ../../../LangRef.rst:12064
msgid "For ``nuw`` (no unsigned wrap):"
msgstr ""

#: ../../../LangRef.rst:12066
msgid ""
"If the type of an index is larger than the pointer index type, the "
"truncation to the pointer index type preserves the unsigned value (``trunc "
"nuw``)."
msgstr ""

#: ../../../LangRef.rst:12069
msgid ""
"The multiplication of an index by the type size does not wrap the pointer "
"index type in an unsigned sense (``mul nuw``)."
msgstr ""

#: ../../../LangRef.rst:12071
msgid ""
"The successive addition of each offset (without adding the base address) "
"does not wrap the pointer index type in an unsigned sense (``add nuw``)."
msgstr ""

#: ../../../LangRef.rst:12073
msgid ""
"The successive addition of the current address, truncated to the pointer "
"index type and interpreted as an unsigned number, and each offset, also "
"interpreted as an unsigned number, does not wrap the pointer index type "
"(``add nuw``)."
msgstr ""

#: ../../../LangRef.rst:12078
msgid ""
"For ``inbounds`` all rules of the ``nusw`` attribute apply. Additionally, if "
"the ``getelementptr`` has any non-zero indices, the following rules apply:"
msgstr ""

#: ../../../LangRef.rst:12081
msgid ""
"The base pointer has an *in bounds* address of the :ref:`allocated "
"object<allocatedobjects>` that it is :ref:`based <pointeraliasing>` on. This "
"means that it points into that allocated object, or to its end. Note that "
"the object does not have to be live anymore; being in-bounds of a "
"deallocated object is sufficient. If the allocated object can grow, then the "
"relevant size for being *in bounds* is the maximal size the object could "
"have while satisfying the allocated object rules, not its current size."
msgstr ""

#: ../../../LangRef.rst:12089
msgid ""
"During the successive addition of offsets to the address, the resulting "
"pointer must remain *in bounds* of the allocated object at each step."
msgstr ""

#: ../../../LangRef.rst:12092
msgid ""
"Note that ``getelementptr`` with all-zero indices is always considered to be "
"``inbounds``, even if the base pointer does not point to an allocated "
"object. As a corollary, the only pointer in bounds of the null pointer in "
"the default address space is the null pointer itself."
msgstr ""

#: ../../../LangRef.rst:12097
msgid ""
"If ``inbounds`` is present on a ``getelementptr`` instruction, the ``nusw`` "
"attribute will be automatically set as well. For this reason, the ``nusw`` "
"will also not be printed in textual IR if ``inbounds`` is already present."
msgstr ""

#: ../../../LangRef.rst:12101
msgid ""
"If the ``inrange(Start, End)`` attribute is present, loading from or storing "
"to any pointer derived from the ``getelementptr`` has undefined behavior if "
"the load or store would access memory outside the half-open range ``[Start, "
"End)`` from the ``getelementptr`` expression result. The result of a pointer "
"comparison or ``ptrtoint`` (including ``ptrtoint``-like operations involving "
"memory) involving a pointer derived from a ``getelementptr`` with the "
"``inrange`` keyword is undefined, with the exception of comparisons in the "
"case where both operands are in the closed range ``[Start, End]``. Note that "
"the ``inrange`` keyword is currently only allowed in constant "
"``getelementptr`` expressions."
msgstr ""

#: ../../../LangRef.rst:12112
msgid ""
"The getelementptr instruction is often confusing. For some more insight into "
"how it works, see :doc:`the getelementptr FAQ <GetElementPtr>`."
msgstr ""

#: ../../../LangRef.rst:12126
msgid "Vector of pointers:"
msgstr ""

#: ../../../LangRef.rst:12128
msgid ""
"The ``getelementptr`` returns a vector of pointers, instead of a single "
"address, when one or more of its arguments is a vector. In such cases, all "
"vector arguments should have the same number of elements, and every scalar "
"argument will be effectively broadcast into a vector during address "
"calculation."
msgstr ""

#: ../../../LangRef.rst:12149
msgid "The two following instructions are equivalent:"
msgstr ""

#: ../../../LangRef.rst:12162
msgid ""
"Let's look at the C code, where the vector version of ``getelementptr`` "
"makes sense:"
msgstr ""

#: ../../../LangRef.rst:12182
msgid "Conversion Operations"
msgstr ""

#: ../../../LangRef.rst:12184
msgid ""
"The instructions in this category are the conversion instructions (casting) "
"which all take a single operand and a type. They perform various bit "
"conversions on the operand."
msgstr ""

#: ../../../LangRef.rst:12191
msgid "'``trunc .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12206
msgid "The '``trunc``' instruction truncates its operand to the type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12211
msgid ""
"The '``trunc``' instruction takes a value to trunc, and a type to trunc it "
"to. Both types must be of :ref:`integer <t_integer>` types, or vectors of "
"the same number of integers. The bit size of the ``value`` must be larger "
"than the bit size of the destination type, ``ty2``. Equal sized types are "
"not allowed."
msgstr ""

#: ../../../LangRef.rst:12220
msgid ""
"The '``trunc``' instruction truncates the high order bits in ``value`` and "
"converts the remaining bits to ``ty2``. Since the source size must be larger "
"than the destination size, ``trunc`` cannot be a *no-op cast*. It will "
"always truncate bits."
msgstr ""

#: ../../../LangRef.rst:12225
msgid ""
"If the ``nuw`` keyword is present, and any of the truncated bits are non-"
"zero, the result is a :ref:`poison value <poisonvalues>`. If the ``nsw`` "
"keyword is present, and any of the truncated bits are not the same as the "
"top bit of the truncation result, the result is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:12243
msgid "'``zext .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12255
msgid "The '``zext``' instruction zero extends its operand to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12257
msgid ""
"The ``nneg`` (non-negative) flag, if present, specifies that the operand is "
"non-negative. This property may be used by optimization passes to later "
"convert the ``zext`` into a ``sext``."
msgstr ""

#: ../../../LangRef.rst:12264
msgid ""
"The '``zext``' instruction takes a value to cast, and a type to cast it to. "
"Both types must be of :ref:`integer <t_integer>` types, or vectors of the "
"same number of integers. The bit size of the ``value`` must be smaller than "
"the bit size of the destination type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12272
msgid ""
"The ``zext`` fills the high order bits of the ``value`` with zero bits until "
"it reaches the size of the destination type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12275
msgid "When zero extending from i1, the result will always be either 0 or 1."
msgstr ""

#: ../../../LangRef.rst:12277
msgid ""
"If the ``nneg`` flag is set, and the ``zext`` argument is negative, the "
"result is a poison value."
msgstr ""

#: ../../../LangRef.rst:12295
msgid "'``sext .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12307
msgid "The '``sext``' sign extends ``value`` to the type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12312
msgid ""
"The '``sext``' instruction takes a value to cast, and a type to cast it to. "
"Both types must be of :ref:`integer <t_integer>` types, or vectors of the "
"same number of integers. The bit size of the ``value`` must be smaller than "
"the bit size of the destination type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12320
msgid ""
"The '``sext``' instruction performs a sign extension by copying the sign bit "
"(highest order bit) of the ``value`` until it reaches the bit size of the "
"type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12324
msgid "When sign extending from i1, the extension always results in -1 or 0."
msgstr ""

#: ../../../LangRef.rst:12338
msgid "'``fptrunc .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12350
msgid "The '``fptrunc``' instruction truncates ``value`` to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12355
msgid ""
"The '``fptrunc``' instruction takes a :ref:`floating-point <t_floating>` "
"value to cast and a :ref:`floating-point <t_floating>` type to cast it to. "
"The size of ``value`` must be larger than the size of ``ty2``. This implies "
"that ``fptrunc`` cannot be used to make a *no-op cast*."
msgstr ""

#: ../../../LangRef.rst:12363
msgid ""
"The '``fptrunc``' instruction casts a ``value`` from a larger :ref:`floating-"
"point <t_floating>` type to a smaller :ref:`floating-point <t_floating>` "
"type. This instruction is assumed to execute in the default :ref:`floating-"
"point environment <floatenv>`."
msgstr ""

#: ../../../LangRef.rst:12369
msgid ""
"NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that "
"_if_ a NaN payload is propagated from the input (\"Quieting NaN "
"propagation\" or \"Unchanged NaN propagation\" cases), then the low order "
"bits of the NaN payload which cannot fit in the resulting type are "
"discarded. Note that if discarding the low order bits leads to an all-0 "
"payload, this cannot be represented as a signaling NaN (it would represent "
"an infinity instead), so in that case \"Unchanged NaN propagation\" is not "
"possible."
msgstr ""

#: ../../../LangRef.rst:12377 ../../../LangRef.rst:12428
msgid ""
"This instruction can also take any number of :ref:`fast-math flags "
"<fastmath>`, which are optimization hints to enable otherwise unsafe "
"floating-point optimizations."
msgstr ""

#: ../../../LangRef.rst:12392
msgid "'``fpext .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12404
msgid ""
"The '``fpext``' extends a floating-point ``value`` to a larger floating-"
"point value."
msgstr ""

#: ../../../LangRef.rst:12410
msgid ""
"The '``fpext``' instruction takes a :ref:`floating-point <t_floating>` "
"``value`` to cast, and a :ref:`floating-point <t_floating>` type to cast it "
"to. The source type must be smaller than the destination type."
msgstr ""

#: ../../../LangRef.rst:12417
msgid ""
"The '``fpext``' instruction extends the ``value`` from a smaller :ref:"
"`floating-point <t_floating>` type to a larger :ref:`floating-point "
"<t_floating>` type. The ``fpext`` cannot be used to make a *no-op cast* "
"because it always changes bits. Use ``bitcast`` to make a *no-op cast* for a "
"floating-point cast."
msgstr ""

#: ../../../LangRef.rst:12423
msgid ""
"NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that "
"_if_ a NaN payload is propagated from the input (\"Quieting NaN "
"propagation\" or \"Unchanged NaN propagation\" cases), then it is copied to "
"the high order bits of the resulting payload, and the remaining low order "
"bits are zero."
msgstr ""

#: ../../../LangRef.rst:12441
msgid "'``fptoui .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12453
msgid ""
"The '``fptoui``' converts a floating-point ``value`` to its unsigned integer "
"equivalent of type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12459
msgid ""
"The '``fptoui``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`floating-point <t_floating>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`integer <t_integer>` type. If ``ty`` is a "
"vector floating-point type, ``ty2`` must be a vector integer type with the "
"same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:12468
msgid ""
"The '``fptoui``' instruction converts its :ref:`floating-point <t_floating>` "
"operand into the nearest (rounding towards zero) unsigned integer value. If "
"the value cannot fit in ``ty2``, the result is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:12483
msgid "'``fptosi .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12495
msgid ""
"The '``fptosi``' instruction converts :ref:`floating-point <t_floating>` "
"``value`` to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12501
msgid ""
"The '``fptosi``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`floating-point <t_floating>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`integer <t_integer>` type. If ``ty`` is a "
"vector floating-point type, ``ty2`` must be a vector integer type with the "
"same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:12510
msgid ""
"The '``fptosi``' instruction converts its :ref:`floating-point <t_floating>` "
"operand into the nearest (rounding towards zero) signed integer value. If "
"the value cannot fit in ``ty2``, the result is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:12525
msgid "'``uitofp .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12537
msgid ""
"The '``uitofp``' instruction regards ``value`` as an unsigned integer and "
"converts that value to the ``ty2`` type."
msgstr ""

#: ../../../LangRef.rst:12540
msgid ""
"The ``nneg`` (non-negative) flag, if present, specifies that the operand is "
"non-negative. This property may be used by optimization passes to later "
"convert the ``uitofp`` into a ``sitofp``."
msgstr ""

#: ../../../LangRef.rst:12547
msgid ""
"The '``uitofp``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`integer <t_integer>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`floating-point <t_floating>` type. If ``ty`` "
"is a vector integer type, ``ty2`` must be a vector floating-point type with "
"the same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:12556
msgid ""
"The '``uitofp``' instruction interprets its operand as an unsigned integer "
"quantity and converts it to the corresponding floating-point value. If the "
"value cannot be exactly represented, it is rounded using the default "
"rounding mode."
msgstr ""

#: ../../../LangRef.rst:12561
msgid ""
"If the ``nneg`` flag is set, and the ``uitofp`` argument is negative, the "
"result is a poison value."
msgstr ""

#: ../../../LangRef.rst:12577
msgid "'``sitofp .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12589
msgid ""
"The '``sitofp``' instruction regards ``value`` as a signed integer and "
"converts that value to the ``ty2`` type."
msgstr ""

#: ../../../LangRef.rst:12595
msgid ""
"The '``sitofp``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`integer <t_integer>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`floating-point <t_floating>` type. If ``ty`` "
"is a vector integer type, ``ty2`` must be a vector floating-point type with "
"the same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:12604
msgid ""
"The '``sitofp``' instruction interprets its operand as a signed integer "
"quantity and converts it to the corresponding floating-point value. If the "
"value cannot be exactly represented, it is rounded using the default "
"rounding mode."
msgstr ""

#: ../../../LangRef.rst:12620
msgid "'``ptrtoint .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12632
msgid ""
"The '``ptrtoint``' instruction converts the pointer or a vector of pointers "
"``value`` to the integer (or vector of integers) type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12638
msgid ""
"The '``ptrtoint``' instruction takes a ``value`` to cast, which must be a "
"value of type :ref:`pointer <t_pointer>` or a vector of pointers, and a type "
"to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` or a "
"vector of integers type."
msgstr ""

#: ../../../LangRef.rst:12646
msgid ""
"The '``ptrtoint``' instruction converts ``value`` to integer type ``ty2`` by "
"interpreting all the pointer representation bits as an integer (equivalent "
"to a ``bitcast``) and either truncating or zero extending that value to the "
"size of the integer type. If ``value`` is smaller than ``ty2`` then a zero "
"extension is done. If ``value`` is larger than ``ty2`` then a truncation is "
"done. If they are the same size, then nothing is done (*no-op cast*) other "
"than a type change. The ``ptrtoint`` always :ref:`captures address and "
"provenance <pointercapture>` of the pointer argument."
msgstr ""

#: ../../../LangRef.rst:12669
msgid "'``ptrtoaddr .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12681
msgid ""
"The '``ptrtoaddr``' instruction converts the pointer or a vector of pointers "
"``value`` to the underlying integer address (or vector of addresses) of type "
"``ty2``. This is different from :ref:`ptrtoint <i_ptrtoint>` in that it only "
"operates on the index bits of the pointer and ignores all other bits, and "
"does not capture the provenance of the pointer."
msgstr ""

#: ../../../LangRef.rst:12690
msgid ""
"The '``ptrtoaddr``' instruction takes a ``value`` to cast, which must be a "
"value of type :ref:`pointer <t_pointer>` or a vector of pointers, and a type "
"to cast it to ``ty2``, which must be must be the :ref:`integer <t_integer>` "
"type (or vector of integers) matching the pointer index width of the address "
"space of ``ty``."
msgstr ""

#: ../../../LangRef.rst:12699
msgid ""
"The '``ptrtoaddr``' instruction converts ``value`` to integer type ``ty2`` "
"by interpreting the lowest index-width pointer representation bits as an "
"integer. If the address size and the pointer representation size are the "
"same and ``value`` and ``ty2`` are the same size, then nothing is done (*no-"
"op cast*) other than a type change."
msgstr ""

#: ../../../LangRef.rst:12705
msgid ""
"The ``ptrtoaddr`` instruction always :ref:`captures the address but not the "
"provenance <pointercapture>` of the pointer argument."
msgstr ""

#: ../../../LangRef.rst:12710
msgid ""
"This example assumes pointers in address space 1 are 64 bits in size with an "
"address width of 32 bits (``p1:64:64:64:32`` :ref:`datalayout "
"string<langref_datalayout>`)"
msgstr ""

#: ../../../LangRef.rst:12722
msgid "'``inttoptr .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12734
msgid ""
"The '``inttoptr``' instruction converts an integer ``value`` to a pointer "
"type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:12740
msgid ""
"The '``inttoptr``' instruction takes an :ref:`integer <t_integer>` value to "
"cast, and a type to cast it to, which must be a :ref:`pointer <t_pointer>` "
"type."
msgstr ""

#: ../../../LangRef.rst:12744
msgid ""
"The optional ``!dereferenceable`` metadata must reference a single metadata "
"name ``<deref_bytes_node>`` corresponding to a metadata node with one "
"``i64`` entry. See ``dereferenceable`` metadata."
msgstr ""

#: ../../../LangRef.rst:12749
msgid ""
"The optional ``!dereferenceable_or_null`` metadata must reference a single "
"metadata name ``<deref_bytes_node>`` corresponding to a metadata node with "
"one ``i64`` entry. See ``dereferenceable_or_null`` metadata."
msgstr ""

#: ../../../LangRef.rst:12754
msgid ""
"The optional ``!nofree`` metadata must reference a single metadata name "
"``<empty_node>`` corresponding to a metadata node with no entries. The "
"existence of the ``!nofree`` metadata on the instruction tells the optimizer "
"that the memory pointed by the pointer will not be freed after this point."
msgstr ""

#: ../../../LangRef.rst:12762
msgid ""
"The '``inttoptr``' instruction converts ``value`` to type ``ty2`` by "
"applying either a zero extension or a truncation depending on the size of "
"the integer ``value``. If ``value`` is larger than the size of a pointer "
"then a truncation is done. If ``value`` is smaller than the size of a "
"pointer then a zero extension is done. If they are the same size, nothing is "
"done (*no-op cast*). The behavior is equivalent to a ``bitcast``, however, "
"the resulting value is not guaranteed to be dereferenceable (e.g. if the "
"result type is a :ref:`non-integral pointers <nointptrtype>`)."
msgstr ""

#: ../../../LangRef.rst:12785
msgid "'``bitcast .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12797
msgid ""
"The '``bitcast``' instruction converts ``value`` to type ``ty2`` without "
"changing any bits."
msgstr ""

#: ../../../LangRef.rst:12803
msgid ""
"The '``bitcast``' instruction takes a value to cast, which must be a non-"
"aggregate first class value, and a type to cast it to, which must also be a "
"non-aggregate :ref:`first class <t_firstclass>` type. The bit sizes of "
"``value`` and the destination type, ``ty2``, must be identical. If the "
"source type is a pointer, the destination type must also be a pointer of the "
"same size. This instruction supports bitwise conversion of vectors to "
"integers and to vectors of other types (as long as they have the same size)."
msgstr ""

#: ../../../LangRef.rst:12815
msgid ""
"The '``bitcast``' instruction converts ``value`` to type ``ty2``. It is "
"always a *no-op cast* because no bits change with this conversion. The "
"conversion is done as if the ``value`` had been stored to memory and read "
"back as type ``ty2``. Pointer (or vector of pointers) types may only be "
"converted to other pointer (or vector of pointers) types with the same "
"address space through this instruction. To convert pointers to other types, "
"use the :ref:`inttoptr <i_inttoptr>` or :ref:`ptrtoint <i_ptrtoint>` "
"instructions first."
msgstr ""

#: ../../../LangRef.rst:12824
msgid ""
"There is a caveat for bitcasts involving vector types in relation to "
"endianness. For example ``bitcast <2 x i8> <value> to i16`` puts element "
"zero of the vector in the least significant bits of the i16 for little-"
"endian while element zero ends up in the most significant bits for big-"
"endian."
msgstr ""

#: ../../../LangRef.rst:12842
msgid "'``addrspacecast .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12854
msgid ""
"The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in "
"address space ``n`` to type ``pty2`` in address space ``m``."
msgstr ""

#: ../../../LangRef.rst:12860
msgid ""
"The '``addrspacecast``' instruction takes a pointer or vector of pointer "
"value to cast and a pointer type to cast it to, which must have a different "
"address space."
msgstr ""

#: ../../../LangRef.rst:12867
msgid ""
"The '``addrspacecast``' instruction converts the pointer value ``ptrval`` to "
"type ``pty2``. It can be a *no-op cast* or a complex value modification, "
"depending on the target and the address space pair. Pointer conversions "
"within the same address space must be performed with the ``bitcast`` "
"instruction. Note that if the address space conversion produces a "
"dereferenceable result then both result and operand refer to the same memory "
"location. The conversion must have no side effects, and must not capture the "
"value of the pointer."
msgstr ""

#: ../../../LangRef.rst:12876
msgid ""
"If the source is :ref:`poison <poisonvalues>`, the result is :ref:`poison "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:12879
msgid ""
"If the source is not :ref:`poison <poisonvalues>`, and both source and "
"destination are :ref:`integral pointers <nointptrtype>`, and the result "
"pointer is dereferenceable, the cast is assumed to be reversible (i.e., "
"casting the result back to the original address space should yield the "
"original bit pattern)."
msgstr ""

#: ../../../LangRef.rst:12885
msgid ""
"Which address space casts are supported depends on the target. Unsupported "
"address space casts return :ref:`poison <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:12900
msgid "Other Operations"
msgstr ""

#: ../../../LangRef.rst:12902
msgid ""
"The instructions in this category are the \"miscellaneous\" instructions, "
"which defy better classification."
msgstr ""

#: ../../../LangRef.rst:12908
msgid "'``icmp``' Instruction"
msgstr ""

#: ../../../LangRef.rst:12921
msgid ""
"The '``icmp``' instruction returns a boolean value or a vector of boolean "
"values based on comparison of its two integer, integer vector, pointer, or "
"pointer vector operands."
msgstr ""

#: ../../../LangRef.rst:12928
msgid ""
"The '``icmp``' instruction takes three operands. The first operand is the "
"condition code indicating the kind of comparison to perform. It is not a "
"value, just a keyword. The possible condition codes are:"
msgstr ""

#: ../../../LangRef.rst:12934
msgid "``eq``: equal"
msgstr ""

#: ../../../LangRef.rst:12935
msgid "``ne``: not equal"
msgstr ""

#: ../../../LangRef.rst:12936
msgid "``ugt``: unsigned greater than"
msgstr ""

#: ../../../LangRef.rst:12937
msgid "``uge``: unsigned greater or equal"
msgstr ""

#: ../../../LangRef.rst:12938
msgid "``ult``: unsigned less than"
msgstr ""

#: ../../../LangRef.rst:12939
msgid "``ule``: unsigned less or equal"
msgstr ""

#: ../../../LangRef.rst:12940
msgid "``sgt``: signed greater than"
msgstr ""

#: ../../../LangRef.rst:12941
msgid "``sge``: signed greater or equal"
msgstr ""

#: ../../../LangRef.rst:12942
msgid "``slt``: signed less than"
msgstr ""

#: ../../../LangRef.rst:12943
msgid "``sle``: signed less or equal"
msgstr ""

#: ../../../LangRef.rst:12945
msgid ""
"The remaining two arguments must be :ref:`integer <t_integer>` or :ref:"
"`pointer <t_pointer>` or integer :ref:`vector <t_vector>` typed. They must "
"also be identical types."
msgstr ""

#: ../../../LangRef.rst:12952
msgid ""
"The '``icmp``' compares ``op1`` and ``op2`` according to the condition code "
"given as ``cond``. The comparison performed always yields either an :ref:`i1 "
"<t_integer>` or vector of ``i1`` result, as follows:"
msgstr ""

#: ../../../LangRef.rst:12958
msgid ""
"``eq``: yields ``true`` if the operands are equal, ``false`` otherwise. No "
"sign interpretation is necessary or performed."
msgstr ""

#: ../../../LangRef.rst:12960
msgid ""
"``ne``: yields ``true`` if the operands are unequal, ``false`` otherwise. No "
"sign interpretation is necessary or performed."
msgstr ""

#: ../../../LangRef.rst:12962
msgid ""
"``ugt``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:12964
msgid ""
"``uge``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:12966
msgid ""
"``ult``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is less than ``op2``."
msgstr ""

#: ../../../LangRef.rst:12968
msgid ""
"``ule``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is less than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:12970
msgid ""
"``sgt``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:12972
msgid ""
"``sge``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:12974
msgid ""
"``slt``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is less than ``op2``."
msgstr ""

#: ../../../LangRef.rst:12976
msgid ""
"``sle``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is less than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:12979
msgid ""
"If the operands are :ref:`pointer <t_pointer>` typed, the pointer values are "
"compared as if they were integers."
msgstr ""

#: ../../../LangRef.rst:12982
msgid ""
"If the operands are integer vectors, then they are compared element by "
"element. The result is an ``i1`` vector with the same number of elements as "
"the values being compared. Otherwise, the result is an ``i1``."
msgstr ""

#: ../../../LangRef.rst:12986
msgid ""
"If the ``samesign`` keyword is present and the operands are not of the same "
"sign then the result is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:13004
msgid "'``fcmp``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13016
msgid ""
"The '``fcmp``' instruction returns a boolean value or vector of boolean "
"values based on comparison of its operands."
msgstr ""

#: ../../../LangRef.rst:13019
msgid ""
"If the operands are floating-point scalars, then the result type is a "
"boolean (:ref:`i1 <t_integer>`)."
msgstr ""

#: ../../../LangRef.rst:13022
msgid ""
"If the operands are floating-point vectors, then the result type is a vector "
"of boolean with the same number of elements as the operands being compared."
msgstr ""

#: ../../../LangRef.rst:13029
msgid ""
"The '``fcmp``' instruction takes three operands. The first operand is the "
"condition code indicating the kind of comparison to perform. It is not a "
"value, just a keyword. The possible condition codes are:"
msgstr ""

#: ../../../LangRef.rst:13033
msgid "``false``: no comparison, always returns false"
msgstr ""

#: ../../../LangRef.rst:13034
msgid "``oeq``: ordered and equal"
msgstr ""

#: ../../../LangRef.rst:13035
msgid "``ogt``: ordered and greater than"
msgstr ""

#: ../../../LangRef.rst:13036
msgid "``oge``: ordered and greater than or equal"
msgstr ""

#: ../../../LangRef.rst:13037
msgid "``olt``: ordered and less than"
msgstr ""

#: ../../../LangRef.rst:13038
msgid "``ole``: ordered and less than or equal"
msgstr ""

#: ../../../LangRef.rst:13039
msgid "``one``: ordered and not equal"
msgstr ""

#: ../../../LangRef.rst:13040
msgid "``ord``: ordered (no nans)"
msgstr ""

#: ../../../LangRef.rst:13041
msgid "``ueq``: unordered or equal"
msgstr ""

#: ../../../LangRef.rst:13042
msgid "``ugt``: unordered or greater than"
msgstr ""

#: ../../../LangRef.rst:13043
msgid "``uge``: unordered or greater than or equal"
msgstr ""

#: ../../../LangRef.rst:13044
msgid "``ult``: unordered or less than"
msgstr ""

#: ../../../LangRef.rst:13045
msgid "``ule``: unordered or less than or equal"
msgstr ""

#: ../../../LangRef.rst:13046
msgid "``une``: unordered or not equal"
msgstr ""

#: ../../../LangRef.rst:13047
msgid "``uno``: unordered (either nans)"
msgstr ""

#: ../../../LangRef.rst:13048
msgid "``true``: no comparison, always returns true"
msgstr ""

#: ../../../LangRef.rst:13050
msgid ""
"*Ordered* means that neither operand is a QNAN while *unordered* means that "
"either operand may be a QNAN."
msgstr ""

#: ../../../LangRef.rst:13053
msgid ""
"Each of ``val1`` and ``val2`` arguments must be either a :ref:`floating-"
"point <t_floating>` type or a :ref:`vector <t_vector>` of floating-point "
"type. They must have identical types."
msgstr ""

#: ../../../LangRef.rst:13060
msgid ""
"The '``fcmp``' instruction compares ``op1`` and ``op2`` according to the "
"condition code given as ``cond``. If the operands are vectors, then the "
"vectors are compared element by element. Each comparison performed always "
"yields an :ref:`i1 <t_integer>` result, as follows:"
msgstr ""

#: ../../../LangRef.rst:13065
msgid "``false``: always yields ``false``, regardless of operands."
msgstr ""

#: ../../../LangRef.rst:13066
msgid ""
"``oeq``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:13068
msgid ""
"``ogt``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:13070
msgid ""
"``oge``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:13072
msgid ""
"``olt``: yields ``true`` if both operands are not a QNAN and ``op1`` is less "
"than ``op2``."
msgstr ""

#: ../../../LangRef.rst:13074
msgid ""
"``ole``: yields ``true`` if both operands are not a QNAN and ``op1`` is less "
"than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:13076
msgid ""
"``one``: yields ``true`` if both operands are not a QNAN and ``op1`` is not "
"equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:13078
msgid "``ord``: yields ``true`` if both operands are not a QNAN."
msgstr ""

#: ../../../LangRef.rst:13079
msgid ""
"``ueq``: yields ``true`` if either operand is a QNAN or ``op1`` is equal to "
"``op2``."
msgstr ""

#: ../../../LangRef.rst:13081
msgid ""
"``ugt``: yields ``true`` if either operand is a QNAN or ``op1`` is greater "
"than ``op2``."
msgstr ""

#: ../../../LangRef.rst:13083
msgid ""
"``uge``: yields ``true`` if either operand is a QNAN or ``op1`` is greater "
"than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:13085
msgid ""
"``ult``: yields ``true`` if either operand is a QNAN or ``op1`` is less than "
"``op2``."
msgstr ""

#: ../../../LangRef.rst:13087
msgid ""
"``ule``: yields ``true`` if either operand is a QNAN or ``op1`` is less than "
"or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:13089
msgid ""
"``une``: yields ``true`` if either operand is a QNAN or ``op1`` is not equal "
"to ``op2``."
msgstr ""

#: ../../../LangRef.rst:13091
msgid "``uno``: yields ``true`` if either operand is a QNAN."
msgstr ""

#: ../../../LangRef.rst:13092
msgid "``true``: always yields ``true``, regardless of operands."
msgstr ""

#: ../../../LangRef.rst:13094
msgid ""
"The ``fcmp`` instruction can also optionally take any number of :ref:`fast-"
"math flags <fastmath>`, which are optimization hints to enable otherwise "
"unsafe floating-point optimizations."
msgstr ""

#: ../../../LangRef.rst:13098
msgid ""
"Any set of fast-math flags are legal on an ``fcmp`` instruction, but the "
"only flags that have any effect on its semantics are those that allow "
"assumptions to be made about the values of input arguments; namely ``nnan``, "
"``ninf``, and ``reassoc``. See :ref:`fastmath` for more information."
msgstr ""

#: ../../../LangRef.rst:13116
msgid "'``phi``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13128
msgid ""
"The '``phi``' instruction is used to implement the φ node in the SSA graph "
"representing the function."
msgstr ""

#: ../../../LangRef.rst:13134
msgid ""
"The type of the incoming values is specified with the first type field. "
"After this, the '``phi``' instruction takes a list of pairs as arguments, "
"with one pair for each predecessor basic block of the current block. Only "
"values of :ref:`first class <t_firstclass>` type may be used as the value "
"arguments to the PHI node. Only labels may be used as the label arguments."
msgstr ""

#: ../../../LangRef.rst:13141
msgid ""
"There must be no non-phi instructions between the start of a basic block and "
"the PHI instructions: i.e., PHI instructions must be first in a basic block."
msgstr ""

#: ../../../LangRef.rst:13145
msgid ""
"For the purposes of the SSA form, the use of each incoming value is deemed "
"to occur on the edge from the corresponding predecessor block to the current "
"block (but after any definition of an '``invoke``' instruction's return "
"value on the same edge)."
msgstr ""

#: ../../../LangRef.rst:13150
msgid ""
"The optional ``fast-math-flags`` marker indicates that the phi has one or "
"more :ref:`fast-math-flags <fastmath>`. These are optimization hints to "
"enable otherwise unsafe floating-point optimizations. Fast-math-flags are "
"only valid for phis that return :ref:`supported floating-point types "
"<fastmath_return_types>`."
msgstr ""

#: ../../../LangRef.rst:13159
msgid ""
"At runtime, the '``phi``' instruction logically takes on the value specified "
"by the pair corresponding to the predecessor basic block that executed just "
"prior to the current block."
msgstr ""

#: ../../../LangRef.rst:13176
msgid "'``select``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13190
msgid ""
"The '``select``' instruction is used to choose one value based on a "
"condition, without IR-level branching."
msgstr ""

#: ../../../LangRef.rst:13196
msgid ""
"The '``select``' instruction requires an 'i1' value or a vector of 'i1' "
"values indicating the condition, and two values of the same :ref:`first "
"class <t_firstclass>` type."
msgstr ""

#: ../../../LangRef.rst:13200
msgid ""
"The optional ``fast-math flags`` marker indicates that the select has one or "
"more :ref:`fast-math flags <fastmath>`. These are optimization hints to "
"enable otherwise unsafe floating-point optimizations. Fast-math flags are "
"only valid for selects that return :ref:`supported floating-point types "
"<fastmath_return_types>`. Note that the presence of value which would "
"otherwise result in poison does not cause the result to be poison if the "
"value is on the non-selected arm. If :ref:`fast-math flags <fastmath>` are "
"present, they are only applied to the result, not both arms."
msgstr ""

#: ../../../LangRef.rst:13212
msgid ""
"If the condition is an i1 and it evaluates to 1, the instruction returns the "
"first value argument; otherwise, it returns the second value argument."
msgstr ""

#: ../../../LangRef.rst:13216
msgid ""
"If the condition is a vector of i1, then the value arguments must be vectors "
"of the same size, and the selection is done element by element."
msgstr ""

#: ../../../LangRef.rst:13219
msgid ""
"If the condition is an i1 and the value arguments are vectors of the same "
"size, then an entire vector is selected."
msgstr ""

#: ../../../LangRef.rst:13235
msgid "'``freeze``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13247
msgid ""
"The '``freeze``' instruction is used to stop propagation of :ref:`undef "
"<undefvalues>` and :ref:`poison <poisonvalues>` values."
msgstr ""

#: ../../../LangRef.rst:13253
msgid "The '``freeze``' instruction takes a single argument."
msgstr ""

#: ../../../LangRef.rst:13258
msgid ""
"If the argument is ``undef`` or ``poison``, '``freeze``' returns an "
"arbitrary, but fixed, value of type '``ty``'. Otherwise, this instruction is "
"a no-op and returns the input argument. All uses of a value returned by the "
"same '``freeze``' instruction are guaranteed to always observe the same "
"value, while different '``freeze``' instructions may yield different values."
msgstr ""

#: ../../../LangRef.rst:13265
msgid ""
"While ``undef`` and ``poison`` pointers can be frozen, the result is a non-"
"dereferenceable pointer. See the :ref:`Pointer Aliasing Rules "
"<pointeraliasing>` section for more information. If an aggregate value or "
"vector is frozen, the operand is frozen element-wise. The padding of an "
"aggregate isn't considered, since it isn't visible without storing it into "
"memory and loading it with a different type."
msgstr ""

#: ../../../LangRef.rst:13305
msgid "'``call``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13318
msgid "The '``call``' instruction represents a simple function call."
msgstr ""

#: ../../../LangRef.rst:13325
msgid ""
"The optional ``tail`` and ``musttail`` markers indicate that the optimizers "
"should perform tail call optimization. The ``tail`` marker is a hint that "
"`can be ignored <CodeGenerator.html#tail-call-optimization>`_. The "
"``musttail`` marker means that the call must be tail call optimized in order "
"for the program to be correct. This is true even in the presence of "
"attributes like \"disable-tail-calls\". The ``musttail`` marker provides "
"these guarantees:"
msgstr ""

#: ../../../LangRef.rst:13333
msgid ""
"The call will not cause unbounded stack growth if it is part of a recursive "
"cycle in the call graph."
msgstr ""

#: ../../../LangRef.rst:13335
msgid ""
"Arguments with the :ref:`inalloca <attr_inalloca>` or :ref:`preallocated "
"<attr_preallocated>` attribute are forwarded in place."
msgstr ""

#: ../../../LangRef.rst:13337
msgid ""
"If the musttail call appears in a function with the ``\"thunk\"`` attribute "
"and the caller and callee both have varargs, then any unprototyped arguments "
"in register or memory are forwarded to the callee. Similarly, the return "
"value of the callee is returned to the caller's caller, even if a void "
"return type is in use."
msgstr ""

#: ../../../LangRef.rst:13343
msgid ""
"Both markers imply that the callee does not access allocas, va_args, or "
"byval arguments from the caller. As an exception to that, an alloca or byval "
"argument may be passed to the callee as a byval argument, which can be "
"dereferenced inside the callee. For example:"
msgstr ""

#: ../../../LangRef.rst:13402
msgid "Calls marked ``musttail`` must obey the following additional rules:"
msgstr ""

#: ../../../LangRef.rst:13404
msgid ""
"The call must immediately precede a :ref:`ret <i_ret>` instruction, or a "
"pointer bitcast followed by a ret instruction."
msgstr ""

#: ../../../LangRef.rst:13406
msgid ""
"The ret instruction must return the (possibly bitcasted) value produced by "
"the call, undef, or void."
msgstr ""

#: ../../../LangRef.rst:13408
msgid "The calling conventions of the caller and callee must match."
msgstr ""

#: ../../../LangRef.rst:13409
msgid ""
"The callee must be varargs iff the caller is varargs. Bitcasting a non-"
"varargs function to the appropriate varargs type is legal so long as the non-"
"varargs prefixes obey the other rules."
msgstr ""

#: ../../../LangRef.rst:13412
msgid ""
"The return type must not undergo automatic conversion to an `sret` pointer."
msgstr ""

#: ../../../LangRef.rst:13414
msgid ""
"In addition, if the calling convention is not `swifttailcc` or `tailcc`:"
msgstr ""

#: ../../../LangRef.rst:13416
msgid ""
"All ABI-impacting function attributes, such as sret, byval, inreg, returned, "
"and inalloca, must match."
msgstr ""

#: ../../../LangRef.rst:13418
msgid ""
"The caller and callee prototypes must match. Pointer types of parameters or "
"return types do not differ in address space."
msgstr ""

#: ../../../LangRef.rst:13421
msgid ""
"On the other hand, if the calling convention is `swifttailcc` or `tailcc`:"
msgstr ""

#: ../../../LangRef.rst:13423
msgid ""
"Only these ABI-impacting attributes attributes are allowed: sret, byval, "
"swiftself, and swiftasync."
msgstr ""

#: ../../../LangRef.rst:13425
msgid "Prototypes are not required to match."
msgstr ""

#: ../../../LangRef.rst:13427
msgid ""
"Tail call optimization for calls marked ``tail`` is guaranteed to occur if "
"the following conditions are met:"
msgstr ""

#: ../../../LangRef.rst:13430
msgid ""
"Caller and callee both have the calling convention ``fastcc`` or ``tailcc``."
msgstr ""

#: ../../../LangRef.rst:13431
msgid ""
"The call is in tail position (ret immediately follows call and ret uses "
"value of call or is void)."
msgstr ""

#: ../../../LangRef.rst:13433
msgid ""
"Option ``-tailcallopt`` is enabled, ``llvm::GuaranteedTailCallOpt`` is "
"``true``, or the calling convention is ``tailcc``."
msgstr ""

#: ../../../LangRef.rst:13435
msgid ""
"`Platform-specific constraints are met. <CodeGenerator.html#tail-call-"
"optimization>`_"
msgstr ""

#: ../../../LangRef.rst:13438
msgid ""
"The optional ``notail`` marker indicates that the optimizers should not add "
"``tail`` or ``musttail`` markers to the call. It is used to prevent tail "
"call optimization from being performed on the call."
msgstr ""

#: ../../../LangRef.rst:13442
msgid ""
"The optional ``fast-math flags`` marker indicates that the call has one or "
"more :ref:`fast-math flags <fastmath>`, which are optimization hints to "
"enable otherwise unsafe floating-point optimizations. Fast-math flags are "
"only valid for calls that return :ref:`supported floating-point types "
"<fastmath_return_types>`."
msgstr ""

#: ../../../LangRef.rst:13447
msgid ""
"The optional \"cconv\" marker indicates which :ref:`calling convention "
"<callingconv>` the call should use. If none is specified, the call defaults "
"to using C calling conventions. The calling convention of the call must "
"match the calling convention of the target function, or else the behavior is "
"undefined."
msgstr ""

#: ../../../LangRef.rst:13465
msgid ""
"'``fnptrval``': An LLVM value containing a pointer to a function to be "
"called. In most cases, this is a direct function call, but indirect "
"``call``'s are just as possible, calling an arbitrary pointer to function "
"value."
msgstr ""

#: ../../../LangRef.rst:13480
msgid ""
"The '``call``' instruction is used to cause control flow to transfer to a "
"specified function, with its incoming arguments bound to the specified "
"values. Upon a '``ret``' instruction in the called function, control flow "
"continues with the instruction after the function call, and the return value "
"of the function is bound to the result argument."
msgstr ""

#: ../../../LangRef.rst:13486
msgid ""
"If the callee refers to an intrinsic function, the signature of the call "
"must match the signature of the callee.  Otherwise, if the signature of the "
"call does not match the signature of the called function, the behavior is "
"target-specific.  For a significant mismatch, this likely results in "
"undefined behavior. LLVM interprocedural optimizations generally only "
"optimize calls where the signature of the caller matches the signature of "
"the callee."
msgstr ""

#: ../../../LangRef.rst:13493
msgid ""
"Note that it is possible for the signatures to mismatch even if a call "
"appears to be a \"direct\" call, like ``call void @f()``."
msgstr ""

#: ../../../LangRef.rst:13514
msgid ""
"llvm treats calls to some functions with names and arguments that match the "
"standard C99 library as being the C99 library functions, and may perform "
"optimizations or generate code for them under that assumption. This is "
"something we'd like to change in the future to provide better support for "
"freestanding environments and non-C-based languages."
msgstr ""

#: ../../../LangRef.rst:13523
msgid "'``va_arg``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13535
msgid ""
"The '``va_arg``' instruction is used to access arguments passed through the "
"\"variable argument\" area of a function call. It is used to implement the "
"``va_arg`` macro in C."
msgstr ""

#: ../../../LangRef.rst:13542
msgid ""
"This instruction takes a ``va_list*`` value and the type of the argument. It "
"returns a value of the specified argument type and increments the "
"``va_list`` to point to the next argument. The actual type of ``va_list`` is "
"target specific."
msgstr ""

#: ../../../LangRef.rst:13550
msgid ""
"The '``va_arg``' instruction loads an argument of the specified type from "
"the specified ``va_list`` and causes the ``va_list`` to point to the next "
"argument. For more information, see the variable argument handling :ref:"
"`Intrinsic Functions <int_varargs>`."
msgstr ""

#: ../../../LangRef.rst:13555
msgid ""
"It is legal for this instruction to be called in a function which does not "
"take a variable number of arguments, for example, the ``vfprintf`` function."
msgstr ""

#: ../../../LangRef.rst:13559
msgid ""
"``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic function "
"<intrinsics>` because it takes a type as an argument."
msgstr ""

#: ../../../LangRef.rst:13565
msgid "See the :ref:`variable argument processing <int_varargs>` section."
msgstr ""

#: ../../../LangRef.rst:13567
msgid ""
"Note that the code generator does not yet fully support va\\_arg on many "
"targets. Also, it does not currently support va\\_arg with aggregate types "
"on any target."
msgstr ""

#: ../../../LangRef.rst:13574
msgid "'``landingpad``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13590
msgid ""
"The '``landingpad``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to specify that a basic block is "
"a landing pad --- one where the exception lands, and corresponds to the code "
"found in the ``catch`` portion of a ``try``/``catch`` sequence. It defines "
"values supplied by the :ref:`personality function <personalityfn>` upon re-"
"entry to the function. The ``resultval`` has the type ``resultty``."
msgstr ""

#: ../../../LangRef.rst:13600
msgid ""
"The optional ``cleanup`` flag indicates that the landing pad block is a "
"cleanup."
msgstr ""

#: ../../../LangRef.rst:13603
msgid ""
"A ``clause`` begins with the clause type --- ``catch`` or ``filter`` --- and "
"contains the global variable representing the \"type\" that may be caught or "
"filtered respectively. Unlike the ``catch`` clause, the ``filter`` clause "
"takes an array constant as its argument. Use \"``[0 x ptr] undef``\" for a "
"filter which cannot throw. The '``landingpad``' instruction must contain *at "
"least* one ``clause`` or the ``cleanup`` flag."
msgstr ""

#: ../../../LangRef.rst:13614
msgid ""
"The '``landingpad``' instruction defines the values which are set by the :"
"ref:`personality function <personalityfn>` upon re-entry to the function, "
"and therefore the \"result type\" of the ``landingpad`` instruction. As with "
"calling conventions, how the personality function results are represented in "
"LLVM IR is target specific."
msgstr ""

#: ../../../LangRef.rst:13620
msgid ""
"The clauses are applied in order from top to bottom. If two ``landingpad`` "
"instructions are merged together through inlining, the clauses from the "
"calling function are appended to the list of clauses. When the call stack is "
"being unwound due to an exception being thrown, the exception is compared "
"against each ``clause`` in turn. If it doesn't match any of the clauses, and "
"the ``cleanup`` flag is not set, then unwinding continues further up the "
"call stack."
msgstr ""

#: ../../../LangRef.rst:13628
msgid "The ``landingpad`` instruction has several restrictions:"
msgstr ""

#: ../../../LangRef.rst:13630
msgid ""
"A landing pad block is a basic block which is the unwind destination of an "
"'``invoke``' instruction."
msgstr ""

#: ../../../LangRef.rst:13632
msgid ""
"A landing pad block must have a '``landingpad``' instruction as its first "
"non-PHI instruction."
msgstr ""

#: ../../../LangRef.rst:13634
msgid ""
"There can be only one '``landingpad``' instruction within the landing pad "
"block."
msgstr ""

#: ../../../LangRef.rst:13636
msgid ""
"A basic block that is not a landing pad block may not include a "
"'``landingpad``' instruction."
msgstr ""

#: ../../../LangRef.rst:13658
msgid "'``catchpad``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13670
msgid ""
"The '``catchpad``' instruction is used by `LLVM's exception handling system "
"<ExceptionHandling.html#overview>`_ to specify that a basic block begins a "
"catch handler --- one where a personality routine attempts to transfer "
"control to catch an exception."
msgstr ""

#: ../../../LangRef.rst:13678
msgid ""
"The ``catchswitch`` operand must always be a token produced by a :ref:"
"`catchswitch <i_catchswitch>` instruction in a predecessor block. This "
"ensures that each ``catchpad`` has exactly one predecessor block, and it "
"always terminates in a ``catchswitch``."
msgstr ""

#: ../../../LangRef.rst:13683
msgid ""
"The ``args`` correspond to whatever information the personality routine "
"requires to determine if this is an appropriate handler for the exception. "
"Control will transfer to the ``catchpad`` if this is the first appropriate "
"handler for the exception."
msgstr ""

#: ../../../LangRef.rst:13688
msgid ""
"The ``resultval`` has the type :ref:`token <t_token>` and is used to match "
"the ``catchpad`` to corresponding :ref:`catchrets <i_catchret>` and other "
"nested EH pads."
msgstr ""

#: ../../../LangRef.rst:13695
msgid ""
"When the call stack is being unwound due to an exception being thrown, the "
"exception is compared against the ``args``. If it doesn't match, control "
"will not reach the ``catchpad`` instruction.  The representation of ``args`` "
"is entirely target and personality function-specific."
msgstr ""

#: ../../../LangRef.rst:13700
msgid ""
"Like the :ref:`landingpad <i_landingpad>` instruction, the ``catchpad`` "
"instruction must be the first non-phi of its parent basic block."
msgstr ""

#: ../../../LangRef.rst:13703
msgid ""
"The meaning of the tokens produced and consumed by ``catchpad`` and other "
"\"pad\" instructions is described in the `Windows exception handling "
"documentation\\ <ExceptionHandling.html#wineh>`_."
msgstr ""

#: ../../../LangRef.rst:13707
msgid ""
"When a ``catchpad`` has been \"entered\" but not yet \"exited\" (as "
"described in the `EH documentation\\ <ExceptionHandling.html#wineh-"
"constraints>`_), it is undefined behavior to execute a :ref:`call <i_call>` "
"or :ref:`invoke <i_invoke>` that does not carry an appropriate :ref:"
"`\"funclet\" bundle <ob_funclet>`."
msgstr ""

#: ../../../LangRef.rst:13726
msgid "'``cleanuppad``' Instruction"
msgstr ""

#: ../../../LangRef.rst:13738
msgid ""
"The '``cleanuppad``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to specify that a basic block is "
"a cleanup block --- one where a personality routine attempts to transfer "
"control to run cleanup actions. The ``args`` correspond to whatever "
"additional information the :ref:`personality function <personalityfn>` "
"requires to execute the cleanup. The ``resultval`` has the type :ref:`token "
"<t_token>` and is used to match the ``cleanuppad`` to corresponding :ref:"
"`cleanuprets <i_cleanupret>`. The ``parent`` argument is the token of the "
"funclet that contains the ``cleanuppad`` instruction. If the ``cleanuppad`` "
"is not inside a funclet, this operand may be the token ``none``."
msgstr ""

#: ../../../LangRef.rst:13754
msgid ""
"The instruction takes a list of arbitrary values which are interpreted by "
"the :ref:`personality function <personalityfn>`."
msgstr ""

#: ../../../LangRef.rst:13760
msgid ""
"When the call stack is being unwound due to an exception being thrown, the :"
"ref:`personality function <personalityfn>` transfers control to the "
"``cleanuppad`` with the aid of the personality-specific arguments. As with "
"calling conventions, how the personality function results are represented in "
"LLVM IR is target specific."
msgstr ""

#: ../../../LangRef.rst:13766
msgid "The ``cleanuppad`` instruction has several restrictions:"
msgstr ""

#: ../../../LangRef.rst:13768
msgid ""
"A cleanup block is a basic block which is the unwind destination of an "
"exceptional instruction."
msgstr ""

#: ../../../LangRef.rst:13770
msgid ""
"A cleanup block must have a '``cleanuppad``' instruction as its first non-"
"PHI instruction."
msgstr ""

#: ../../../LangRef.rst:13772
msgid ""
"There can be only one '``cleanuppad``' instruction within the cleanup block."
msgstr ""

#: ../../../LangRef.rst:13774
msgid ""
"A basic block that is not a cleanup block may not include a '``cleanuppad``' "
"instruction."
msgstr ""

#: ../../../LangRef.rst:13777
msgid ""
"When a ``cleanuppad`` has been \"entered\" but not yet \"exited\" (as "
"described in the `EH documentation\\ <ExceptionHandling.html#wineh-"
"constraints>`_), it is undefined behavior to execute a :ref:`call <i_call>` "
"or :ref:`invoke <i_invoke>` that does not carry an appropriate :ref:"
"`\"funclet\" bundle <ob_funclet>`."
msgstr ""

#: ../../../LangRef.rst:13792
msgid "Debug Records"
msgstr ""

#: ../../../LangRef.rst:13794
msgid ""
"Debug records appear interleaved with instructions, but are not "
"instructions; they are used only to define debug information, and have no "
"effect on generated code. They are distinguished from instructions by the "
"use of a leading `#` and an extra level of indentation. As an example:"
msgstr ""

#: ../../../LangRef.rst:13805
msgid ""
"These debug records replace the prior :ref:`debug "
"intrinsics<dbg_intrinsics>`. Debug records will be disabled if ``--"
"experimental-debuginfo-iterators=false`` is passed to LLVM; it is an error "
"for both records and intrinsics to appear in the same module. More "
"information about debug records can be found in the `LLVM Source Level "
"Debugging <SourceLevelDebugging.html#format-common-intrinsics>`_ document."
msgstr ""

#: ../../../LangRef.rst:13815
msgid "Intrinsic Functions"
msgstr ""

#: ../../../LangRef.rst:13817
msgid ""
"LLVM supports the notion of an \"intrinsic function\". These functions have "
"well known names and semantics and are required to follow certain "
"restrictions. Overall, these intrinsics represent an extension mechanism for "
"the LLVM language that does not require changing all of the transformations "
"in LLVM when adding to the language (or the bitcode reader/writer, the "
"parser, etc...)."
msgstr ""

#: ../../../LangRef.rst:13824
msgid ""
"Intrinsic function names must all start with an \"``llvm.``\" prefix. This "
"prefix is reserved in LLVM for intrinsic names; thus, function names may not "
"begin with this prefix. Intrinsic functions must always be external "
"functions: you cannot define the body of intrinsic functions. Intrinsic "
"functions may only be used in call or invoke instructions: it is illegal to "
"take the address of an intrinsic function. Additionally, because intrinsic "
"functions are part of the LLVM language, it is required if any are added "
"that they be documented here."
msgstr ""

#: ../../../LangRef.rst:13833
msgid ""
"Some intrinsic functions can be overloaded, i.e., the intrinsic represents a "
"family of functions that perform the same operation but on different data "
"types. Because LLVM can represent over 8 million different integer types, "
"overloading is used commonly to allow an intrinsic function to operate on "
"any integer type. One or more of the argument types or the result type can "
"be overloaded to accept any integer type. Argument types may also be defined "
"as exactly matching a previous argument's type or the result type. This "
"allows an intrinsic function which accepts multiple arguments, but needs all "
"of them to be of the same type, to only be overloaded with respect to a "
"single argument or the result."
msgstr ""

#: ../../../LangRef.rst:13845
msgid ""
"Overloaded intrinsics will have the names of its overloaded argument types "
"encoded into its function name, each preceded by a period. Only those types "
"which are overloaded result in a name suffix. Arguments whose type is "
"matched against another type do not. For example, the ``llvm.ctpop`` "
"function can take an integer of any width and returns an integer of exactly "
"the same integer width. This leads to a family of functions such as ``i8 "
"@llvm.ctpop.i8(i8 %val)`` and ``i29 @llvm.ctpop.i29(i29 %val)``. Only one "
"type, the return type, is overloaded, and only one type suffix is required. "
"Because the argument's type is matched against the return type, it does not "
"require its own name suffix."
msgstr ""

#: ../../../LangRef.rst:13857
msgid ""
":ref:`Unnamed types <t_opaque>` are encoded as ``s_s``. Overloaded "
"intrinsics that depend on an unnamed type in one of its overloaded argument "
"types get an additional ``.<number>`` suffix. This allows differentiating "
"intrinsics with different unnamed types as arguments. (For example: ``llvm."
"ssa.copy.p0s_s.2(%42*)``) The number is tracked in the LLVM module and it "
"ensures unique names in the module. While linking together two modules, it "
"is still possible to get a name clash. In that case one of the names will be "
"changed by getting a new number."
msgstr ""

#: ../../../LangRef.rst:13866
msgid ""
"For target developers who are defining intrinsics for back-end code "
"generation, any intrinsic overloads based solely the distinction between "
"integer or floating point types should not be relied upon for correct code "
"generation. In such cases, the recommended approach for target maintainers "
"when defining intrinsics is to create separate integer and FP intrinsics "
"rather than rely on overloading. For example, if different codegen is "
"required for ``llvm.target.foo(<4 x i32>)`` and ``llvm.target.foo(<4 x "
"float>)`` then these should be split into different intrinsics."
msgstr ""

#: ../../../LangRef.rst:13876
msgid ""
"To learn how to add an intrinsic function, please see the `Extending LLVM "
"Guide <ExtendingLLVM.html>`_."
msgstr ""

#: ../../../LangRef.rst:13882
msgid "Variable Argument Handling Intrinsics"
msgstr ""

#: ../../../LangRef.rst:13884
msgid ""
"Variable argument support is defined in LLVM with the :ref:`va_arg "
"<i_va_arg>` instruction and these three intrinsic functions. These functions "
"are related to the similarly named macros defined in the ``<stdarg.h>`` "
"header file."
msgstr ""

#: ../../../LangRef.rst:13889
msgid ""
"All of these functions take as arguments pointers to a target-specific value "
"type \"``va_list``\". The LLVM assembly language reference manual does not "
"define what this type is, so all transformations should be prepared to "
"handle these functions regardless of the type used. The intrinsics are "
"overloaded, and can be used for pointers to different address spaces."
msgstr ""

#: ../../../LangRef.rst:13895
msgid ""
"This example shows how the :ref:`va_arg <i_va_arg>` instruction and the "
"variable argument handling intrinsic functions are used."
msgstr ""

#: ../../../LangRef.rst:13932
msgid "'``llvm.va_start``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:13945
msgid ""
"The '``llvm.va_start``' intrinsic initializes ``<arglist>`` for subsequent "
"use by ``va_arg``."
msgstr ""

#: ../../../LangRef.rst:13951
msgid "The argument is a pointer to a ``va_list`` element to initialize."
msgstr ""

#: ../../../LangRef.rst:13956
msgid ""
"The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro "
"available in C. In a target-dependent way, it initializes the ``va_list`` "
"element to which the argument points, so that the next call to ``va_arg`` "
"will produce the first variable argument passed to the function. Unlike the "
"C ``va_start`` macro, this intrinsic does not need to know the last argument "
"of the function as the compiler can figure that out."
msgstr ""

#: ../../../LangRef.rst:13965
msgid "'``llvm.va_end``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:13978
msgid ""
"The '``llvm.va_end``' intrinsic destroys ``<arglist>``, which has been "
"initialized previously with ``llvm.va_start`` or ``llvm.va_copy``."
msgstr ""

#: ../../../LangRef.rst:13984
msgid "The argument is a pointer to a ``va_list`` to destroy."
msgstr ""

#: ../../../LangRef.rst:13989
msgid ""
"The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro "
"available in C. In a target-dependent way, it destroys the ``va_list`` "
"element to which the argument points. Calls to :ref:`llvm.va_start "
"<int_va_start>` and :ref:`llvm.va_copy <int_va_copy>` must be matched "
"exactly with calls to ``llvm.va_end``."
msgstr ""

#: ../../../LangRef.rst:13999
msgid "'``llvm.va_copy``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14012
msgid ""
"The '``llvm.va_copy``' intrinsic copies the current argument position from "
"the source argument list to the destination argument list."
msgstr ""

#: ../../../LangRef.rst:14018
msgid ""
"The first argument is a pointer to a ``va_list`` element to initialize. The "
"second argument is a pointer to a ``va_list`` element to copy from. The "
"address spaces of the two arguments must match."
msgstr ""

#: ../../../LangRef.rst:14025
msgid ""
"The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro "
"available in C. In a target-dependent way, it copies the source ``va_list`` "
"element into the destination ``va_list`` element. This intrinsic is "
"necessary because the ``llvm.va_start`` intrinsic may be arbitrarily complex "
"and require, for example, memory allocation."
msgstr ""

#: ../../../LangRef.rst:14032
msgid "Accurate Garbage Collection Intrinsics"
msgstr ""

#: ../../../LangRef.rst:14034
msgid ""
"LLVM's support for `Accurate Garbage Collection <GarbageCollection.html>`_ "
"(GC) requires the frontend to generate code containing appropriate intrinsic "
"calls and select an appropriate GC strategy which knows how to lower these "
"intrinsics in a manner which is appropriate for the target collector."
msgstr ""

#: ../../../LangRef.rst:14039
msgid ""
"These intrinsics allow identification of :ref:`GC roots on the stack "
"<int_gcroot>`, as well as garbage collector implementations that require :"
"ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. Frontends "
"for type-safe garbage collected languages should generate these intrinsics "
"to make use of the LLVM garbage collectors. For more details, see `Garbage "
"Collection with LLVM <GarbageCollection.html>`_."
msgstr ""

#: ../../../LangRef.rst:14046
msgid ""
"LLVM provides an second experimental set of intrinsics for describing "
"garbage collection safepoints in compiled code. These intrinsics are an "
"alternative to the ``llvm.gcroot`` intrinsics, but are compatible with the "
"ones for :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. "
"The differences in approach are covered in the `Garbage Collection with LLVM "
"<GarbageCollection.html>`_ documentation. The intrinsics themselves are "
"described in :doc:`Statepoints`."
msgstr ""

#: ../../../LangRef.rst:14057
msgid "'``llvm.gcroot``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14069
msgid ""
"The '``llvm.gcroot``' intrinsic declares the existence of a GC root to the "
"code generator, and allows some metadata to be associated with it."
msgstr ""

#: ../../../LangRef.rst:14075
msgid ""
"The first argument specifies the address of a stack object that contains the "
"root pointer. The second pointer (which must be either a constant or a "
"global value address) contains the meta-data to be associated with the root."
msgstr ""

#: ../../../LangRef.rst:14083
msgid ""
"At runtime, a call to this intrinsic stores a null pointer into the "
"\"ptrloc\" location. At compile-time, the code generator generates "
"information to allow the runtime to find the pointer at GC safe points. The "
"'``llvm.gcroot``' intrinsic may only be used in a function which :ref:"
"`specifies a GC algorithm <gc>`."
msgstr ""

#: ../../../LangRef.rst:14092
msgid "'``llvm.gcread``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14104
msgid ""
"The '``llvm.gcread``' intrinsic identifies reads of references from heap "
"locations, allowing garbage collector implementations that require read "
"barriers."
msgstr ""

#: ../../../LangRef.rst:14111
msgid ""
"The second argument is the address to read from, which should be an address "
"allocated from the garbage collector. The first object is a pointer to the "
"start of the referenced object, if needed by the language runtime (otherwise "
"null)."
msgstr ""

#: ../../../LangRef.rst:14119
msgid ""
"The '``llvm.gcread``' intrinsic has the same semantics as a load "
"instruction, but may be replaced with substantially more complex code by the "
"garbage collector runtime, as needed. The '``llvm.gcread``' intrinsic may "
"only be used in a function which :ref:`specifies a GC algorithm <gc>`."
msgstr ""

#: ../../../LangRef.rst:14128
msgid "'``llvm.gcwrite``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14140
msgid ""
"The '``llvm.gcwrite``' intrinsic identifies writes of references to heap "
"locations, allowing garbage collector implementations that require write "
"barriers (such as generational or reference counting collectors)."
msgstr ""

#: ../../../LangRef.rst:14147
msgid ""
"The first argument is the reference to store, the second is the start of the "
"object to store it to, and the third is the address of the field of Obj to "
"store to. If the runtime does not require a pointer to the object, Obj may "
"be null."
msgstr ""

#: ../../../LangRef.rst:14155
msgid ""
"The '``llvm.gcwrite``' intrinsic has the same semantics as a store "
"instruction, but may be replaced with substantially more complex code by the "
"garbage collector runtime, as needed. The '``llvm.gcwrite``' intrinsic may "
"only be used in a function which :ref:`specifies a GC algorithm <gc>`."
msgstr ""

#: ../../../LangRef.rst:14165
msgid "'``llvm.experimental.gc.statepoint``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14182
msgid ""
"The statepoint intrinsic represents a call which is parse-able by the "
"runtime."
msgstr ""

#: ../../../LangRef.rst:14186 ../../../LangRef.rst:14281
#: ../../../LangRef.rst:14320 ../../../LangRef.rst:14379
#: ../../../LangRef.rst:14418
msgid "Operands:"
msgstr ""

#: ../../../LangRef.rst:14188
msgid ""
"The 'id' operand is a constant integer that is reported as the ID field in "
"the generated stackmap.  LLVM does not interpret this parameter in any way "
"and its meaning is up to the statepoint user to decide.  Note that LLVM is "
"free to duplicate code containing statepoint calls, and this may transform "
"IR that had a unique 'id' per lexical call to statepoint to IR that does not."
msgstr ""

#: ../../../LangRef.rst:14195
msgid ""
"If 'num patch bytes' is non-zero then the call instruction corresponding to "
"the statepoint is not emitted and LLVM emits 'num patch bytes' bytes of nops "
"in its place.  LLVM will emit code to prepare the function arguments and "
"retrieve the function return value in accordance to the calling convention; "
"the former before the nop sequence and the latter after the nop sequence.  "
"It is expected that the user will patch over the 'num patch bytes' bytes of "
"nops with a calling sequence specific to their runtime before executing the "
"generated machine code.  There are no guarantees with respect to the "
"alignment of the nop sequence.  Unlike :doc:`StackMaps` statepoints do not "
"have a concept of shadow bytes.  Note that semantically the statepoint still "
"represents a call or invoke to 'target', and the nop sequence after patching "
"is expected to represent an operation equivalent to a call or invoke to "
"'target'."
msgstr ""

#: ../../../LangRef.rst:14210
msgid ""
"The 'target' operand is the function actually being called. The operand must "
"have an :ref:`elementtype <attr_elementtype>` attribute specifying the "
"function type of the target. The target can be specified as either a "
"symbolic LLVM function, or as an arbitrary Value of pointer type. Note that "
"the function type must match the signature of the callee and the types of "
"the 'call parameters' arguments."
msgstr ""

#: ../../../LangRef.rst:14217
msgid ""
"The '#call args' operand is the number of arguments to the actual call.  It "
"must exactly match the number of arguments passed in the 'call parameters' "
"variable-length section."
msgstr ""

#: ../../../LangRef.rst:14221
msgid ""
"The 'flags' operand is used to specify extra information about the "
"statepoint. This is currently only used to mark certain statepoints as GC "
"transitions. This operand is a 64-bit integer with the following layout, "
"where bit 0 is the least significant bit:"
msgstr ""

#: ../../../LangRef.rst:14227 ../../../LangRef.rst:29639
msgid "Bit #"
msgstr ""

#: ../../../LangRef.rst:14227
msgid "Usage"
msgstr ""

#: ../../../LangRef.rst:14229
msgid "Set if the statepoint is a GC transition, cleared otherwise."
msgstr ""

#: ../../../LangRef.rst:14232
msgid "1-63"
msgstr ""

#: ../../../LangRef.rst:14232
msgid "Reserved for future use; must be cleared."
msgstr ""

#: ../../../LangRef.rst:14235
msgid ""
"The 'call parameters' arguments are simply the arguments which need to be "
"passed to the call target.  They will be lowered according to the specified "
"calling convention and otherwise handled like a normal call instruction.  "
"The number of arguments must exactly match what is specified in '# call "
"args'.  The types must match the signature of 'target'."
msgstr ""

#: ../../../LangRef.rst:14242
msgid ""
"The 'call parameter' attributes must be followed by two 'i64 0' constants. "
"These were originally the length prefixes for 'gc transition parameter' and "
"'deopt parameter' arguments, but the role of these parameter sets have been "
"entirely replaced with the corresponding operand bundles.  In a future "
"revision, these now redundant arguments will be removed."
msgstr ""

#: ../../../LangRef.rst:14251
msgid ""
"A statepoint is assumed to read and write all memory.  As a result, memory "
"operations can not be reordered past a statepoint.  It is illegal to mark a "
"statepoint as being either 'readonly' or 'readnone'."
msgstr ""

#: ../../../LangRef.rst:14255
msgid ""
"Note that legal IR can not perform any memory operation on a 'gc pointer' "
"argument of the statepoint in a location statically reachable from the "
"statepoint.  Instead, the explicitly relocated value (from a ``gc."
"relocate``) must be used."
msgstr ""

#: ../../../LangRef.rst:14261
msgid "'``llvm.experimental.gc.result``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14274
msgid ""
"``gc.result`` extracts the result of the original call instruction which was "
"replaced by the ``gc.statepoint``.  The ``gc.result`` intrinsic is actually "
"a family of three intrinsics due to an implementation limitation.  Other "
"than the type of the return value, the semantics are the same."
msgstr ""

#: ../../../LangRef.rst:14283
msgid ""
"The first and only argument is the ``gc.statepoint`` which starts the "
"safepoint sequence of which this ``gc.result`` is a part. Despite the typing "
"of this as a generic token, *only* the value defined by a ``gc.statepoint`` "
"is legal here."
msgstr ""

#: ../../../LangRef.rst:14291
msgid ""
"The ``gc.result`` represents the return value of the call target of the "
"``statepoint``.  The type of the ``gc.result`` must exactly match the type "
"of the target.  If the call target returns void, there will be no ``gc."
"result``."
msgstr ""

#: ../../../LangRef.rst:14296
msgid ""
"A ``gc.result`` is modeled as a 'readnone' pure function.  It has no side "
"effects since it is just a projection of the return value of the previous "
"call represented by the ``gc.statepoint``."
msgstr ""

#: ../../../LangRef.rst:14301
msgid "'``llvm.experimental.gc.relocate``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14316
msgid ""
"A ``gc.relocate`` returns the potentially relocated value of a pointer at "
"the safepoint."
msgstr ""

#: ../../../LangRef.rst:14322
msgid ""
"The first argument is the ``gc.statepoint`` which starts the safepoint "
"sequence of which this ``gc.relocation`` is a part. Despite the typing of "
"this as a generic token, *only* the value defined by a ``gc.statepoint`` is "
"legal here."
msgstr ""

#: ../../../LangRef.rst:14327
msgid ""
"The second and third arguments are both indices into operands of the "
"corresponding statepoint's :ref:`gc-live <ob_gc_live>` operand bundle."
msgstr ""

#: ../../../LangRef.rst:14330
msgid ""
"The second argument is an index which specifies the allocation for the "
"pointer being relocated. The associated value must be within the object with "
"which the pointer being relocated is associated. The optimizer is free to "
"change *which* interior derived pointer is reported, provided that it does "
"not replace an actual base pointer with another interior derived pointer. "
"Collectors are allowed to rely on the base pointer operand remaining an "
"actual base pointer if so constructed."
msgstr ""

#: ../../../LangRef.rst:14338
msgid ""
"The third argument is an index which specify the (potentially) derived "
"pointer being relocated.  It is legal for this index to be the same as the "
"second argument if and only if a base pointer is being relocated."
msgstr ""

#: ../../../LangRef.rst:14345
msgid ""
"The return value of ``gc.relocate`` is the potentially relocated value of "
"the pointer specified by its arguments.  It is unspecified how the value of "
"the returned pointer relates to the argument to the ``gc.statepoint`` other "
"than that a) it points to the same source language object with the same "
"offset, and b) the 'based-on' relationship of the newly relocated pointers "
"is a projection of the unrelocated pointers.  In particular, the integer "
"value of the pointer returned is unspecified."
msgstr ""

#: ../../../LangRef.rst:14354
msgid ""
"A ``gc.relocate`` is modeled as a ``readnone`` pure function.  It has no "
"side effects since it is just a way to extract information about work done "
"during the actual call modeled by the ``gc.statepoint``."
msgstr ""

#: ../../../LangRef.rst:14361
msgid "'``llvm.experimental.gc.get.pointer.base``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14376
msgid "``gc.get.pointer.base`` for a derived pointer returns its base pointer."
msgstr ""

#: ../../../LangRef.rst:14381 ../../../LangRef.rst:14420
msgid ""
"The only argument is a pointer which is based on some object with an unknown "
"offset from the base of said object."
msgstr ""

#: ../../../LangRef.rst:14387
msgid ""
"This intrinsic is used in the abstract machine model for GC to represent the "
"base pointer for an arbitrary derived pointer."
msgstr ""

#: ../../../LangRef.rst:14390 ../../../LangRef.rst:14429
msgid ""
"This intrinsic is inlined by the :ref:`RewriteStatepointsForGC` pass by "
"replacing all uses of this callsite with the offset of a derived pointer "
"from its base pointer value. The replacement is done as part of the lowering "
"to the explicit statepoint model."
msgstr ""

#: ../../../LangRef.rst:14395
msgid "The return pointer type must be the same as the type of the parameter."
msgstr ""

#: ../../../LangRef.rst:14399
msgid "'``llvm.experimental.gc.get.pointer.offset``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14414
msgid ""
"``gc.get.pointer.offset`` for a derived pointer returns the offset from its "
"base pointer."
msgstr ""

#: ../../../LangRef.rst:14426
msgid ""
"This intrinsic is used in the abstract machine model for GC to represent the "
"offset of an arbitrary derived pointer from its base pointer."
msgstr ""

#: ../../../LangRef.rst:14434
msgid ""
"Basically this call calculates difference between the derived pointer and "
"its base pointer (see :ref:`gc.get.pointer.base`) both ptrtoint casted. But "
"this cast done outside the :ref:`RewriteStatepointsForGC` pass could result "
"in the pointers lost for further lowering from the abstract model to the "
"explicit physical one."
msgstr ""

#: ../../../LangRef.rst:14441
msgid "Code Generator Intrinsics"
msgstr ""

#: ../../../LangRef.rst:14443
msgid ""
"These intrinsics are provided by LLVM to expose special features that may "
"only be implemented with code generator support."
msgstr ""

#: ../../../LangRef.rst:14447
msgid "'``llvm.returnaddress``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14459
msgid ""
"The '``llvm.returnaddress``' intrinsic attempts to compute a target-specific "
"value indicating the return address of the current function or one of its "
"callers."
msgstr ""

#: ../../../LangRef.rst:14466
msgid ""
"The argument to this intrinsic indicates which function to return the "
"address for. Zero indicates the calling function, one indicates its caller, "
"etc. The argument is **required** to be a constant integer value."
msgstr ""

#: ../../../LangRef.rst:14474
msgid ""
"The '``llvm.returnaddress``' intrinsic either returns a pointer indicating "
"the return address of the specified call frame, or zero if it cannot be "
"identified. The value returned by this intrinsic is likely to be incorrect "
"or 0 for arguments other than zero, so it should only be used for debugging "
"purposes."
msgstr ""

#: ../../../LangRef.rst:14480 ../../../LangRef.rst:14504
#: ../../../LangRef.rst:14564
msgid ""
"Note that calling this intrinsic does not prevent function inlining or other "
"aggressive transformations, so the value returned may not be that of the "
"obvious source-language caller."
msgstr ""

#: ../../../LangRef.rst:14485
msgid "'``llvm.addressofreturnaddress``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14497
msgid ""
"The '``llvm.addressofreturnaddress``' intrinsic returns a target-specific "
"pointer to the place in the stack frame where the return address of the "
"current function is stored."
msgstr ""

#: ../../../LangRef.rst:14508
msgid "This intrinsic is only implemented for x86 and aarch64."
msgstr ""

#: ../../../LangRef.rst:14511
msgid "'``llvm.sponentry``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14523
msgid ""
"The '``llvm.sponentry``' intrinsic returns the stack pointer value at the "
"entry of the current function calling this intrinsic."
msgstr ""

#: ../../../LangRef.rst:14529
msgid "Note this intrinsic is only verified on AArch64 and ARM."
msgstr ""

#: ../../../LangRef.rst:14532
msgid "'``llvm.frameaddress``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14544
msgid ""
"The '``llvm.frameaddress``' intrinsic attempts to return the target-specific "
"frame pointer value for the specified stack frame."
msgstr ""

#: ../../../LangRef.rst:14550
msgid ""
"The argument to this intrinsic indicates which function to return the frame "
"pointer for. Zero indicates the calling function, one indicates its caller, "
"etc. The argument is **required** to be a constant integer value."
msgstr ""

#: ../../../LangRef.rst:14558
msgid ""
"The '``llvm.frameaddress``' intrinsic either returns a pointer indicating "
"the frame address of the specified call frame, or zero if it cannot be "
"identified. The value returned by this intrinsic is likely to be incorrect "
"or 0 for arguments other than zero, so it should only be used for debugging "
"purposes."
msgstr ""

#: ../../../LangRef.rst:14569
msgid "'``llvm.swift.async.context.addr``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14581
msgid ""
"The '``llvm.swift.async.context.addr``' intrinsic returns a pointer to the "
"part of the extended frame record containing the asynchronous context of a "
"Swift execution."
msgstr ""

#: ../../../LangRef.rst:14588
msgid ""
"If the caller has a ``swiftasync`` parameter, that argument will initially "
"be stored at the returned address. If not, it will be initialized to null."
msgstr ""

#: ../../../LangRef.rst:14592
msgid "'``llvm.localescape``' and '``llvm.localrecover``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:14605
msgid ""
"The '``llvm.localescape``' intrinsic escapes offsets of a collection of "
"static allocas, and the '``llvm.localrecover``' intrinsic applies those "
"offsets to a live frame pointer to recover the address of the allocation. "
"The offset is computed during frame layout of the caller of ``llvm."
"localescape``."
msgstr ""

#: ../../../LangRef.rst:14613
msgid ""
"All arguments to '``llvm.localescape``' must be pointers to static allocas "
"or casts of static allocas. Each function can only call '``llvm."
"localescape``' once, and it can only do so from the entry block."
msgstr ""

#: ../../../LangRef.rst:14617
msgid ""
"The ``func`` argument to '``llvm.localrecover``' must be a constant "
"bitcasted pointer to a function defined in the current module. The code "
"generator cannot determine the frame allocation offset of functions defined "
"in other modules."
msgstr ""

#: ../../../LangRef.rst:14622
msgid ""
"The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a "
"call frame that is currently live. The return value of '``llvm."
"localaddress``' is one way to produce such a value, but various runtimes "
"also expose a suitable pointer in platform-specific ways."
msgstr ""

#: ../../../LangRef.rst:14627
msgid ""
"The ``idx`` argument to '``llvm.localrecover``' indicates which alloca "
"passed to '``llvm.localescape``' to recover. It is zero-indexed."
msgstr ""

#: ../../../LangRef.rst:14633
msgid ""
"These intrinsics allow a group of functions to share access to a set of "
"local stack allocations of a one parent function. The parent function may "
"call the '``llvm.localescape``' intrinsic once from the function entry "
"block, and the child functions can use '``llvm.localrecover``' to access the "
"escaped allocas. The '``llvm.localescape``' intrinsic blocks inlining, as "
"inlining changes where the escaped allocas are allocated, which would break "
"attempts to use '``llvm.localrecover``'."
msgstr ""

#: ../../../LangRef.rst:14642
msgid "'``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:14655
msgid ""
"The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark the "
"boundary of a _try region for Windows SEH Asynchronous Exception Handling."
msgstr ""

#: ../../../LangRef.rst:14661
msgid ""
"When a C-function is compiled with Windows SEH Asynchronous Exception "
"option, -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to "
"mark _try boundary and to prevent potential exceptions from being moved "
"across boundary. Any set of operations can then be confined to the region by "
"reading their leaf inputs via volatile loads and writing their root outputs "
"via volatile stores."
msgstr ""

#: ../../../LangRef.rst:14668
msgid "'``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:14681
msgid ""
"The '``llvm.seh.scope.begin``' and '``llvm.seh.scope.end``' intrinsics mark "
"the boundary of a CPP object lifetime for Windows SEH Asynchronous Exception "
"Handling (MSVC option -EHa)."
msgstr ""

#: ../../../LangRef.rst:14688
msgid ""
"LLVM's ordinary exception-handling representation associates EH cleanups and "
"handlers only with ``invoke``s, which normally correspond only to call "
"sites.  To support arbitrary faulting instructions, it must be possible to "
"recover the current EH scope for any instruction.  Turning every operation "
"in LLVM that could fault into an ``invoke`` of a new, potentially-throwing "
"intrinsic would require adding a large number of intrinsics, impede "
"optimization of those operations, and make compilation slower by introducing "
"many extra basic blocks.  These intrinsics can be used instead to mark the "
"region protected by a cleanup, such as for a local C++ object with a non-"
"trivial destructor.  ``llvm.seh.scope.begin`` is used to mark the start of "
"the region; it is always called with ``invoke``, with the unwind block being "
"the desired unwind destination for any potentially-throwing instructions "
"within the region.  `llvm.seh.scope.end` is used to mark when the scope ends "
"and the EH cleanup is no longer required (e.g. because the destructor is "
"being called)."
msgstr ""

#: ../../../LangRef.rst:14708
msgid ""
"'``llvm.read_register``', '``llvm.read_volatile_register``', and '``llvm."
"write_register``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:14726
msgid ""
"The '``llvm.read_register``', '``llvm.read_volatile_register``', and '``llvm."
"write_register``' intrinsics provide access to the named register. The "
"register must be valid on the architecture being compiled to. The type needs "
"to be compatible with the register being read."
msgstr ""

#: ../../../LangRef.rst:14734
msgid ""
"The '``llvm.read_register``' and '``llvm.read_volatile_register``' "
"intrinsics return the current value of the register, where possible. The "
"'``llvm.write_register``' intrinsic sets the current value of the register, "
"where possible."
msgstr ""

#: ../../../LangRef.rst:14739
msgid ""
"A call to '``llvm.read_volatile_register``' is assumed to have side-effects "
"and possibly return a different value each time (e.g. for a timer register)."
msgstr ""

#: ../../../LangRef.rst:14742
msgid ""
"This is useful to implement named register global variables that need to "
"always be mapped to a specific register, as is common practice on bare-metal "
"programs including OS kernels."
msgstr ""

#: ../../../LangRef.rst:14746
msgid ""
"The compiler doesn't check for register availability or use of the used "
"register in surrounding code, including inline assembly. Because of that, "
"allocatable registers are not supported."
msgstr ""

#: ../../../LangRef.rst:14750
msgid ""
"Warning: So far it only works with the stack pointer on selected "
"architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of work "
"is needed to support other registers and even more so, allocatable registers."
msgstr ""

#: ../../../LangRef.rst:14758
msgid "'``llvm.stacksave``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14771
msgid ""
"The '``llvm.stacksave``' intrinsic is used to remember the current state of "
"the function stack, for use with :ref:`llvm.stackrestore "
"<int_stackrestore>`. This is useful for implementing language features like "
"scoped automatic variable sized arrays in C99."
msgstr ""

#: ../../../LangRef.rst:14780
msgid ""
"This intrinsic returns an opaque pointer value that can be passed to :ref:"
"`llvm.stackrestore <int_stackrestore>`. When an ``llvm.stackrestore`` "
"intrinsic is executed with a value saved from ``llvm.stacksave``, it "
"effectively restores the state of the stack to the state it was in when the "
"``llvm.stacksave`` intrinsic executed. In practice, this pops any :ref:"
"`alloca <i_alloca>` blocks from the stack that were allocated after the "
"``llvm.stacksave`` was executed. The address space should typically be the :"
"ref:`alloca address space <alloca_addrspace>`."
msgstr ""

#: ../../../LangRef.rst:14793
msgid "'``llvm.stackrestore``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14806
msgid ""
"The '``llvm.stackrestore``' intrinsic is used to restore the state of the "
"function stack to the state it was in when the corresponding :ref:`llvm."
"stacksave <int_stacksave>` intrinsic executed. This is useful for "
"implementing language features like scoped automatic variable sized arrays "
"in C99. The address space should typically be the :ref:`alloca address space "
"<alloca_addrspace>`."
msgstr ""

#: ../../../LangRef.rst:14816
msgid "See the description for :ref:`llvm.stacksave <int_stacksave>`."
msgstr ""

#: ../../../LangRef.rst:14821
msgid "'``llvm.get.dynamic.area.offset``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14834
msgid ""
"The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to get the "
"offset from native stack pointer to the address of the most recent dynamic "
"alloca on the caller's stack. These intrinsics are intended for use in "
"combination with :ref:`llvm.stacksave <int_stacksave>` to get a pointer to "
"the most recent dynamic alloca. This is useful, for example, for "
"AddressSanitizer's stack unpoisoning routines."
msgstr ""

#: ../../../LangRef.rst:14845
msgid ""
"These intrinsics return a non-negative integer value that can be used to get "
"the address of the most recent dynamic alloca, allocated by :ref:`alloca "
"<i_alloca>` on the caller's stack. In particular, for targets where stack "
"grows downwards, adding this offset to the native stack pointer would get "
"the address of the most recent dynamic alloca. For targets where stack grows "
"upwards, the situation is a bit more complicated, because subtracting this "
"value from stack pointer would get the address one past the end of the most "
"recent dynamic alloca."
msgstr ""

#: ../../../LangRef.rst:14853
msgid ""
"Although for most targets `llvm.get.dynamic.area.offset "
"<int_get_dynamic_area_offset>` returns just a zero, for others, such as "
"PowerPC and PowerPC64, it returns a compile-time-known constant value."
msgstr ""

#: ../../../LangRef.rst:14857
msgid ""
"The return value type of :ref:`llvm.get.dynamic.area.offset "
"<int_get_dynamic_area_offset>` must match the target's :ref:`alloca address "
"space <alloca_addrspace>` type."
msgstr ""

#: ../../../LangRef.rst:14863
msgid "'``llvm.prefetch``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14875
msgid ""
"The '``llvm.prefetch``' intrinsic is a hint to the code generator to insert "
"a prefetch instruction if supported; otherwise, it is a noop. Prefetches "
"have no effect on the behavior of the program but can change its performance "
"characteristics."
msgstr ""

#: ../../../LangRef.rst:14883
msgid ""
"``address`` is the address to be prefetched, ``rw`` is the specifier "
"determining if the fetch should be for a read (0) or write (1), and "
"``locality`` is a temporal locality specifier ranging from (0) - no "
"locality, to (3) - extremely local keep in cache. The ``cache type`` "
"specifies whether the prefetch is performed on the data (1) or instruction "
"(0) cache. The ``rw``, ``locality`` and ``cache type`` arguments must be "
"constant integers."
msgstr ""

#: ../../../LangRef.rst:14894
msgid ""
"This intrinsic does not modify the behavior of the program. In particular, "
"prefetches cannot trap and do not produce a value. On targets that support "
"this intrinsic, the prefetch can provide hints to the processor cache for "
"better performance."
msgstr ""

#: ../../../LangRef.rst:14900
msgid "'``llvm.pcmarker``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14912
msgid ""
"The '``llvm.pcmarker``' intrinsic is a method to export a Program Counter "
"(PC) in a region of code to simulators and other tools. The method is target "
"specific, but it is expected that the marker will use exported symbols to "
"transmit the PC of the marker. The marker makes no guarantees that it will "
"remain with any specific instruction after optimizations. It is possible "
"that the presence of a marker will inhibit optimizations. The intended use "
"is to be inserted after optimizations to allow correlations of simulation "
"runs."
msgstr ""

#: ../../../LangRef.rst:14924
msgid "``id`` is a numerical id identifying the marker."
msgstr ""

#: ../../../LangRef.rst:14929
msgid ""
"This intrinsic does not modify the behavior of the program. Backends that do "
"not support this intrinsic may ignore it."
msgstr ""

#: ../../../LangRef.rst:14933
msgid "'``llvm.readcyclecounter``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14945
msgid ""
"The '``llvm.readcyclecounter``' intrinsic provides access to the cycle "
"counter register (or similar low latency, high accuracy clocks) on those "
"targets that support it. On X86, it should map to RDTSC. On Alpha, it should "
"map to RPCC. As the backing counters overflow quickly (on the order of 9 "
"seconds on alpha), this should only be used for small timings."
msgstr ""

#: ../../../LangRef.rst:14955
msgid ""
"When directly supported, reading the cycle counter should not modify any "
"memory. Implementations are allowed to either return an application specific "
"value or a system wide value. On backends without support, this is lowered "
"to a constant 0."
msgstr ""

#: ../../../LangRef.rst:14960
msgid ""
"Note that runtime support may be conditional on the privilege-level code is "
"running at and the host platform."
msgstr ""

#: ../../../LangRef.rst:14964
msgid "'``llvm.readsteadycounter``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:14976
msgid ""
"The '``llvm.readsteadycounter``' intrinsic provides access to the fixed "
"frequency clock on targets that support it. Unlike '``llvm."
"readcyclecounter``', this clock is expected to tick at a constant rate, "
"making it suitable for measuring elapsed time. The actual frequency of the "
"clock is implementation defined."
msgstr ""

#: ../../../LangRef.rst:14985
msgid ""
"When directly supported, reading the steady counter should not modify any "
"memory. Implementations are allowed to either return an application specific "
"value or a system wide value. On backends without support, this is lowered "
"to a constant 0."
msgstr ""

#: ../../../LangRef.rst:14991
msgid "'``llvm.clear_cache``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15003
msgid ""
"The '``llvm.clear_cache``' intrinsic ensures visibility of modifications in "
"the specified range to the execution unit of the processor. On targets with "
"non-unified instruction and data cache, the implementation flushes the "
"instruction cache."
msgstr ""

#: ../../../LangRef.rst:15011
msgid ""
"On platforms with coherent instruction and data caches (e.g. x86), this "
"intrinsic is a nop. On platforms with non-coherent instruction and data "
"cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate "
"instructions or a system call, if cache flushing requires special privileges."
msgstr ""

#: ../../../LangRef.rst:15017
msgid ""
"The default behavior is to emit a call to ``__clear_cache`` from the run "
"time library."
msgstr ""

#: ../../../LangRef.rst:15020
msgid ""
"This intrinsic does *not* empty the instruction pipeline. Modifications of "
"the current function are outside the scope of the intrinsic."
msgstr ""

#: ../../../LangRef.rst:15024
msgid "'``llvm.instrprof.increment``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15037
msgid ""
"The '``llvm.instrprof.increment``' intrinsic can be emitted by a frontend "
"for use with instrumentation-based profiling. These will be lowered by the "
"``-instrprof`` pass to generate execution counts of a program at runtime."
msgstr ""

#: ../../../LangRef.rst:15045 ../../../LangRef.rst:15294
#: ../../../LangRef.rst:15338
msgid ""
"The first argument is a pointer to a global variable containing the name of "
"the entity being instrumented. This should generally be the (mangled) "
"function name for a set of counters."
msgstr ""

#: ../../../LangRef.rst:15049
msgid ""
"The second argument is a hash value that can be used by the consumer of the "
"profile data to detect changes to the instrumented source, and the third is "
"the number of counters associated with ``name``. It is an error if ``hash`` "
"or ``num-counters`` differ between two instances of ``instrprof.increment`` "
"that refer to the same name."
msgstr ""

#: ../../../LangRef.rst:15055
msgid ""
"The last argument refers to which of the counters for ``name`` should be "
"incremented. It should be a value between 0 and ``num-counters``."
msgstr ""

#: ../../../LangRef.rst:15061
msgid ""
"This intrinsic represents an increment of a profiling counter. It will cause "
"the ``-instrprof`` pass to generate the appropriate data structures and the "
"code to increment the appropriate value, in a format that can be written out "
"by a compiler runtime and consumed via the ``llvm-profdata`` tool."
msgstr ""

#: ../../../LangRef.rst:15070
msgid ""
"The intrinsic is lowered differently for contextual profiling by the ``-ctx-"
"instr-lower`` pass. Here:"
msgstr ""

#: ../../../LangRef.rst:15073
msgid ""
"the entry basic block increment counter is lowered as a call to compiler-rt, "
"to either ``__llvm_ctx_profile_start_context`` or "
"``__llvm_ctx_profile_get_context``. Either returns a pointer to a context "
"object which contains a buffer into which counter increments can happen. "
"Note that the pointer value returned by compiler-rt may have its LSB set - "
"counter increments happen offset from the address with the LSB cleared."
msgstr ""

#: ../../../LangRef.rst:15080
msgid ""
"all the other lowerings of ``llvm.instrprof.increment[.step]`` happen within "
"that context."
msgstr ""

#: ../../../LangRef.rst:15083
msgid ""
"the context is assumed to be a local value to the function, and no "
"concurrency concerns need to be handled by LLVM."
msgstr ""

#: ../../../LangRef.rst:15087
msgid "'``llvm.instrprof.increment.step``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15101
msgid ""
"The '``llvm.instrprof.increment.step``' intrinsic is an extension to the "
"'``llvm.instrprof.increment``' intrinsic with an additional fifth argument "
"to specify the step of the increment."
msgstr ""

#: ../../../LangRef.rst:15107
msgid ""
"The first four arguments are the same as '``llvm.instrprof.increment``' "
"intrinsic."
msgstr ""

#: ../../../LangRef.rst:15110
msgid ""
"The last argument specifies the value of the increment of the counter "
"variable."
msgstr ""

#: ../../../LangRef.rst:15114
msgid "See description of '``llvm.instrprof.increment``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:15117
msgid "'``llvm.instrprof.callsite``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15131
msgid ""
"The '``llvm.instrprof.callsite``' intrinsic should be emitted before a "
"callsite that's not to a \"fake\" callee (like another intrinsic or asm). It "
"is used by contextual profiling and has side-effects. Its lowering happens "
"in IR, and target-specific backends should never encounter it."
msgstr ""

#: ../../../LangRef.rst:15138
msgid ""
"The first 4 arguments are similar to ``llvm.instrprof.increment``. The "
"indexing is specific to callsites, meaning callsites are indexed from 0, "
"independent from the indexes used by the other intrinsics (such as ``llvm."
"instrprof.increment[.step]``)."
msgstr ""

#: ../../../LangRef.rst:15143
msgid ""
"The last argument is the called value of the callsite this intrinsic "
"precedes."
msgstr ""

#: ../../../LangRef.rst:15148
msgid ""
"This is lowered by contextual profiling. In contextual profiling, functions "
"get, from compiler-rt, a pointer to a context object. The context object "
"consists of a buffer LLVM can use to perform counter increments (i.e., the "
"lowering of ``llvm.instrprof.increment[.step]``. The address range following "
"the counter buffer, ``<num-counters>`` x ``sizeof(ptr)`` - sized, is "
"expected to contain pointers to contexts of functions called from this "
"function (\"subcontexts\"). LLVM does not dereference into that memory "
"region, just calculates GEPs."
msgstr ""

#: ../../../LangRef.rst:15156
msgid "The lowering of ``llvm.instrprof.callsite`` consists of:"
msgstr ""

#: ../../../LangRef.rst:15158
msgid ""
"write to ``__llvm_ctx_profile_expected_callee`` the ``<callsite>`` value;"
msgstr ""

#: ../../../LangRef.rst:15160
msgid ""
"write to ``__llvm_ctx_profile_callsite`` the address into this function's "
"context of the ``<index>`` position into the subcontexts region."
msgstr ""

#: ../../../LangRef.rst:15164
msgid ""
"``__llvm_ctx_profile_{expected_callee|callsite}`` are initialized by "
"compiler-rt and are TLS. They are both vectors of pointers of size 2. The "
"index into each is determined when the current function obtains the pointer "
"to its context from compiler-rt. The pointer's LSB gives the index."
msgstr ""

#: ../../../LangRef.rst:15171
msgid "'``llvm.instrprof.timestamp``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15184
msgid ""
"The '``llvm.instrprof.timestamp``' intrinsic is used to implement temporal "
"profiling."
msgstr ""

#: ../../../LangRef.rst:15189
msgid ""
"The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` "
"is expected to always be zero."
msgstr ""

#: ../../../LangRef.rst:15194
msgid ""
"Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores a "
"timestamp representing when this function was executed for the first time."
msgstr ""

#: ../../../LangRef.rst:15198
msgid "'``llvm.instrprof.cover``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15211
msgid ""
"The '``llvm.instrprof.cover``' intrinsic is used to implement coverage "
"instrumentation."
msgstr ""

#: ../../../LangRef.rst:15216
msgid ""
"The arguments are the same as the first four arguments of '``llvm.instrprof."
"increment``'."
msgstr ""

#: ../../../LangRef.rst:15221
msgid ""
"Similar to the '``llvm.instrprof.increment``' intrinsic, but it stores zero "
"to the profiling variable to signify that the function has been covered. We "
"store zero because this is more efficient on some targets."
msgstr ""

#: ../../../LangRef.rst:15226
msgid "'``llvm.instrprof.value.profile``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15240
msgid ""
"The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a "
"frontend for use with instrumentation-based profiling. This will be lowered "
"by the ``-instrprof`` pass to find out the target values, instrumented "
"expressions take in a program at runtime."
msgstr ""

#: ../../../LangRef.rst:15248
msgid ""
"The first argument is a pointer to a global variable containing the name of "
"the entity being instrumented. ``name`` should generally be the (mangled) "
"function name for a set of counters."
msgstr ""

#: ../../../LangRef.rst:15252
msgid ""
"The second argument is a hash value that can be used by the consumer of the "
"profile data to detect changes to the instrumented source. It is an error if "
"``hash`` differs between two instances of ``llvm.instrprof.*`` that refer to "
"the same name."
msgstr ""

#: ../../../LangRef.rst:15257
msgid ""
"The third argument is the value of the expression being profiled. The "
"profiled expression's value should be representable as an unsigned 64-bit "
"value. The fourth argument represents the kind of value profiling that is "
"being done. The supported value profiling kinds are enumerated through the "
"``InstrProfValueKind`` type declared in the ``<include/llvm/ProfileData/"
"InstrProf.h>`` header file. The last argument is the index of the "
"instrumented expression within ``name``. It should be >= 0."
msgstr ""

#: ../../../LangRef.rst:15268
msgid ""
"This intrinsic represents the point where a call to a runtime routine should "
"be inserted for value profiling of target expressions. ``-instrprof`` pass "
"will generate the appropriate data structures and replace the ``llvm."
"instrprof.value.profile`` intrinsic with the call to the profile runtime "
"library with proper arguments."
msgstr ""

#: ../../../LangRef.rst:15275
msgid "'``llvm.instrprof.mcdc.parameters``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15288
msgid ""
"The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC "
"code coverage instrumentation for a function."
msgstr ""

#: ../../../LangRef.rst:15298 ../../../LangRef.rst:15342
msgid ""
"The second argument is a hash value that can be used by the consumer of the "
"profile data to detect changes to the instrumented source."
msgstr ""

#: ../../../LangRef.rst:15301
msgid ""
"The third argument is the number of bitmap bits required by the function to "
"record the number of test vectors executed for each boolean expression."
msgstr ""

#: ../../../LangRef.rst:15307
msgid ""
"This intrinsic represents basic MC/DC parameters initiating one or more MC/"
"DC instrumentation sequences in a function. It will cause the ``-instrprof`` "
"pass to generate the appropriate data structures and the code to instrument "
"MC/DC test vectors in a format that can be written out by a compiler runtime "
"and consumed via the ``llvm-profdata`` tool."
msgstr ""

#: ../../../LangRef.rst:15314
msgid "'``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15328
msgid ""
"The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/"
"DC test vector execution after each boolean expression has been fully "
"executed. The overall value of the condition bitmap, after it has been "
"successively updated with the true or false evaluation of each condition, "
"uniquely identifies an executed MC/DC test vector and is used as a bit index "
"into the global test vector bitmap."
msgstr ""

#: ../../../LangRef.rst:15345
msgid ""
"The third argument is the bit index into the global test vector bitmap "
"corresponding to the function."
msgstr ""

#: ../../../LangRef.rst:15348
msgid ""
"The fourth argument is the address of the condition bitmap, which contains a "
"value representing an executed MC/DC test vector. It is loaded and used as "
"the bit index of the test vector bitmap."
msgstr ""

#: ../../../LangRef.rst:15355
msgid ""
"This intrinsic represents the final operation of an MC/DC instrumentation "
"sequence and will cause the ``-instrprof`` pass to generate the code to "
"instrument an update of a function's global test vector bitmap to indicate "
"that a test vector has been executed. The global test vector bitmap can be "
"consumed by the ``llvm-profdata`` and ``llvm-cov`` tools."
msgstr ""

#: ../../../LangRef.rst:15362
msgid "'``llvm.thread.pointer``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15375
msgid ""
"The '``llvm.thread.pointer``' intrinsic returns the value of the thread "
"pointer."
msgstr ""

#: ../../../LangRef.rst:15381
msgid ""
"The '``llvm.thread.pointer``' intrinsic returns a pointer to the TLS area "
"for the current thread.  The exact semantics of this value are target "
"specific: it may point to the start of TLS area, to the end, or somewhere in "
"the middle.  Depending on the target, this intrinsic may read a register, "
"call a helper function, read from an alternate memory space, or perform "
"other operations necessary to locate the TLS area.  Not all targets support "
"this intrinsic.  The address space must be the :ref:`globals address space "
"<globals_addrspace>`."
msgstr ""

#: ../../../LangRef.rst:15391
msgid "'``llvm.call.preallocated.setup``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15403
msgid ""
"The '``llvm.call.preallocated.setup``' intrinsic returns a token which can "
"be used with a call's ``\"preallocated\"`` operand bundle to indicate that "
"certain arguments are allocated and initialized before the call."
msgstr ""

#: ../../../LangRef.rst:15410
msgid ""
"The '``llvm.call.preallocated.setup``' intrinsic returns a token which is "
"associated with at most one call. The token can be passed to '``@llvm.call."
"preallocated.arg``' to get a pointer to get that corresponding argument. The "
"token must be the parameter to a ``\"preallocated\"`` operand bundle for the "
"corresponding call."
msgstr ""

#: ../../../LangRef.rst:15416
msgid ""
"Nested calls to '``llvm.call.preallocated.setup``' are allowed, but must be "
"properly nested. e.g."
msgstr ""

#: ../../../LangRef.rst:15419 ../../../LangRef.rst:15428
msgid ":: code-block:: llvm"
msgstr ""

#: ../../../LangRef.rst:15421
msgid ""
"%t1 = call token @llvm.call.preallocated.setup(i32 0) %t2 = call token @llvm."
"call.preallocated.setup(i32 0) call void foo() [\"preallocated\"(token %t2)] "
"call void foo() [\"preallocated\"(token %t1)]"
msgstr ""

#: ../../../LangRef.rst:15426
msgid "is allowed, but not"
msgstr ""

#: ../../../LangRef.rst:15430
msgid ""
"%t1 = call token @llvm.call.preallocated.setup(i32 0) %t2 = call token @llvm."
"call.preallocated.setup(i32 0) call void foo() [\"preallocated\"(token %t1)] "
"call void foo() [\"preallocated\"(token %t2)]"
msgstr ""

#: ../../../LangRef.rst:15438
msgid "'``llvm.call.preallocated.arg``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15450
msgid ""
"The '``llvm.call.preallocated.arg``' intrinsic returns a pointer to the "
"corresponding preallocated argument for the preallocated call."
msgstr ""

#: ../../../LangRef.rst:15456
msgid ""
"The '``llvm.call.preallocated.arg``' intrinsic returns a pointer to the "
"``%arg_index``th argument with the ``preallocated`` attribute for the call "
"associated with the ``%setup_token``, which must be from '``llvm.call."
"preallocated.setup``'."
msgstr ""

#: ../../../LangRef.rst:15461
msgid ""
"A call to '``llvm.call.preallocated.arg``' must have a call site "
"``preallocated`` attribute. The type of the ``preallocated`` attribute must "
"match the type used by the ``preallocated`` attribute of the corresponding "
"argument at the preallocated call. The type is used in the case that an "
"``llvm.call.preallocated.setup`` does not have a corresponding call (e.g. "
"due to DCE), where otherwise we cannot know how large the arguments are."
msgstr ""

#: ../../../LangRef.rst:15468
msgid ""
"It is undefined behavior if this is called with a token from an '``llvm.call."
"preallocated.setup``' if another '``llvm.call.preallocated.setup``' has "
"already been called or if the preallocated call corresponding to the '``llvm."
"call.preallocated.setup``' has already been called."
msgstr ""

#: ../../../LangRef.rst:15477
msgid "'``llvm.call.preallocated.teardown``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15489
msgid ""
"The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack "
"created by a '``llvm.call.preallocated.setup``'."
msgstr ""

#: ../../../LangRef.rst:15495
msgid "The token argument must be a '``llvm.call.preallocated.setup``'."
msgstr ""

#: ../../../LangRef.rst:15497
msgid ""
"The '``llvm.call.preallocated.teardown``' intrinsic cleans up the stack "
"allocated by the corresponding '``llvm.call.preallocated.setup``'. Exactly "
"one of this or the preallocated call must be called to prevent stack leaks. "
"It is undefined behavior to call both a '``llvm.call.preallocated."
"teardown``' and the preallocated call for a given '``llvm.call.preallocated."
"setup``'."
msgstr ""

#: ../../../LangRef.rst:15503
msgid ""
"For example, if the stack is allocated for a preallocated call by a '``llvm."
"call.preallocated.setup``', then an initializer function called on an "
"allocated argument throws an exception, there should be a '``llvm.call."
"preallocated.teardown``' in the exception handler to prevent stack leaks."
msgstr ""

#: ../../../LangRef.rst:15509
msgid ""
"Following the nesting rules in '``llvm.call.preallocated.setup``', nested "
"calls to '``llvm.call.preallocated.setup``' and '``llvm.call.preallocated."
"teardown``' are allowed but must be properly nested."
msgstr ""

#: ../../../LangRef.rst:15533
msgid "Standard C/C++ Library Intrinsics"
msgstr ""

#: ../../../LangRef.rst:15535
msgid ""
"LLVM provides intrinsics for a few important standard C/C++ library "
"functions. These intrinsics allow source-language front-ends to pass "
"information about the alignment of the pointer arguments to the code "
"generator, providing opportunity for more efficient code generation."
msgstr ""

#: ../../../LangRef.rst:15543
msgid "'``llvm.abs.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15548
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.abs`` on any integer bit "
"width or any vector of integer elements."
msgstr ""

#: ../../../LangRef.rst:15559
msgid ""
"The '``llvm.abs``' family of intrinsic functions returns the absolute value "
"of an argument."
msgstr ""

#: ../../../LangRef.rst:15565
msgid ""
"The first argument is the value for which the absolute value is to be "
"returned. This argument may be of any integer type or a vector with integer "
"element type. The return type must match the first argument type."
msgstr ""

#: ../../../LangRef.rst:15569
msgid ""
"The second argument must be a constant and is a flag to indicate whether the "
"result value of the '``llvm.abs``' intrinsic is a :ref:`poison value "
"<poisonvalues>` if the first argument is statically or dynamically an "
"``INT_MIN`` value."
msgstr ""

#: ../../../LangRef.rst:15577
msgid ""
"The '``llvm.abs``' intrinsic returns the magnitude (always positive) of the "
"first argument or each element of a vector argument.\". If the first "
"argument is ``INT_MIN``, then the result is also ``INT_MIN`` if "
"``is_int_min_poison == 0`` and ``poison`` otherwise."
msgstr ""

#: ../../../LangRef.rst:15586
msgid "'``llvm.smax.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15591
msgid ""
"This is an overloaded intrinsic. You can use ``@llvm.smax`` on any integer "
"bit width or any vector of integer elements."
msgstr ""

#: ../../../LangRef.rst:15602
msgid ""
"Return the larger of ``%a`` and ``%b`` comparing the values as signed "
"integers. Vector intrinsics operate on a per-element basis. The larger "
"element of ``%a`` and ``%b`` at a given index is returned for that index."
msgstr ""

#: ../../../LangRef.rst:15609 ../../../LangRef.rst:15640
#: ../../../LangRef.rst:15671 ../../../LangRef.rst:15702
msgid ""
"The arguments (``%a`` and ``%b``) may be of any integer type or a vector "
"with integer element type. The argument types must match each other, and the "
"return type must match the argument type."
msgstr ""

#: ../../../LangRef.rst:15617
msgid "'``llvm.smin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15622
msgid ""
"This is an overloaded intrinsic. You can use ``@llvm.smin`` on any integer "
"bit width or any vector of integer elements."
msgstr ""

#: ../../../LangRef.rst:15633
msgid ""
"Return the smaller of ``%a`` and ``%b`` comparing the values as signed "
"integers. Vector intrinsics operate on a per-element basis. The smaller "
"element of ``%a`` and ``%b`` at a given index is returned for that index."
msgstr ""

#: ../../../LangRef.rst:15648
msgid "'``llvm.umax.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15653
msgid ""
"This is an overloaded intrinsic. You can use ``@llvm.umax`` on any integer "
"bit width or any vector of integer elements."
msgstr ""

#: ../../../LangRef.rst:15664
msgid ""
"Return the larger of ``%a`` and ``%b`` comparing the values as unsigned "
"integers. Vector intrinsics operate on a per-element basis. The larger "
"element of ``%a`` and ``%b`` at a given index is returned for that index."
msgstr ""

#: ../../../LangRef.rst:15679
msgid "'``llvm.umin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15684
msgid ""
"This is an overloaded intrinsic. You can use ``@llvm.umin`` on any integer "
"bit width or any vector of integer elements."
msgstr ""

#: ../../../LangRef.rst:15695
msgid ""
"Return the smaller of ``%a`` and ``%b`` comparing the values as unsigned "
"integers. Vector intrinsics operate on a per-element basis. The smaller "
"element of ``%a`` and ``%b`` at a given index is returned for that index."
msgstr ""

#: ../../../LangRef.rst:15709
msgid "'``llvm.scmp.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15714
msgid ""
"This is an overloaded intrinsic. You can use ``@llvm.scmp`` on any integer "
"bit width or any vector of integer elements."
msgstr ""

#: ../../../LangRef.rst:15725
msgid ""
"Return ``-1`` if ``%a`` is signed less than ``%b``, ``0`` if they are equal, "
"and ``1`` if ``%a`` is signed greater than ``%b``. Vector intrinsics operate "
"on a per-element basis."
msgstr ""

#: ../../../LangRef.rst:15731 ../../../LangRef.rst:15760
msgid ""
"The arguments (``%a`` and ``%b``) may be of any integer type or a vector "
"with integer element type. The argument types must match each other, and the "
"return type must be at least as wide as ``i2``, to hold the three possible "
"return values."
msgstr ""

#: ../../../LangRef.rst:15738
msgid "'``llvm.ucmp.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15743
msgid ""
"This is an overloaded intrinsic. You can use ``@llvm.ucmp`` on any integer "
"bit width or any vector of integer elements."
msgstr ""

#: ../../../LangRef.rst:15754
msgid ""
"Return ``-1`` if ``%a`` is unsigned less than ``%b``, ``0`` if they are "
"equal, and ``1`` if ``%a`` is unsigned greater than ``%b``. Vector "
"intrinsics operate on a per-element basis."
msgstr ""

#: ../../../LangRef.rst:15767
msgid "'``llvm.memcpy``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15772
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memcpy`` on any integer "
"bit width and for different address spaces. Not all targets support all bit "
"widths however."
msgstr ""

#: ../../../LangRef.rst:15786
msgid ""
"The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source "
"location to the destination location."
msgstr ""

#: ../../../LangRef.rst:15789
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memcpy.*`` "
"intrinsics do not return a value, takes extra isvolatile arguments and the "
"pointers can be in specified address spaces."
msgstr ""

#: ../../../LangRef.rst:15796 ../../../LangRef.rst:15856
#: ../../../LangRef.rst:15914
msgid ""
"The first argument is a pointer to the destination, the second is a pointer "
"to the source. The third argument is an integer argument specifying the "
"number of bytes to copy, and the fourth is a boolean indicating a volatile "
"access."
msgstr ""

#: ../../../LangRef.rst:15801 ../../../LangRef.rst:15861
#: ../../../LangRef.rst:15919
msgid ""
"The :ref:`align <attr_align>` parameter attribute can be provided for the "
"first and second arguments."
msgstr ""

#: ../../../LangRef.rst:15804
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is a :"
"ref:`volatile operation <volatile>`. The detailed access behavior is not "
"very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:15811
msgid ""
"The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source "
"location to the destination location, which must either be equal or non-"
"overlapping. It copies \"len\" bytes of memory over. If the argument is "
"known to be aligned to some boundary, this can be specified as an attribute "
"on the argument."
msgstr ""

#: ../../../LangRef.rst:15817 ../../../LangRef.rst:15935
msgid ""
"If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to "
"the arguments. If ``<len>`` is not a well-defined value, the behavior is "
"undefined. If ``<len>`` is not zero, both ``<dest>`` and ``<src>`` should be "
"well-defined, otherwise the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:15826
msgid "'``llvm.memcpy.inline``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15831
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memcpy.inline`` on any "
"integer bit width and for different address spaces. Not all targets support "
"all bit widths however."
msgstr ""

#: ../../../LangRef.rst:15845
msgid ""
"The '``llvm.memcpy.inline.*``' intrinsics copy a block of memory from the "
"source location to the destination location and guarantees that no external "
"functions are called."
msgstr ""

#: ../../../LangRef.rst:15849
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memcpy.inline.*`` "
"intrinsics do not return a value, takes extra isvolatile arguments and the "
"pointers can be in specified address spaces."
msgstr ""

#: ../../../LangRef.rst:15864
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy.inline`` call "
"is a :ref:`volatile operation <volatile>`. The detailed access behavior is "
"not very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:15871
msgid ""
"The '``llvm.memcpy.inline.*``' intrinsics copy a block of memory from the "
"source location to the destination location, which are not allowed to "
"overlap. It copies \"len\" bytes of memory over. If the argument is known to "
"be aligned to some boundary, this can be specified as an attribute on the "
"argument. The behavior of '``llvm.memcpy.inline.*``' is equivalent to the "
"behavior of '``llvm.memcpy.*``', but the generated code is guaranteed not to "
"call any external functions."
msgstr ""

#: ../../../LangRef.rst:15883
msgid "'``llvm.memmove``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:15888
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memmove`` on any integer "
"bit width and for different address space. Not all targets support all bit "
"widths however."
msgstr ""

#: ../../../LangRef.rst:15902
msgid ""
"The '``llvm.memmove.*``' intrinsics move a block of memory from the source "
"location to the destination location. It is similar to the '``llvm.memcpy``' "
"intrinsic but allows the two memory locations to overlap."
msgstr ""

#: ../../../LangRef.rst:15907
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memmove.*`` "
"intrinsics do not return a value, takes an extra isvolatile argument and the "
"pointers can be in specified address spaces."
msgstr ""

#: ../../../LangRef.rst:15922
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memmove`` call is a :"
"ref:`volatile operation <volatile>`. The detailed access behavior is not "
"very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:15929
msgid ""
"The '``llvm.memmove.*``' intrinsics copy a block of memory from the source "
"location to the destination location, which may overlap. It copies \"len\" "
"bytes of memory over. If the argument is known to be aligned to some "
"boundary, this can be specified as an attribute on the argument."
msgstr ""

#: ../../../LangRef.rst:15944
msgid "'``llvm.memset.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:15949
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memset`` on any integer "
"bit width and for different address spaces. However, not all targets support "
"all bit widths."
msgstr ""

#: ../../../LangRef.rst:15963
msgid ""
"The '``llvm.memset.*``' intrinsics fill a block of memory with a particular "
"byte value."
msgstr ""

#: ../../../LangRef.rst:15966
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memset`` intrinsic "
"does not return a value and takes an extra volatile argument. Also, the "
"destination can be in an arbitrary address space."
msgstr ""

#: ../../../LangRef.rst:15973
msgid ""
"The first argument is a pointer to the destination to fill, the second is "
"the byte value with which to fill it, the third argument is an integer "
"argument specifying the number of bytes to fill, and the fourth is a boolean "
"indicating a volatile access."
msgstr ""

#: ../../../LangRef.rst:15978
msgid ""
"The :ref:`align <attr_align>` parameter attribute can be provided for the "
"first arguments."
msgstr ""

#: ../../../LangRef.rst:15981
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memset`` call is a :"
"ref:`volatile operation <volatile>`. The detailed access behavior is not "
"very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:15988
msgid ""
"The '``llvm.memset.*``' intrinsics fill \"len\" bytes of memory starting at "
"the destination location. If the argument is known to be aligned to some "
"boundary, this can be specified as an attribute on the argument."
msgstr ""

#: ../../../LangRef.rst:15993 ../../../LangRef.rst:16051
msgid ""
"If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to "
"the arguments. If ``<len>`` is not a well-defined value, the behavior is "
"undefined. If ``<len>`` is not zero, ``<dest>`` should be well-defined, "
"otherwise the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:16002
msgid "'``llvm.memset.inline``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16007
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memset.inline`` on any "
"integer bit width and for different address spaces. Not all targets support "
"all bit widths however."
msgstr ""

#: ../../../LangRef.rst:16021
msgid ""
"The '``llvm.memset.inline.*``' intrinsics fill a block of memory with a "
"particular byte value and guarantees that no external functions are called."
msgstr ""

#: ../../../LangRef.rst:16024
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memset.inline.*`` "
"intrinsics do not return a value, take an extra isvolatile argument and the "
"pointer can be in specified address spaces."
msgstr ""

#: ../../../LangRef.rst:16031
msgid ""
"The first argument is a pointer to the destination to fill, the second is "
"the byte value with which to fill it, the third argument is a constant "
"integer argument specifying the number of bytes to fill, and the fourth is a "
"boolean indicating a volatile access."
msgstr ""

#: ../../../LangRef.rst:16036 ../../../LangRef.rst:16094
#: ../../../LangRef.rst:24590 ../../../LangRef.rst:24647
#: ../../../LangRef.rst:24788 ../../../LangRef.rst:24910
msgid ""
"The :ref:`align <attr_align>` parameter attribute can be provided for the "
"first argument."
msgstr ""

#: ../../../LangRef.rst:16039
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memset.inline`` call "
"is a :ref:`volatile operation <volatile>`. The detailed access behavior is "
"not very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:16046
msgid ""
"The '``llvm.memset.inline.*``' intrinsics fill \"len\" bytes of memory "
"starting at the destination location. If the argument is known to be aligned "
"to some boundary, this can be specified as an attribute on the argument."
msgstr ""

#: ../../../LangRef.rst:16057
msgid ""
"The behavior of '``llvm.memset.inline.*``' is equivalent to the behavior of "
"'``llvm.memset.*``', but the generated code is guaranteed not to call any "
"external functions."
msgstr ""

#: ../../../LangRef.rst:16064
msgid "'``llvm.experimental.memset.pattern``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16069
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.experimental.memset."
"pattern`` on any sized type and for different address spaces."
msgstr ""

#: ../../../LangRef.rst:16081
msgid ""
"The '``llvm.experimental.memset.pattern.*``' intrinsics fill a block of "
"memory with a particular value. This may be expanded to an inline loop, a "
"sequence of stores, or a libcall depending on what is available for the "
"target and the expected performance and code size impact."
msgstr ""

#: ../../../LangRef.rst:16089
msgid ""
"The first argument is a pointer to the destination to fill, the second is "
"the value with which to fill it, the third argument is an integer argument "
"specifying the number of times to fill the value, and the fourth is a "
"boolean indicating a volatile access."
msgstr ""

#: ../../../LangRef.rst:16097
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.experimental.memset."
"pattern`` call is a :ref:`volatile operation <volatile>`. The detailed "
"access behavior is not very cleanly specified and it is unwise to depend on "
"it."
msgstr ""

#: ../../../LangRef.rst:16105
msgid ""
"The '``llvm.experimental.memset.pattern*``' intrinsic fills memory starting "
"at the destination location with the given pattern ``<count>`` times, "
"incrementing by the allocation size of the type each time. The stores follow "
"the usual semantics of store instructions, including regarding endianness "
"and padding. If the argument is known to be aligned to some boundary, this "
"can be specified as an attribute on the argument."
msgstr ""

#: ../../../LangRef.rst:16112
msgid ""
"If ``<count>`` is 0, it is no-op modulo the behavior of attributes attached "
"to the arguments. If ``<count>`` is not a well-defined value, the behavior "
"is undefined. If ``<count>`` is not zero, ``<dest>`` should be well-defined, "
"otherwise the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:16121
msgid "'``llvm.sqrt.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16126
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sqrt`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16141
msgid ""
"The '``llvm.sqrt``' intrinsics return the square root of the specified value."
msgstr ""

#: ../../../LangRef.rst:16146 ../../../LangRef.rst:16227
#: ../../../LangRef.rst:16266 ../../../LangRef.rst:16303
#: ../../../LangRef.rst:16340 ../../../LangRef.rst:16377
#: ../../../LangRef.rst:16414 ../../../LangRef.rst:16489
#: ../../../LangRef.rst:16526 ../../../LangRef.rst:16563
#: ../../../LangRef.rst:16790 ../../../LangRef.rst:16830
#: ../../../LangRef.rst:16870 ../../../LangRef.rst:17008
#: ../../../LangRef.rst:17048 ../../../LangRef.rst:17089
#: ../../../LangRef.rst:17168 ../../../LangRef.rst:17636
#: ../../../LangRef.rst:17673 ../../../LangRef.rst:17712
#: ../../../LangRef.rst:17751 ../../../LangRef.rst:17793
#: ../../../LangRef.rst:17835 ../../../LangRef.rst:17874
msgid ""
"The argument and return value are floating-point numbers of the same type."
msgstr ""

#: ../../../LangRef.rst:16151
msgid ""
"Return the same value as a corresponding libm '``sqrt``' function but "
"without trapping or setting ``errno``. For types specified by IEEE-754, the "
"result matches a conforming libm implementation."
msgstr ""

#: ../../../LangRef.rst:16155 ../../../LangRef.rst:16235
#: ../../../LangRef.rst:16274 ../../../LangRef.rst:16311
#: ../../../LangRef.rst:16348 ../../../LangRef.rst:16385
#: ../../../LangRef.rst:16422 ../../../LangRef.rst:16460
#: ../../../LangRef.rst:16497 ../../../LangRef.rst:16534
#: ../../../LangRef.rst:16571 ../../../LangRef.rst:16615
#: ../../../LangRef.rst:16661 ../../../LangRef.rst:16720
#: ../../../LangRef.rst:16758 ../../../LangRef.rst:16798
#: ../../../LangRef.rst:16838 ../../../LangRef.rst:16878
#: ../../../LangRef.rst:17016 ../../../LangRef.rst:17056
#: ../../../LangRef.rst:17097 ../../../LangRef.rst:17136
msgid ""
"When specified with the fast-math-flag 'afn', the result may be approximated "
"using a less accurate calculation."
msgstr ""

#: ../../../LangRef.rst:16159
msgid "'``llvm.powi.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16164
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.powi`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16168
msgid ""
"Generally, the only supported type for the exponent is the one matching with "
"the C type ``int``."
msgstr ""

#: ../../../LangRef.rst:16182
msgid ""
"The '``llvm.powi.*``' intrinsics return the first operand raised to the "
"specified (positive or negative) power. The order of evaluation of "
"multiplications is not defined. When a vector of floating-point type is "
"used, the second argument remains a scalar integer value."
msgstr ""

#: ../../../LangRef.rst:16190
msgid ""
"The second argument is an integer power, and the first is a value to raise "
"to that power."
msgstr ""

#: ../../../LangRef.rst:16196 ../../../LangRef.rst:28144
msgid ""
"This function returns the first value raised to the second power with an "
"unspecified sequence of rounding operations."
msgstr ""

#: ../../../LangRef.rst:16202
msgid "'``llvm.sin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16207
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sin`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16222
msgid "The '``llvm.sin.*``' intrinsics return the sine of the operand."
msgstr ""

#: ../../../LangRef.rst:16232
msgid ""
"Return the same value as a corresponding libm '``sin``' function but without "
"trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16241
msgid "'``llvm.cos.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16246
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.cos`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16261
msgid "The '``llvm.cos.*``' intrinsics return the cosine of the operand."
msgstr ""

#: ../../../LangRef.rst:16271
msgid ""
"Return the same value as a corresponding libm '``cos``' function but without "
"trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16278
msgid "'``llvm.tan.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16283
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.tan`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16298
msgid "The '``llvm.tan.*``' intrinsics return the tangent of the operand."
msgstr ""

#: ../../../LangRef.rst:16308
msgid ""
"Return the same value as a corresponding libm '``tan``' function but without "
"trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16315
msgid "'``llvm.asin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16320
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.asin`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16335
msgid "The '``llvm.asin.*``' intrinsics return the arcsine of the operand."
msgstr ""

#: ../../../LangRef.rst:16345
msgid ""
"Return the same value as a corresponding libm '``asin``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16352
msgid "'``llvm.acos.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16357
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.acos`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16372
msgid "The '``llvm.acos.*``' intrinsics return the arccosine of the operand."
msgstr ""

#: ../../../LangRef.rst:16382
msgid ""
"Return the same value as a corresponding libm '``acos``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16389
msgid "'``llvm.atan.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16394
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.atan`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16409
msgid "The '``llvm.atan.*``' intrinsics return the arctangent of the operand."
msgstr ""

#: ../../../LangRef.rst:16419
msgid ""
"Return the same value as a corresponding libm '``atan``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16426
msgid "'``llvm.atan2.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16431
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.atan2`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16446
msgid ""
"The '``llvm.atan2.*``' intrinsics return the arctangent of ``Y/X`` "
"accounting for the quadrant."
msgstr ""

#: ../../../LangRef.rst:16452 ../../../LangRef.rst:16750
#: ../../../LangRef.rst:17128 ../../../LangRef.rst:17300
#: ../../../LangRef.rst:17360 ../../../LangRef.rst:17420
#: ../../../LangRef.rst:17460 ../../../LangRef.rst:17500
#: ../../../LangRef.rst:17548 ../../../LangRef.rst:17596
msgid ""
"The arguments and return value are floating-point numbers of the same type."
msgstr ""

#: ../../../LangRef.rst:16457
msgid ""
"Return the same value as a corresponding libm '``atan2``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16464
msgid "'``llvm.sinh.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16469
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sinh`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16484
msgid ""
"The '``llvm.sinh.*``' intrinsics return the hyperbolic sine of the operand."
msgstr ""

#: ../../../LangRef.rst:16494
msgid ""
"Return the same value as a corresponding libm '``sinh``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16501
msgid "'``llvm.cosh.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16506
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.cosh`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16521
msgid ""
"The '``llvm.cosh.*``' intrinsics return the hyperbolic cosine of the operand."
msgstr ""

#: ../../../LangRef.rst:16531
msgid ""
"Return the same value as a corresponding libm '``cosh``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16538
msgid "'``llvm.tanh.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16543
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.tanh`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16558
msgid ""
"The '``llvm.tanh.*``' intrinsics return the hyperbolic tangent of the "
"operand."
msgstr ""

#: ../../../LangRef.rst:16568
msgid ""
"Return the same value as a corresponding libm '``tanh``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16576
msgid "'``llvm.sincos.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16581
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sincos`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16597
msgid ""
"The '``llvm.sincos.*``' intrinsics returns the sine and cosine of the "
"operand."
msgstr ""

#: ../../../LangRef.rst:16602 ../../../LangRef.rst:16645
#: ../../../LangRef.rst:16691
msgid ""
"The argument is a :ref:`floating-point <t_floating>` value or :ref:`vector "
"<t_vector>` of floating-point values. Returns two values matching the "
"argument type in a struct."
msgstr ""

#: ../../../LangRef.rst:16609
msgid ""
"This intrinsic is equivalent to a calling both :ref:`llvm.sin <t_llvm_sin>` "
"and :ref:`llvm.cos <t_llvm_cos>` on the argument."
msgstr ""

#: ../../../LangRef.rst:16612
msgid ""
"The first result is the sine of the argument and the second result is the "
"cosine of the argument."
msgstr ""

#: ../../../LangRef.rst:16619
msgid "'``llvm.sincospi.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16624
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sincospi`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:16640
msgid ""
"The '``llvm.sincospi.*``' intrinsics returns the sine and cosine of "
"pi*operand."
msgstr ""

#: ../../../LangRef.rst:16652
msgid ""
"This is equivalent to the ``llvm.sincos.*`` intrinsic where the argument has "
"been multiplied by pi, however, it computes the result more accurately "
"especially for large input values."
msgstr ""

#: ../../../LangRef.rst:16658
msgid ""
"Currently, the default lowering of this intrinsic relies on the ``sincospi[f|"
"l]`` functions being available in the target's runtime (e.g. libc)."
msgstr ""

#: ../../../LangRef.rst:16665
msgid "'``llvm.modf.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16670
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.modf`` on any floating-"
"point or vector of floating-point type. However, not all targets support all "
"types."
msgstr ""

#: ../../../LangRef.rst:16685
msgid ""
"The '``llvm.modf.*``' intrinsics return the operand's integral and "
"fractional parts."
msgstr ""

#: ../../../LangRef.rst:16698
msgid ""
"Return the same values as a corresponding libm '``modf``' function without "
"trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16701
msgid ""
"The first result is the fractional part of the operand and the second result "
"is the integral part of the operand. Both results have the same sign as the "
"operand."
msgstr ""

#: ../../../LangRef.rst:16704
msgid ""
"Not including exceptional inputs (listed below), ``llvm.modf.*`` is "
"semantically equivalent to:"
msgstr ""

#: ../../../LangRef.rst:16712
msgid "(assuming no floating-point precision errors)"
msgstr ""

#: ../../../LangRef.rst:16714
msgid ""
"If the argument is a zero, returns a zero with the same sign for both the "
"fractional and integral parts."
msgstr ""

#: ../../../LangRef.rst:16717
msgid ""
"If the argument is an infinity, returns a fractional part of zero with the "
"same sign, and infinity with the same sign as the integral part."
msgstr ""

#: ../../../LangRef.rst:16724
msgid "'``llvm.pow.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16729
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.pow`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16744
msgid ""
"The '``llvm.pow.*``' intrinsics return the first operand raised to the "
"specified (positive or negative) power."
msgstr ""

#: ../../../LangRef.rst:16755
msgid ""
"Return the same value as a corresponding libm '``pow``' function but without "
"trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16764
msgid "'``llvm.exp.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16769
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.exp`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16784
msgid ""
"The '``llvm.exp.*``' intrinsics compute the base-e exponential of the "
"specified value."
msgstr ""

#: ../../../LangRef.rst:16795
msgid ""
"Return the same value as a corresponding libm '``exp``' function but without "
"trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16804
msgid "'``llvm.exp2.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16809
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.exp2`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16824
msgid ""
"The '``llvm.exp2.*``' intrinsics compute the base-2 exponential of the "
"specified value."
msgstr ""

#: ../../../LangRef.rst:16835
msgid ""
"Return the same value as a corresponding libm '``exp2``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16844
msgid "'``llvm.exp10.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16849
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.exp10`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16864
msgid ""
"The '``llvm.exp10.*``' intrinsics compute the base-10 exponential of the "
"specified value."
msgstr ""

#: ../../../LangRef.rst:16875
msgid ""
"Return the same value as a corresponding libm '``exp10``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:16883
msgid "'``llvm.ldexp.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16888
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ldexp`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16904
msgid "The '``llvm.ldexp.*``' intrinsics perform the ldexp function."
msgstr ""

#: ../../../LangRef.rst:16909 ../../../LangRef.rst:28170
msgid ""
"The first argument and the return value are :ref:`floating-point "
"<t_floating>` or :ref:`vector <t_vector>` of floating-point values of the "
"same type. The second argument is an integer with the same number of "
"elements."
msgstr ""

#: ../../../LangRef.rst:16917 ../../../LangRef.rst:28182
msgid ""
"This function multiplies the first argument by 2 raised to the second "
"argument's power. If the first argument is NaN or infinite, the same value "
"is returned. If the result underflows a zero with the same sign is returned. "
"If the result overflows, the result is an infinity with the same sign."
msgstr ""

#: ../../../LangRef.rst:16926
msgid "'``llvm.frexp.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16931
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.frexp`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:16947
msgid "The '``llvm.frexp.*``' intrinsics perform the frexp function."
msgstr ""

#: ../../../LangRef.rst:16952
msgid ""
"The argument is a :ref:`floating-point <t_floating>` or :ref:`vector "
"<t_vector>` of floating-point values. Returns two values in a struct. The "
"first struct field matches the argument type, and the second field is an "
"integer or a vector of integer values with the same number of elements as "
"the argument."
msgstr ""

#: ../../../LangRef.rst:16961
msgid ""
"This intrinsic splits a floating point value into a normalized fractional "
"component and integral exponent."
msgstr ""

#: ../../../LangRef.rst:16964
msgid ""
"For a non-zero argument, returns the argument multiplied by some power of "
"two such that the absolute value of the returned value is in the range [0.5, "
"1.0), with the same sign as the argument. The second result is an integer "
"such that the first result raised to the power of the second result is the "
"input argument."
msgstr ""

#: ../../../LangRef.rst:16970
msgid ""
"If the argument is a zero, returns a zero with the same sign and a 0 "
"exponent."
msgstr ""

#: ../../../LangRef.rst:16973
msgid ""
"If the argument is a NaN, a NaN is returned and the returned exponent is "
"unspecified."
msgstr ""

#: ../../../LangRef.rst:16976
msgid ""
"If the argument is an infinity, returns an infinity with the same sign and "
"an unspecified exponent."
msgstr ""

#: ../../../LangRef.rst:16982
msgid "'``llvm.log.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:16987
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17002
msgid ""
"The '``llvm.log.*``' intrinsics compute the base-e logarithm of the "
"specified value."
msgstr ""

#: ../../../LangRef.rst:17013
msgid ""
"Return the same value as a corresponding libm '``log``' function but without "
"trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:17022
msgid "'``llvm.log10.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17027
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log10`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17042
msgid ""
"The '``llvm.log10.*``' intrinsics compute the base-10 logarithm of the "
"specified value."
msgstr ""

#: ../../../LangRef.rst:17053
msgid ""
"Return the same value as a corresponding libm '``log10``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:17063
msgid "'``llvm.log2.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17068
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log2`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17083
msgid ""
"The '``llvm.log2.*``' intrinsics compute the base-2 logarithm of the "
"specified value."
msgstr ""

#: ../../../LangRef.rst:17094
msgid ""
"Return the same value as a corresponding libm '``log2``' function but "
"without trapping or setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:17103
msgid "'``llvm.fma.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17108
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fma`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17123
msgid ""
"The '``llvm.fma.*``' intrinsics perform the fused multiply-add operation."
msgstr ""

#: ../../../LangRef.rst:17133
msgid ""
"Return the same value as the IEEE-754 fusedMultiplyAdd operation. This is "
"assumed to not trap or set ``errno``."
msgstr ""

#: ../../../LangRef.rst:17142
msgid "'``llvm.fabs.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17147
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fabs`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17162
msgid ""
"The '``llvm.fabs.*``' intrinsics return the absolute value of the operand."
msgstr ""

#: ../../../LangRef.rst:17174
msgid ""
"This function returns the same values as the libm ``fabs`` functions would, "
"and handles error conditions in the same way. The returned value is "
"completely identical to the input except for the sign bit; in particular, if "
"the input is a NaN, then the quiet/signaling bit and payload are perfectly "
"preserved."
msgstr ""

#: ../../../LangRef.rst:17183
msgid "'``llvm.min.*``' Intrinsics Comparation"
msgstr ""

#: ../../../LangRef.rst:17186
msgid "Standard:"
msgstr ""

#: ../../../LangRef.rst:17188
msgid ""
"IEEE754 and ISO C define some min/max operations, and they have some "
"differences on working with qNaN/sNaN and +0.0/-0.0. Here is the list:"
msgstr ""

#: ../../../LangRef.rst:17194
msgid "``ISO C``"
msgstr ""

#: ../../../LangRef.rst:17195
msgid "fmin/fmax"
msgstr ""

#: ../../../LangRef.rst:17196
msgid "fmininum/fmaximum"
msgstr ""

#: ../../../LangRef.rst:17197
msgid "fminimum_num/fmaximum_num"
msgstr ""

#: ../../../LangRef.rst:17199
msgid "``IEEE754``"
msgstr ""

#: ../../../LangRef.rst:17200
msgid "minNum/maxNum (2008)"
msgstr ""

#: ../../../LangRef.rst:17201
msgid "minimum/maximum (2019)"
msgstr ""

#: ../../../LangRef.rst:17202
msgid "minimumNumber/maximumNumber (2019)"
msgstr ""

#: ../../../LangRef.rst:17204 ../../../LangRef.rst:17260
msgid "``+0.0 vs -0.0``"
msgstr ""

#: ../../../LangRef.rst:17205
msgid "either one"
msgstr ""

#: ../../../LangRef.rst:17206 ../../../LangRef.rst:17207
msgid "+0.0 > -0.0"
msgstr ""

#: ../../../LangRef.rst:17209 ../../../LangRef.rst:17245
msgid "``NUM vs sNaN``"
msgstr ""

#: ../../../LangRef.rst:17210 ../../../LangRef.rst:17211
#: ../../../LangRef.rst:17215 ../../../LangRef.rst:17216
#: ../../../LangRef.rst:17217 ../../../LangRef.rst:17246
#: ../../../LangRef.rst:17247 ../../../LangRef.rst:17251
#: ../../../LangRef.rst:17252 ../../../LangRef.rst:17253
#: ../../../LangRef.rst:17256 ../../../LangRef.rst:17257
#: ../../../LangRef.rst:17258
msgid "qNaN, invalid exception"
msgstr ""

#: ../../../LangRef.rst:17212 ../../../LangRef.rst:17248
msgid "NUM, invalid exception"
msgstr ""

#: ../../../LangRef.rst:17214 ../../../LangRef.rst:17250
msgid "``qNaN vs sNaN``"
msgstr ""

#: ../../../LangRef.rst:17219 ../../../LangRef.rst:17240
msgid "``NUM vs qNaN``"
msgstr ""

#: ../../../LangRef.rst:17220 ../../../LangRef.rst:17222
#: ../../../LangRef.rst:17241 ../../../LangRef.rst:17243
msgid "NUM, no exception"
msgstr ""

#: ../../../LangRef.rst:17221 ../../../LangRef.rst:17242
msgid "qNaN, no exception"
msgstr ""

#: ../../../LangRef.rst:17225
msgid "LLVM Implementation:"
msgstr ""

#: ../../../LangRef.rst:17227
msgid ""
"LLVM implements all ISO C flavors as listed in this table, except in the "
"default floating-point environment exceptions are ignored. The constrained "
"versions of the intrinsics respect the exception behavior."
msgstr ""

#: ../../../LangRef.rst:17235
msgid "Operation"
msgstr ""

#: ../../../LangRef.rst:17236
msgid "minnum/maxnum"
msgstr ""

#: ../../../LangRef.rst:17237
msgid "minimum/maximum"
msgstr ""

#: ../../../LangRef.rst:17238
msgid "minimumnum/maximumnum"
msgstr ""

#: ../../../LangRef.rst:17255
msgid "``sNaN vs sNaN``"
msgstr ""

#: ../../../LangRef.rst:17261 ../../../LangRef.rst:17262
#: ../../../LangRef.rst:17263
msgid "+0.0(max)/-0.0(min)"
msgstr ""

#: ../../../LangRef.rst:17265
msgid "``NUM vs NUM``"
msgstr ""

#: ../../../LangRef.rst:17266 ../../../LangRef.rst:17267
#: ../../../LangRef.rst:17268
msgid "larger(max)/smaller(min)"
msgstr ""

#: ../../../LangRef.rst:17273
msgid "'``llvm.minnum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17278
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.minnum`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17293
msgid ""
"The '``llvm.minnum.*``' intrinsics return the minimum of the two arguments."
msgstr ""

#: ../../../LangRef.rst:17305
msgid ""
"Follows the semantics of minNum in IEEE-754-2008, except that -0.0 < +0.0 "
"for the purposes of this intrinsic. As for signaling NaNs, per the minNum "
"semantics, if either operand is sNaN, the result is qNaN. This matches the "
"recommended behavior for the libm function ``fmin``, although not all "
"implementations have implemented these recommended behaviors."
msgstr ""

#: ../../../LangRef.rst:17310
msgid ""
"If either operand is a qNaN, returns the other non-NaN operand. Returns NaN "
"only if both operands are NaN or if either operand is sNaN. Note that "
"arithmetic on an sNaN doesn't consistently produce a qNaN, so arithmetic "
"feeding into a minnum can produce inconsistent results. For example, "
"``minnum(fadd(sNaN, -0.0), 1.0)`` can produce qNaN or 1.0 depending on "
"whether ``fadd`` is folded."
msgstr ""

#: ../../../LangRef.rst:17315
msgid ""
"IEEE-754-2008 defines minNum, and it was removed in IEEE-754-2019. As the "
"replacement, IEEE-754-2019 defines :ref:`minimumNumber <i_minimumnum>`."
msgstr ""

#: ../../../LangRef.rst:17318
msgid ""
"If the intrinsic is marked with the nsz attribute, then the effect is as in "
"the definition in C and IEEE-754-2008: the result of ``minnum(-0.0, +0.0)`` "
"may be either -0.0 or +0.0."
msgstr ""

#: ../../../LangRef.rst:17321
msgid ""
"Some architectures, such as ARMv8 (FMINNM), LoongArch (fmin), MIPSr6 (min."
"fmt), PowerPC/VSX (xsmindp), have instructions that match these semantics "
"exactly; thus it is quite simple for these architectures. Some architectures "
"have similar ones while they are not exact equivalent. Such as x86 "
"implements ``MINPS``, which implements the semantics of C code ``a<b?a:b``: "
"NUM vs qNaN always return qNaN. ``MINPS`` can be used if ``nsz`` and "
"``nnan`` are given."
msgstr ""

#: ../../../LangRef.rst:17327 ../../../LangRef.rst:17387
msgid ""
"For existing libc implementations, the behaviors of fmin may be quite "
"different on sNaN and signed zero behaviors, even in the same release of a "
"single libm implementation."
msgstr ""

#: ../../../LangRef.rst:17333
msgid "'``llvm.maxnum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17338
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.maxnum`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17353
msgid ""
"The '``llvm.maxnum.*``' intrinsics return the maximum of the two arguments."
msgstr ""

#: ../../../LangRef.rst:17365
msgid ""
"Follows the semantics of maxNum in IEEE-754-2008, except that -0.0 < +0.0 "
"for the purposes of this intrinsic. As for signaling NaNs, per the maxNum "
"semantics, if either operand is sNaN, the result is qNaN. This matches the "
"recommended behavior for the libm function ``fmax``, although not all "
"implementations have implemented these recommended behaviors."
msgstr ""

#: ../../../LangRef.rst:17370
msgid ""
"If either operand is a qNaN, returns the other non-NaN operand. Returns NaN "
"only if both operands are NaN or if either operand is sNaN. Note that "
"arithmetic on an sNaN doesn't consistently produce a qNaN, so arithmetic "
"feeding into a maxnum can produce inconsistent results. For example, "
"``maxnum(fadd(sNaN, -0.0), 1.0)`` can produce qNaN or 1.0 depending on "
"whether ``fadd`` is folded."
msgstr ""

#: ../../../LangRef.rst:17375
msgid ""
"IEEE-754-2008 defines maxNum, and it was removed in IEEE-754-2019. As the "
"replacement, IEEE-754-2019 defines :ref:`maximumNumber <i_maximumnum>`."
msgstr ""

#: ../../../LangRef.rst:17378
msgid ""
"If the intrinsic is marked with the nsz attribute, then the effect is as in "
"the definition in C and IEEE-754-2008: the result of maxnum(-0.0, +0.0) may "
"be either -0.0 or +0.0."
msgstr ""

#: ../../../LangRef.rst:17381
msgid ""
"Some architectures, such as ARMv8 (FMAXNM), LoongArch (fmax), MIPSr6 (max."
"fmt), PowerPC/VSX (xsmaxdp), have instructions that match these semantics "
"exactly; thus it is quite simple for these architectures. Some architectures "
"have similar ones while they are not exact equivalent. Such as x86 "
"implements ``MAXPS``, which implements the semantics of C code ``a>b?a:b``: "
"NUM vs qNaN always return qNaN. ``MAXPS`` can be used if ``nsz`` and "
"``nnan`` are given."
msgstr ""

#: ../../../LangRef.rst:17393
msgid "'``llvm.minimum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17398
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.minimum`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17413
msgid ""
"The '``llvm.minimum.*``' intrinsics return the minimum of the two arguments, "
"propagating NaNs and treating -0.0 as less than +0.0."
msgstr ""

#: ../../../LangRef.rst:17425
msgid ""
"If either operand is a NaN, returns NaN. Otherwise returns the lesser of the "
"two arguments. -0.0 is considered to be less than +0.0 for this intrinsic. "
"Note that these are the semantics specified in the draft of IEEE 754-2019."
msgstr ""

#: ../../../LangRef.rst:17433
msgid "'``llvm.maximum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17438
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.maximum`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17453
msgid ""
"The '``llvm.maximum.*``' intrinsics return the maximum of the two arguments, "
"propagating NaNs and treating -0.0 as less than +0.0."
msgstr ""

#: ../../../LangRef.rst:17465
msgid ""
"If either operand is a NaN, returns NaN. Otherwise returns the greater of "
"the two arguments. -0.0 is considered to be less than +0.0 for this "
"intrinsic. Note that these are the semantics specified in the draft of IEEE "
"754-2019."
msgstr ""

#: ../../../LangRef.rst:17473
msgid "'``llvm.minimumnum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17478
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.minimumnum`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17493
msgid ""
"The '``llvm.minimumnum.*``' intrinsics return the minimum of the two "
"arguments, not propagating NaNs and treating -0.0 as less than +0.0."
msgstr ""

#: ../../../LangRef.rst:17506
msgid ""
"If both operands are NaNs (including sNaN), returns a :ref:`NaN <floatnan>`. "
"If one operand is NaN (including sNaN) and another operand is a number, "
"return the number.  Otherwise returns the lesser of the two arguments. -0.0 "
"is considered to be less than +0.0 for this intrinsic."
msgstr ""

#: ../../../LangRef.rst:17511
msgid ""
"Note that these are the semantics of minimumNumber specified in "
"IEEE-754-2019 with the usual :ref:`signaling NaN <floatnan>` exception."
msgstr ""

#: ../../../LangRef.rst:17514
msgid ""
"It has some differences with '``llvm.minnum.*``': 1)'``llvm.minnum.*``' will "
"return qNaN if either operand is sNaN. 2)'``llvm.minnum*``' may return "
"either one if we compare +0.0 vs -0.0."
msgstr ""

#: ../../../LangRef.rst:17521
msgid "'``llvm.maximumnum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17526
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.maximumnum`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17541
msgid ""
"The '``llvm.maximumnum.*``' intrinsics return the maximum of the two "
"arguments, not propagating NaNs and treating -0.0 as less than +0.0."
msgstr ""

#: ../../../LangRef.rst:17554
msgid ""
"If both operands are NaNs (including sNaN), returns a :ref:`NaN <floatnan>`. "
"If one operand is NaN (including sNaN) and another operand is a number, "
"return the number.  Otherwise returns the greater of the two arguments. -0.0 "
"is considered to be less than +0.0 for this intrinsic."
msgstr ""

#: ../../../LangRef.rst:17560
msgid ""
"Note that these are the semantics of maximumNumber specified in "
"IEEE-754-2019  with the usual :ref:`signaling NaN <floatnan>` exception."
msgstr ""

#: ../../../LangRef.rst:17563
msgid ""
"It has some differences with '``llvm.maxnum.*``': 1)'``llvm.maxnum.*``' will "
"return qNaN if either operand is sNaN. 2)'``llvm.maxnum*``' may return "
"either one if we compare +0.0 vs -0.0."
msgstr ""

#: ../../../LangRef.rst:17570
msgid "'``llvm.copysign.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17575
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.copysign`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17590
msgid ""
"The '``llvm.copysign.*``' intrinsics return a value with the magnitude of "
"the first operand and the sign of the second operand."
msgstr ""

#: ../../../LangRef.rst:17602
msgid ""
"This function returns the same values as the libm ``copysign`` functions "
"would, and handles error conditions in the same way. The returned value is "
"completely identical to the first operand except for the sign bit; in "
"particular, if the input is a NaN, then the quiet/signaling bit and payload "
"are perfectly preserved."
msgstr ""

#: ../../../LangRef.rst:17611
msgid "'``llvm.floor.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17616
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.floor`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17631
msgid "The '``llvm.floor.*``' intrinsics return the floor of the operand."
msgstr ""

#: ../../../LangRef.rst:17642
msgid ""
"This function returns the same values as the libm ``floor`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:17648
msgid "'``llvm.ceil.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17653
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ceil`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17668
msgid "The '``llvm.ceil.*``' intrinsics return the ceiling of the operand."
msgstr ""

#: ../../../LangRef.rst:17679
msgid ""
"This function returns the same values as the libm ``ceil`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:17686
msgid "'``llvm.trunc.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17691
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.trunc`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17706
msgid ""
"The '``llvm.trunc.*``' intrinsics returns the operand rounded to the nearest "
"integer not larger in magnitude than the operand."
msgstr ""

#: ../../../LangRef.rst:17718
msgid ""
"This function returns the same values as the libm ``trunc`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:17724
msgid "'``llvm.rint.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17729
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.rint`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17744
msgid ""
"The '``llvm.rint.*``' intrinsics returns the operand rounded to the nearest "
"integer. It may raise an inexact floating-point exception if the operand "
"isn't an integer."
msgstr ""

#: ../../../LangRef.rst:17757
msgid ""
"This function returns the same values as the libm ``rint`` functions would, "
"and handles error conditions in the same way. Since LLVM assumes the :ref:"
"`default floating-point environment <floatenv>`, the rounding mode is "
"assumed to be set to \"nearest\", so halfway cases are rounded to the even "
"integer. Use :ref:`Constrained Floating-Point Intrinsics <constrainedfp>` to "
"avoid that assumption."
msgstr ""

#: ../../../LangRef.rst:17767
msgid "'``llvm.nearbyint.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17772
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.nearbyint`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17787
msgid ""
"The '``llvm.nearbyint.*``' intrinsics returns the operand rounded to the "
"nearest integer."
msgstr ""

#: ../../../LangRef.rst:17799
msgid ""
"This function returns the same values as the libm ``nearbyint`` functions "
"would, and handles error conditions in the same way. Since LLVM assumes the :"
"ref:`default floating-point environment <floatenv>`, the rounding mode is "
"assumed to be set to \"nearest\", so halfway cases are rounded to the even "
"integer. Use :ref:`Constrained Floating-Point Intrinsics <constrainedfp>` to "
"avoid that assumption."
msgstr ""

#: ../../../LangRef.rst:17809
msgid "'``llvm.round.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17814
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.round`` on any floating-"
"point or vector of floating-point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:17829
msgid ""
"The '``llvm.round.*``' intrinsics returns the operand rounded to the nearest "
"integer."
msgstr ""

#: ../../../LangRef.rst:17841
msgid ""
"This function returns the same values as the libm ``round`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:17847
msgid "'``llvm.roundeven.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17852
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.roundeven`` on any "
"floating-point or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17867
msgid ""
"The '``llvm.roundeven.*``' intrinsics returns the operand rounded to the "
"nearest integer in floating-point format rounding halfway cases to even "
"(that is, to the nearest value that is an even integer)."
msgstr ""

#: ../../../LangRef.rst:17879
msgid ""
"This function implements IEEE-754 operation ``roundToIntegralTiesToEven``. "
"It also behaves in the same way as C standard function ``roundeven``, "
"including that it disregards rounding mode and does not raise floating point "
"exceptions."
msgstr ""

#: ../../../LangRef.rst:17885
msgid "'``llvm.lround.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17890
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.lround`` on any floating-"
"point type or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17911
msgid ""
"The '``llvm.lround.*``' intrinsics return the operand rounded to the nearest "
"integer with ties away from zero."
msgstr ""

#: ../../../LangRef.rst:17918 ../../../LangRef.rst:17955
#: ../../../LangRef.rst:18002 ../../../LangRef.rst:18042
msgid ""
"The argument is a floating-point number and the return value is an integer "
"type."
msgstr ""

#: ../../../LangRef.rst:17924
msgid ""
"This function returns the same values as the libm ``lround`` functions "
"would, but without setting errno. If the rounded value is too large to be "
"stored in the result type, the return value is a non-deterministic value "
"(equivalent to `freeze poison`)."
msgstr ""

#: ../../../LangRef.rst:17930
msgid "'``llvm.llround.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17935
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.llround`` on any "
"floating-point type. Not all targets support all types however."
msgstr ""

#: ../../../LangRef.rst:17949
msgid ""
"The '``llvm.llround.*``' intrinsics return the operand rounded to the "
"nearest integer with ties away from zero."
msgstr ""

#: ../../../LangRef.rst:17961
msgid ""
"This function returns the same values as the libm ``llround`` functions "
"would, but without setting errno. If the rounded value is too large to be "
"stored in the result type, the return value is a non-deterministic value "
"(equivalent to `freeze poison`)."
msgstr ""

#: ../../../LangRef.rst:17969
msgid "'``llvm.lrint.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:17974
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.lrint`` on any floating-"
"point type or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:17995
msgid ""
"The '``llvm.lrint.*``' intrinsics return the operand rounded to the nearest "
"integer."
msgstr ""

#: ../../../LangRef.rst:18008
msgid ""
"This function returns the same values as the libm ``lrint`` functions would, "
"but without setting errno. If the rounded value is too large to be stored in "
"the result type, the return value is a non-deterministic value (equivalent "
"to `freeze poison`)."
msgstr ""

#: ../../../LangRef.rst:18016
msgid "'``llvm.llrint.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:18021
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.llrint`` on any floating-"
"point type or vector of floating-point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:18036
msgid ""
"The '``llvm.llrint.*``' intrinsics return the operand rounded to the nearest "
"integer."
msgstr ""

#: ../../../LangRef.rst:18048
msgid ""
"This function returns the same values as the libm ``llrint`` functions "
"would, but without setting errno. If the rounded value is too large to be "
"stored in the result type, the return value is a non-deterministic value "
"(equivalent to `freeze poison`)."
msgstr ""

#: ../../../LangRef.rst:18054
msgid "Bit Manipulation Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18056
msgid ""
"LLVM provides intrinsics for a few important bit manipulation operations. "
"These allow efficient code generation for some algorithms."
msgstr ""

#: ../../../LangRef.rst:18062
msgid "'``llvm.bitreverse.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18067
msgid ""
"This is an overloaded intrinsic function. You can use bitreverse on any "
"integer type."
msgstr ""

#: ../../../LangRef.rst:18080
msgid ""
"The '``llvm.bitreverse``' family of intrinsics is used to reverse the "
"bitpattern of an integer value or vector of integer values; for example "
"``0b10110110`` becomes ``0b01101101``."
msgstr ""

#: ../../../LangRef.rst:18087
msgid ""
"The ``llvm.bitreverse.iN`` intrinsic returns an iN value that has bit ``M`` "
"in the input moved to bit ``N-M-1`` in the output. The vector intrinsics, "
"such as ``llvm.bitreverse.v4i32``, operate on a per-element basis and the "
"element order is not affected."
msgstr ""

#: ../../../LangRef.rst:18095
msgid "'``llvm.bswap.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18100
msgid ""
"This is an overloaded intrinsic function. You can use bswap on any integer "
"type that is an even number of bytes (i.e., BitWidth % 16 == 0)."
msgstr ""

#: ../../../LangRef.rst:18113
msgid ""
"The '``llvm.bswap``' family of intrinsics is used to byte swap an integer "
"value or vector of integer values with an even number of bytes (positive "
"multiple of 16 bits)."
msgstr ""

#: ../../../LangRef.rst:18120
msgid ""
"The ``llvm.bswap.i16`` intrinsic returns an i16 value that has the high and "
"low byte of the input i16 swapped. Similarly, the ``llvm.bswap.i32`` "
"intrinsic returns an i32 value that has the four bytes of the input i32 "
"swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the "
"returned i32 will have its bytes in 3, 2, 1, 0 order. The ``llvm.bswap."
"i48``, ``llvm.bswap.i64`` and other intrinsics extend this concept to "
"additional even-byte lengths (6 bytes, 8 bytes and more, respectively). The "
"vector intrinsics, such as ``llvm.bswap.v4i32``, operate on a per-element "
"basis and the element order is not affected."
msgstr ""

#: ../../../LangRef.rst:18133
msgid "'``llvm.ctpop.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:18138
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ctpop`` on any integer "
"bit width, or on any vector with integer elements. Not all targets support "
"all bit widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:18154
msgid ""
"The '``llvm.ctpop``' family of intrinsics counts the number of bits set in a "
"value."
msgstr ""

#: ../../../LangRef.rst:18160
msgid ""
"The only argument is the value to be counted. The argument may be of any "
"integer type, or a vector with integer elements. The return type must match "
"the argument type."
msgstr ""

#: ../../../LangRef.rst:18167
msgid ""
"The '``llvm.ctpop``' intrinsic counts the 1's in a variable, or within each "
"element of a vector."
msgstr ""

#: ../../../LangRef.rst:18173
msgid "'``llvm.ctlz.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:18178
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any integer "
"bit width, or any vector whose elements are integers. Not all targets "
"support all bit widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:18190
msgid ""
"The '``llvm.ctlz``' family of intrinsic functions counts the number of "
"leading zeros in a variable."
msgstr ""

#: ../../../LangRef.rst:18196 ../../../LangRef.rst:18242
msgid ""
"The first argument is the value to be counted. This argument may be of any "
"integer type, or a vector with integer element type. The return type must "
"match the first argument type."
msgstr ""

#: ../../../LangRef.rst:18200 ../../../LangRef.rst:18246
msgid ""
"The second argument is a constant flag that indicates whether the intrinsic "
"returns a valid result if the first argument is zero. If the first argument "
"is zero and the second argument is true, the result is poison. Historically "
"some architectures did not provide a defined result for zero values as "
"efficiently, and many algorithms are now predicated on avoiding zero-value "
"inputs."
msgstr ""

#: ../../../LangRef.rst:18210
msgid ""
"The '``llvm.ctlz``' intrinsic counts the leading (most significant) zeros in "
"a variable, or within each element of the vector. If ``src == 0`` then the "
"result is the size in bits of the type of ``src`` if ``is_zero_poison == 0`` "
"and ``poison`` otherwise. For example, ``llvm.ctlz(i32 2) = 30``."
msgstr ""

#: ../../../LangRef.rst:18219
msgid "'``llvm.cttz.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:18224
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.cttz`` on any integer "
"bit width, or any vector of integer elements. Not all targets support all "
"bit widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:18236
msgid ""
"The '``llvm.cttz``' family of intrinsic functions counts the number of "
"trailing zeros."
msgstr ""

#: ../../../LangRef.rst:18256
msgid ""
"The '``llvm.cttz``' intrinsic counts the trailing (least significant) zeros "
"in a variable, or within each element of a vector. If ``src == 0`` then the "
"result is the size in bits of the type of ``src`` if ``is_zero_poison == 0`` "
"and ``poison`` otherwise. For example, ``llvm.cttz(2) = 1``."
msgstr ""

#: ../../../LangRef.rst:18267
msgid "'``llvm.fshl.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:18272
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fshl`` on any integer "
"bit width or any vector of integer elements. Not all targets support all bit "
"widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:18285
msgid ""
"The '``llvm.fshl``' family of intrinsic functions performs a funnel shift "
"left: the first two values are concatenated as { %a : %b } (%a is the most "
"significant bits of the wide value), the combined value is shifted left, and "
"the most significant bits are extracted to produce a result that is the same "
"size as the original arguments. If the first 2 arguments are identical, this "
"is equivalent to a rotate left operation. For vector types, the operation "
"occurs for each element of the vector. The shift argument is treated as an "
"unsigned amount modulo the element size of the arguments."
msgstr ""

#: ../../../LangRef.rst:18297 ../../../LangRef.rst:18345
msgid ""
"The first two arguments are the values to be concatenated. The third "
"argument is the shift amount. The arguments may be any integer type or a "
"vector with integer element type. All arguments and the return value must "
"have the same type."
msgstr ""

#: ../../../LangRef.rst:18315
msgid "'``llvm.fshr.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:18320
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fshr`` on any integer "
"bit width or any vector of integer elements. Not all targets support all bit "
"widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:18333
msgid ""
"The '``llvm.fshr``' family of intrinsic functions performs a funnel shift "
"right: the first two values are concatenated as { %a : %b } (%a is the most "
"significant bits of the wide value), the combined value is shifted right, "
"and the least significant bits are extracted to produce a result that is the "
"same size as the original arguments. If the first 2 arguments are identical, "
"this is equivalent to a rotate right operation. For vector types, the "
"operation occurs for each element of the vector. The shift argument is "
"treated as an unsigned amount modulo the element size of the arguments."
msgstr ""

#: ../../../LangRef.rst:18361
msgid "Arithmetic with Overflow Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18363
msgid "LLVM provides intrinsics for fast arithmetic overflow checking."
msgstr ""

#: ../../../LangRef.rst:18365
msgid ""
"Each of these intrinsics returns a two-element struct. The first element of "
"this struct contains the result of the corresponding arithmetic operation "
"modulo 2\\ :sup:`n`\\ , where n is the bit width of the result. Therefore, "
"for example, the first element of the struct returned by ``llvm.sadd.with."
"overflow.i32`` is always the same as the result of a 32-bit ``add`` "
"instruction with the same operands, where the ``add`` is *not* modified by "
"an ``nsw`` or ``nuw`` flag."
msgstr ""

#: ../../../LangRef.rst:18373
msgid ""
"The second element of the result is an ``i1`` that is 1 if the arithmetic "
"operation overflowed and 0 otherwise. An operation overflows if, for any "
"values of its operands ``A`` and ``B`` and for any ``N`` larger than the "
"operands' width, ``ext(A op B) to iN`` is not equal to ``(ext(A) to iN) op "
"(ext(B) to iN)`` where ``ext`` is ``sext`` for signed overflow and ``zext`` "
"for unsigned overflow, and ``op`` is the underlying arithmetic operation."
msgstr ""

#: ../../../LangRef.rst:18381
msgid ""
"The behavior of these intrinsics is well-defined for all argument values."
msgstr ""

#: ../../../LangRef.rst:18385
msgid "'``llvm.sadd.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18390
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sadd.with.overflow`` on "
"any integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18403
msgid ""
"The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a "
"signed addition of the two arguments, and indicate whether an overflow "
"occurred during the signed summation."
msgstr ""

#: ../../../LangRef.rst:18410
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo signed addition."
msgstr ""

#: ../../../LangRef.rst:18419
msgid ""
"The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a "
"signed addition of the two variables. They return a structure --- the first "
"element of which is the signed summation, and the second element of which is "
"a bit specifying if the signed summation resulted in an overflow."
msgstr ""

#: ../../../LangRef.rst:18436
msgid "'``llvm.uadd.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18441
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.uadd.with.overflow`` on "
"any integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18454
msgid ""
"The '``llvm.uadd.with.overflow``' family of intrinsic functions perform an "
"unsigned addition of the two arguments, and indicate whether a carry "
"occurred during the unsigned summation."
msgstr ""

#: ../../../LangRef.rst:18461
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo unsigned addition."
msgstr ""

#: ../../../LangRef.rst:18470
msgid ""
"The '``llvm.uadd.with.overflow``' family of intrinsic functions perform an "
"unsigned addition of the two arguments. They return a structure --- the "
"first element of which is the sum, and the second element of which is a bit "
"specifying if the unsigned summation resulted in a carry."
msgstr ""

#: ../../../LangRef.rst:18486
msgid "'``llvm.ssub.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18491
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ssub.with.overflow`` on "
"any integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18504
msgid ""
"The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a "
"signed subtraction of the two arguments, and indicate whether an overflow "
"occurred during the signed subtraction."
msgstr ""

#: ../../../LangRef.rst:18511
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo signed subtraction."
msgstr ""

#: ../../../LangRef.rst:18520
msgid ""
"The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a "
"signed subtraction of the two arguments. They return a structure --- the "
"first element of which is the subtraction, and the second element of which "
"is a bit specifying if the signed subtraction resulted in an overflow."
msgstr ""

#: ../../../LangRef.rst:18537
msgid "'``llvm.usub.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18542
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.usub.with.overflow`` on "
"any integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18555
msgid ""
"The '``llvm.usub.with.overflow``' family of intrinsic functions perform an "
"unsigned subtraction of the two arguments, and indicate whether an overflow "
"occurred during the unsigned subtraction."
msgstr ""

#: ../../../LangRef.rst:18562
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo unsigned subtraction."
msgstr ""

#: ../../../LangRef.rst:18571
msgid ""
"The '``llvm.usub.with.overflow``' family of intrinsic functions perform an "
"unsigned subtraction of the two arguments. They return a structure --- the "
"first element of which is the subtraction, and the second element of which "
"is a bit specifying if the unsigned subtraction resulted in an overflow."
msgstr ""

#: ../../../LangRef.rst:18588
msgid "'``llvm.smul.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18593
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.smul.with.overflow`` on "
"any integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18606
msgid ""
"The '``llvm.smul.with.overflow``' family of intrinsic functions perform a "
"signed multiplication of the two arguments, and indicate whether an overflow "
"occurred during the signed multiplication."
msgstr ""

#: ../../../LangRef.rst:18613
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo signed multiplication."
msgstr ""

#: ../../../LangRef.rst:18622
msgid ""
"The '``llvm.smul.with.overflow``' family of intrinsic functions perform a "
"signed multiplication of the two arguments. They return a structure --- the "
"first element of which is the multiplication, and the second element of "
"which is a bit specifying if the signed multiplication resulted in an "
"overflow."
msgstr ""

#: ../../../LangRef.rst:18639
msgid "'``llvm.umul.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18644
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.umul.with.overflow`` on "
"any integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18657
msgid ""
"The '``llvm.umul.with.overflow``' family of intrinsic functions perform an "
"unsigned multiplication of the two arguments, and indicate whether an "
"overflow occurred during the unsigned multiplication."
msgstr ""

#: ../../../LangRef.rst:18664
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo unsigned multiplication."
msgstr ""

#: ../../../LangRef.rst:18673
msgid ""
"The '``llvm.umul.with.overflow``' family of intrinsic functions perform an "
"unsigned multiplication of the two arguments. They return a structure --- "
"the first element of which is the multiplication, and the second element of "
"which is a bit specifying if the unsigned multiplication resulted in an "
"overflow."
msgstr ""

#: ../../../LangRef.rst:18690
msgid "Saturation Arithmetic Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18692
msgid ""
"Saturation arithmetic is a version of arithmetic in which operations are "
"limited to a fixed range between a minimum and maximum value. If the result "
"of an operation is greater than the maximum value, the result is set (or "
"\"clamped\") to this maximum. If it is below the minimum, it is clamped to "
"this minimum."
msgstr ""

#: ../../../LangRef.rst:18701
msgid "'``llvm.sadd.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18706
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sadd.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18719
msgid ""
"The '``llvm.sadd.sat``' family of intrinsic functions perform signed "
"saturating addition on the 2 arguments."
msgstr ""

#: ../../../LangRef.rst:18723 ../../../LangRef.rst:18773
#: ../../../LangRef.rst:18822 ../../../LangRef.rst:18872
#: ../../../LangRef.rst:18919 ../../../LangRef.rst:18972
#: ../../../LangRef.rst:19075 ../../../LangRef.rst:19135
#: ../../../LangRef.rst:19194 ../../../LangRef.rst:19264
#: ../../../LangRef.rst:19331 ../../../LangRef.rst:19391
#: ../../../LangRef.rst:19451 ../../../LangRef.rst:19518
msgid "Arguments"
msgstr ""

#: ../../../LangRef.rst:18725
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo signed addition."
msgstr ""

#: ../../../LangRef.rst:18732 ../../../LangRef.rst:18831
#: ../../../LangRef.rst:18933
msgid ""
"The maximum value this operation can clamp to is the largest signed value "
"representable by the bit width of the arguments. The minimum value is the "
"smallest signed value representable by this bit width."
msgstr ""

#: ../../../LangRef.rst:18751
msgid "'``llvm.uadd.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18756
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.uadd.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18769
msgid ""
"The '``llvm.uadd.sat``' family of intrinsic functions perform unsigned "
"saturating addition on the 2 arguments."
msgstr ""

#: ../../../LangRef.rst:18775
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo unsigned addition."
msgstr ""

#: ../../../LangRef.rst:18782
msgid ""
"The maximum value this operation can clamp to is the largest unsigned value "
"representable by the bit width of the arguments. Because this is an unsigned "
"operation, the result will never saturate towards zero."
msgstr ""

#: ../../../LangRef.rst:18800
msgid "'``llvm.ssub.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18805
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ssub.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18818
msgid ""
"The '``llvm.ssub.sat``' family of intrinsic functions perform signed "
"saturating subtraction on the 2 arguments."
msgstr ""

#: ../../../LangRef.rst:18824
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo signed subtraction."
msgstr ""

#: ../../../LangRef.rst:18850
msgid "'``llvm.usub.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18855
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.usub.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:18868
msgid ""
"The '``llvm.usub.sat``' family of intrinsic functions perform unsigned "
"saturating subtraction on the 2 arguments."
msgstr ""

#: ../../../LangRef.rst:18874
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo unsigned subtraction."
msgstr ""

#: ../../../LangRef.rst:18881
msgid ""
"The minimum value this operation can clamp to is 0, which is the smallest "
"unsigned value representable by the bit width of the unsigned arguments. "
"Because this is an unsigned operation, the result will never saturate "
"towards the largest possible value representable by this bit width."
msgstr ""

#: ../../../LangRef.rst:18897
msgid "'``llvm.sshl.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18902
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sshl.sat`` on integers "
"or vectors of integers of any bit width."
msgstr ""

#: ../../../LangRef.rst:18915
msgid ""
"The '``llvm.sshl.sat``' family of intrinsic functions perform signed "
"saturating left shift on the first argument."
msgstr ""

#: ../../../LangRef.rst:18921 ../../../LangRef.rst:18974
msgid ""
"The arguments (``%a`` and ``%b``) and the result may be of integer types of "
"any bit width, but they must have the same bit width. ``%a`` is the value to "
"be shifted, and ``%b`` is the amount to shift by. If ``b`` is (statically or "
"dynamically) equal to or larger than the integer bit width of the arguments, "
"the result is a :ref:`poison value <poisonvalues>`. If the arguments are "
"vectors, each vector element of ``a`` is shifted by the corresponding shift "
"amount in ``b``."
msgstr ""

#: ../../../LangRef.rst:18950
msgid "'``llvm.ushl.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:18955
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ushl.sat`` on integers "
"or vectors of integers of any bit width."
msgstr ""

#: ../../../LangRef.rst:18968
msgid ""
"The '``llvm.ushl.sat``' family of intrinsic functions perform unsigned "
"saturating left shift on the first argument."
msgstr ""

#: ../../../LangRef.rst:18985
msgid ""
"The maximum value this operation can clamp to is the largest unsigned value "
"representable by the bit width of the arguments."
msgstr ""

#: ../../../LangRef.rst:18999
msgid "Fixed Point Arithmetic Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19001
msgid ""
"A fixed point number represents a real data type for a number that has a "
"fixed number of digits after a radix point (equivalent to the decimal point "
"'.'). The number of digits after the radix point is referred as the `scale`. "
"These are useful for representing fractional values to a specific precision. "
"The following intrinsics perform fixed point arithmetic operations on 2 "
"operands of the same scale, specified as the third argument."
msgstr ""

#: ../../../LangRef.rst:19008
msgid ""
"The ``llvm.*mul.fix`` family of intrinsic functions represents a "
"multiplication of fixed point numbers through scaled integers. Therefore, "
"fixed point multiplication can be represented as"
msgstr ""

#: ../../../LangRef.rst:19024
msgid ""
"The ``llvm.*div.fix`` family of intrinsic functions represents a division of "
"fixed point numbers through scaled integers. Fixed point division can be "
"represented as:"
msgstr ""

#: ../../../LangRef.rst:19040
msgid ""
"For each of these functions, if the result cannot be represented exactly "
"with the provided scale, the result is rounded. Rounding is unspecified "
"since preferred rounding may vary for different targets. Rounding is "
"specified through a target hook. Different pipelines should legalize or "
"optimize this using the rounding specified by this hook if it is provided. "
"Operations like constant folding, instruction combining, KnownBits, and "
"ValueTracking should also use this hook, if provided, and not assume the "
"direction of rounding. A rounded result must always be within one unit of "
"precision from the true result. That is, the error between the returned "
"result and the true result must be less than 1/2^(scale)."
msgstr ""

#: ../../../LangRef.rst:19053
msgid "'``llvm.smul.fix.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19058
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.smul.fix`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19071
msgid ""
"The '``llvm.smul.fix``' family of intrinsic functions perform signed fixed "
"point multiplication on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19077
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. The arguments may also work "
"with int vectors of the same length and int size. ``%a`` and ``%b`` are the "
"two values that will undergo signed fixed point multiplication. The argument "
"``%scale`` represents the scale of both operands, and must be a constant "
"integer."
msgstr ""

#: ../../../LangRef.rst:19087 ../../../LangRef.rst:19205
#: ../../../LangRef.rst:19275
msgid ""
"This operation performs fixed point multiplication on the 2 arguments of a "
"specified scale. The result will also be returned in the same scale "
"specified in the third argument."
msgstr ""

#: ../../../LangRef.rst:19091 ../../../LangRef.rst:19151
#: ../../../LangRef.rst:19209 ../../../LangRef.rst:19279
#: ../../../LangRef.rst:19347 ../../../LangRef.rst:19407
#: ../../../LangRef.rst:19466 ../../../LangRef.rst:19533
msgid ""
"If the result value cannot be precisely represented in the given scale, the "
"value is rounded up or down to the closest representable value. The rounding "
"direction is unspecified."
msgstr ""

#: ../../../LangRef.rst:19095 ../../../LangRef.rst:19155
msgid ""
"It is undefined behavior if the result value does not fit within the range "
"of the fixed point type."
msgstr ""

#: ../../../LangRef.rst:19113
msgid "'``llvm.umul.fix.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19118
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.umul.fix`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19131
msgid ""
"The '``llvm.umul.fix``' family of intrinsic functions perform unsigned fixed "
"point multiplication on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19137
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. The arguments may also work "
"with int vectors of the same length and int size. ``%a`` and ``%b`` are the "
"two values that will undergo unsigned fixed point multiplication. The "
"argument ``%scale`` represents the scale of both operands, and must be a "
"constant integer."
msgstr ""

#: ../../../LangRef.rst:19147
msgid ""
"This operation performs unsigned fixed point multiplication on the 2 "
"arguments of a specified scale. The result will also be returned in the same "
"scale specified in the third argument."
msgstr ""

#: ../../../LangRef.rst:19172
msgid "'``llvm.smul.fix.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19177
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.smul.fix.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19190
msgid ""
"The '``llvm.smul.fix.sat``' family of intrinsic functions perform signed "
"fixed point saturating multiplication on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19196
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo signed fixed point multiplication. The argument "
"``%scale`` represents the scale of both operands, and must be a constant "
"integer."
msgstr ""

#: ../../../LangRef.rst:19213 ../../../LangRef.rst:19470
msgid ""
"The maximum value this operation can clamp to is the largest signed value "
"representable by the bit width of the first 2 arguments. The minimum value "
"is the smallest signed value representable by this bit width."
msgstr ""

#: ../../../LangRef.rst:19242
msgid "'``llvm.umul.fix.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19247
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.umul.fix.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19260
msgid ""
"The '``llvm.umul.fix.sat``' family of intrinsic functions perform unsigned "
"fixed point saturating multiplication on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19266
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo unsigned fixed point multiplication. The argument "
"``%scale`` represents the scale of both operands, and must be a constant "
"integer."
msgstr ""

#: ../../../LangRef.rst:19283 ../../../LangRef.rst:19537
msgid ""
"The maximum value this operation can clamp to is the largest unsigned value "
"representable by the bit width of the first 2 arguments. The minimum value "
"is the smallest unsigned value representable by this bit width (zero)."
msgstr ""

#: ../../../LangRef.rst:19309
msgid "'``llvm.sdiv.fix.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19314
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sdiv.fix`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19327
msgid ""
"The '``llvm.sdiv.fix``' family of intrinsic functions perform signed fixed "
"point division on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19333
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. The arguments may also work "
"with int vectors of the same length and int size. ``%a`` and ``%b`` are the "
"two values that will undergo signed fixed point division. The argument "
"``%scale`` represents the scale of both operands, and must be a constant "
"integer."
msgstr ""

#: ../../../LangRef.rst:19343 ../../../LangRef.rst:19403
#: ../../../LangRef.rst:19462 ../../../LangRef.rst:19529
msgid ""
"This operation performs fixed point division on the 2 arguments of a "
"specified scale. The result will also be returned in the same scale "
"specified in the third argument."
msgstr ""

#: ../../../LangRef.rst:19351 ../../../LangRef.rst:19411
msgid ""
"It is undefined behavior if the result value does not fit within the range "
"of the fixed point type, or if the second argument is zero."
msgstr ""

#: ../../../LangRef.rst:19369
msgid "'``llvm.udiv.fix.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19374
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.udiv.fix`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19387
msgid ""
"The '``llvm.udiv.fix``' family of intrinsic functions perform unsigned fixed "
"point division on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19393
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. The arguments may also work "
"with int vectors of the same length and int size. ``%a`` and ``%b`` are the "
"two values that will undergo unsigned fixed point division. The argument "
"``%scale`` represents the scale of both operands, and must be a constant "
"integer."
msgstr ""

#: ../../../LangRef.rst:19429
msgid "'``llvm.sdiv.fix.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19434
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sdiv.fix.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19447
msgid ""
"The '``llvm.sdiv.fix.sat``' family of intrinsic functions perform signed "
"fixed point saturating division on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19453
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo signed fixed point division. The argument "
"``%scale`` represents the scale of both operands, and must be a constant "
"integer."
msgstr ""

#: ../../../LangRef.rst:19474 ../../../LangRef.rst:19541
msgid "It is undefined behavior if the second argument is zero."
msgstr ""

#: ../../../LangRef.rst:19496
msgid "'``llvm.udiv.fix.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19501
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.udiv.fix.sat`` on any "
"integer bit width or vectors of integers."
msgstr ""

#: ../../../LangRef.rst:19514
msgid ""
"The '``llvm.udiv.fix.sat``' family of intrinsic functions perform unsigned "
"fixed point saturating division on 2 arguments of the same scale."
msgstr ""

#: ../../../LangRef.rst:19520
msgid ""
"The arguments (%a and %b) and the result may be of integer types of any bit "
"width, but they must have the same bit width. ``%a`` and ``%b`` are the two "
"values that will undergo unsigned fixed point division. The argument "
"``%scale`` represents the scale of both operands, and must be a constant "
"integer."
msgstr ""

#: ../../../LangRef.rst:19559
msgid "Specialized Arithmetic Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19564
msgid "'``llvm.canonicalize.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19577
msgid ""
"The '``llvm.canonicalize.*``' intrinsic returns the platform specific "
"canonical encoding of a floating-point number. This canonicalization is "
"useful for implementing certain numeric primitives such as frexp. The "
"canonical encoding is defined by IEEE-754-2008 to be:"
msgstr ""

#: ../../../LangRef.rst:19588
msgid ""
"This operation can also be considered equivalent to the IEEE-754-2008 "
"conversion of a floating-point value to the same format. NaNs are handled "
"according to section 6.2."
msgstr ""

#: ../../../LangRef.rst:19592
msgid "Examples of non-canonical encodings:"
msgstr ""

#: ../../../LangRef.rst:19594
msgid ""
"x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are "
"converted to a canonical representation per hardware-specific protocol."
msgstr ""

#: ../../../LangRef.rst:19596
msgid ""
"Many normal decimal floating-point numbers have non-canonical alternative "
"encodings."
msgstr ""

#: ../../../LangRef.rst:19598
msgid ""
"Some machines, like GPUs or ARMv7 NEON, do not support subnormal values. "
"These are treated as non-canonical encodings of zero and will be flushed to "
"a zero of the same sign by this operation."
msgstr ""

#: ../../../LangRef.rst:19602
msgid ""
"Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with "
"default exception handling must signal an invalid exception, and produce a "
"quiet NaN result."
msgstr ""

#: ../../../LangRef.rst:19606
msgid ""
"This function should always be implementable as multiplication by 1.0, "
"provided that the compiler does not constant fold the operation. Likewise, "
"division by 1.0 and ``llvm.minnum(x, x)`` are possible implementations. "
"Addition with -0.0 is also sufficient provided that the rounding mode is not "
"-Infinity."
msgstr ""

#: ../../../LangRef.rst:19611
msgid "``@llvm.canonicalize`` must preserve the equality relation. That is:"
msgstr ""

#: ../../../LangRef.rst:19613
msgid "``(@llvm.canonicalize(x) == x)`` is equivalent to ``(x == x)``"
msgstr ""

#: ../../../LangRef.rst:19614
msgid ""
"``(@llvm.canonicalize(x) == @llvm.canonicalize(y))`` is equivalent to ``(x "
"== y)``"
msgstr ""

#: ../../../LangRef.rst:19617
msgid ""
"Additionally, the sign of zero must be conserved: ``@llvm.canonicalize(-0.0) "
"= -0.0`` and ``@llvm.canonicalize(+0.0) = +0.0``"
msgstr ""

#: ../../../LangRef.rst:19620
msgid ""
"The payload bits of a NaN must be conserved, with two exceptions. First, "
"environments which use only a single canonical representation of NaN must "
"perform said canonicalization. Second, SNaNs must be quieted per the usual "
"methods."
msgstr ""

#: ../../../LangRef.rst:19625
msgid "The canonicalization operation may be optimized away if:"
msgstr ""

#: ../../../LangRef.rst:19627
msgid ""
"The input is known to be canonical. For example, it was produced by a "
"floating-point operation that is required by the standard to be canonical."
msgstr ""

#: ../../../LangRef.rst:19629
msgid ""
"The result is consumed only by (or fused with) other floating-point "
"operations. That is, the bits of the floating-point value are not examined."
msgstr ""

#: ../../../LangRef.rst:19635
msgid "'``llvm.fmuladd.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19648
msgid ""
"The '``llvm.fmuladd.*``' intrinsic functions represent multiply-add "
"expressions that can be fused if the code generator determines that (a) the "
"target instruction set has support for a fused operation, and (b) that the "
"fused operation is more efficient than the equivalent, separate pair of mul "
"and add instructions."
msgstr ""

#: ../../../LangRef.rst:19657
msgid ""
"The '``llvm.fmuladd.*``' intrinsics each take three arguments: two "
"multiplicands, a and b, and an addend c."
msgstr ""

#: ../../../LangRef.rst:19663 ../../../LangRef.rst:27994
msgid "The expression:"
msgstr ""

#: ../../../LangRef.rst:19669
msgid ""
"is equivalent to the expression a \\* b + c, except that it is unspecified "
"whether rounding will be performed between the multiplication and addition "
"steps. Fusion is not guaranteed, even if the target platform supports it. If "
"a fused multiply-add is required, the corresponding :ref:`llvm.fma "
"<int_fma>` intrinsic function should be used instead. This never sets errno, "
"just as '``llvm.fma.*``'."
msgstr ""

#: ../../../LangRef.rst:19685
msgid "Hardware-Loop Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19687
msgid ""
"LLVM support several intrinsics to mark a loop as a hardware-loop. They are "
"hints to the backend which are required to lower these intrinsics further to "
"target specific instructions, or revert the hardware-loop to a normal loop "
"if target specific restriction are not met and a hardware-loop can't be "
"generated."
msgstr ""

#: ../../../LangRef.rst:19692
msgid ""
"These intrinsics may be modified in the future and are not intended to be "
"used outside the backend. Thus, front-end and mid-level optimizations should "
"not be generating these intrinsics."
msgstr ""

#: ../../../LangRef.rst:19698
msgid "'``llvm.set.loop.iterations.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19703 ../../../LangRef.rst:19739
#: ../../../LangRef.rst:19777 ../../../LangRef.rst:19815
#: ../../../LangRef.rst:19854 ../../../LangRef.rst:19894
#: ../../../LangRef.rst:20286 ../../../LangRef.rst:20315
#: ../../../LangRef.rst:20344 ../../../LangRef.rst:20371
#: ../../../LangRef.rst:20417 ../../../LangRef.rst:20462
#: ../../../LangRef.rst:20490 ../../../LangRef.rst:20531
#: ../../../LangRef.rst:20609 ../../../LangRef.rst:20686
#: ../../../LangRef.rst:20744 ../../../LangRef.rst:20843
#: ../../../LangRef.rst:20960 ../../../LangRef.rst:21009
#: ../../../LangRef.rst:21035 ../../../LangRef.rst:21065
#: ../../../LangRef.rst:21597 ../../../LangRef.rst:21655
#: ../../../LangRef.rst:21717 ../../../LangRef.rst:21764
#: ../../../LangRef.rst:21813 ../../../LangRef.rst:21860
#: ../../../LangRef.rst:21908 ../../../LangRef.rst:21957
#: ../../../LangRef.rst:22006 ../../../LangRef.rst:22054
#: ../../../LangRef.rst:22104 ../../../LangRef.rst:22153
#: ../../../LangRef.rst:22201 ../../../LangRef.rst:22249
#: ../../../LangRef.rst:22297 ../../../LangRef.rst:22344
#: ../../../LangRef.rst:22395 ../../../LangRef.rst:22443
#: ../../../LangRef.rst:22491 ../../../LangRef.rst:22539
#: ../../../LangRef.rst:22587 ../../../LangRef.rst:22636
#: ../../../LangRef.rst:22685 ../../../LangRef.rst:22734
#: ../../../LangRef.rst:22784 ../../../LangRef.rst:22834
#: ../../../LangRef.rst:22883 ../../../LangRef.rst:22932
#: ../../../LangRef.rst:22981 ../../../LangRef.rst:23030
#: ../../../LangRef.rst:23079 ../../../LangRef.rst:23127
#: ../../../LangRef.rst:23175 ../../../LangRef.rst:23224
#: ../../../LangRef.rst:23273 ../../../LangRef.rst:23324
#: ../../../LangRef.rst:23380 ../../../LangRef.rst:23439
#: ../../../LangRef.rst:23495 ../../../LangRef.rst:23555
#: ../../../LangRef.rst:23612 ../../../LangRef.rst:23668
#: ../../../LangRef.rst:23725 ../../../LangRef.rst:23782
#: ../../../LangRef.rst:23839 ../../../LangRef.rst:23896
#: ../../../LangRef.rst:23953 ../../../LangRef.rst:24020
#: ../../../LangRef.rst:24087 ../../../LangRef.rst:24157
#: ../../../LangRef.rst:24227 ../../../LangRef.rst:24302
#: ../../../LangRef.rst:24361 ../../../LangRef.rst:24426
#: ../../../LangRef.rst:24485 ../../../LangRef.rst:24532
#: ../../../LangRef.rst:24567 ../../../LangRef.rst:24623
#: ../../../LangRef.rst:24709 ../../../LangRef.rst:24766
#: ../../../LangRef.rst:24825 ../../../LangRef.rst:24886
#: ../../../LangRef.rst:24943 ../../../LangRef.rst:25001
#: ../../../LangRef.rst:25054 ../../../LangRef.rst:25106
#: ../../../LangRef.rst:25158 ../../../LangRef.rst:25214
#: ../../../LangRef.rst:25270 ../../../LangRef.rst:25326
#: ../../../LangRef.rst:25382 ../../../LangRef.rst:25438
#: ../../../LangRef.rst:25494 ../../../LangRef.rst:25551
#: ../../../LangRef.rst:25606 ../../../LangRef.rst:25664
#: ../../../LangRef.rst:25721 ../../../LangRef.rst:25768
#: ../../../LangRef.rst:25815 ../../../LangRef.rst:25862
#: ../../../LangRef.rst:25909 ../../../LangRef.rst:25956
#: ../../../LangRef.rst:26003 ../../../LangRef.rst:26050
#: ../../../LangRef.rst:26097 ../../../LangRef.rst:26144
#: ../../../LangRef.rst:26191 ../../../LangRef.rst:26238
#: ../../../LangRef.rst:26285 ../../../LangRef.rst:26334
#: ../../../LangRef.rst:26431 ../../../LangRef.rst:26480
#: ../../../LangRef.rst:26529 ../../../LangRef.rst:26578
#: ../../../LangRef.rst:26627 ../../../LangRef.rst:26673
#: ../../../LangRef.rst:26718
msgid "This is an overloaded intrinsic."
msgstr ""

#: ../../../LangRef.rst:19713
msgid ""
"The '``llvm.set.loop.iterations.*``' intrinsics are used to specify the "
"hardware-loop trip count. They are placed in the loop preheader basic block "
"and are marked as ``IntrNoDuplicate`` to avoid optimizers duplicating these "
"instructions."
msgstr ""

#: ../../../LangRef.rst:19721 ../../../LangRef.rst:19760
#: ../../../LangRef.rst:19796 ../../../LangRef.rst:19834
msgid ""
"The integer operand is the loop trip count of the hardware-loop, and thus "
"not e.g. the loop back-edge taken count."
msgstr ""

#: ../../../LangRef.rst:19727
msgid ""
"The '``llvm.set.loop.iterations.*``' intrinsics do not perform any "
"arithmetic on their operand. It's a hint to the backend that can use this to "
"set up the hardware-loop count with a target-specific instruction, usually a "
"move of this value to a special register or a hardware-loop instruction."
msgstr ""

#: ../../../LangRef.rst:19734
msgid "'``llvm.start.loop.iterations.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19749
msgid ""
"The '``llvm.start.loop.iterations.*``' intrinsics are similar to the '``llvm."
"set.loop.iterations.*``' intrinsics, used to specify the hardware-loop trip "
"count but also produce a value identical to the input that can be used as "
"the input to the loop. They are placed in the loop preheader basic block and "
"the output is expected to be the input to the phi for the induction variable "
"of the loop, decremented by the '``llvm.loop.decrement.reg.*``'."
msgstr ""

#: ../../../LangRef.rst:19766
msgid ""
"The '``llvm.start.loop.iterations.*``' intrinsics do not perform any "
"arithmetic on their operand. It's a hint to the backend that can use this to "
"set up the hardware-loop count with a target-specific instruction, usually a "
"move of this value to a special register or a hardware-loop instruction."
msgstr ""

#: ../../../LangRef.rst:19772
msgid "'``llvm.test.set.loop.iterations.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19787
msgid ""
"The '``llvm.test.set.loop.iterations.*``' intrinsics are used to specify the "
"the loop trip count, and also test that the given count is not zero, "
"allowing it to control entry to a while-loop.  They are placed in the loop "
"preheader's predecessor basic block, and are marked as ``IntrNoDuplicate`` "
"to avoid optimizers duplicating these instructions."
msgstr ""

#: ../../../LangRef.rst:19802
msgid ""
"The '``llvm.test.set.loop.iterations.*``' intrinsics do not perform any "
"arithmetic on their operand. It's a hint to the backend that can use this to "
"set up the hardware-loop count with a target-specific instruction, usually a "
"move of this value to a special register or a hardware-loop instruction. The "
"result is the conditional value of whether the given count is not zero."
msgstr ""

#: ../../../LangRef.rst:19810
msgid "'``llvm.test.start.loop.iterations.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19825
msgid ""
"The '``llvm.test.start.loop.iterations.*``' intrinsics are similar to the "
"'``llvm.test.set.loop.iterations.*``' and '``llvm.start.loop.iterations.*``' "
"intrinsics, used to specify the hardware-loop trip count, but also produce a "
"value identical to the input that can be used as the input to the loop. The "
"second i1 output controls entry to a while-loop."
msgstr ""

#: ../../../LangRef.rst:19840
msgid ""
"The '``llvm.test.start.loop.iterations.*``' intrinsics do not perform any "
"arithmetic on their operand. It's a hint to the backend that can use this to "
"set up the hardware-loop count with a target-specific instruction, usually a "
"move of this value to a special register or a hardware-loop instruction. The "
"result is a pair of the input and a conditional value of whether the given "
"count is not zero."
msgstr ""

#: ../../../LangRef.rst:19849
msgid "'``llvm.loop.decrement.reg.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19864
msgid ""
"The '``llvm.loop.decrement.reg.*``' intrinsics are used to lower the loop "
"iteration counter and return an updated value that will be used in the next "
"loop test check."
msgstr ""

#: ../../../LangRef.rst:19871
msgid ""
"Both arguments must have identical integer types. The first operand is the "
"loop iteration counter. The second operand is the maximum number of elements "
"processed in an iteration."
msgstr ""

#: ../../../LangRef.rst:19878
msgid ""
"The '``llvm.loop.decrement.reg.*``' intrinsics do an integer ``SUB`` of its "
"two operands, which is not allowed to wrap. They return the remaining number "
"of iterations still to be executed, and can be used together with a ``PHI``, "
"``ICMP`` and ``BR`` to control the number of loop iterations executed. Any "
"optimizations are allowed to treat it is a ``SUB``, and it is supported by "
"SCEV, so it's the backends responsibility to handle cases where it may be "
"optimized. These intrinsics are marked as ``IntrNoDuplicate`` to avoid "
"optimizers duplicating these instructions."
msgstr ""

#: ../../../LangRef.rst:19889
msgid "'``llvm.loop.decrement.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19904
msgid ""
"The HardwareLoops pass allows the loop decrement value to be specified with "
"an option. It defaults to a loop decrement value of 1, but it can be an "
"unsigned integer value provided by this option.  The '``llvm.loop.decrement."
"*``' intrinsics decrement the loop iteration counter with this value, and "
"return a false predicate if the loop should exit, and true otherwise. This "
"is emitted if the loop counter is not updated via a ``PHI`` node, which can "
"also be controlled with an option."
msgstr ""

#: ../../../LangRef.rst:19915
msgid ""
"The integer argument is the loop decrement value used to decrement the loop "
"iteration counter."
msgstr ""

#: ../../../LangRef.rst:19921
msgid ""
"The '``llvm.loop.decrement.*``' intrinsics do a ``SUB`` of the loop "
"iteration counter with the given loop decrement value, and return false if "
"the loop should exit, this ``SUB`` is not allowed to wrap. The result is a "
"condition that is used by the conditional branch controlling the loop."
msgstr ""

#: ../../../LangRef.rst:19928
msgid "Vector Reduction Intrinsics"
msgstr ""

#: ../../../LangRef.rst:19930
msgid ""
"Horizontal reductions of vectors can be expressed using the following "
"intrinsics. Each one takes a vector operand as an input and applies its "
"respective operation across all elements of the vector, returning a single "
"scalar result of the same element type."
msgstr ""

#: ../../../LangRef.rst:19938
msgid "'``llvm.vector.reduce.add.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19951
msgid ""
"The '``llvm.vector.reduce.add.*``' intrinsics do an integer ``ADD`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:19957 ../../../LangRef.rst:20035
#: ../../../LangRef.rst:20111 ../../../LangRef.rst:20134
#: ../../../LangRef.rst:20157 ../../../LangRef.rst:20180
#: ../../../LangRef.rst:20203 ../../../LangRef.rst:20226
#: ../../../LangRef.rst:20249
msgid "The argument to this intrinsic must be a vector of integer values."
msgstr ""

#: ../../../LangRef.rst:19962
msgid "'``llvm.vector.reduce.fadd.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:19975
msgid ""
"The '``llvm.vector.reduce.fadd.*``' intrinsics do a floating-point ``ADD`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:19979
msgid ""
"If the intrinsic call has the 'reassoc' flag set, then the reduction will "
"not preserve the associativity of an equivalent scalarized counterpart. "
"Otherwise the reduction will be *sequential*, thus implying that the "
"operation respects the associativity of a scalarized reduction. That is, the "
"reduction begins with the start value and performs an fadd operation with "
"consecutively increasing vector element indices. See the following "
"pseudocode:"
msgstr ""

#: ../../../LangRef.rst:19997 ../../../LangRef.rst:20075
msgid ""
"The first argument to this intrinsic is a scalar start value for the "
"reduction. The type of the start value matches the element-type of the "
"vector input. The second argument must be a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:20001
msgid ""
"To ignore the start value, negative zero (``-0.0``) can be used, as it is "
"the neutral value of floating point addition."
msgstr ""

#: ../../../LangRef.rst:20016
msgid "'``llvm.vector.reduce.mul.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20029
msgid ""
"The '``llvm.vector.reduce.mul.*``' intrinsics do an integer ``MUL`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20040
msgid "'``llvm.vector.reduce.fmul.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20053
msgid ""
"The '``llvm.vector.reduce.fmul.*``' intrinsics do a floating-point ``MUL`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20057
msgid ""
"If the intrinsic call has the 'reassoc' flag set, then the reduction will "
"not preserve the associativity of an equivalent scalarized counterpart. "
"Otherwise the reduction will be *sequential*, thus implying that the "
"operation respects the associativity of a scalarized reduction. That is, the "
"reduction begins with the start value and performs an fmul operation with "
"consecutively increasing vector element indices. See the following "
"pseudocode:"
msgstr ""

#: ../../../LangRef.rst:20079
msgid ""
"To ignore the start value, one (``1.0``) can be used, as it is the neutral "
"value of floating point multiplication."
msgstr ""

#: ../../../LangRef.rst:20093
msgid "'``llvm.vector.reduce.and.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20105
msgid ""
"The '``llvm.vector.reduce.and.*``' intrinsics do a bitwise ``AND`` reduction "
"of a vector, returning the result as a scalar. The return type matches the "
"element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20116
msgid "'``llvm.vector.reduce.or.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20128
msgid ""
"The '``llvm.vector.reduce.or.*``' intrinsics do a bitwise ``OR`` reduction "
"of a vector, returning the result as a scalar. The return type matches the "
"element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20139
msgid "'``llvm.vector.reduce.xor.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20151
msgid ""
"The '``llvm.vector.reduce.xor.*``' intrinsics do a bitwise ``XOR`` reduction "
"of a vector, returning the result as a scalar. The return type matches the "
"element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20162
msgid "'``llvm.vector.reduce.smax.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20174
msgid ""
"The '``llvm.vector.reduce.smax.*``' intrinsics do a signed integer ``MAX`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20185
msgid "'``llvm.vector.reduce.smin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20197
msgid ""
"The '``llvm.vector.reduce.smin.*``' intrinsics do a signed integer ``MIN`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20208
msgid "'``llvm.vector.reduce.umax.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20220
msgid ""
"The '``llvm.vector.reduce.umax.*``' intrinsics do an unsigned integer "
"``MAX`` reduction of a vector, returning the result as a scalar. The return "
"type matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20231
msgid "'``llvm.vector.reduce.umin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20243
msgid ""
"The '``llvm.vector.reduce.umin.*``' intrinsics do an unsigned integer "
"``MIN`` reduction of a vector, returning the result as a scalar. The return "
"type matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20254
msgid "'``llvm.vector.reduce.fmax.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20267
msgid ""
"The '``llvm.vector.reduce.fmax.*``' intrinsics do a floating-point ``MAX`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20271
msgid ""
"This instruction has the same comparison semantics as the '``llvm.maxnum."
"*``' intrinsic.  If the intrinsic call has the ``nnan`` fast-math flag, then "
"the operation can assume that NaNs are not present in the input vector."
msgstr ""

#: ../../../LangRef.rst:20277 ../../../LangRef.rst:20306
#: ../../../LangRef.rst:20335 ../../../LangRef.rst:20364
msgid ""
"The argument to this intrinsic must be a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:20282
msgid "'``llvm.vector.reduce.fmin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20296
msgid ""
"The '``llvm.vector.reduce.fmin.*``' intrinsics do a floating-point ``MIN`` "
"reduction of a vector, returning the result as a scalar. The return type "
"matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20300
msgid ""
"This instruction has the same comparison semantics as the '``llvm.minnum."
"*``' intrinsic. If the intrinsic call has the ``nnan`` fast-math flag, then "
"the operation can assume that NaNs are not present in the input vector."
msgstr ""

#: ../../../LangRef.rst:20311
msgid "'``llvm.vector.reduce.fmaximum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20325
msgid ""
"The '``llvm.vector.reduce.fmaximum.*``' intrinsics do a floating-point "
"``MAX`` reduction of a vector, returning the result as a scalar. The return "
"type matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20329
msgid ""
"This instruction has the same comparison semantics as the '``llvm.maximum."
"*``' intrinsic. That is, this intrinsic propagates NaNs and +0.0 is "
"considered greater than -0.0. If any element of the vector is a NaN, the "
"result is NaN."
msgstr ""

#: ../../../LangRef.rst:20340
msgid "'``llvm.vector.reduce.fminimum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20354
msgid ""
"The '``llvm.vector.reduce.fminimum.*``' intrinsics do a floating-point "
"``MIN`` reduction of a vector, returning the result as a scalar. The return "
"type matches the element-type of the vector input."
msgstr ""

#: ../../../LangRef.rst:20358
msgid ""
"This instruction has the same comparison semantics as the '``llvm.minimum."
"*``' intrinsic. That is, this intrinsic propagates NaNs and -0.0 is "
"considered less than +0.0. If any element of the vector is a NaN, the result "
"is NaN."
msgstr ""

#: ../../../LangRef.rst:20367
msgid "'``llvm.vector.insert``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20388
msgid ""
"The '``llvm.vector.insert.*``' intrinsics insert a vector into another "
"vector starting from a given index. The return type matches the type of the "
"vector we insert into. Conceptually, this can be used to build a scalable "
"vector out of non-scalable vectors, however this intrinsic can also be used "
"on purely fixed types."
msgstr ""

#: ../../../LangRef.rst:20394
msgid "Scalable vectors can only be inserted into other scalable vectors."
msgstr ""

#: ../../../LangRef.rst:20399
msgid ""
"The ``vec`` is the vector which ``subvec`` will be inserted into. The "
"``subvec`` is the vector that will be inserted."
msgstr ""

#: ../../../LangRef.rst:20402
msgid ""
"``idx`` represents the starting element number at which ``subvec`` will be "
"inserted. ``idx`` must be a constant multiple of ``subvec``'s known minimum "
"vector length. If ``subvec`` is a scalable vector, ``idx`` is first scaled "
"by the runtime scaling factor of ``subvec``. The elements of ``vec`` "
"starting at ``idx`` are overwritten with ``subvec``. Elements ``idx`` "
"through (``idx`` + num_elements(``subvec``) - 1) must be valid ``vec`` "
"indices. If this condition cannot be determined statically but is false at "
"runtime, then the result vector is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:20413
msgid "'``llvm.vector.extract``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20434
msgid ""
"The '``llvm.vector.extract.*``' intrinsics extract a vector from within "
"another vector starting from a given index. The return type must be "
"explicitly specified. Conceptually, this can be used to decompose a scalable "
"vector into non-scalable parts, however this intrinsic can also be used on "
"purely fixed types."
msgstr ""

#: ../../../LangRef.rst:20440
msgid "Scalable vectors can only be extracted from other scalable vectors."
msgstr ""

#: ../../../LangRef.rst:20445
msgid "The ``vec`` is the vector from which we will extract a subvector."
msgstr ""

#: ../../../LangRef.rst:20447
msgid ""
"The ``idx`` specifies the starting element number within ``vec`` from which "
"a subvector is extracted. ``idx`` must be a constant multiple of the known-"
"minimum vector length of the result type. If the result type is a scalable "
"vector, ``idx`` is first scaled by the result type's runtime scaling factor. "
"Elements ``idx`` through (``idx`` + num_elements(result_type) - 1) must be "
"valid vector indices. If this condition cannot be determined statically but "
"is false at runtime, then the result vector is a :ref:`poison value "
"<poisonvalues>`. The ``idx`` parameter must be a vector index constant type "
"(for most targets this will be an integer pointer type)."
msgstr ""

#: ../../../LangRef.rst:20458
msgid "'``llvm.vector.reverse``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20472
msgid ""
"The '``llvm.vector.reverse.*``' intrinsics reverse a vector. The intrinsic "
"takes a single vector and returns a vector of matching type but with the "
"original lane order reversed. These intrinsics work for both fixed and "
"scalable vectors. While this intrinsic supports all vector types the "
"recommended way to express this operation for fixed-width vectors is still "
"to use a shufflevector, as that may allow for more optimization "
"opportunities."
msgstr ""

#: ../../../LangRef.rst:20483
msgid "The argument to this intrinsic must be a vector."
msgstr ""

#: ../../../LangRef.rst:20486
msgid "'``llvm.vector.deinterleave2/3/4/5/6/7/8``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20503
msgid ""
"The '``llvm.vector.deinterleave2/3/4/5/6/7/8``' intrinsics deinterleave "
"adjacent lanes into 2 through to 8 separate vectors, respectively, and "
"return them as the result."
msgstr ""

#: ../../../LangRef.rst:20507 ../../../LangRef.rst:20547
msgid ""
"This intrinsic works for both fixed and scalable vectors. While this "
"intrinsic supports all vector types the recommended way to express this "
"operation for factor of 2 on fixed-width vectors is still to use a "
"shufflevector, as that may allow for more optimization opportunities."
msgstr ""

#: ../../../LangRef.rst:20523
msgid ""
"The argument is a vector whose type corresponds to the logical concatenation "
"of the aggregated result types."
msgstr ""

#: ../../../LangRef.rst:20527
msgid "'``llvm.vector.interleave2/3/4/5/6/7/8``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20544
msgid ""
"The '``llvm.vector.interleave2/3/4/5/6/7/8``' intrinsic constructs a vector "
"by interleaving all the input vectors."
msgstr ""

#: ../../../LangRef.rst:20562
msgid ""
"All arguments must be vectors of the same type whereby their logical "
"concatenation matches the result type."
msgstr ""

#: ../../../LangRef.rst:20566
msgid "'``llvm.experimental.cttz.elts``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20571
msgid ""
"This is an overloaded intrinsic. You can use ```llvm.experimental.cttz."
"elts``` on any vector of integer elements, both fixed width and scalable."
msgstr ""

#: ../../../LangRef.rst:20581
msgid ""
"The '``llvm.experimental.cttz.elts``' intrinsic counts the number of "
"trailing zero elements of a vector."
msgstr ""

#: ../../../LangRef.rst:20587 ../../../LangRef.rst:26402
msgid ""
"The first argument is the vector to be counted. This argument must be a "
"vector with integer element type. The return type must also be an integer "
"type which is wide enough to hold the maximum number of elements of the "
"source vector. The behavior of this intrinsic is undefined if the return "
"type is not wide enough for the number of elements in the input vector."
msgstr ""

#: ../../../LangRef.rst:20593
msgid ""
"The second argument is a constant flag that indicates whether the intrinsic "
"returns a valid result if the first argument is all zero. If the first "
"argument is all zero and the second argument is true, the result is poison."
msgstr ""

#: ../../../LangRef.rst:20600
msgid ""
"The '``llvm.experimental.cttz.elts``' intrinsic counts the trailing (least "
"significant) zero elements in a vector. If ``src == 0`` the result is the "
"number of elements in the input vector."
msgstr ""

#: ../../../LangRef.rst:20605
msgid "'``llvm.vector.splice``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20619
msgid ""
"The '``llvm.vector.splice.*``' intrinsics construct a vector by "
"concatenating elements from the first input vector with elements of the "
"second input vector, returning a vector of the same type as the input "
"vectors. The signed immediate, modulo the number of elements in the vector, "
"is the index into the first vector from which to extract the result value. "
"This means conceptually that for a positive immediate, a vector is extracted "
"from ``concat(%vec1, %vec2)`` starting at index ``imm``, whereas for a "
"negative immediate, it extracts ``-imm`` trailing elements from the first "
"vector, and the remaining elements from ``%vec2``."
msgstr ""

#: ../../../LangRef.rst:20629
msgid ""
"These intrinsics work for both fixed and scalable vectors. While this "
"intrinsic supports all vector types the recommended way to express this "
"operation for fixed-width vectors is still to use a shufflevector, as that "
"may allow for more optimization opportunities."
msgstr ""

#: ../../../LangRef.rst:20645
msgid ""
"The first two operands are vectors with the same type. The start index is "
"imm modulo the runtime number of elements in the source vector. For a fixed-"
"width vector <N x eltty>, imm is a signed integer constant in the range -N "
"<= imm < N. For a scalable vector <vscale x N x eltty>, imm is a signed "
"integer constant in the range -X <= imm < X where X=vscale_range_min * N."
msgstr ""

#: ../../../LangRef.rst:20652
msgid "'``llvm.stepvector``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20654
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.stepvector`` to generate "
"a vector whose lane values comprise the linear sequence <0, 1, 2, ...>. It "
"is primarily intended for scalable vectors."
msgstr ""

#: ../../../LangRef.rst:20663
msgid ""
"The '``llvm.stepvector``' intrinsics are used to create vectors of integers "
"whose elements contain a linear sequence of values starting from 0 with a "
"step of 1. This intrinsic can only be used for vectors with integer elements "
"that are at least 8 bits in size. If the sequence value exceeds the allowed "
"limit for the element type then the result for that lane is a poison value."
msgstr ""

#: ../../../LangRef.rst:20670
msgid ""
"These intrinsics work for both fixed and scalable vectors. While this "
"intrinsic supports all vector types, the recommended way to express this "
"operation for fixed-width vectors is still to generate a constant vector "
"instead."
msgstr ""

#: ../../../LangRef.rst:20678 ../../../LangRef.rst:29523
#: ../../../LangRef.rst:29586 ../../../LangRef.rst:29836
#: ../../../LangRef.rst:29865 ../../../LangRef.rst:29963
#: ../../../LangRef.rst:30325 ../../../LangRef.rst:30494
#: ../../../LangRef.rst:30763
msgid "None."
msgstr ""

#: ../../../LangRef.rst:20682
msgid "'``llvm.experimental.get.vector.length``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20696
msgid ""
"The '``llvm.experimental.get.vector.length.*``' intrinsics take a number of "
"elements to process and returns how many of the elements can be processed "
"with the requested vectorization factor."
msgstr ""

#: ../../../LangRef.rst:20703
msgid ""
"The first argument is an unsigned value of any scalar integer type and "
"specifies the total number of elements to be processed. The second argument "
"is an i32 immediate for the vectorization factor. The third argument "
"indicates if the vectorization factor should be multiplied by vscale."
msgstr ""

#: ../../../LangRef.rst:20711
msgid ""
"Returns a non-negative i32 value (explicit vector length) that is unknown at "
"compile time and depends on the hardware specification. If the result value "
"does not fit in the result type, then the result is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:20716
msgid ""
"This intrinsic is intended to be used by loop vectorization with VP "
"intrinsics in order to get the number of elements to process on each loop "
"iteration. The result should be used to decrease the count for the next "
"iteration until the count reaches zero."
msgstr ""

#: ../../../LangRef.rst:20721
msgid ""
"Let ``%max_lanes`` be the number of lanes in the type described by ``%vf`` "
"and ``%scalable``, here are the constraints on the returned value:"
msgstr ""

#: ../../../LangRef.rst:20724
msgid "If ``%cnt`` equals to 0, returns 0."
msgstr ""

#: ../../../LangRef.rst:20725
msgid "The returned value is always less than or equal to ``%max_lanes``."
msgstr ""

#: ../../../LangRef.rst:20726
msgid ""
"The returned value is always greater than or equal to ``ceil(%cnt / "
"ceil(%cnt / %max_lanes))``, if ``%cnt`` is non-zero."
msgstr ""

#: ../../../LangRef.rst:20728
msgid ""
"The returned values are monotonically non-increasing in each loop iteration. "
"That is, the returned value of an iteration is at least as large as that of "
"any later iteration."
msgstr ""

#: ../../../LangRef.rst:20732
msgid "Note that it has the following implications:"
msgstr ""

#: ../../../LangRef.rst:20734
msgid ""
"For a loop that uses this intrinsic, the number of iterations is equal to "
"``ceil(%C / %max_lanes)`` where ``%C`` is the initial ``%cnt`` value."
msgstr ""

#: ../../../LangRef.rst:20736
msgid "If ``%cnt`` is non-zero, the return value is non-zero as well."
msgstr ""

#: ../../../LangRef.rst:20737
msgid ""
"If ``%cnt`` is less than or equal to ``%max_lanes``, the return value is "
"equal to ``%cnt``."
msgstr ""

#: ../../../LangRef.rst:20740
msgid "'``llvm.vector.partial.reduce.add.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20756
msgid ""
"The '``llvm.vector.partial.reduce.add.*``' intrinsics reduce the "
"concatenation of the two vector arguments down to the number of elements of "
"the result vector type."
msgstr ""

#: ../../../LangRef.rst:20763
msgid ""
"The first argument is an integer vector with the same type as the result."
msgstr ""

#: ../../../LangRef.rst:20765
msgid ""
"The second argument is a vector with a length that is a known integer "
"multiple of the result's type, while maintaining the same element type."
msgstr ""

#: ../../../LangRef.rst:20771
msgid ""
"Other than the reduction operator (e.g. add) the way in which the "
"concatenated arguments is reduced is entirely unspecified. By their nature "
"these intrinsics are not expected to be useful in isolation but instead "
"implement the first phase of an overall reduction operation."
msgstr ""

#: ../../../LangRef.rst:20776
msgid ""
"The typical use case is loop vectorization where reductions are split into "
"an in-loop phase, where maintaining an unordered vector result is important "
"for performance, and an out-of-loop phase to calculate the final scalar "
"result."
msgstr ""

#: ../../../LangRef.rst:20780
msgid ""
"By avoiding the introduction of new ordering constraints, these intrinsics "
"enhance the ability to leverage a target's accumulation instructions."
msgstr ""

#: ../../../LangRef.rst:20784
msgid "'``llvm.experimental.vector.histogram.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20786
msgid "These intrinsics are overloaded."
msgstr ""

#: ../../../LangRef.rst:20788
msgid ""
"These intrinsics represent histogram-like operations; that is, updating "
"values in memory that may not be contiguous, and where multiple elements "
"within a single vector may be updating the same value in memory."
msgstr ""

#: ../../../LangRef.rst:20792
msgid ""
"The update operation must be specified as part of the intrinsic name. For a "
"simple histogram like the following the ``add`` operation would be used."
msgstr ""

#: ../../../LangRef.rst:20802
msgid "More update operation types may be added in the future."
msgstr ""

#: ../../../LangRef.rst:20815
msgid ""
"The first argument is a vector of pointers to the memory locations to be "
"updated. The second argument is a scalar used to update the value from "
"memory; it must match the type of value to be updated. The final argument is "
"a mask value to exclude locations from being modified."
msgstr ""

#: ../../../LangRef.rst:20823
msgid ""
"The '``llvm.experimental.vector.histogram.*``' intrinsics are used to "
"perform updates on potentially overlapping values in memory. The intrinsics "
"represent the following sequence of operations:"
msgstr ""

#: ../../../LangRef.rst:20827
msgid ""
"Gather load from the ``ptrs`` operand, with element type matching that of "
"the ``inc`` operand."
msgstr ""

#: ../../../LangRef.rst:20829
msgid ""
"Update of the values loaded from memory. In the case of the ``add`` update "
"operation, this means:"
msgstr ""

#: ../../../LangRef.rst:20832
msgid "Perform a cross-vector histogram operation on the ``ptrs`` operand."
msgstr ""

#: ../../../LangRef.rst:20833
msgid "Multiply the result by the ``inc`` operand."
msgstr ""

#: ../../../LangRef.rst:20834
msgid "Add the result to the values loaded from memory"
msgstr ""

#: ../../../LangRef.rst:20835
msgid ""
"Scatter the result of the update operation to the memory locations from the "
"``ptrs`` operand."
msgstr ""

#: ../../../LangRef.rst:20838
msgid ""
"The ``mask`` operand will apply to at least the gather and scatter "
"operations."
msgstr ""

#: ../../../LangRef.rst:20841
msgid "'``llvm.experimental.vector.extract.last.active``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20853
msgid ""
"The first argument is the data vector to extract a lane from. The second is "
"a mask vector controlling the extraction. The third argument is a passthru "
"value."
msgstr ""

#: ../../../LangRef.rst:20857
msgid ""
"The two input vectors must have the same number of elements, and the type of "
"the passthru value must match that of the elements of the data vector."
msgstr ""

#: ../../../LangRef.rst:20863
msgid ""
"The '``llvm.experimental.vector.extract.last.active``' intrinsic will "
"extract an element from the data vector at the index matching the highest "
"active lane of the mask vector. If no mask lanes are active then the "
"passthru value is returned instead."
msgstr ""

#: ../../../LangRef.rst:20871
msgid "'``llvm.experimental.vector.compress.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:20873
msgid ""
"LLVM provides an intrinsic for compressing data within a vector based on a "
"selection mask. Semantically, this is similar to :ref:`llvm.masked."
"compressstore <int_compressstore>` but with weaker assumptions and without "
"storing the results to memory, i.e., the data remains in the vector."
msgstr ""

#: ../../../LangRef.rst:20879
msgid ""
"This is an overloaded intrinsic. A number of scalar values of integer, "
"floating point or pointer data type are collected from an input vector and "
"placed adjacently within the result vector. A mask defines which elements to "
"collect from the vector. The remaining lanes are filled with values from "
"``passthru``."
msgstr ""

#: ../../../LangRef.rst:20891
msgid ""
"Selects elements from input vector ``value`` according to the ``mask``. All "
"selected elements are written into adjacent lanes in the result vector, from "
"lower to higher. The mask holds an entry for each vector lane, and is used "
"to select elements to be kept. If a ``passthru`` vector is given, all "
"remaining lanes are filled with the corresponding lane's value from "
"``passthru``. The main difference to :ref:`llvm.masked.compressstore "
"<int_compressstore>` is that the we do not need to guard against memory "
"access for unselected lanes. This allows for branchless code and better "
"optimization for all targets that do not support or have inefficient "
"instructions of the explicit semantics of :ref:`llvm.masked.compressstore "
"<int_compressstore>` but still have some form of compress operations. The "
"result vector can be written with a similar effect, as all the selected "
"values are at the lower positions of the vector, but without requiring "
"branches to avoid writes where the mask is ``false``."
msgstr ""

#: ../../../LangRef.rst:20912
msgid ""
"The first operand is the input vector, from which elements are selected. The "
"second operand is the mask, a vector of boolean values. The third operand is "
"the passthru vector, from which elements are filled into remaining lanes. "
"The mask and the input vector must have the same number of vector elements. "
"The input and passthru vectors must have the same type."
msgstr ""

#: ../../../LangRef.rst:20922
msgid ""
"The ``llvm.experimental.vector.compress`` intrinsic compresses data within a "
"vector. It collects elements from possibly non-adjacent lanes of a vector "
"and places them contiguously in the result vector based on a selection mask, "
"filling the remaining lanes with values from ``passthru``. This intrinsic "
"performs the logic of the following C++ example. All values in ``out`` after "
"the last selected one are undefined if ``passthru`` is undefined. If all "
"entries in the ``mask`` are 0, the ``out`` vector is ``passthru``. If any "
"element of the mask is poison, all elements of the result are poison. "
"Otherwise, if any element of the mask is undef, all elements of the result "
"are undef. If ``passthru`` is undefined, the number of valid lanes is equal "
"to the number of ``true`` entries in the mask, i.e., all lanes >= number-of-"
"selected-values are undefined."
msgstr ""

#: ../../../LangRef.rst:20955
msgid "'``llvm.experimental.vector.match.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:20970
msgid ""
"Find active elements of the first argument matching any elements of the "
"second."
msgstr ""

#: ../../../LangRef.rst:20975
msgid ""
"The first argument is the search vector, the second argument the vector of "
"elements we are searching for (i.e., for which we consider a match "
"successful), and the third argument is a mask that controls which elements "
"of the first argument are active. The first two arguments must be vectors of "
"matching integer element types. The first and third arguments and the result "
"type must have matching element counts (fixed or scalable). The second "
"argument must be a fixed vector, but its length may be different from the "
"remaining arguments."
msgstr ""

#: ../../../LangRef.rst:20986
msgid ""
"The '``llvm.experimental.vector.match``' intrinsic compares each active "
"element in the first argument against the elements of the second argument, "
"placing ``1`` in the corresponding element of the output vector if any "
"equality comparison is successful, and ``0`` otherwise. Inactive elements in "
"the mask are set to ``0`` in the output."
msgstr ""

#: ../../../LangRef.rst:20993
msgid "Matrix Intrinsics"
msgstr ""

#: ../../../LangRef.rst:20995
msgid ""
"Operations on matrixes requiring shape information (like number of rows/"
"columns or the memory layout) can be expressed using the matrix intrinsics. "
"These intrinsics require matrix dimensions to be passed as immediate "
"arguments, and matrixes are passed and returned as vectors. This means that "
"for a ``R`` x ``C`` matrix, element ``i`` of column ``j`` is at index ``j * "
"R + i`` in the corresponding vector, with indices starting at 0. Currently "
"column-major layout is assumed.  The intrinsics support both integer and "
"floating point matrixes."
msgstr ""

#: ../../../LangRef.rst:21005
msgid "'``llvm.matrix.transpose.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21018
msgid ""
"The '``llvm.matrix.transpose.*``' intrinsics treat ``%In`` as a ``<Rows> x "
"<Cols>`` matrix and return the transposed matrix in the result vector."
msgstr ""

#: ../../../LangRef.rst:21024
msgid ""
"The first argument ``%In`` is a vector that corresponds to a ``<Rows> x "
"<Cols>`` matrix. Thus, arguments ``<Rows>`` and ``<Cols>`` correspond to the "
"number of rows and columns, respectively, and must be positive, constant "
"integers. The returned vector must have ``<Rows> * <Cols>`` elements, and "
"have the same float or integer element type as ``%In``."
msgstr ""

#: ../../../LangRef.rst:21031
msgid "'``llvm.matrix.multiply.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21044
msgid ""
"The '``llvm.matrix.multiply.*``' intrinsics treat ``%A`` as a ``<OuterRows> "
"x <Inner>`` matrix, ``%B`` as a ``<Inner> x <OuterColumns>`` matrix, and "
"multiplies them. The result matrix is returned in the result vector."
msgstr ""

#: ../../../LangRef.rst:21051
msgid ""
"The first vector argument ``%A`` corresponds to a matrix with ``<OuterRows> "
"* <Inner>`` elements, and the second argument ``%B`` to a matrix with "
"``<Inner> * <OuterColumns>`` elements. Arguments ``<OuterRows>``, "
"``<Inner>`` and ``<OuterColumns>`` must be positive, constant integers. The "
"returned vector must have ``<OuterRows> * <OuterColumns>`` elements. Vectors "
"``%A``, ``%B``, and the returned vector all have the same float or integer "
"element type."
msgstr ""

#: ../../../LangRef.rst:21061
msgid "'``llvm.matrix.column.major.load.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21075
msgid ""
"The '``llvm.matrix.column.major.load.*``' intrinsics load a ``<Rows> x "
"<Cols>`` matrix using a stride of ``%Stride`` to compute the start address "
"of the different columns.  The offset is computed using ``%Stride``'s "
"bitwidth. This allows for convenient loading of sub matrixes. If "
"``<IsVolatile>`` is true, the intrinsic is considered a :ref:`volatile "
"memory access <volatile>`. The result matrix is returned in the result "
"vector. If the ``%Ptr`` argument is known to be aligned to some boundary, "
"this can be specified as an attribute on the argument."
msgstr ""

#: ../../../LangRef.rst:21087
msgid ""
"The first argument ``%Ptr`` is a pointer type to the returned vector type, "
"and corresponds to the start address to load from. The second argument "
"``%Stride`` is a positive, constant integer with ``%Stride >= <Rows>``. "
"``%Stride`` is used to compute the column memory addresses. I.e., for a "
"column ``C``, its start memory addresses is calculated with ``%Ptr + C * "
"%Stride``. The third Argument ``<IsVolatile>`` is a boolean value.  The "
"fourth and fifth arguments, ``<Rows>`` and ``<Cols>``, correspond to the "
"number of rows and columns, respectively, and must be positive, constant "
"integers. The returned vector must have ``<Rows> * <Cols>`` elements."
msgstr ""

#: ../../../LangRef.rst:21097 ../../../LangRef.rst:21137
msgid ""
"The :ref:`align <attr_align>` parameter attribute can be provided for the "
"``%Ptr`` arguments."
msgstr ""

#: ../../../LangRef.rst:21102
msgid "'``llvm.matrix.column.major.store.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21115
msgid ""
"The '``llvm.matrix.column.major.store.*``' intrinsics store the ``<Rows> x "
"<Cols>`` matrix in ``%In`` to memory using a stride of ``%Stride`` between "
"columns. The offset is computed using ``%Stride``'s bitwidth. If "
"``<IsVolatile>`` is true, the intrinsic is considered a :ref:`volatile "
"memory access <volatile>`."
msgstr ""

#: ../../../LangRef.rst:21121
msgid ""
"If the ``%Ptr`` argument is known to be aligned to some boundary, this can "
"be specified as an attribute on the argument."
msgstr ""

#: ../../../LangRef.rst:21127
msgid ""
"The first argument ``%In`` is a vector that corresponds to a ``<Rows> x "
"<Cols>`` matrix to be stored to memory. The second argument ``%Ptr`` is a "
"pointer to the vector type of ``%In``, and is the start address of the "
"matrix in memory. The third argument ``%Stride`` is a positive, constant "
"integer with ``%Stride >= <Rows>``.  ``%Stride`` is used to compute the "
"column memory addresses. I.e., for a column ``C``, its start memory "
"addresses is calculated with ``%Ptr + C * %Stride``.  The fourth argument "
"``<IsVolatile>`` is a boolean value. The arguments ``<Rows>`` and ``<Cols>`` "
"correspond to the number of rows and columns, respectively, and must be "
"positive, constant integers."
msgstr ""

#: ../../../LangRef.rst:21142
msgid "Half Precision Floating-Point Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21144
msgid ""
"For most target platforms, half precision floating-point is a storage-only "
"format. This means that it is a dense encoding (in memory) but does not "
"support computation in the format."
msgstr ""

#: ../../../LangRef.rst:21148
msgid ""
"This means that code must first load the half-precision floating-point value "
"as an i16, then convert it to float with :ref:`llvm.convert.from.fp16 "
"<int_convert_from_fp16>`. Computation can then be performed on the float "
"value (including extending to double etc). To store the value back to "
"memory, it is first converted to float if needed, then converted to i16 "
"with :ref:`llvm.convert.to.fp16 <int_convert_to_fp16>`, then storing as an "
"i16 value."
msgstr ""

#: ../../../LangRef.rst:21160
msgid "'``llvm.convert.to.fp16``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21173
msgid ""
"The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from "
"a conventional floating-point type to half precision floating-point format."
msgstr ""

#: ../../../LangRef.rst:21179 ../../../LangRef.rst:21220
msgid ""
"The intrinsic function contains single argument - the value to be converted."
msgstr ""

#: ../../../LangRef.rst:21185
msgid ""
"The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from "
"a conventional floating-point format to half precision floating-point "
"format. The return value is an ``i16`` which contains the converted number."
msgstr ""

#: ../../../LangRef.rst:21200
msgid "'``llvm.convert.from.fp16``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21213
msgid ""
"The '``llvm.convert.from.fp16``' intrinsic function performs a conversion "
"from half precision floating-point format to single precision floating-point "
"format."
msgstr ""

#: ../../../LangRef.rst:21226
msgid ""
"The '``llvm.convert.from.fp16``' intrinsic function performs a conversion "
"from half single precision floating-point format to single precision "
"floating-point format. The input half-float value is represented by an "
"``i16`` value."
msgstr ""

#: ../../../LangRef.rst:21240
msgid "Saturating floating-point to integer conversions"
msgstr ""

#: ../../../LangRef.rst:21242
msgid ""
"The ``fptoui`` and ``fptosi`` instructions return a :ref:`poison value "
"<poisonvalues>` if the rounded-towards-zero value is not representable by "
"the result type. These intrinsics provide an alternative conversion, which "
"will saturate towards the smallest and largest representable integer values "
"instead."
msgstr ""

#: ../../../LangRef.rst:21249
msgid "'``llvm.fptoui.sat.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21254
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fptoui.sat`` on any "
"floating-point argument type and any integer result type, or vectors "
"thereof. Not all targets may support all types, however."
msgstr ""

#: ../../../LangRef.rst:21267
msgid ""
"This intrinsic converts the argument into an unsigned integer using "
"saturating semantics."
msgstr ""

#: ../../../LangRef.rst:21273 ../../../LangRef.rst:21325
msgid ""
"The argument may be any floating-point or vector of floating-point type. The "
"return value may be any integer or vector of integer type. The number of "
"vector elements in argument and return must be the same."
msgstr ""

#: ../../../LangRef.rst:21280 ../../../LangRef.rst:21332
msgid "The conversion to integer is performed subject to the following rules:"
msgstr ""

#: ../../../LangRef.rst:21282 ../../../LangRef.rst:21334
msgid "If the argument is any NaN, zero is returned."
msgstr ""

#: ../../../LangRef.rst:21283
msgid ""
"If the argument is smaller than zero (this includes negative infinity), zero "
"is returned."
msgstr ""

#: ../../../LangRef.rst:21285
msgid ""
"If the argument is larger than the largest representable unsigned integer of "
"the result type (this includes positive infinity), the largest representable "
"unsigned integer is returned."
msgstr ""

#: ../../../LangRef.rst:21288 ../../../LangRef.rst:21341
msgid ""
"Otherwise, the result of rounding the argument towards zero is returned."
msgstr ""

#: ../../../LangRef.rst:21301
msgid "'``llvm.fptosi.sat.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21306
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fptosi.sat`` on any "
"floating-point argument type and any integer result type, or vectors "
"thereof. Not all targets may support all types, however."
msgstr ""

#: ../../../LangRef.rst:21319
msgid ""
"This intrinsic converts the argument into a signed integer using saturating "
"semantics."
msgstr ""

#: ../../../LangRef.rst:21335
msgid ""
"If the argument is smaller than the smallest representable signed integer of "
"the result type (this includes negative infinity), the smallest "
"representable signed integer is returned."
msgstr ""

#: ../../../LangRef.rst:21338
msgid ""
"If the argument is larger than the largest representable signed integer of "
"the result type (this includes positive infinity), the largest representable "
"signed integer is returned."
msgstr ""

#: ../../../LangRef.rst:21354
msgid "Floating-Point Conversion Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21356
msgid ""
"This class of intrinsics is designed for floating-point conversions that do "
"not fall into other categories. For example conversions with specified "
"rounding mode or mini-float conversions."
msgstr ""

#: ../../../LangRef.rst:21361
msgid "'``llvm.fptrunc.round``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21374
msgid ""
"The '``llvm.fptrunc.round``' intrinsic truncates :ref:`floating-point "
"<t_floating>` ``value`` to type ``ty2`` with a specified rounding mode."
msgstr ""

#: ../../../LangRef.rst:21381
msgid ""
"The '``llvm.fptrunc.round``' intrinsic takes a :ref:`floating-point "
"<t_floating>` value to cast and a :ref:`floating-point <t_floating>` type to "
"cast it to. This argument must be larger in size than the result."
msgstr ""

#: ../../../LangRef.rst:21385
msgid ""
"The second argument specifies the rounding mode as described in the "
"constrained intrinsics section. For this intrinsic, the \"round.dynamic\" "
"mode is not supported."
msgstr ""

#: ../../../LangRef.rst:21392
msgid ""
"The '``llvm.fptrunc.round``' intrinsic casts a ``value`` from a larger :ref:"
"`floating-point <t_floating>` type to a smaller :ref:`floating-point "
"<t_floating>` type. This intrinsic is assumed to execute in the default :ref:"
"`floating-point environment <floatenv>` *except* for the rounding mode. This "
"intrinsic is not supported on all targets. Some targets may not support all "
"rounding modes."
msgstr ""

#: ../../../LangRef.rst:21401
msgid "Convergence Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21403
msgid ""
"The LLVM convergence intrinsics for controlling the semantics of "
"``convergent`` operations, which all start with the ``llvm.experimental."
"convergence.`` prefix, are described in the :doc:`ConvergentOperations` "
"document."
msgstr ""

#: ../../../LangRef.rst:21410
msgid "Debugger Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21412
msgid ""
"The LLVM debugger intrinsics (which all start with ``llvm.dbg.`` prefix), "
"are described in the `LLVM Source Level Debugging <SourceLevelDebugging."
"html#format-common-intrinsics>`_ document."
msgstr ""

#: ../../../LangRef.rst:21418
msgid "Exception Handling Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21420
msgid ""
"The LLVM exception handling intrinsics (which all start with ``llvm.eh.`` "
"prefix), are described in the `LLVM Exception Handling <ExceptionHandling."
"html#format-common-intrinsics>`_ document."
msgstr ""

#: ../../../LangRef.rst:21425
msgid "Pointer Authentication Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21427
msgid ""
"The LLVM pointer authentication intrinsics (which all start with ``llvm."
"ptrauth.`` prefix), are described in the `Pointer Authentication "
"<PointerAuth.html#intrinsics>`_ document."
msgstr ""

#: ../../../LangRef.rst:21434
msgid "Trampoline Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21436
msgid ""
"These intrinsics make it possible to excise one parameter, marked with the :"
"ref:`nest <nest>` attribute, from a function. The result is a callable "
"function pointer lacking the nest parameter - the caller does not need to "
"provide a value for it. Instead, the value to use is stored in advance in a "
"\"trampoline\", a block of memory usually allocated on the stack, which also "
"contains code to splice the nest value into the argument list. This is used "
"to implement the GCC nested function address extension."
msgstr ""

#: ../../../LangRef.rst:21445
msgid ""
"For example, if the function is ``i32 f(ptr nest %c, i32 %x, i32 %y)`` then "
"the resulting function pointer has signature ``i32 (i32, i32)``. It can be "
"created as follows:"
msgstr ""

#: ../../../LangRef.rst:21455
msgid ""
"The call ``%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to "
"``%val = call i32 %f(ptr %nval, i32 %x, i32 %y)``."
msgstr ""

#: ../../../LangRef.rst:21461
msgid "'``llvm.init.trampoline``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21473
msgid ""
"This fills the memory pointed to by ``tramp`` with executable code, turning "
"it into a trampoline."
msgstr ""

#: ../../../LangRef.rst:21479
msgid ""
"The ``llvm.init.trampoline`` intrinsic takes three arguments, all pointers. "
"The ``tramp`` argument must point to a sufficiently large and sufficiently "
"aligned block of memory; this memory is written to by the intrinsic. Note "
"that the size and the alignment are target-specific - LLVM currently "
"provides no portable way of determining them, so a front-end that generates "
"this intrinsic needs to have some target-specific knowledge."
msgstr ""

#: ../../../LangRef.rst:21487
msgid ""
"The ``func`` argument must be a constant (potentially bitcasted) pointer to "
"a function declaration or definition, since the calling convention may "
"affect the content of the trampoline that is created."
msgstr ""

#: ../../../LangRef.rst:21495
msgid ""
"The block of memory pointed to by ``tramp`` is filled with target dependent "
"code, turning it into a function. Then ``tramp`` needs to be passed to :ref:"
"`llvm.adjust.trampoline <int_at>` to get a pointer which can be :ref:"
"`bitcast (to a new function) and called <int_trampoline>`. The new "
"function's signature is the same as that of ``func`` with any arguments "
"marked with the ``nest`` attribute removed. At most one such ``nest`` "
"argument is allowed, and it must be of pointer type. Calling the new "
"function is equivalent to calling ``func`` with the same argument list, but "
"with ``nval`` used for the missing ``nest`` argument. If, after calling "
"``llvm.init.trampoline``, the memory pointed to by ``tramp`` is modified, "
"then the effect of any later call to the returned function pointer is "
"undefined."
msgstr ""

#: ../../../LangRef.rst:21511
msgid "'``llvm.adjust.trampoline``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:21523
msgid ""
"This performs any required machine-specific adjustment to the address of a "
"trampoline (passed as ``tramp``)."
msgstr ""

#: ../../../LangRef.rst:21529
msgid ""
"``tramp`` must point to a block of memory which already has trampoline code "
"filled in by a previous call to :ref:`llvm.init.trampoline <int_it>`."
msgstr ""

#: ../../../LangRef.rst:21536
msgid ""
"On some architectures the address of the code to be executed needs to be "
"different than the address where the trampoline is actually stored. This "
"intrinsic returns the executable address corresponding to ``tramp`` after "
"performing the required machine-specific adjustments. The pointer returned "
"can then be :ref:`bitcast and executed <int_trampoline>`."
msgstr ""

#: ../../../LangRef.rst:21546
msgid "Vector Predication Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21547
msgid ""
"VP intrinsics are intended for predicated SIMD/vector code.  A typical VP "
"operation takes a vector mask and an explicit vector length parameter as in:"
msgstr ""

#: ../../../LangRef.rst:21554
msgid ""
"The vector mask parameter (%mask) always has a vector of `i1` type, for "
"example `<32 x i1>`.  The explicit vector length parameter always has the "
"type `i32` and is an unsigned integer value.  The explicit vector length "
"parameter (%evl) is in the range:"
msgstr ""

#: ../../../LangRef.rst:21563
msgid ""
"Note that for :ref:`scalable vector types <t_vector>` ``W`` is the runtime "
"length of the vector."
msgstr ""

#: ../../../LangRef.rst:21566
msgid ""
"The VP intrinsic has undefined behavior if ``%evl > W``.  The explicit "
"vector length (%evl) creates a mask, %EVLmask, with all elements ``0 <= i < "
"%evl`` set to True, and all other lanes ``%evl <= i < W`` to False.  A new "
"mask %M is calculated with an element-wise AND from %mask and %EVLmask:"
msgstr ""

#: ../../../LangRef.rst:21575
msgid "A vector operation ``<opcode>`` on vectors ``A`` and ``B`` calculates:"
msgstr ""

#: ../../../LangRef.rst:21583
msgid "Optimization Hint"
msgstr ""

#: ../../../LangRef.rst:21585
msgid ""
"Some targets, such as AVX512, do not support the %evl parameter in hardware. "
"The use of an effective %evl is discouraged for those targets.  The function "
"``TargetTransformInfo::hasActiveVectorLength()`` returns true when the "
"target has native support for %evl."
msgstr ""

#: ../../../LangRef.rst:21593
msgid "'``llvm.vp.select.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21607
msgid ""
"The '``llvm.vp.select``' intrinsic is used to choose one value based on a "
"condition vector, without IR-level branching."
msgstr ""

#: ../../../LangRef.rst:21613
msgid ""
"The first argument is a vector of ``i1`` and indicates the condition.  The "
"second argument is the value that is selected where the condition vector is "
"true.  The third argument is the value that is selected where the condition "
"vector is false.  The vectors must be of the same size.  The fourth argument "
"is the explicit vector length."
msgstr ""

#: ../../../LangRef.rst:21619
msgid ""
"The optional ``fast-math flags`` marker indicates that the select has one or "
"more :ref:`fast-math flags <fastmath>`. These are optimization hints to "
"enable otherwise unsafe floating-point optimizations. Fast-math flags are "
"only valid for selects that return :ref:`supported floating-point types "
"<fastmath_return_types>`."
msgstr ""

#: ../../../LangRef.rst:21628
msgid ""
"The intrinsic selects lanes from the second and third argument depending on "
"a condition vector."
msgstr ""

#: ../../../LangRef.rst:21631
msgid ""
"All result lanes at positions greater or equal than ``%evl`` are undefined. "
"For all lanes below ``%evl`` where the condition vector is true the lane is "
"taken from the second argument.  Otherwise, the lane is taken from the third "
"argument."
msgstr ""

#: ../../../LangRef.rst:21651
msgid "'``llvm.vp.merge.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21665
msgid ""
"The '``llvm.vp.merge``' intrinsic is used to choose one value based on a "
"condition vector and an index argument, without IR-level branching."
msgstr ""

#: ../../../LangRef.rst:21671
msgid ""
"The first argument is a vector of ``i1`` and indicates the condition.  The "
"second argument is the value that is merged where the condition vector is "
"true. The third argument is the value that is selected where the condition "
"vector is false or the lane position is greater equal than the pivot. The "
"fourth argument is the pivot."
msgstr ""

#: ../../../LangRef.rst:21677
msgid ""
"The optional ``fast-math flags`` marker indicates that the merge has one or "
"more :ref:`fast-math flags <fastmath>`. These are optimization hints to "
"enable otherwise unsafe floating-point optimizations. Fast-math flags are "
"only valid for merges that return :ref:`supported floating-point types "
"<fastmath_return_types>`."
msgstr ""

#: ../../../LangRef.rst:21686
msgid ""
"The intrinsic selects lanes from the second and third argument depending on "
"a condition vector and pivot value."
msgstr ""

#: ../../../LangRef.rst:21689
msgid ""
"For all lanes where the condition vector is true and the lane position is "
"less than ``%pivot`` the lane is taken from the second argument.  Otherwise, "
"the lane is taken from the third argument."
msgstr ""

#: ../../../LangRef.rst:21713
msgid "'``llvm.vp.add.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21728
msgid "Predicated integer addition of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:21734 ../../../LangRef.rst:21781
#: ../../../LangRef.rst:21830 ../../../LangRef.rst:21877
#: ../../../LangRef.rst:21925 ../../../LangRef.rst:21974
#: ../../../LangRef.rst:22023 ../../../LangRef.rst:22071
#: ../../../LangRef.rst:22121 ../../../LangRef.rst:22170
#: ../../../LangRef.rst:22218 ../../../LangRef.rst:22266
#: ../../../LangRef.rst:22314 ../../../LangRef.rst:22412
#: ../../../LangRef.rst:22460 ../../../LangRef.rst:22508
#: ../../../LangRef.rst:22556 ../../../LangRef.rst:26448
#: ../../../LangRef.rst:26497 ../../../LangRef.rst:26546
#: ../../../LangRef.rst:26595
msgid ""
"The first two arguments and the result have the same vector of integer type. "
"The third argument is the vector mask and has the same number of elements as "
"the result vector type. The fourth argument is the explicit vector length of "
"the operation."
msgstr ""

#: ../../../LangRef.rst:21742
msgid ""
"The '``llvm.vp.add``' intrinsic performs integer addition (:ref:`add "
"<i_add>`) of the first and second vector arguments on each enabled lane.  "
"The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:21760
msgid "'``llvm.vp.sub.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21775
msgid "Predicated integer subtraction of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:21789
msgid ""
"The '``llvm.vp.sub``' intrinsic performs integer subtraction (:ref:`sub "
"<i_sub>`)  of the first and second vector arguments on each enabled lane. "
"The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:21809
msgid "'``llvm.vp.mul.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21824
msgid "Predicated integer multiplication of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:21837
msgid ""
"The '``llvm.vp.mul``' intrinsic performs integer multiplication (:ref:`mul "
"<i_mul>`) of the first and second vector arguments on each enabled lane. The "
"result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:21856
msgid "'``llvm.vp.sdiv.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21871
msgid "Predicated, signed division of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:21885
msgid ""
"The '``llvm.vp.sdiv``' intrinsic performs signed division (:ref:`sdiv "
"<i_sdiv>`) of the first and second vector arguments on each enabled lane.  "
"The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:21904
msgid "'``llvm.vp.udiv.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21919
msgid "Predicated, unsigned division of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:21933
msgid ""
"The '``llvm.vp.udiv``' intrinsic performs unsigned division (:ref:`udiv "
"<i_udiv>`) of the first and second vector arguments on each enabled lane. "
"The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:21953
msgid "'``llvm.vp.srem.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:21968
msgid "Predicated computations of the signed remainder of two integer vectors."
msgstr ""

#: ../../../LangRef.rst:21982
msgid ""
"The '``llvm.vp.srem``' intrinsic computes the remainder of the signed "
"division (:ref:`srem <i_srem>`) of the first and second vector arguments on "
"each enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22002
msgid "'``llvm.vp.urem.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22017
msgid ""
"Predicated computation of the unsigned remainder of two integer vectors."
msgstr ""

#: ../../../LangRef.rst:22031
msgid ""
"The '``llvm.vp.urem``' intrinsic computes the remainder of the unsigned "
"division (:ref:`urem <i_urem>`) of the first and second vector arguments on "
"each enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22050
msgid "'``llvm.vp.ashr.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22065
msgid "Vector-predicated arithmetic right-shift."
msgstr ""

#: ../../../LangRef.rst:22079
msgid ""
"The '``llvm.vp.ashr``' intrinsic computes the arithmetic right shift (:ref:"
"`ashr <i_ashr>`) of the first argument by the second argument on each "
"enabled lane. The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22100
msgid "'``llvm.vp.lshr.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22115
msgid "Vector-predicated logical right-shift."
msgstr ""

#: ../../../LangRef.rst:22129
msgid ""
"The '``llvm.vp.lshr``' intrinsic computes the logical right shift (:ref:"
"`lshr <i_lshr>`) of the first argument by the second argument on each "
"enabled lane. The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22149
msgid "'``llvm.vp.shl.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22164
msgid "Vector-predicated left shift."
msgstr ""

#: ../../../LangRef.rst:22178
msgid ""
"The '``llvm.vp.shl``' intrinsic computes the left shift (:ref:`shl <i_shl>`) "
"of the first argument by the second argument on each enabled lane.  The "
"result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22197
msgid "'``llvm.vp.or.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22212
msgid "Vector-predicated or."
msgstr ""

#: ../../../LangRef.rst:22226
msgid ""
"The '``llvm.vp.or``' intrinsic performs a bitwise or (:ref:`or <i_or>`) of "
"the first two arguments on each enabled lane.  The result on disabled lanes "
"is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22245
msgid "'``llvm.vp.and.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22260
msgid "Vector-predicated and."
msgstr ""

#: ../../../LangRef.rst:22274
msgid ""
"The '``llvm.vp.and``' intrinsic performs a bitwise and (:ref:`and <i_or>`) "
"of the first two arguments on each enabled lane.  The result on disabled "
"lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22293
msgid "'``llvm.vp.xor.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22308
msgid "Vector-predicated, bitwise xor."
msgstr ""

#: ../../../LangRef.rst:22322
msgid ""
"The '``llvm.vp.xor``' intrinsic performs a bitwise xor (:ref:`xor <i_xor>`) "
"of the first two arguments on each enabled lane. The result on disabled "
"lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22340
msgid "'``llvm.vp.abs.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22355
msgid "Predicated abs of a vector of integers."
msgstr ""

#: ../../../LangRef.rst:22361
msgid ""
"The first argument and the result have the same vector of integer type. The "
"second argument must be a constant and is a flag to indicate whether the "
"result value of the '``llvm.vp.abs``' intrinsic is a :ref:`poison value "
"<poisonvalues>` if the first argument is statically or dynamically an "
"``INT_MIN`` value. The third argument is the vector mask and has the same "
"number of elements as the result vector type. The fourth argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:22372
msgid ""
"The '``llvm.vp.abs``' intrinsic performs abs (:ref:`abs <int_abs>`) of the "
"first argument on each enabled lane.  The result on disabled lanes is a :ref:"
"`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22391
msgid "'``llvm.vp.smax.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22406
msgid "Predicated integer signed maximum of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:22420
msgid ""
"The '``llvm.vp.smax``' intrinsic performs integer signed maximum (:ref:`smax "
"<int_smax>`) of the first and second vector arguments on each enabled lane.  "
"The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22439
msgid "'``llvm.vp.smin.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22454
msgid "Predicated integer signed minimum of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:22468
msgid ""
"The '``llvm.vp.smin``' intrinsic performs integer signed minimum (:ref:`smin "
"<int_smin>`) of the first and second vector arguments on each enabled lane.  "
"The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22487
msgid "'``llvm.vp.umax.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22502
msgid "Predicated integer unsigned maximum of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:22516
msgid ""
"The '``llvm.vp.umax``' intrinsic performs integer unsigned maximum (:ref:"
"`umax <int_umax>`) of the first and second vector arguments on each enabled "
"lane.  The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22535
msgid "'``llvm.vp.umin.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22550
msgid "Predicated integer unsigned minimum of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:22564
msgid ""
"The '``llvm.vp.umin``' intrinsic performs integer unsigned minimum (:ref:"
"`umin <int_umin>`) of the first and second vector arguments on each enabled "
"lane.  The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:22583
msgid "'``llvm.vp.copysign.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22598
msgid ""
"Predicated floating-point copysign of two vectors of floating-point values."
msgstr ""

#: ../../../LangRef.rst:22604 ../../../LangRef.rst:22653
#: ../../../LangRef.rst:22702 ../../../LangRef.rst:22751
#: ../../../LangRef.rst:22801 ../../../LangRef.rst:22851
#: ../../../LangRef.rst:22900 ../../../LangRef.rst:22949
#: ../../../LangRef.rst:22998 ../../../LangRef.rst:23047
msgid ""
"The first two arguments and the result have the same vector of floating-"
"point type. The third argument is the vector mask and has the same number of "
"elements as the result vector type. The fourth argument is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:22612
msgid ""
"The '``llvm.vp.copysign``' intrinsic performs floating-point copysign (:ref:"
"`copysign <int_copysign>`) of the first and second vector arguments on each "
"enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:22632
msgid "'``llvm.vp.minnum.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22647
msgid ""
"Predicated floating-point IEEE-754-2008 minNum of two vectors of floating-"
"point values."
msgstr ""

#: ../../../LangRef.rst:22661
msgid ""
"The '``llvm.vp.minnum``' intrinsic performs floating-point minimum (:ref:"
"`minnum <i_minnum>`) of the first and second vector arguments on each "
"enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:22681
msgid "'``llvm.vp.maxnum.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22696
msgid ""
"Predicated floating-point IEEE-754-2008 maxNum of two vectors of floating-"
"point values."
msgstr ""

#: ../../../LangRef.rst:22710
msgid ""
"The '``llvm.vp.maxnum``' intrinsic performs floating-point maximum (:ref:"
"`maxnum <i_maxnum>`) of the first and second vector arguments on each "
"enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:22730
msgid "'``llvm.vp.minimum.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22745
msgid ""
"Predicated floating-point minimum of two vectors of floating-point values, "
"propagating NaNs and treating -0.0 as less than +0.0."
msgstr ""

#: ../../../LangRef.rst:22759
msgid ""
"The '``llvm.vp.minimum``' intrinsic performs floating-point minimum (:ref:"
"`minimum <i_minimum>`) of the first and second vector arguments on each "
"enabled lane, the result being NaN if either argument is a NaN. -0.0 is "
"considered to be less than +0.0 for this intrinsic. The result on disabled "
"lanes is a :ref:`poison value <poisonvalues>`. The operation is performed in "
"the default floating-point environment."
msgstr ""

#: ../../../LangRef.rst:22780
msgid "'``llvm.vp.maximum.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22795
msgid ""
"Predicated floating-point maximum of two vectors of floating-point values, "
"propagating NaNs and treating -0.0 as less than +0.0."
msgstr ""

#: ../../../LangRef.rst:22809
msgid ""
"The '``llvm.vp.maximum``' intrinsic performs floating-point maximum (:ref:"
"`maximum <i_maximum>`) of the first and second vector arguments on each "
"enabled lane, the result being NaN if either argument is a NaN. -0.0 is "
"considered to be less than +0.0 for this intrinsic. The result on disabled "
"lanes is a :ref:`poison value <poisonvalues>`. The operation is performed in "
"the default floating-point environment."
msgstr ""

#: ../../../LangRef.rst:22830
msgid "'``llvm.vp.fadd.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22845
msgid ""
"Predicated floating-point addition of two vectors of floating-point values."
msgstr ""

#: ../../../LangRef.rst:22859
msgid ""
"The '``llvm.vp.fadd``' intrinsic performs floating-point addition (:ref:"
"`fadd <i_fadd>`) of the first and second vector arguments on each enabled "
"lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:22879
msgid "'``llvm.vp.fsub.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22894
msgid ""
"Predicated floating-point subtraction of two vectors of floating-point "
"values."
msgstr ""

#: ../../../LangRef.rst:22908
msgid ""
"The '``llvm.vp.fsub``' intrinsic performs floating-point subtraction (:ref:"
"`fsub <i_fsub>`) of the first and second vector arguments on each enabled "
"lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:22928
msgid "'``llvm.vp.fmul.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22943
msgid ""
"Predicated floating-point multiplication of two vectors of floating-point "
"values."
msgstr ""

#: ../../../LangRef.rst:22957
msgid ""
"The '``llvm.vp.fmul``' intrinsic performs floating-point multiplication (:"
"ref:`fmul <i_fmul>`) of the first and second vector arguments on each "
"enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:22977
msgid "'``llvm.vp.fdiv.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:22992
msgid ""
"Predicated floating-point division of two vectors of floating-point values."
msgstr ""

#: ../../../LangRef.rst:23006
msgid ""
"The '``llvm.vp.fdiv``' intrinsic performs floating-point division (:ref:"
"`fdiv <i_fdiv>`) of the first and second vector arguments on each enabled "
"lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:23026
msgid "'``llvm.vp.frem.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23041
msgid ""
"Predicated floating-point remainder of two vectors of floating-point values."
msgstr ""

#: ../../../LangRef.rst:23055
msgid ""
"The '``llvm.vp.frem``' intrinsic performs floating-point remainder (:ref:"
"`frem <i_frem>`) of the first and second vector arguments on each enabled "
"lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:23075
msgid "'``llvm.vp.fneg.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23090
msgid ""
"Predicated floating-point negation of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:23096 ../../../LangRef.rst:23144
#: ../../../LangRef.rst:23192 ../../../LangRef.rst:25738
#: ../../../LangRef.rst:25785 ../../../LangRef.rst:25832
#: ../../../LangRef.rst:25879 ../../../LangRef.rst:25926
#: ../../../LangRef.rst:25973 ../../../LangRef.rst:26020
msgid ""
"The first argument and the result have the same vector of floating-point "
"type. The second argument is the vector mask and has the same number of "
"elements as the result vector type. The third argument is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:23104
msgid ""
"The '``llvm.vp.fneg``' intrinsic performs floating-point negation (:ref:"
"`fneg <i_fneg>`) of the first vector argument on each enabled lane.  The "
"result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:23123
msgid "'``llvm.vp.fabs.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23138
msgid ""
"Predicated floating-point absolute value of a vector of floating-point "
"values."
msgstr ""

#: ../../../LangRef.rst:23152
msgid ""
"The '``llvm.vp.fabs``' intrinsic performs floating-point absolute value (:"
"ref:`fabs <int_fabs>`) of the first vector argument on each enabled lane.  "
"The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:23171
msgid "'``llvm.vp.sqrt.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23186
msgid ""
"Predicated floating-point square root of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:23200
msgid ""
"The '``llvm.vp.sqrt``' intrinsic performs floating-point square root (:ref:"
"`sqrt <int_sqrt>`) of the first vector argument on each enabled lane.  The "
"result on disabled lanes is a :ref:`poison value <poisonvalues>`. The "
"operation is performed in the default floating-point environment."
msgstr ""

#: ../../../LangRef.rst:23220
msgid "'``llvm.vp.fma.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23235
msgid ""
"Predicated floating-point fused multiply-add of two vectors of floating-"
"point values."
msgstr ""

#: ../../../LangRef.rst:23241 ../../../LangRef.rst:23292
msgid ""
"The first three arguments and the result have the same vector of floating-"
"point type. The fourth argument is the vector mask and has the same number "
"of elements as the result vector type. The fifth argument is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:23249
msgid ""
"The '``llvm.vp.fma``' intrinsic performs floating-point fused multiply-add (:"
"ref:`llvm.fma <int_fma>`) of the first, second, and third vector argument on "
"each enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`.  The operation is performed in the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:23269
msgid "'``llvm.vp.fmuladd.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23284
msgid ""
"Predicated floating-point multiply-add of two vectors of floating-point "
"values that can be fused if code generator determines that (a) the target "
"instruction set has support for a fused operation, and (b) that the fused "
"operation is more efficient than the equivalent, separate pair of mul and "
"add instructions."
msgstr ""

#: ../../../LangRef.rst:23300
msgid ""
"The '``llvm.vp.fmuladd``' intrinsic performs floating-point multiply-add (:"
"ref:`llvm.fuladd <int_fmuladd>`) of the first, second, and third vector "
"argument on each enabled lane.  The result on disabled lanes is a :ref:"
"`poison value <poisonvalues>`.  The operation is performed in the default "
"floating-point environment."
msgstr ""

#: ../../../LangRef.rst:23320
msgid "'``llvm.vp.reduce.add.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23334
msgid ""
"Predicated integer ``ADD`` reduction of a vector and a scalar starting "
"value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23340 ../../../LangRef.rst:23456
#: ../../../LangRef.rst:23572 ../../../LangRef.rst:23629
#: ../../../LangRef.rst:23685 ../../../LangRef.rst:23742
#: ../../../LangRef.rst:23799 ../../../LangRef.rst:23856
#: ../../../LangRef.rst:23913
msgid ""
"The first argument is the start value of the reduction, which must be a "
"scalar integer type equal to the result type. The second argument is the "
"vector on which the reduction is performed and must be a vector of integer "
"values whose element type is the result/start type. The third argument is "
"the vector mask and is a vector of boolean values with the same number of "
"elements as the vector argument. The fourth argument is the explicit vector "
"length of the operation."
msgstr ""

#: ../../../LangRef.rst:23350
msgid ""
"The '``llvm.vp.reduce.add``' intrinsic performs the integer ``ADD`` "
"reduction (:ref:`llvm.vector.reduce.add <int_vector_reduce_add>`) of the "
"vector argument ``val`` on each enabled lane, adding it to the scalar "
"``start_value``. Disabled lanes are treated as containing the neutral value "
"``0`` (i.e., having no effect on the reduction operation). If the vector "
"length is zero, the result is equal to ``start_value``."
msgstr ""

#: ../../../LangRef.rst:23357 ../../../LangRef.rst:23414
#: ../../../LangRef.rst:23473 ../../../LangRef.rst:23530
#: ../../../LangRef.rst:23589 ../../../LangRef.rst:23646
#: ../../../LangRef.rst:23702 ../../../LangRef.rst:23759
#: ../../../LangRef.rst:23816 ../../../LangRef.rst:23873
#: ../../../LangRef.rst:23930 ../../../LangRef.rst:23997
#: ../../../LangRef.rst:24064 ../../../LangRef.rst:24134
#: ../../../LangRef.rst:24204
msgid "To ignore the start value, the neutral value can be used."
msgstr ""

#: ../../../LangRef.rst:23376
msgid "'``llvm.vp.reduce.fadd.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23390
msgid ""
"Predicated floating-point ``ADD`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23396 ../../../LangRef.rst:23512
#: ../../../LangRef.rst:23970 ../../../LangRef.rst:24037
#: ../../../LangRef.rst:24104 ../../../LangRef.rst:24174
msgid ""
"The first argument is the start value of the reduction, which must be a "
"scalar floating-point type equal to the result type. The second argument is "
"the vector on which the reduction is performed and must be a vector of "
"floating-point values whose element type is the result/start type. The third "
"argument is the vector mask and is a vector of boolean values with the same "
"number of elements as the vector argument. The fourth argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:23407
msgid ""
"The '``llvm.vp.reduce.fadd``' intrinsic performs the floating-point ``ADD`` "
"reduction (:ref:`llvm.vector.reduce.fadd <int_vector_reduce_fadd>`) of the "
"vector argument ``val`` on each enabled lane, adding it to the scalar "
"``start_value``. Disabled lanes are treated as containing the neutral value "
"``-0.0`` (i.e., having no effect on the reduction operation). If no lanes "
"are enabled, the resulting value will be equal to ``start_value``."
msgstr ""

#: ../../../LangRef.rst:23416
msgid ""
"See the unpredicated version (:ref:`llvm.vector.reduce.fadd "
"<int_vector_reduce_fadd>`) for more detail on the semantics of the reduction."
msgstr ""

#: ../../../LangRef.rst:23435
msgid "'``llvm.vp.reduce.mul.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23449
msgid ""
"Predicated integer ``MUL`` reduction of a vector and a scalar starting "
"value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23466
msgid ""
"The '``llvm.vp.reduce.mul``' intrinsic performs the integer ``MUL`` "
"reduction (:ref:`llvm.vector.reduce.mul <int_vector_reduce_mul>`) of the "
"vector argument ``val`` on each enabled lane, multiplying it by the scalar "
"``start_value``. Disabled lanes are treated as containing the neutral value "
"``1`` (i.e., having no effect on the reduction operation). If the vector "
"length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:23491
msgid "'``llvm.vp.reduce.fmul.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23505
msgid ""
"Predicated floating-point ``MUL`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23523
msgid ""
"The '``llvm.vp.reduce.fmul``' intrinsic performs the floating-point ``MUL`` "
"reduction (:ref:`llvm.vector.reduce.fmul <int_vector_reduce_fmul>`) of the "
"vector argument ``val`` on each enabled lane, multiplying it by the scalar "
"`start_value``. Disabled lanes are treated as containing the neutral value "
"``1.0`` (i.e., having no effect on the reduction operation). If no lanes are "
"enabled, the resulting value will be equal to the starting value."
msgstr ""

#: ../../../LangRef.rst:23532
msgid ""
"See the unpredicated version (:ref:`llvm.vector.reduce.fmul "
"<int_vector_reduce_fmul>`) for more detail on the semantics."
msgstr ""

#: ../../../LangRef.rst:23551
msgid "'``llvm.vp.reduce.and.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23565
msgid ""
"Predicated integer ``AND`` reduction of a vector and a scalar starting "
"value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23582
msgid ""
"The '``llvm.vp.reduce.and``' intrinsic performs the integer ``AND`` "
"reduction (:ref:`llvm.vector.reduce.and <int_vector_reduce_and>`) of the "
"vector argument ``val`` on each enabled lane, performing an '``and``' of "
"that with with the scalar ``start_value``. Disabled lanes are treated as "
"containing the neutral value ``UINT_MAX``, or ``-1`` (i.e., having no effect "
"on the reduction operation). If the vector length is zero, the result is the "
"start value."
msgstr ""

#: ../../../LangRef.rst:23608
msgid "'``llvm.vp.reduce.or.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23622
msgid ""
"Predicated integer ``OR`` reduction of a vector and a scalar starting value, "
"returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23639
msgid ""
"The '``llvm.vp.reduce.or``' intrinsic performs the integer ``OR`` reduction "
"(:ref:`llvm.vector.reduce.or <int_vector_reduce_or>`) of the vector argument "
"``val`` on each enabled lane, performing an '``or``' of that with the scalar "
"``start_value``. Disabled lanes are treated as containing the neutral value "
"``0`` (i.e., having no effect on the reduction operation). If the vector "
"length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:23664
msgid "'``llvm.vp.reduce.xor.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23678
msgid ""
"Predicated integer ``XOR`` reduction of a vector and a scalar starting "
"value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23695
msgid ""
"The '``llvm.vp.reduce.xor``' intrinsic performs the integer ``XOR`` "
"reduction (:ref:`llvm.vector.reduce.xor <int_vector_reduce_xor>`) of the "
"vector argument ``val`` on each enabled lane, performing an '``xor``' of "
"that with the scalar ``start_value``. Disabled lanes are treated as "
"containing the neutral value ``0`` (i.e., having no effect on the reduction "
"operation). If the vector length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:23721
msgid "'``llvm.vp.reduce.smax.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23735
msgid ""
"Predicated signed-integer ``MAX`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23752
msgid ""
"The '``llvm.vp.reduce.smax``' intrinsic performs the signed-integer ``MAX`` "
"reduction (:ref:`llvm.vector.reduce.smax <int_vector_reduce_smax>`) of the "
"vector argument ``val`` on each enabled lane, and taking the maximum of that "
"and the scalar ``start_value``. Disabled lanes are treated as containing the "
"neutral value ``INT_MIN`` (i.e., having no effect on the reduction "
"operation). If the vector length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:23778
msgid "'``llvm.vp.reduce.smin.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23792
msgid ""
"Predicated signed-integer ``MIN`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23809
msgid ""
"The '``llvm.vp.reduce.smin``' intrinsic performs the signed-integer ``MIN`` "
"reduction (:ref:`llvm.vector.reduce.smin <int_vector_reduce_smin>`) of the "
"vector argument ``val`` on each enabled lane, and taking the minimum of that "
"and the scalar ``start_value``. Disabled lanes are treated as containing the "
"neutral value ``INT_MAX`` (i.e., having no effect on the reduction "
"operation). If the vector length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:23835
msgid "'``llvm.vp.reduce.umax.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23849
msgid ""
"Predicated unsigned-integer ``MAX`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23866
msgid ""
"The '``llvm.vp.reduce.umax``' intrinsic performs the unsigned-integer "
"``MAX`` reduction (:ref:`llvm.vector.reduce.umax <int_vector_reduce_umax>`) "
"of the vector argument ``val`` on each enabled lane, and taking the maximum "
"of that and the scalar ``start_value``. Disabled lanes are treated as "
"containing the neutral value ``0`` (i.e., having no effect on the reduction "
"operation). If the vector length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:23892
msgid "'``llvm.vp.reduce.umin.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23906
msgid ""
"Predicated unsigned-integer ``MIN`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23923
msgid ""
"The '``llvm.vp.reduce.umin``' intrinsic performs the unsigned-integer "
"``MIN`` reduction (:ref:`llvm.vector.reduce.umin <int_vector_reduce_umin>`) "
"of the vector argument ``val`` on each enabled lane, taking the minimum of "
"that and the scalar ``start_value``. Disabled lanes are treated as "
"containing the neutral value ``UINT_MAX``, or ``-1`` (i.e., having no effect "
"on the reduction operation). If the vector length is zero, the result is the "
"start value."
msgstr ""

#: ../../../LangRef.rst:23949
msgid "'``llvm.vp.reduce.fmax.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:23963 ../../../LangRef.rst:24097
msgid ""
"Predicated floating-point ``MAX`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:23981
msgid ""
"The '``llvm.vp.reduce.fmax``' intrinsic performs the floating-point ``MAX`` "
"reduction (:ref:`llvm.vector.reduce.fmax <int_vector_reduce_fmax>`) of the "
"vector argument ``val`` on each enabled lane, taking the maximum of that and "
"the scalar ``start_value``. Disabled lanes are treated as containing the "
"neutral value (i.e., having no effect on the reduction operation). If the "
"vector length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:23988
msgid ""
"The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If "
"no flags are set, the neutral value is ``-QNAN``. If ``nnan``  and ``ninf`` "
"are both set, then the neutral value is the smallest floating-point value "
"for the result type. If only ``nnan`` is set then the neutral value is ``-"
"Infinity``."
msgstr ""

#: ../../../LangRef.rst:23993
msgid ""
"This instruction has the same comparison semantics as the :ref:`llvm.vector."
"reduce.fmax <int_vector_reduce_fmax>` intrinsic (and thus the '``llvm.maxnum."
"*``' intrinsic)."
msgstr ""

#: ../../../LangRef.rst:24016
msgid "'``llvm.vp.reduce.fmin.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:24030 ../../../LangRef.rst:24167
msgid ""
"Predicated floating-point ``MIN`` reduction of a vector and a scalar "
"starting value, returning the result as a scalar."
msgstr ""

#: ../../../LangRef.rst:24048
msgid ""
"The '``llvm.vp.reduce.fmin``' intrinsic performs the floating-point ``MIN`` "
"reduction (:ref:`llvm.vector.reduce.fmin <int_vector_reduce_fmin>`) of the "
"vector argument ``val`` on each enabled lane, taking the minimum of that and "
"the scalar ``start_value``. Disabled lanes are treated as containing the "
"neutral value (i.e., having no effect on the reduction operation). If the "
"vector length is zero, the result is the start value."
msgstr ""

#: ../../../LangRef.rst:24055
msgid ""
"The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If "
"no flags are set, the neutral value is ``+QNAN``. If ``nnan``  and ``ninf`` "
"are both set, then the neutral value is the largest floating-point value for "
"the result type. If only ``nnan`` is set then the neutral value is "
"``+Infinity``."
msgstr ""

#: ../../../LangRef.rst:24060
msgid ""
"This instruction has the same comparison semantics as the :ref:`llvm.vector."
"reduce.fmin <int_vector_reduce_fmin>` intrinsic (and thus the '``llvm.minnum."
"*``' intrinsic)."
msgstr ""

#: ../../../LangRef.rst:24083
msgid "'``llvm.vp.reduce.fmaximum.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:24115
msgid ""
"The '``llvm.vp.reduce.fmaximum``' intrinsic performs the floating-point "
"``MAX`` reduction (:ref:`llvm.vector.reduce.fmaximum "
"<int_vector_reduce_fmaximum>`) of the vector argument ``val`` on each "
"enabled lane, taking the maximum of that and the scalar ``start_value``. "
"Disabled lanes are treated as containing the neutral value (i.e., having no "
"effect on the reduction operation). If the vector length is zero, the result "
"is the start value."
msgstr ""

#: ../../../LangRef.rst:24122
msgid ""
"The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If "
"no flags are set or only the ``nnan`` is set, the neutral value is ``-"
"Infinity``. If ``ninf`` is set, then the neutral value is the smallest "
"floating-point value for the result type."
msgstr ""

#: ../../../LangRef.rst:24127
msgid ""
"This instruction has the same comparison semantics as the :ref:`llvm.vector."
"reduce.fmaximum <int_vector_reduce_fmaximum>` intrinsic (and thus the "
"'``llvm.maximum.*``' intrinsic). That is, the result will always be a number "
"unless any of the elements in the vector or the starting value is ``NaN``. "
"Namely, this intrinsic propagates ``NaN``. Also, -0.0 is considered less "
"than +0.0."
msgstr ""

#: ../../../LangRef.rst:24153
msgid "'``llvm.vp.reduce.fminimum.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:24185
msgid ""
"The '``llvm.vp.reduce.fminimum``' intrinsic performs the floating-point "
"``MIN`` reduction (:ref:`llvm.vector.reduce.fminimum "
"<int_vector_reduce_fminimum>`) of the vector argument ``val`` on each "
"enabled lane, taking the minimum of that and the scalar ``start_value``. "
"Disabled lanes are treated as containing the neutral value (i.e., having no "
"effect on the reduction operation). If the vector length is zero, the result "
"is the start value."
msgstr ""

#: ../../../LangRef.rst:24192
msgid ""
"The neutral value is dependent on the :ref:`fast-math flags <fastmath>`. If "
"no flags are set or only the ``nnan`` is set, the neutral value is "
"``+Infinity``. If ``ninf`` is set, then the neutral value is the largest "
"floating-point value for the result type."
msgstr ""

#: ../../../LangRef.rst:24197
msgid ""
"This instruction has the same comparison semantics as the :ref:`llvm.vector."
"reduce.fminimum <int_vector_reduce_fminimum>` intrinsic (and thus the "
"'``llvm.minimum.*``' intrinsic). That is, the result will always be a number "
"unless any of the elements in the vector or the starting value is ``NaN``. "
"Namely, this intrinsic propagates ``NaN``. Also, -0.0 is considered less "
"than +0.0."
msgstr ""

#: ../../../LangRef.rst:24223
msgid "'``llvm.get.active.lane.mask.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:24240
msgid "Create a mask representing active and inactive vector lanes."
msgstr ""

#: ../../../LangRef.rst:24246
msgid ""
"Both arguments have the same scalar integer type. The result is a vector "
"with the i1 element type."
msgstr ""

#: ../../../LangRef.rst:24252
msgid ""
"The '``llvm.get.active.lane.mask.*``' intrinsics are semantically equivalent "
"to:"
msgstr ""

#: ../../../LangRef.rst:24259
msgid ""
"where ``%m`` is a vector (mask) of active/inactive lanes with its elements "
"indexed by ``i``,  and ``%base``, ``%n`` are the two arguments to ``llvm.get."
"active.lane.mask.*``, ``%icmp`` is an integer compare and ``ult`` the "
"unsigned less-than comparison operator.  Overflow cannot occur in ``(%base + "
"i)`` and its comparison against ``%n`` as it is performed in integer numbers "
"and not in machine numbers.  The above is equivalent to:"
msgstr ""

#: ../../../LangRef.rst:24270
msgid ""
"This can, for example, be emitted by the loop vectorizer in which case "
"``%base`` is the first element of the vector induction variable (VIV) and "
"``%n`` is the loop tripcount. Thus, these intrinsics perform an element-wise "
"less than comparison of VIV with the loop tripcount, producing a mask of "
"true/false values representing active/inactive vector lanes, except if the "
"VIV overflows in which case they return false in the lanes where the VIV "
"overflows. The arguments are scalar types to accommodate scalable vector "
"types, for which it is unknown what the type of the step vector needs to be "
"that enumerate its lanes without overflow."
msgstr ""

#: ../../../LangRef.rst:24280
msgid ""
"This mask ``%m`` can e.g. be used in masked load/store instructions. These "
"intrinsics provide a hint to the backend. I.e., for a vector loop, the back-"
"edge taken count of the original scalar loop is explicit as the second "
"argument."
msgstr ""

#: ../../../LangRef.rst:24298
msgid "'``llvm.loop.dependence.war.mask.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:24315
msgid ""
"Given a vector load from %ptrA followed by a vector store to %ptrB, this "
"instruction generates a mask where an active lane indicates that the write-"
"after-read sequence can be performed safely for that lane, without the "
"danger of a write-after-read hazard occurring."
msgstr ""

#: ../../../LangRef.rst:24320
msgid ""
"A write-after-read hazard occurs when a write-after-read sequence for a "
"given lane in a vector ends up being executed as a read-after-write sequence "
"due to the aliasing of pointers."
msgstr ""

#: ../../../LangRef.rst:24327 ../../../LangRef.rst:24391
msgid ""
"The first two arguments are pointers and the last argument is an immediate. "
"The result is a vector with the i1 element type."
msgstr ""

#: ../../../LangRef.rst:24333
msgid ""
"``%elementSize`` is the size of the accessed elements in bytes. The "
"intrinsic returns ``poison`` if the distance between ``%prtA`` and ``%ptrB`` "
"is smaller than ``VF * %elementsize`` and either ``%ptrA + VF * "
"%elementSize`` or ``%ptrB + VF * %elementSize`` wrap. The element of the "
"result mask is active when loading from %ptrA then storing to %ptrB is safe "
"and doesn't result in a write-after-read hazard, meaning that:"
msgstr ""

#: ../../../LangRef.rst:24340
msgid ""
"(ptrB - ptrA) <= 0 (guarantees that all lanes are loaded before any stores), "
"or"
msgstr ""

#: ../../../LangRef.rst:24341
msgid ""
"(ptrB - ptrA) >= elementSize * lane (guarantees that this lane is loaded "
"before the store to the same address)"
msgstr ""

#: ../../../LangRef.rst:24357
msgid "'``llvm.loop.dependence.raw.mask.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:24374
msgid ""
"Given a vector store to %ptrA followed by a vector load from %ptrB, this "
"instruction generates a mask where an active lane indicates that the read-"
"after-write sequence can be performed safely for that lane, without a read-"
"after-write hazard or a store-to-load forwarding hazard being introduced."
msgstr ""

#: ../../../LangRef.rst:24379
msgid ""
"A read-after-write hazard occurs when a read-after-write sequence for a "
"given lane in a vector ends up being executed as a write-after-read sequence "
"due to the aliasing of pointers."
msgstr ""

#: ../../../LangRef.rst:24383
msgid ""
"A store-to-load forwarding hazard occurs when a vector store writes to an "
"address that partially overlaps with the address of a subsequent vector "
"load, meaning that the vector load can't be performed until the vector store "
"is complete."
msgstr ""

#: ../../../LangRef.rst:24397
msgid ""
"``%elementSize`` is the size of the accessed elements in bytes. The "
"intrinsic returns ``poison`` if the distance between ``%prtA`` and ``%ptrB`` "
"is smaller than ``VF * %elementsize`` and either ``%ptrA + VF * "
"%elementSize`` or ``%ptrB + VF * %elementSize`` wrap. The element of the "
"result mask is active when storing to %ptrA then loading from %ptrB is safe "
"and doesn't result in aliasing, meaning that:"
msgstr ""

#: ../../../LangRef.rst:24404
msgid ""
"abs(ptrB - ptrA) >= elementSize * lane (guarantees that the store of this "
"lane occurs before loading from this address), or"
msgstr ""

#: ../../../LangRef.rst:24406
msgid ""
"ptrA == ptrB (doesn't introduce any new hazards that weren't in the scalar "
"code)"
msgstr ""

#: ../../../LangRef.rst:24422
msgid "'``llvm.experimental.vp.splice``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24436
msgid ""
"The '``llvm.experimental.vp.splice.*``' intrinsic is the vector length "
"predicated version of the '``llvm.vector.splice.*``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:24442
msgid ""
"The result and the first two arguments ``vec1`` and ``vec2`` are vectors "
"with the same type.  The third argument ``imm`` is an immediate signed "
"integer that indicates the offset index.  The fourth argument ``mask`` is a "
"vector mask and has the same number of elements as the result.  The last two "
"arguments ``evl1`` and ``evl2`` are unsigned integers indicating the "
"explicit vector lengths of ``vec1`` and ``vec2`` respectively.  ``imm``, "
"``evl1`` and ``evl2`` should respect the following constraints: ``-evl1 <= "
"imm < evl1``, ``0 <= evl1 <= VL`` and ``0 <= evl2 <= VL``, where ``VL`` is "
"the runtime vector factor. If these constraints are not satisfied the "
"intrinsic has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:24455
msgid ""
"Effectively, this intrinsic concatenates ``vec1[0..evl1-1]`` and ``vec2[0.."
"evl2-1]`` and creates the result vector by selecting the elements in a "
"window of size ``evl2``, starting at index ``imm`` (for a positive "
"immediate) of the concatenated vector. Elements in the result vector beyond "
"``evl2`` are ``undef``.  If ``imm`` is negative the starting index is ``evl1 "
"+ imm``.  The result vector of active vector length ``evl2`` contains ``evl1 "
"- imm`` (``-imm`` for negative ``imm``) elements from indices ``[imm..evl1 - "
"1]`` (``[evl1 + imm..evl1 -1]`` for negative ``imm``) of ``vec1`` followed "
"by the first ``evl2 - (evl1 - imm)`` (``evl2 + imm`` for negative ``imm``) "
"elements of ``vec2``. If ``evl1 - imm`` (``-imm``) >= ``evl2``, only the "
"first ``evl2`` elements are considered and the remaining are ``undef``.  The "
"lanes in the result vector disabled by ``mask`` are ``poison``."
msgstr ""

#: ../../../LangRef.rst:24481
msgid "'``llvm.experimental.vp.splat``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24495
msgid ""
"The '``llvm.experimental.vp.splat.*``' intrinsic is to create a predicated "
"splat with specific effective vector length."
msgstr ""

#: ../../../LangRef.rst:24501
msgid ""
"The result is a vector and it is a splat of the first scalar argument. The "
"second argument ``mask`` is a vector mask and has the same number of "
"elements as the result. The third argument is the explicit vector length of "
"the operation."
msgstr ""

#: ../../../LangRef.rst:24508
msgid ""
"This intrinsic splats a vector with ``evl`` elements of a scalar argument. "
"The lanes in the result vector disabled by ``mask`` are ``poison``. The "
"elements past ``evl`` are poison."
msgstr ""

#: ../../../LangRef.rst:24528
msgid "'``llvm.experimental.vp.reverse``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24542
msgid ""
"The '``llvm.experimental.vp.reverse.*``' intrinsic is the vector length "
"predicated version of the '``llvm.vector.reverse.*``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:24548
msgid ""
"The result and the first argument ``vec`` are vectors with the same type. "
"The second argument ``mask`` is a vector mask and has the same number of "
"elements as the result. The third argument is the explicit vector length of "
"the operation."
msgstr ""

#: ../../../LangRef.rst:24556
msgid ""
"This intrinsic reverses the order of the first ``evl`` elements in a vector. "
"The lanes in the result vector disabled by ``mask`` are ``poison``. The "
"elements past ``evl`` are poison."
msgstr ""

#: ../../../LangRef.rst:24563
msgid "'``llvm.vp.load``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24579
msgid ""
"The '``llvm.vp.load.*``' intrinsic is the vector length predicated version "
"of the :ref:`llvm.masked.load <int_mload>` intrinsic."
msgstr ""

#: ../../../LangRef.rst:24585
msgid ""
"The first argument is the base pointer for the load. The second argument is "
"a vector of boolean values with the same number of elements as the return "
"type. The third is the explicit vector length of the operation. The return "
"type and underlying type of the base pointer are the same vector types."
msgstr ""

#: ../../../LangRef.rst:24596
msgid ""
"The '``llvm.vp.load``' intrinsic reads a vector from memory in the same way "
"as the '``llvm.masked.load``' intrinsic, where the mask is taken from the "
"combination of the '``mask``' and '``evl``' arguments in the usual VP way. "
"Certain '``llvm.masked.load``' arguments do not have corresponding arguments "
"in '``llvm.vp.load``': the '``passthru``' argument is implicitly ``poison``; "
"the '``alignment``' argument is taken as the ``align`` parameter attribute, "
"if provided. The default alignment is taken as the ABI alignment of the "
"return type as specified by the :ref:`datalayout string<langref_datalayout>`."
msgstr ""

#: ../../../LangRef.rst:24619
msgid "'``llvm.vp.load_ff``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24635
msgid ""
"The '``llvm.vp.load.ff.*``' intrinsic is similar to '``llvm.vp.load.*``', "
"but will not trap if there are not ``evl`` readable lanes at the pointer. "
"'``ff``' stands for first-fault or fault-only-first."
msgstr ""

#: ../../../LangRef.rst:24642
msgid ""
"The first argument is the base pointer for the load. The second argument is "
"a vector of boolean values with the same number of elements as the first "
"return type.  The third is the explicit vector length of the operation. The "
"first return type and underlying type of the base pointer are the same "
"vector types."
msgstr ""

#: ../../../LangRef.rst:24653
msgid ""
"The '``llvm.vp.load.ff``' is designed for reading vector lanes in a single "
"IR operation where the number of lanes that can be read is not known and can "
"only be determined by looking at the data. This is useful for vectorizing "
"strcmp or strlen like loops where the data contains a null terminator. Some "
"targets have a fault-only-first load instruction that this intrinsic can be "
"lowered to. Other targets may support this intrinsic differently, for "
"example by lowering to a single scalar load guarded by ``evl!=0`` and "
"``mask[0]==1`` and indicating only 1 lane could be read."
msgstr ""

#: ../../../LangRef.rst:24662
msgid ""
"Like '``llvm.vp.load``', this intrinsic reads memory based on a ``mask`` and "
"an ``evl``. If ``evl`` is non-zero and the first lane is masked-on, then the "
"first lane of the vector needs to be inbounds of an allocation. The "
"remaining masked-on lanes with index less than ``evl`` do not need to be "
"inbounds of an the same allocation or any allocation."
msgstr ""

#: ../../../LangRef.rst:24668
msgid ""
"The second return value from the intrinsic indicates the index of the first "
"lane that could not be read for some reason or ``evl`` if all lanes could be "
"be read. Lanes at this index or higher in the first return value are :ref:"
"`poison value <poisonvalues>`. If ``evl`` is non-zero, the result in the "
"second return value must be at least 1, even if the first lane is masked-off."
msgstr ""

#: ../../../LangRef.rst:24674
msgid ""
"The second result is usually less than ``evl`` when an exception would occur "
"for reading that lane, but it can be reduced for any reason. This "
"facilitates emulating this intrinsic when the hardware only supports "
"narrower vector types natively or when when hardware does not support fault-"
"only-first loads."
msgstr ""

#: ../../../LangRef.rst:24679
msgid ""
"Masked-on lanes that are not inbounds of the allocation that contains the "
"first lane are :ref:`poison value <poisonvalues>`. There should be a marker "
"in the allocation that indicates where valid data stops such as a null "
"terminator. The terminator should be checked for after calling this "
"intrinsic to prevent using any lanes past the terminator. Even if second "
"return value is less than ``evl``, the terminator value may not have been "
"read."
msgstr ""

#: ../../../LangRef.rst:24686
msgid ""
"This intrinsic will typically be called in a loop until a terminator is "
"found. The second result should be used to indicates how many elements are "
"valid to look for the null terminator. If the terminator is not found, the "
"pointer should be advanced by the number of elements in the second result "
"and the intrinsic called again."
msgstr ""

#: ../../../LangRef.rst:24692
msgid ""
"The default alignment is taken as the ABI alignment of the first return type "
"as specified by the :ref:`datalayout string<langref_datalayout>`."
msgstr ""

#: ../../../LangRef.rst:24705
msgid "'``llvm.vp.store``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24721
msgid ""
"The '``llvm.vp.store.*``' intrinsic is the vector length predicated version "
"of the :ref:`llvm.masked.store <int_mstore>` intrinsic."
msgstr ""

#: ../../../LangRef.rst:24727
msgid ""
"The first argument is the vector value to be written to memory. The second "
"argument is the base pointer for the store. It has the same underlying type "
"as the value argument. The third argument is a vector of boolean values with "
"the same number of elements as the return type. The fourth is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:24733 ../../../LangRef.rst:24849
#: ../../../LangRef.rst:24967
msgid ""
"The :ref:`align <attr_align>` parameter attribute can be provided for the "
"second argument."
msgstr ""

#: ../../../LangRef.rst:24739
msgid ""
"The '``llvm.vp.store``' intrinsic reads a vector from memory in the same way "
"as the '``llvm.masked.store``' intrinsic, where the mask is taken from the "
"combination of the '``mask``' and '``evl``' arguments in the usual VP way. "
"The alignment of the operation (corresponding to the '``alignment``' "
"argument of '``llvm.masked.store``') is specified by the ``align`` parameter "
"attribute (see above). If it is not provided then the ABI alignment of the "
"type of the '``value``' argument as specified by the :ref:`datalayout "
"string<langref_datalayout>` is used instead."
msgstr ""

#: ../../../LangRef.rst:24762
msgid "'``llvm.experimental.vp.strided.load``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24776
msgid ""
"The '``llvm.experimental.vp.strided.load``' intrinsic loads, into a vector, "
"scalar values from memory locations evenly spaced apart by '``stride``' "
"number of bytes, starting from '``ptr``'."
msgstr ""

#: ../../../LangRef.rst:24782
msgid ""
"The first argument is the base pointer for the load. The second argument is "
"the stride value expressed in bytes. The third argument is a vector of "
"boolean values with the same number of elements as the return type. The "
"fourth is the explicit vector length of the operation. The base pointer "
"underlying type matches the type of the scalar elements of the return "
"argument."
msgstr ""

#: ../../../LangRef.rst:24794
msgid ""
"The '``llvm.experimental.vp.strided.load``' intrinsic loads, into a vector, "
"multiple scalar values from memory in the same way as the :ref:`llvm.vp."
"gather <int_vp_gather>` intrinsic, where the vector of pointers is in the "
"form:"
msgstr ""

#: ../../../LangRef.rst:24798 ../../../LangRef.rst:24859
msgid "``%ptrs = <%ptr, %ptr + %stride, %ptr + 2 * %stride, ... >``,"
msgstr ""

#: ../../../LangRef.rst:24800 ../../../LangRef.rst:24861
msgid ""
"with '``ptr``' previously casted to a pointer '``i8``', '``stride``' always "
"interpreted as a signed integer and all arithmetic occurring in the pointer "
"type."
msgstr ""

#: ../../../LangRef.rst:24821
msgid "'``llvm.experimental.vp.strided.store``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24835
msgid ""
"The '``@llvm.experimental.vp.strided.store``' intrinsic stores the elements "
"of '``val``' into memory locations evenly spaced apart by '``stride``' "
"number of bytes, starting from '``ptr``'."
msgstr ""

#: ../../../LangRef.rst:24842
msgid ""
"The first argument is the vector value to be written to memory. The second "
"argument is the base pointer for the store. Its underlying type matches the "
"scalar element type of the value argument. The third argument is the stride "
"value expressed in bytes. The fourth argument is a vector of boolean values "
"with the same number of elements as the return type. The fifth is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:24855
msgid ""
"The '``llvm.experimental.vp.strided.store``' intrinsic stores the elements "
"of '``val``' in the same way as the :ref:`llvm.vp.scatter <int_vp_scatter>` "
"intrinsic, where the vector of pointers is in the form:"
msgstr ""

#: ../../../LangRef.rst:24882
msgid "'``llvm.vp.gather``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24898
msgid ""
"The '``llvm.vp.gather.*``' intrinsic is the vector length predicated version "
"of the :ref:`llvm.masked.gather <int_mgather>` intrinsic."
msgstr ""

#: ../../../LangRef.rst:24904
msgid ""
"The first argument is a vector of pointers which holds all memory addresses "
"to read. The second argument is a vector of boolean values with the same "
"number of elements as the return type. The third is the explicit vector "
"length of the operation. The return type and underlying type of the vector "
"of pointers are the same vector types."
msgstr ""

#: ../../../LangRef.rst:24916
msgid ""
"The '``llvm.vp.gather``' intrinsic reads multiple scalar values from memory "
"in the same way as the '``llvm.masked.gather``' intrinsic, where the mask is "
"taken from the combination of the '``mask``' and '``evl``' arguments in the "
"usual VP way. Certain '``llvm.masked.gather``' arguments do not have "
"corresponding arguments in '``llvm.vp.gather``': the '``passthru``' argument "
"is implicitly ``poison``; the '``alignment``' argument is taken as the "
"``align`` parameter, if provided. The default alignment is taken as the ABI "
"alignment of the source addresses as specified by the :ref:`datalayout "
"string<langref_datalayout>`."
msgstr ""

#: ../../../LangRef.rst:24939
msgid "'``llvm.vp.scatter``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:24955
msgid ""
"The '``llvm.vp.scatter.*``' intrinsic is the vector length predicated "
"version of the :ref:`llvm.masked.scatter <int_mscatter>` intrinsic."
msgstr ""

#: ../../../LangRef.rst:24961
msgid ""
"The first argument is a vector value to be written to memory. The second "
"argument is a vector of pointers, pointing to where the value elements "
"should be stored. The third argument is a vector of boolean values with the "
"same number of elements as the return type. The fourth is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:24973
msgid ""
"The '``llvm.vp.scatter``' intrinsic writes multiple scalar values to memory "
"in the same way as the '``llvm.masked.scatter``' intrinsic, where the mask "
"is taken from the combination of the '``mask``' and '``evl``' arguments in "
"the usual VP way. The '``alignment``' argument of the '``llvm.masked."
"scatter``' does not have a corresponding argument in '``llvm.vp.scatter``': "
"it is instead provided via the optional ``align`` parameter attribute on the "
"vector-of-pointers argument. Otherwise it is taken as the ABI alignment of "
"the destination addresses as specified by the :ref:`datalayout "
"string<langref_datalayout>`."
msgstr ""

#: ../../../LangRef.rst:24997
msgid "'``llvm.vp.trunc.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25011
msgid ""
"The '``llvm.vp.trunc``' intrinsic truncates its first argument to the return "
"type. The operation has a mask and an explicit vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25018
msgid ""
"The '``llvm.vp.trunc``' intrinsic takes a value to cast as its first "
"argument. The return type is the type to cast the value to. Both types must "
"be vector of :ref:`integer <t_integer>` type. The bit size of the value must "
"be larger than the bit size of the return type. The second argument is the "
"vector mask. The return type, the value to cast, and the vector mask have "
"the same number of elements.  The third argument is the explicit vector "
"length of the operation."
msgstr ""

#: ../../../LangRef.rst:25028
msgid ""
"The '``llvm.vp.trunc``' intrinsic truncates the high order bits in value and "
"converts the remaining bits to return type. Since the source size must be "
"larger than the destination size, '``llvm.vp.trunc``' cannot be a *no-op "
"cast*. It will always truncate bits. The conversion is performed on lane "
"positions below the explicit vector length and where the vector mask is "
"true.  Masked-off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25050
msgid "'``llvm.vp.zext.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25064
msgid ""
"The '``llvm.vp.zext``' intrinsic zero extends its first argument to the "
"return type. The operation has a mask and an explicit vector length "
"parameter."
msgstr ""

#: ../../../LangRef.rst:25071
msgid ""
"The '``llvm.vp.zext``' intrinsic takes a value to cast as its first "
"argument. The return type is the type to cast the value to. Both types must "
"be vectors of :ref:`integer <t_integer>` type. The bit size of the value "
"must be smaller than the bit size of the return type. The second argument is "
"the vector mask. The return type, the value to cast, and the vector mask "
"have the same number of elements.  The third argument is the explicit vector "
"length of the operation."
msgstr ""

#: ../../../LangRef.rst:25081
msgid ""
"The '``llvm.vp.zext``' intrinsic fill the high order bits of the value with "
"zero bits until it reaches the size of the return type. When zero extending "
"from i1, the result will always be either 0 or 1. The conversion is "
"performed on lane positions below the explicit vector length and where the "
"vector mask is true. Masked-off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25102
msgid "'``llvm.vp.sext.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25116
msgid ""
"The '``llvm.vp.sext``' intrinsic sign extends its first argument to the "
"return type. The operation has a mask and an explicit vector length "
"parameter."
msgstr ""

#: ../../../LangRef.rst:25123
msgid ""
"The '``llvm.vp.sext``' intrinsic takes a value to cast as its first "
"argument. The return type is the type to cast the value to. Both types must "
"be vectors of :ref:`integer <t_integer>` type. The bit size of the value "
"must be smaller than the bit size of the return type. The second argument is "
"the vector mask. The return type, the value to cast, and the vector mask "
"have the same number of elements.  The third argument is the explicit vector "
"length of the operation."
msgstr ""

#: ../../../LangRef.rst:25133
msgid ""
"The '``llvm.vp.sext``' intrinsic performs a sign extension by copying the "
"sign bit (highest order bit) of the value until it reaches the size of the "
"return type. When sign extending from i1, the result will always be either "
"-1 or 0. The conversion is performed on lane positions below the explicit "
"vector length and where the vector mask is true. Masked-off lanes are "
"``poison``."
msgstr ""

#: ../../../LangRef.rst:25154
msgid "'``llvm.vp.fptrunc.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25168
msgid ""
"The '``llvm.vp.fptrunc``' intrinsic truncates its first argument to the "
"return type. The operation has a mask and an explicit vector length "
"parameter."
msgstr ""

#: ../../../LangRef.rst:25175
msgid ""
"The '``llvm.vp.fptrunc``' intrinsic takes a value to cast as its first "
"argument. The return type is the type to cast the value to. Both types must "
"be vector of :ref:`floating-point <t_floating>` type. The bit size of the "
"value must be larger than the bit size of the return type. This implies that "
"'``llvm.vp.fptrunc``' cannot be used to make a *no-op cast*. The second "
"argument is the vector mask. The return type, the value to cast, and the "
"vector mask have the same number of elements.  The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25187
msgid ""
"The '``llvm.vp.fptrunc``' intrinsic casts a ``value`` from a larger :ref:"
"`floating-point <t_floating>` type to a smaller :ref:`floating-point "
"<t_floating>` type. This instruction is assumed to execute in the default :"
"ref:`floating-point environment <floatenv>`. The conversion is performed on "
"lane positions below the explicit vector length and where the vector mask is "
"true.  Masked-off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25210
msgid "'``llvm.vp.fpext.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25224
msgid ""
"The '``llvm.vp.fpext``' intrinsic extends its first argument to the return "
"type. The operation has a mask and an explicit vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25231
msgid ""
"The '``llvm.vp.fpext``' intrinsic takes a value to cast as its first "
"argument. The return type is the type to cast the value to. Both types must "
"be vector of :ref:`floating-point <t_floating>` type. The bit size of the "
"value must be smaller than the bit size of the return type. This implies "
"that '``llvm.vp.fpext``' cannot be used to make a *no-op cast*. The second "
"argument is the vector mask. The return type, the value to cast, and the "
"vector mask have the same number of elements.  The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25243
msgid ""
"The '``llvm.vp.fpext``' intrinsic extends the ``value`` from a smaller :ref:"
"`floating-point <t_floating>` type to a larger :ref:`floating-point "
"<t_floating>` type. The '``llvm.vp.fpext``' cannot be used to make a *no-op "
"cast* because it always changes bits. Use ``bitcast`` to make a *no-op cast* "
"for a floating-point cast. The conversion is performed on lane positions "
"below the explicit vector length and where the vector mask is true.  Masked-"
"off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25266
msgid "'``llvm.vp.fptoui.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25281
msgid ""
"The '``llvm.vp.fptoui``' intrinsic converts the :ref:`floating-point "
"<t_floating>` argument to the unsigned integer return type. The operation "
"has a mask and an explicit vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25289
msgid ""
"The '``llvm.vp.fptoui``' intrinsic takes a value to cast as its first "
"argument. The value to cast must be a vector of :ref:`floating-point "
"<t_floating>` type. The return type is the type to cast the value to. The "
"return type must be vector of :ref:`integer <t_integer>` type.  The second "
"argument is the vector mask. The return type, the value to cast, and the "
"vector mask have the same number of elements.  The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25300
msgid ""
"The '``llvm.vp.fptoui``' intrinsic converts its :ref:`floating-point "
"<t_floating>` argument into the nearest (rounding towards zero) unsigned "
"integer value where the lane position is below the explicit vector length "
"and the vector mask is true.  Masked-off lanes are ``poison``. On enabled "
"lanes where conversion takes place and the value cannot fit in the return "
"type, the result on that lane is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25322
msgid "'``llvm.vp.fptosi.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25337
msgid ""
"The '``llvm.vp.fptosi``' intrinsic converts the :ref:`floating-point "
"<t_floating>` argument to the signed integer return type. The operation has "
"a mask and an explicit vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25345
msgid ""
"The '``llvm.vp.fptosi``' intrinsic takes a value to cast as its first "
"argument. The value to cast must be a vector of :ref:`floating-point "
"<t_floating>` type. The return type is the type to cast the value to. The "
"return type must be vector of :ref:`integer <t_integer>` type.  The second "
"argument is the vector mask. The return type, the value to cast, and the "
"vector mask have the same number of elements.  The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25356
msgid ""
"The '``llvm.vp.fptosi``' intrinsic converts its :ref:`floating-point "
"<t_floating>` argument into the nearest (rounding towards zero) signed "
"integer value where the lane position is below the explicit vector length "
"and the vector mask is true.  Masked-off lanes are ``poison``. On enabled "
"lanes where conversion takes place and the value cannot fit in the return "
"type, the result on that lane is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25378
msgid "'``llvm.vp.uitofp.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25393
msgid ""
"The '``llvm.vp.uitofp``' intrinsic converts its unsigned integer argument to "
"the :ref:`floating-point <t_floating>` return type.  The operation has a "
"mask and an explicit vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25401
msgid ""
"The '``llvm.vp.uitofp``' intrinsic takes a value to cast as its first "
"argument. The value to cast must be vector of :ref:`integer <t_integer>` "
"type.  The return type is the type to cast the value to.  The return type "
"must be a vector of :ref:`floating-point <t_floating>` type.  The second "
"argument is the vector mask. The return type, the value to cast, and the "
"vector mask have the same number of elements.  The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25412
msgid ""
"The '``llvm.vp.uitofp``' intrinsic interprets its first argument as an "
"unsigned integer quantity and converts it to the corresponding floating-"
"point value. If the value cannot be exactly represented, it is rounded using "
"the default rounding mode.  The conversion is performed on lane positions "
"below the explicit vector length and where the vector mask is true.  Masked-"
"off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25434
msgid "'``llvm.vp.sitofp.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25449
msgid ""
"The '``llvm.vp.sitofp``' intrinsic converts its signed integer argument to "
"the :ref:`floating-point <t_floating>` return type.  The operation has a "
"mask and an explicit vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25457
msgid ""
"The '``llvm.vp.sitofp``' intrinsic takes a value to cast as its first "
"argument. The value to cast must be vector of :ref:`integer <t_integer>` "
"type.  The return type is the type to cast the value to.  The return type "
"must be a vector of :ref:`floating-point <t_floating>` type.  The second "
"argument is the vector mask. The return type, the value to cast, and the "
"vector mask have the same number of elements.  The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25468
msgid ""
"The '``llvm.vp.sitofp``' intrinsic interprets its first argument as a signed "
"integer quantity and converts it to the corresponding floating-point value. "
"If the value cannot be exactly represented, it is rounded using the default "
"rounding mode.  The conversion is performed on lane positions below the "
"explicit vector length and where the vector mask is true.  Masked-off lanes "
"are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25490
msgid "'``llvm.vp.ptrtoint.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25505
msgid ""
"The '``llvm.vp.ptrtoint``' intrinsic converts its pointer to the integer "
"return type.  The operation has a mask and an explicit vector length "
"parameter."
msgstr ""

#: ../../../LangRef.rst:25512
msgid ""
"The '``llvm.vp.ptrtoint``' intrinsic takes a value to cast as its first "
"argument , which must be a vector of pointers, and a type to cast it to "
"return type, which must be a vector of :ref:`integer <t_integer>` type. The "
"second argument is the vector mask. The return type, the value to cast, and "
"the vector mask have the same number of elements. The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25522
msgid ""
"The '``llvm.vp.ptrtoint``' intrinsic converts value to return type by "
"interpreting the pointer value as an integer and either truncating or zero "
"extending that value to the size of the integer type. If ``value`` is "
"smaller than return type, then a zero extension is done. If ``value`` is "
"larger than return type, then a truncation is done. If they are the same "
"size, then nothing is done (*no-op cast*) other than a type change. The "
"conversion is performed on lane positions below the explicit vector length "
"and where the vector mask is true.  Masked-off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25547
msgid "'``llvm.vp.inttoptr.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25562
msgid ""
"The '``llvm.vp.inttoptr``' intrinsic converts its integer value to the point "
"return type. The operation has a mask and an explicit vector length "
"parameter."
msgstr ""

#: ../../../LangRef.rst:25569
msgid ""
"The '``llvm.vp.inttoptr``' intrinsic takes a value to cast as its first "
"argument , which must be a vector of :ref:`integer <t_integer>` type, and a "
"type to cast it to return type, which must be a vector of pointers type. The "
"second argument is the vector mask. The return type, the value to cast, and "
"the vector mask have the same number of elements. The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25579
msgid ""
"The '``llvm.vp.inttoptr``' intrinsic converts ``value`` to return type by "
"applying either a zero extension or a truncation depending on the size of "
"the integer ``value``. If ``value`` is larger than the size of a pointer, "
"then a truncation is done. If ``value`` is smaller than the size of a "
"pointer, then a zero extension is done. If they are the same size, nothing "
"is done (*no-op cast*). The conversion is performed on lane positions below "
"the explicit vector length and where the vector mask is true.  Masked-off "
"lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25602
msgid "'``llvm.vp.fcmp.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25617
msgid ""
"The '``llvm.vp.fcmp``' intrinsic returns a vector of boolean values based on "
"the comparison of its arguments. The operation has a mask and an explicit "
"vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25625
msgid ""
"The '``llvm.vp.fcmp``' intrinsic takes the two values to compare as its "
"first and second arguments. These two values must be vectors of :ref:"
"`floating-point <t_floating>` types. The return type is the result of the "
"comparison. The return type must be a vector of :ref:`i1 <t_integer>` type. "
"The fourth argument is the vector mask. The return type, the values to "
"compare, and the vector mask have the same number of elements. The third "
"argument is the condition code indicating the kind of comparison to perform. "
"It must be a metadata string with :ref:`one of the supported floating-point "
"condition code values <fcmp_md_cc>`. The fifth argument is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25639
msgid ""
"The '``llvm.vp.fcmp``' compares its first two arguments according to the "
"condition code given as the third argument. The arguments are compared "
"element by element on each enabled lane, where the semantics of the "
"comparison are defined :ref:`according to the condition code "
"<fcmp_md_cc_sem>`. Masked-off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25660
msgid "'``llvm.vp.icmp.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25675
msgid ""
"The '``llvm.vp.icmp``' intrinsic returns a vector of boolean values based on "
"the comparison of its arguments. The operation has a mask and an explicit "
"vector length parameter."
msgstr ""

#: ../../../LangRef.rst:25683
msgid ""
"The '``llvm.vp.icmp``' intrinsic takes the two values to compare as its "
"first and second arguments. These two values must be vectors of :ref:"
"`integer <t_integer>` types. The return type is the result of the "
"comparison. The return type must be a vector of :ref:`i1 <t_integer>` type. "
"The fourth argument is the vector mask. The return type, the values to "
"compare, and the vector mask have the same number of elements. The third "
"argument is the condition code indicating the kind of comparison to perform. "
"It must be a metadata string with :ref:`one of the supported integer "
"condition code values <icmp_md_cc>`. The fifth argument is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:25697
msgid ""
"The '``llvm.vp.icmp``' compares its first two arguments according to the "
"condition code given as the third argument. The arguments are compared "
"element by element on each enabled lane, where the semantics of the "
"comparison are defined :ref:`according to the condition code "
"<icmp_md_cc_sem>`. Masked-off lanes are ``poison``."
msgstr ""

#: ../../../LangRef.rst:25717
msgid "'``llvm.vp.ceil.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25732
msgid "Predicated floating-point ceiling of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:25746
msgid ""
"The '``llvm.vp.ceil``' intrinsic performs floating-point ceiling (:ref:`ceil "
"<int_ceil>`) of the first vector argument on each enabled lane. The result "
"on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25764
msgid "'``llvm.vp.floor.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25779
msgid "Predicated floating-point floor of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:25793
msgid ""
"The '``llvm.vp.floor``' intrinsic performs floating-point floor (:ref:`floor "
"<int_floor>`) of the first vector argument on each enabled lane. The result "
"on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25811
msgid "'``llvm.vp.rint.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25826
msgid "Predicated floating-point rint of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:25840
msgid ""
"The '``llvm.vp.rint``' intrinsic performs floating-point rint (:ref:`rint "
"<int_rint>`) of the first vector argument on each enabled lane. The result "
"on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25858
msgid "'``llvm.vp.nearbyint.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25873
msgid ""
"Predicated floating-point nearbyint of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:25887
msgid ""
"The '``llvm.vp.nearbyint``' intrinsic performs floating-point nearbyint (:"
"ref:`nearbyint <int_nearbyint>`) of the first vector argument on each "
"enabled lane. The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25905
msgid "'``llvm.vp.round.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25920
msgid "Predicated floating-point round of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:25934
msgid ""
"The '``llvm.vp.round``' intrinsic performs floating-point round (:ref:`round "
"<int_round>`) of the first vector argument on each enabled lane. The result "
"on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25952
msgid "'``llvm.vp.roundeven.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:25967
msgid ""
"Predicated floating-point roundeven of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:25981
msgid ""
"The '``llvm.vp.roundeven``' intrinsic performs floating-point roundeven (:"
"ref:`roundeven <int_roundeven>`) of the first vector argument on each "
"enabled lane. The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:25999
msgid "'``llvm.vp.roundtozero.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26014
msgid ""
"Predicated floating-point round-to-zero of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:26028
msgid ""
"The '``llvm.vp.roundtozero``' intrinsic performs floating-point roundeven (:"
"ref:`llvm.trunc <int_llvm_trunc>`) of the first vector argument on each "
"enabled lane.  The result on disabled lanes is a :ref:`poison value "
"<poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26046
msgid "'``llvm.vp.lrint.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26061
msgid "Predicated lrint of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:26067 ../../../LangRef.rst:26113
msgid ""
"The result is an integer vector and the first argument is a vector of :ref:"
"`floating-point <t_floating>` type with the same number of elements as the "
"result vector type. The second argument is the vector mask and has the same "
"number of elements as the result vector type. The third argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:26075
msgid ""
"The '``llvm.vp.lrint``' intrinsic performs lrint (:ref:`lrint <int_lrint>`) "
"of the first vector argument on each enabled lane. The result on disabled "
"lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26093
msgid "'``llvm.vp.llrint.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26108
msgid "Predicated llrint of a vector of floating-point values."
msgstr ""

#: ../../../LangRef.rst:26121
msgid ""
"The '``llvm.vp.llrint``' intrinsic performs lrint (:ref:`llrint "
"<int_llrint>`) of the first vector argument on each enabled lane. The result "
"on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26140
msgid "'``llvm.vp.bitreverse.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26155
msgid "Predicated bitreverse of a vector of integers."
msgstr ""

#: ../../../LangRef.rst:26161 ../../../LangRef.rst:26208
#: ../../../LangRef.rst:26255
msgid ""
"The first argument and the result have the same vector of integer type. The "
"second argument is the vector mask and has the same number of elements as "
"the result vector type. The third argument is the explicit vector length of "
"the operation."
msgstr ""

#: ../../../LangRef.rst:26169
msgid ""
"The '``llvm.vp.bitreverse``' intrinsic performs bitreverse (:ref:`bitreverse "
"<int_bitreverse>`) of the first argument on each enabled lane.  The result "
"on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26187
msgid "'``llvm.vp.bswap.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26202
msgid "Predicated bswap of a vector of integers."
msgstr ""

#: ../../../LangRef.rst:26216
msgid ""
"The '``llvm.vp.bswap``' intrinsic performs bswap (:ref:`bswap <int_bswap>`) "
"of the first argument on each enabled lane.  The result on disabled lanes is "
"a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26234
msgid "'``llvm.vp.ctpop.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26249
msgid "Predicated ctpop of a vector of integers."
msgstr ""

#: ../../../LangRef.rst:26263
msgid ""
"The '``llvm.vp.ctpop``' intrinsic performs ctpop (:ref:`ctpop <int_ctpop>`) "
"of the first argument on each enabled lane.  The result on disabled lanes is "
"a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26281
msgid "'``llvm.vp.ctlz.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26296
msgid "Predicated ctlz of a vector of integers."
msgstr ""

#: ../../../LangRef.rst:26302
msgid ""
"The first argument and the result have the same vector of integer type. The "
"second argument is a constant flag that indicates whether the intrinsic "
"returns a valid result if the first argument is zero. The third argument is "
"the vector mask and has the same number of elements as the result vector "
"type. the fourth argument is the explicit vector length of the operation. If "
"the first argument is zero and the second argument is true, the result is "
"poison."
msgstr ""

#: ../../../LangRef.rst:26312
msgid ""
"The '``llvm.vp.ctlz``' intrinsic performs ctlz (:ref:`ctlz <int_ctlz>`) of "
"the first argument on each enabled lane.  The result on disabled lanes is a :"
"ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26330
msgid "'``llvm.vp.cttz.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26345
msgid "Predicated cttz of a vector of integers."
msgstr ""

#: ../../../LangRef.rst:26351
msgid ""
"The first argument and the result have the same vector of integer type. The "
"second argument is a constant flag that indicates whether the intrinsic "
"returns a valid result if the first argument is zero. The third argument is "
"the vector mask and has the same number of elements as the result vector "
"type. The fourth argument is the explicit vector length of the operation. If "
"the first argument is zero and the second argument is true, the result is "
"poison."
msgstr ""

#: ../../../LangRef.rst:26361
msgid ""
"The '``llvm.vp.cttz``' intrinsic performs cttz (:ref:`cttz <int_cttz>`) of "
"the first argument on each enabled lane.  The result on disabled lanes is a :"
"ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26379
msgid "'``llvm.vp.cttz.elts.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26383
msgid ""
"This is an overloaded intrinsic. You can use ```llvm.vp.cttz.elts``` on any "
"vector of integer elements, both fixed width and scalable."
msgstr ""

#: ../../../LangRef.rst:26395
msgid ""
"This '```llvm.vp.cttz.elts```' intrinsic counts the number of trailing zero "
"elements of a vector. This is basically the vector-predicated version of "
"'```llvm.experimental.cttz.elts```'."
msgstr ""

#: ../../../LangRef.rst:26408
msgid ""
"The second argument is a constant flag that indicates whether the intrinsic "
"returns a valid result if the first argument is all zero."
msgstr ""

#: ../../../LangRef.rst:26411
msgid ""
"The third argument is the vector mask and has the same number of elements as "
"the input vector type. The fourth argument is the explicit vector length of "
"the operation."
msgstr ""

#: ../../../LangRef.rst:26418
msgid ""
"The '``llvm.vp.cttz.elts``' intrinsic counts the trailing (least "
"significant / lowest-numbered) zero elements in the first argument on each "
"enabled lane. If the first argument is all zero and the second argument is "
"true, the result is poison. Otherwise, it returns the explicit vector length "
"(i.e., the fourth argument)."
msgstr ""

#: ../../../LangRef.rst:26427
msgid "'``llvm.vp.sadd.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26442
msgid "Predicated signed saturating addition of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:26456
msgid ""
"The '``llvm.vp.sadd.sat``' intrinsic performs sadd.sat (:ref:`sadd.sat "
"<int_sadd_sat>`) of the first and second vector arguments on each enabled "
"lane. The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26476
msgid "'``llvm.vp.uadd.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26491
msgid "Predicated unsigned saturating addition of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:26505
msgid ""
"The '``llvm.vp.uadd.sat``' intrinsic performs uadd.sat (:ref:`uadd.sat "
"<int_uadd_sat>`) of the first and second vector arguments on each enabled "
"lane. The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26525
msgid "'``llvm.vp.ssub.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26540
msgid "Predicated signed saturating subtraction of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:26554
msgid ""
"The '``llvm.vp.ssub.sat``' intrinsic performs ssub.sat (:ref:`ssub.sat "
"<int_ssub_sat>`) of the first and second vector arguments on each enabled "
"lane. The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26574
msgid "'``llvm.vp.usub.sat.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26589
msgid "Predicated unsigned saturating subtraction of two vectors of integers."
msgstr ""

#: ../../../LangRef.rst:26603
msgid ""
"The '``llvm.vp.usub.sat``' intrinsic performs usub.sat (:ref:`usub.sat "
"<int_usub_sat>`) of the first and second vector arguments on each enabled "
"lane. The result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26623
msgid "'``llvm.vp.fshl.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26638
msgid "Predicated fshl of three vectors of integers."
msgstr ""

#: ../../../LangRef.rst:26644 ../../../LangRef.rst:26690
msgid ""
"The first three arguments and the result have the same vector of integer "
"type. The fourth argument is the vector mask and has the same number of "
"elements as the result vector type. The fifth argument is the explicit "
"vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:26652
msgid ""
"The '``llvm.vp.fshl``' intrinsic performs fshl (:ref:`fshl <int_fshl>`) of "
"the first, second, and third vector argument on each enabled lane. The "
"result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26669
msgid "'``llvm.vp.fshr.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26684
msgid "Predicated fshr of three vectors of integers."
msgstr ""

#: ../../../LangRef.rst:26698
msgid ""
"The '``llvm.vp.fshr``' intrinsic performs fshr (:ref:`fshr <int_fshr>`) of "
"the first, second, and third vector argument on each enabled lane. The "
"result on disabled lanes is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:26714
msgid "'``llvm.vp.is.fpclass.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26728
msgid "Predicated ``llvm.is.fpclass`` :ref:`llvm.is.fpclass <llvm.is.fpclass>`"
msgstr ""

#: ../../../LangRef.rst:26733
msgid ""
"The first argument is a floating-point vector, the result type is a vector "
"of boolean with the same number of elements as the first argument.  The "
"second argument specifies, which tests to perform :ref:`llvm.is.fpclass "
"<llvm.is.fpclass>`. The third argument is the vector mask and has the same "
"number of elements as the result vector type. The fourth argument is the "
"explicit vector length of the operation."
msgstr ""

#: ../../../LangRef.rst:26743
msgid ""
"The '``llvm.vp.is.fpclass``' intrinsic performs ``llvm.is.fpclass`` (:ref:"
"`llvm.is.fpclass <llvm.is.fpclass>`)."
msgstr ""

#: ../../../LangRef.rst:26757
msgid "Masked Vector Load and Store Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26759
msgid ""
"LLVM provides intrinsics for predicated vector load and store operations. "
"The predicate is specified by a mask argument, which holds one bit per "
"vector element, switching the associated vector lane on or off. The memory "
"addresses corresponding to the \"off\" lanes are not accessed. When all bits "
"of the mask are on, the intrinsic is identical to a regular vector load or "
"store. When all bits are off, no memory is accessed."
msgstr ""

#: ../../../LangRef.rst:26764
msgid "'``llvm.masked.load.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26768
msgid ""
"This is an overloaded intrinsic. The loaded data is a vector of any integer, "
"floating-point or pointer data type."
msgstr ""

#: ../../../LangRef.rst:26780
msgid ""
"Reads a vector from memory according to the provided mask. The mask holds a "
"bit for each vector lane, and is used to prevent memory accesses to the "
"masked-off lanes. The masked-off lanes in the result vector are taken from "
"the corresponding lanes of the '``passthru``' argument."
msgstr ""

#: ../../../LangRef.rst:26786
msgid ""
"The first argument is the base pointer for the load. The second argument is "
"the alignment of the source location. It must be a power of two constant "
"integer value. The third argument, mask, is a vector of boolean values with "
"the same number of elements as the return type. The fourth is a pass-through "
"value that is used to fill the masked-off lanes of the result. The return "
"type, underlying type of the base pointer and the type of the '``passthru``' "
"argument are the same vector types."
msgstr ""

#: ../../../LangRef.rst:26791
msgid ""
"The '``llvm.masked.load``' intrinsic is designed for conditional reading of "
"selected vector elements in a single IR operation. It is useful for targets "
"that support vector masked loads and allows vectorizing predicated basic "
"blocks on these targets. Other targets may support this intrinsic "
"differently, for example by lowering it into a sequence of branches that "
"guard scalar load operations. The result of this operation is equivalent to "
"a regular vector load instruction followed by a 'select' between the loaded "
"and the passthru values, predicated on the same mask, except that the masked-"
"off lanes are not accessed. Only the masked-on lanes of the vector need to "
"be inbounds of an allocation (but all these lanes need to be inbounds of the "
"same allocation). In particular, using this intrinsic prevents exceptions on "
"memory accesses to masked-off lanes. Masked-off lanes are also not "
"considered accessed for the purpose of data races or ``noalias`` constraints."
msgstr ""

#: ../../../LangRef.rst:26809
msgid "'``llvm.masked.store.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26813
msgid ""
"This is an overloaded intrinsic. The data stored in memory is a vector of "
"any integer, floating-point or pointer data type."
msgstr ""

#: ../../../LangRef.rst:26825
msgid ""
"Writes a vector to memory according to the provided mask. The mask holds a "
"bit for each vector lane, and is used to prevent memory accesses to the "
"masked-off lanes."
msgstr ""

#: ../../../LangRef.rst:26830
msgid ""
"The first argument is the vector value to be written to memory. The second "
"argument is the base pointer for the store, it has the same underlying type "
"as the value argument. The third argument is the alignment of the "
"destination location. It must be a power of two constant integer value. The "
"fourth argument, mask, is a vector of boolean values. The types of the mask "
"and the value argument must have the same number of vector elements."
msgstr ""

#: ../../../LangRef.rst:26836
msgid ""
"The '``llvm.masked.store``' intrinsics is designed for conditional writing "
"of selected vector elements in a single IR operation. It is useful for "
"targets that support vector masked store and allows vectorizing predicated "
"basic blocks on these targets. Other targets may support this intrinsic "
"differently, for example by lowering it into a sequence of branches that "
"guard scalar store operations. The result of this operation is equivalent to "
"a load-modify-store sequence, except that the masked-off lanes are not "
"accessed. Only the masked-on lanes of the vector need to be inbounds of an "
"allocation (but all these lanes need to be inbounds of the same allocation). "
"In particular, using this intrinsic prevents exceptions on memory accesses "
"to masked-off lanes. Masked-off lanes are also not considered accessed for "
"the purpose of data races or ``noalias`` constraints."
msgstr ""

#: ../../../LangRef.rst:26853
msgid "Masked Vector Gather and Scatter Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26855
msgid ""
"LLVM provides intrinsics for vector gather and scatter operations. They are "
"similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except "
"they are designed for arbitrary memory accesses, rather than sequential "
"memory accesses. Gather and scatter also employ a mask argument, which holds "
"one bit per vector element, switching the associated vector lane on or off. "
"The memory addresses corresponding to the \"off\" lanes are not accessed. "
"When all bits are off, no memory is accessed."
msgstr ""

#: ../../../LangRef.rst:26860
msgid "'``llvm.masked.gather.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26864
msgid ""
"This is an overloaded intrinsic. The loaded data are multiple scalar values "
"of any integer, floating-point or pointer data type gathered together into "
"one vector."
msgstr ""

#: ../../../LangRef.rst:26875
msgid ""
"Reads scalar values from arbitrary memory locations and gathers them into "
"one vector. The memory locations are provided in the vector of pointers "
"'``ptrs``'. The memory is accessed according to the provided mask. The mask "
"holds a bit for each vector lane, and is used to prevent memory accesses to "
"the masked-off lanes. The masked-off lanes in the result vector are taken "
"from the corresponding lanes of the '``passthru``' argument."
msgstr ""

#: ../../../LangRef.rst:26881
msgid ""
"The first argument is a vector of pointers which holds all memory addresses "
"to read. The second argument is an alignment of the source addresses. It "
"must be 0 or a power of two constant integer value. The third argument, "
"mask, is a vector of boolean values with the same number of elements as the "
"return type. The fourth is a pass-through value that is used to fill the "
"masked-off lanes of the result. The return type, underlying type of the "
"vector of pointers and the type of the '``passthru``' argument are the same "
"vector types."
msgstr ""

#: ../../../LangRef.rst:26886
msgid ""
"The '``llvm.masked.gather``' intrinsic is designed for conditional reading "
"of multiple scalar values from arbitrary memory locations in a single IR "
"operation. It is useful for targets that support vector masked gathers and "
"allows vectorizing basic blocks with data and control divergence. Other "
"targets may support this intrinsic differently, for example by lowering it "
"into a sequence of scalar load operations. The semantics of this operation "
"are equivalent to a sequence of conditional scalar loads with subsequent "
"gathering all loaded values into a single vector. The mask restricts memory "
"access to certain lanes and facilitates vectorization of predicated basic "
"blocks."
msgstr ""

#: ../../../LangRef.rst:26913
msgid "'``llvm.masked.scatter.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26917
msgid ""
"This is an overloaded intrinsic. The data stored in memory is a vector of "
"any integer, floating-point or pointer data type. Each vector element is "
"stored in an arbitrary memory address. Scatter with overlapping addresses is "
"guaranteed to be ordered from least-significant to most-significant element."
msgstr ""

#: ../../../LangRef.rst:26928
msgid ""
"Writes each element from the value vector to the corresponding memory "
"address. The memory addresses are represented as a vector of pointers. "
"Writing is done according to the provided mask. The mask holds a bit for "
"each vector lane, and is used to prevent memory accesses to the masked-off "
"lanes."
msgstr ""

#: ../../../LangRef.rst:26933
msgid ""
"The first argument is a vector value to be written to memory. The second "
"argument is a vector of pointers, pointing to where the value elements "
"should be stored. It has the same underlying type as the value argument. The "
"third argument is an alignment of the destination addresses. It must be 0 or "
"a power of two constant integer value. The fourth argument, mask, is a "
"vector of boolean values. The types of the mask and the value argument must "
"have the same number of vector elements."
msgstr ""

#: ../../../LangRef.rst:26938
msgid ""
"The '``llvm.masked.scatter``' intrinsics is designed for writing selected "
"vector elements to arbitrary memory addresses in a single IR operation. The "
"operation may be conditional, when not all bits in the mask are switched on. "
"It is useful for targets that support vector masked scatter and allows "
"vectorizing basic blocks with data and control divergence. Other targets may "
"support this intrinsic differently, for example by lowering it into a "
"sequence of branches that guard scalar store operations."
msgstr ""

#: ../../../LangRef.rst:26962
msgid "Masked Vector Expanding Load and Compressing Store Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26964
msgid ""
"LLVM provides intrinsics for expanding load and compressing store "
"operations. Data selected from a vector according to a mask is stored in "
"consecutive memory addresses (compressed store), and vice-versa (expanding "
"load). These operations effective map to \"if (cond.i) a[j++] = v.i\" and "
"\"if (cond.i) v.i = a[j++]\" patterns, respectively. Note that when the mask "
"starts with '1' bits followed by '0' bits, these operations are identical "
"to :ref:`llvm.masked.store <int_mstore>` and :ref:`llvm.masked.load "
"<int_mload>`."
msgstr ""

#: ../../../LangRef.rst:26969
msgid "'``llvm.masked.expandload.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:26973
msgid ""
"This is an overloaded intrinsic. Several values of integer, floating point "
"or pointer data type are loaded from consecutive memory addresses and stored "
"into the elements of a vector according to the mask."
msgstr ""

#: ../../../LangRef.rst:26983
msgid ""
"Reads a number of scalar values sequentially from memory location provided "
"in '``ptr``' and spreads them in a vector. The '``mask``' holds a bit for "
"each vector lane. The number of elements read from memory is equal to the "
"number of '1' bits in the mask. The loaded elements are positioned in the "
"destination vector according to the sequence of '1' and '0' bits in the "
"mask. E.g., if the mask vector is '10010001', \"expandload\" reads 3 values "
"from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 "
"accordingly. The masked-off lanes are filled by elements from the "
"corresponding lanes of the '``passthru``' argument."
msgstr ""

#: ../../../LangRef.rst:26989
msgid ""
"The first argument is the base pointer for the load. It has the same "
"underlying type as the element of the returned vector. The second argument, "
"mask, is a vector of boolean values with the same number of elements as the "
"return type. The third is a pass-through value that is used to fill the "
"masked-off lanes of the result. The return type and the type of the "
"'``passthru``' argument have the same vector type."
msgstr ""

#: ../../../LangRef.rst:26991
msgid ""
"The :ref:`align <attr_align>` parameter attribute can be provided for the "
"first argument. The pointer alignment defaults to 1."
msgstr ""

#: ../../../LangRef.rst:26997
msgid ""
"The '``llvm.masked.expandload``' intrinsic is designed for reading multiple "
"scalar values from adjacent memory addresses into possibly non-adjacent "
"vector lanes. It is useful for targets that support vector expanding loads "
"and allows vectorizing loop with cross-iteration dependency like in the "
"following example:"
msgstr ""

#: ../../../LangRef.rst:27024
msgid ""
"Other targets may support this intrinsic differently, for example, by "
"lowering it into a sequence of conditional scalar load operations and "
"shuffles. If all mask elements are '1', the intrinsic behavior is equivalent "
"to the regular unmasked vector load."
msgstr ""

#: ../../../LangRef.rst:27030
msgid "'``llvm.masked.compressstore.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:27034
msgid ""
"This is an overloaded intrinsic. A number of scalar values of integer, "
"floating point or pointer data type are collected from an input vector and "
"stored into adjacent memory addresses. A mask defines which elements to "
"collect from the vector."
msgstr ""

#: ../../../LangRef.rst:27044
msgid ""
"Selects elements from input vector '``value``' according to the '``mask``'. "
"All selected elements are written into adjacent memory addresses starting at "
"address '`ptr`', from lower to higher. The mask holds a bit for each vector "
"lane, and is used to select elements to be stored. The number of elements to "
"be stored is equal to the number of active bits in the mask."
msgstr ""

#: ../../../LangRef.rst:27049
msgid ""
"The first argument is the input vector, from which elements are collected "
"and written to memory. The second argument is the base pointer for the "
"store, it has the same underlying type as the element of the input vector "
"argument. The third argument is the mask, a vector of boolean values. The "
"mask and the input vector must have the same number of vector elements."
msgstr ""

#: ../../../LangRef.rst:27051
msgid ""
"The :ref:`align <attr_align>` parameter attribute can be provided for the "
"second argument. The pointer alignment defaults to 1."
msgstr ""

#: ../../../LangRef.rst:27057
msgid ""
"The '``llvm.masked.compressstore``' intrinsic is designed for compressing "
"data in memory. It allows to collect elements from possibly non-adjacent "
"lanes of a vector and store them contiguously in memory in one IR operation. "
"It is useful for targets that support compressing store operations and "
"allows vectorizing loops with cross-iteration dependencies like in the "
"following example:"
msgstr ""

#: ../../../LangRef.rst:27083
msgid ""
"Other targets may support this intrinsic differently, for example, by "
"lowering it into a sequence of branches that guard scalar store operations."
msgstr ""

#: ../../../LangRef.rst:27087
msgid "Memory Use Markers"
msgstr ""

#: ../../../LangRef.rst:27089
msgid ""
"This class of intrinsics provides information about the :ref:`lifetime of "
"allocated objects <objectlifetime>` and ranges where variables are immutable."
msgstr ""

#: ../../../LangRef.rst:27096
msgid "'``llvm.lifetime.start``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27108
msgid ""
"The '``llvm.lifetime.start``' intrinsic specifies the start of a memory "
"object's lifetime."
msgstr ""

#: ../../../LangRef.rst:27114 ../../../LangRef.rst:27155
msgid ""
"The argument is either a pointer to an ``alloca`` instruction or a "
"``poison`` value."
msgstr ""

#: ../../../LangRef.rst:27120 ../../../LangRef.rst:27161
msgid "If ``ptr`` is a ``poison`` value, the intrinsic has no effect."
msgstr ""

#: ../../../LangRef.rst:27122
msgid ""
"Otherwise, the stack-allocated object that ``ptr`` points to is initially "
"marked as dead. After '``llvm.lifetime.start``', the stack object is marked "
"as alive and has an uninitialized value. The stack object is marked as dead "
"when either :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed "
"or the function returns."
msgstr ""

#: ../../../LangRef.rst:27129
msgid ""
"After :ref:`llvm.lifetime.end <int_lifeend>` is called, '``llvm.lifetime."
"start``' on the stack object can be called again. The second '``llvm."
"lifetime.start``' call marks the object as alive, but it does not change the "
"address of the object."
msgstr ""

#: ../../../LangRef.rst:27137
msgid "'``llvm.lifetime.end``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27149
msgid ""
"The '``llvm.lifetime.end``' intrinsic specifies the end of a :ref:`allocated "
"object's lifetime<objectlifetime>`."
msgstr ""

#: ../../../LangRef.rst:27163
msgid ""
"Otherwise, the stack-allocated object that ``ptr`` points to becomes dead "
"after the call to this intrinsic."
msgstr ""

#: ../../../LangRef.rst:27166
msgid "Calling ``llvm.lifetime.end`` on an already dead alloca is no-op."
msgstr ""

#: ../../../LangRef.rst:27169
msgid "'``llvm.invariant.start``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27173 ../../../LangRef.rst:27205
msgid ""
"This is an overloaded intrinsic. The :ref:`allocated "
"object<allocatedobjects>` can belong to any address space."
msgstr ""

#: ../../../LangRef.rst:27183
msgid ""
"The '``llvm.invariant.start``' intrinsic specifies that the contents of an :"
"ref:`allocated object<allocatedobjects>` will not change."
msgstr ""

#: ../../../LangRef.rst:27189
msgid ""
"The first argument is a constant integer representing the size of the "
"object, or -1 if it is variable sized. The second argument is a pointer to "
"the object."
msgstr ""

#: ../../../LangRef.rst:27196
msgid ""
"This intrinsic indicates that until an ``llvm.invariant.end`` that uses the "
"return value, the referenced memory location is constant and unchanging."
msgstr ""

#: ../../../LangRef.rst:27201
msgid "'``llvm.invariant.end``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27215
msgid ""
"The '``llvm.invariant.end``' intrinsic specifies that the contents of an :"
"ref:`allocated object<allocatedobjects>` are mutable."
msgstr ""

#: ../../../LangRef.rst:27221
msgid ""
"The first argument is the matching ``llvm.invariant.start`` intrinsic. The "
"second argument is a constant integer representing the size of the object, "
"or -1 if it is variable sized and the third argument is a pointer to the "
"object."
msgstr ""

#: ../../../LangRef.rst:27229
msgid "This intrinsic indicates that the memory is mutable again."
msgstr ""

#: ../../../LangRef.rst:27232
msgid "'``llvm.launder.invariant.group``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27236 ../../../LangRef.rst:27272
msgid ""
"This is an overloaded intrinsic. The :ref:`allocated "
"object<allocatedobjects>` can belong to any address space. The returned "
"pointer must belong to the same address space as the argument."
msgstr ""

#: ../../../LangRef.rst:27247
msgid ""
"The '``llvm.launder.invariant.group``' intrinsic can be used when an "
"invariant established by ``invariant.group`` metadata no longer holds, to "
"obtain a new pointer value that carries fresh invariant group information. "
"It is an experimental intrinsic, which means that its semantics might change "
"in the future."
msgstr ""

#: ../../../LangRef.rst:27257
msgid ""
"The ``llvm.launder.invariant.group`` takes only one argument, which is a "
"pointer to the memory."
msgstr ""

#: ../../../LangRef.rst:27263
msgid ""
"Returns another pointer that aliases its argument but which is considered "
"different for the purposes of ``load``/``store`` ``invariant.group`` "
"metadata. It does not read any accessible memory and the execution can be "
"speculated."
msgstr ""

#: ../../../LangRef.rst:27268
msgid "'``llvm.strip.invariant.group``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27283
msgid ""
"The '``llvm.strip.invariant.group``' intrinsic can be used when an invariant "
"established by ``invariant.group`` metadata no longer holds, to obtain a new "
"pointer value that does not carry the invariant information. It is an "
"experimental intrinsic, which means that its semantics might change in the "
"future."
msgstr ""

#: ../../../LangRef.rst:27292
msgid ""
"The ``llvm.strip.invariant.group`` takes only one argument, which is a "
"pointer to the memory."
msgstr ""

#: ../../../LangRef.rst:27298
msgid ""
"Returns another pointer that aliases its argument but which has no "
"associated ``invariant.group`` metadata. It does not read any memory and can "
"be speculated."
msgstr ""

#: ../../../LangRef.rst:27307
msgid "Constrained Floating-Point Intrinsics"
msgstr ""

#: ../../../LangRef.rst:27309
msgid ""
"These intrinsics are used to provide special handling of floating-point "
"operations when specific rounding mode or floating-point exception behavior "
"is required.  By default, LLVM optimization passes assume that the rounding "
"mode is round-to-nearest and that floating-point exceptions will not be "
"monitored. Constrained FP intrinsics are used to support non-default "
"rounding modes and accurately preserve exception behavior without "
"compromising LLVM's ability to optimize FP code when the default behavior is "
"used."
msgstr ""

#: ../../../LangRef.rst:27317
msgid ""
"If any FP operation in a function is constrained then they all must be "
"constrained. This is required for correct LLVM IR. Optimizations that move "
"code around can create miscompiles if mixing of constrained and normal "
"operations is done. The correct way to mix constrained and less constrained "
"operations is to use the rounding mode and exception handling metadata to "
"mark constrained intrinsics as having LLVM's default behavior."
msgstr ""

#: ../../../LangRef.rst:27324
msgid ""
"Each of these intrinsics corresponds to a normal floating-point operation. "
"The data arguments and the return value are the same as the corresponding FP "
"operation."
msgstr ""

#: ../../../LangRef.rst:27328
msgid ""
"The rounding mode argument is a metadata string specifying what assumptions, "
"if any, the optimizer can make when transforming constant values. Some "
"constrained FP intrinsics omit this argument. If required by the intrinsic, "
"this argument must be one of the following strings:"
msgstr ""

#: ../../../LangRef.rst:27342
msgid ""
"If this argument is \"round.dynamic\" optimization passes must assume that "
"the rounding mode is unknown and may change at runtime.  No transformations "
"that depend on rounding mode may be performed in this case."
msgstr ""

#: ../../../LangRef.rst:27346
msgid ""
"The other possible values for the rounding mode argument correspond to the "
"similarly named IEEE rounding modes.  If the argument is any of these values "
"optimization passes may perform transformations as long as they are "
"consistent with the specified rounding mode."
msgstr ""

#: ../../../LangRef.rst:27351
msgid ""
"For example, 'x-0'->'x' is not a valid transformation if the rounding mode "
"is \"round.downward\" or \"round.dynamic\" because if the value of 'x' is +0 "
"then 'x-0' should evaluate to '-0' when rounding downward.  However, this "
"transformation is legal for all other rounding modes."
msgstr ""

#: ../../../LangRef.rst:27356
msgid ""
"For values other than \"round.dynamic\" optimization passes may assume that "
"the actual runtime rounding mode (as defined in a target-specific manner) "
"matches the specified rounding mode, but this is not guaranteed.  Using a "
"specific non-dynamic rounding mode which does not match the actual rounding "
"mode at runtime results in undefined behavior."
msgstr ""

#: ../../../LangRef.rst:27362
msgid ""
"The exception behavior argument is a metadata string describing the floating "
"point exception semantics that required for the intrinsic. This argument "
"must be one of the following strings:"
msgstr ""

#: ../../../LangRef.rst:27372
msgid ""
"If this argument is \"fpexcept.ignore\" optimization passes may assume that "
"the exception status flags will not be read and that floating-point "
"exceptions will be masked.  This allows transformations to be performed that "
"may change the exception semantics of the original code.  For example, FP "
"operations may be speculatively executed in this case whereas they must not "
"be for either of the other possible values of this argument."
msgstr ""

#: ../../../LangRef.rst:27379
msgid ""
"If the exception behavior argument is \"fpexcept.maytrap\" optimization "
"passes must avoid transformations that may raise exceptions that would not "
"have been raised by the original code (such as speculatively executing FP "
"operations), but passes are not required to preserve all exceptions that are "
"implied by the original code.  For example, exceptions may be potentially "
"hidden by constant folding."
msgstr ""

#: ../../../LangRef.rst:27386
msgid ""
"If the exception behavior argument is \"fpexcept.strict\" all "
"transformations must strictly preserve the floating-point exception "
"semantics of the original code. Any FP exception that would have been raised "
"by the original code must be raised by the transformed code, and the "
"transformed code must not raise any FP exceptions that would not have been "
"raised by the original code.  This is the exception behavior argument that "
"will be used if the code being compiled reads the FP exception status flags, "
"but this mode can also be used with code that unmasks FP exceptions."
msgstr ""

#: ../../../LangRef.rst:27395
msgid ""
"The number and order of floating-point exceptions is NOT guaranteed.  For "
"example, a series of FP operations that each may raise exceptions may be "
"vectorized into a single instruction that raises each unique exception a "
"single time."
msgstr ""

#: ../../../LangRef.rst:27400
msgid ""
"Proper :ref:`function attributes <fnattrs>` usage is required for the "
"constrained intrinsics to function correctly."
msgstr ""

#: ../../../LangRef.rst:27403
msgid ""
"All function *calls* done in a function that uses constrained floating point "
"intrinsics must have the ``strictfp`` attribute either on the calling "
"instruction or on the declaration or definition of the function being called."
msgstr ""

#: ../../../LangRef.rst:27408
msgid ""
"All function *definitions* that use constrained floating point intrinsics "
"must have the ``strictfp`` attribute."
msgstr ""

#: ../../../LangRef.rst:27412
msgid "'``llvm.experimental.constrained.fadd``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27427
msgid ""
"The '``llvm.experimental.constrained.fadd``' intrinsic returns the sum of "
"its two arguments."
msgstr ""

#: ../../../LangRef.rst:27434
msgid ""
"The first two arguments to the '``llvm.experimental.constrained.fadd``' "
"intrinsic must be :ref:`floating-point <t_floating>` or :ref:`vector "
"<t_vector>` of floating-point values. Both arguments must have identical "
"types."
msgstr ""

#: ../../../LangRef.rst:27438 ../../../LangRef.rst:27475
#: ../../../LangRef.rst:27512 ../../../LangRef.rst:27549
#: ../../../LangRef.rst:28098 ../../../LangRef.rst:28138
#: ../../../LangRef.rst:28176 ../../../LangRef.rst:28429
msgid ""
"The third and fourth arguments specify the rounding mode and exception "
"behavior as described above."
msgstr ""

#: ../../../LangRef.rst:27444
msgid ""
"The value produced is the floating-point sum of the two value arguments and "
"has the same type as the arguments."
msgstr ""

#: ../../../LangRef.rst:27449
msgid "'``llvm.experimental.constrained.fsub``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27464
msgid ""
"The '``llvm.experimental.constrained.fsub``' intrinsic returns the "
"difference of its two arguments."
msgstr ""

#: ../../../LangRef.rst:27471
msgid ""
"The first two arguments to the '``llvm.experimental.constrained.fsub``' "
"intrinsic must be :ref:`floating-point <t_floating>` or :ref:`vector "
"<t_vector>` of floating-point values. Both arguments must have identical "
"types."
msgstr ""

#: ../../../LangRef.rst:27481
msgid ""
"The value produced is the floating-point difference of the two value "
"arguments and has the same type as the arguments."
msgstr ""

#: ../../../LangRef.rst:27486
msgid "'``llvm.experimental.constrained.fmul``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27501
msgid ""
"The '``llvm.experimental.constrained.fmul``' intrinsic returns the product "
"of its two arguments."
msgstr ""

#: ../../../LangRef.rst:27508
msgid ""
"The first two arguments to the '``llvm.experimental.constrained.fmul``' "
"intrinsic must be :ref:`floating-point <t_floating>` or :ref:`vector "
"<t_vector>` of floating-point values. Both arguments must have identical "
"types."
msgstr ""

#: ../../../LangRef.rst:27518
msgid ""
"The value produced is the floating-point product of the two value arguments "
"and has the same type as the arguments."
msgstr ""

#: ../../../LangRef.rst:27523
msgid "'``llvm.experimental.constrained.fdiv``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27538
msgid ""
"The '``llvm.experimental.constrained.fdiv``' intrinsic returns the quotient "
"of its two arguments."
msgstr ""

#: ../../../LangRef.rst:27545
msgid ""
"The first two arguments to the '``llvm.experimental.constrained.fdiv``' "
"intrinsic must be :ref:`floating-point <t_floating>` or :ref:`vector "
"<t_vector>` of floating-point values. Both arguments must have identical "
"types."
msgstr ""

#: ../../../LangRef.rst:27555
msgid ""
"The value produced is the floating-point quotient of the two value arguments "
"and has the same type as the arguments."
msgstr ""

#: ../../../LangRef.rst:27560
msgid "'``llvm.experimental.constrained.frem``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27575
msgid ""
"The '``llvm.experimental.constrained.frem``' intrinsic returns the remainder "
"from the division of its two arguments."
msgstr ""

#: ../../../LangRef.rst:27582
msgid ""
"The first two arguments to the '``llvm.experimental.constrained.frem``' "
"intrinsic must be :ref:`floating-point <t_floating>` or :ref:`vector "
"<t_vector>` of floating-point values. Both arguments must have identical "
"types."
msgstr ""

#: ../../../LangRef.rst:27586
msgid ""
"The third and fourth arguments specify the rounding mode and exception "
"behavior as described above.  The rounding mode argument has no effect, "
"since the result of frem is never rounded, but the argument is included for "
"consistency with the other constrained floating-point intrinsics."
msgstr ""

#: ../../../LangRef.rst:27594
msgid ""
"The value produced is the floating-point remainder from the division of the "
"two value arguments and has the same type as the arguments.  The remainder "
"has the same sign as the dividend."
msgstr ""

#: ../../../LangRef.rst:27599
msgid "'``llvm.experimental.constrained.fma``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27614
msgid ""
"The '``llvm.experimental.constrained.fma``' intrinsic returns the result of "
"a fused-multiply-add operation on its arguments."
msgstr ""

#: ../../../LangRef.rst:27620
msgid ""
"The first three arguments to the '``llvm.experimental.constrained.fma``' "
"intrinsic must be :ref:`floating-point <t_floating>` or :ref:`vector "
"<t_vector>` of floating-point values. All arguments must have identical "
"types."
msgstr ""

#: ../../../LangRef.rst:27624 ../../../LangRef.rst:27988
msgid ""
"The fourth and fifth arguments specify the rounding mode and exception "
"behavior as described above."
msgstr ""

#: ../../../LangRef.rst:27630
msgid ""
"The result produced is the product of the first two arguments added to the "
"third argument computed with infinite precision, and then rounded to the "
"target precision."
msgstr ""

#: ../../../LangRef.rst:27635
msgid "'``llvm.experimental.constrained.fptoui``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27649
msgid ""
"The '``llvm.experimental.constrained.fptoui``' intrinsic converts a floating-"
"point ``value`` to its unsigned integer equivalent of type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:27655
msgid ""
"The first argument to the '``llvm.experimental.constrained.fptoui``' "
"intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector "
"<t_vector>` of floating point values."
msgstr ""

#: ../../../LangRef.rst:27659 ../../../LangRef.rst:27692
#: ../../../LangRef.rst:27834 ../../../LangRef.rst:29050
#: ../../../LangRef.rst:29083 ../../../LangRef.rst:29116
#: ../../../LangRef.rst:29151 ../../../LangRef.rst:29191
#: ../../../LangRef.rst:29230 ../../../LangRef.rst:29264
msgid ""
"The second argument specifies the exception behavior as described above."
msgstr ""

#: ../../../LangRef.rst:27664
msgid ""
"The result produced is an unsigned integer converted from the floating point "
"argument. The value is truncated, so it is rounded towards zero."
msgstr ""

#: ../../../LangRef.rst:27668
msgid "'``llvm.experimental.constrained.fptosi``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27682
msgid ""
"The '``llvm.experimental.constrained.fptosi``' intrinsic converts :ref:"
"`floating-point <t_floating>` ``value`` to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:27688
msgid ""
"The first argument to the '``llvm.experimental.constrained.fptosi``' "
"intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector "
"<t_vector>` of floating point values."
msgstr ""

#: ../../../LangRef.rst:27697
msgid ""
"The result produced is a signed integer converted from the floating point "
"argument. The value is truncated, so it is rounded towards zero."
msgstr ""

#: ../../../LangRef.rst:27701
msgid "'``llvm.experimental.constrained.uitofp``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27716
msgid ""
"The '``llvm.experimental.constrained.uitofp``' intrinsic converts an "
"unsigned integer ``value`` to a floating-point of type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:27722
msgid ""
"The first argument to the '``llvm.experimental.constrained.uitofp``' "
"intrinsic must be an :ref:`integer <t_integer>` or :ref:`vector <t_vector>` "
"of integer values."
msgstr ""

#: ../../../LangRef.rst:27726 ../../../LangRef.rst:27762
#: ../../../LangRef.rst:27799 ../../../LangRef.rst:28061
#: ../../../LangRef.rst:28214 ../../../LangRef.rst:28250
#: ../../../LangRef.rst:28286 ../../../LangRef.rst:28321
#: ../../../LangRef.rst:28357 ../../../LangRef.rst:28393
#: ../../../LangRef.rst:28464 ../../../LangRef.rst:28500
#: ../../../LangRef.rst:28536 ../../../LangRef.rst:28571
#: ../../../LangRef.rst:28607 ../../../LangRef.rst:28642
#: ../../../LangRef.rst:28678 ../../../LangRef.rst:28713
#: ../../../LangRef.rst:28749 ../../../LangRef.rst:28792
#: ../../../LangRef.rst:28840 ../../../LangRef.rst:28885
msgid ""
"The second and third arguments specify the rounding mode and exception "
"behavior as described above."
msgstr ""

#: ../../../LangRef.rst:27732 ../../../LangRef.rst:27768
msgid ""
"An inexact floating-point exception will be raised if rounding is required. "
"Any result produced is a floating point value converted from the input "
"integer argument."
msgstr ""

#: ../../../LangRef.rst:27737
msgid "'``llvm.experimental.constrained.sitofp``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27752
msgid ""
"The '``llvm.experimental.constrained.sitofp``' intrinsic converts a signed "
"integer ``value`` to a floating-point of type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:27758
msgid ""
"The first argument to the '``llvm.experimental.constrained.sitofp``' "
"intrinsic must be an :ref:`integer <t_integer>` or :ref:`vector <t_vector>` "
"of integer values."
msgstr ""

#: ../../../LangRef.rst:27773
msgid "'``llvm.experimental.constrained.fptrunc``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27788
msgid ""
"The '``llvm.experimental.constrained.fptrunc``' intrinsic truncates "
"``value`` to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:27794
msgid ""
"The first argument to the '``llvm.experimental.constrained.fptrunc``' "
"intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector "
"<t_vector>` of floating point values. This argument must be larger in size "
"than the result."
msgstr ""

#: ../../../LangRef.rst:27805
msgid ""
"The result produced is a floating point value truncated to be smaller in "
"size than the argument."
msgstr ""

#: ../../../LangRef.rst:27809
msgid "'``llvm.experimental.constrained.fpext``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27823
msgid ""
"The '``llvm.experimental.constrained.fpext``' intrinsic extends a floating-"
"point ``value`` to a larger floating-point value."
msgstr ""

#: ../../../LangRef.rst:27829
msgid ""
"The first argument to the '``llvm.experimental.constrained.fpext``' "
"intrinsic must be :ref:`floating point <t_floating>` or :ref:`vector "
"<t_vector>` of floating point values. This argument must be smaller in size "
"than the result."
msgstr ""

#: ../../../LangRef.rst:27839
msgid ""
"The result produced is a floating point value extended to be larger in size "
"than the argument. All restrictions that apply to the fpext instruction also "
"apply to this intrinsic."
msgstr ""

#: ../../../LangRef.rst:27844
msgid ""
"'``llvm.experimental.constrained.fcmp``' and '``llvm.experimental."
"constrained.fcmps``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:27863
msgid ""
"The '``llvm.experimental.constrained.fcmp``' and '``llvm.experimental."
"constrained.fcmps``' intrinsics return a boolean value or vector of boolean "
"values based on comparison of its arguments."
msgstr ""

#: ../../../LangRef.rst:27867
msgid ""
"If the arguments are floating-point scalars, then the result type is a "
"boolean (:ref:`i1 <t_integer>`)."
msgstr ""

#: ../../../LangRef.rst:27870
msgid ""
"If the arguments are floating-point vectors, then the result type is a "
"vector of boolean with the same number of elements as the arguments being "
"compared."
msgstr ""

#: ../../../LangRef.rst:27874
msgid ""
"The '``llvm.experimental.constrained.fcmp``' intrinsic performs a quiet "
"comparison operation while the '``llvm.experimental.constrained.fcmps``' "
"intrinsic performs a signaling comparison operation."
msgstr ""

#: ../../../LangRef.rst:27881
msgid ""
"The first two arguments to the '``llvm.experimental.constrained.fcmp``' and "
"'``llvm.experimental.constrained.fcmps``' intrinsics must be :ref:`floating-"
"point <t_floating>` or :ref:`vector <t_vector>` of floating-point values. "
"Both arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:27886
msgid ""
"The third argument is the condition code indicating the kind of comparison "
"to perform. It must be a metadata string with one of the following values:"
msgstr ""

#: ../../../LangRef.rst:27891
msgid "\"``oeq``\": ordered and equal"
msgstr ""

#: ../../../LangRef.rst:27892
msgid "\"``ogt``\": ordered and greater than"
msgstr ""

#: ../../../LangRef.rst:27893
msgid "\"``oge``\": ordered and greater than or equal"
msgstr ""

#: ../../../LangRef.rst:27894
msgid "\"``olt``\": ordered and less than"
msgstr ""

#: ../../../LangRef.rst:27895
msgid "\"``ole``\": ordered and less than or equal"
msgstr ""

#: ../../../LangRef.rst:27896
msgid "\"``one``\": ordered and not equal"
msgstr ""

#: ../../../LangRef.rst:27897
msgid "\"``ord``\": ordered (no nans)"
msgstr ""

#: ../../../LangRef.rst:27898
msgid "\"``ueq``\": unordered or equal"
msgstr ""

#: ../../../LangRef.rst:27899
msgid "\"``ugt``\": unordered or greater than"
msgstr ""

#: ../../../LangRef.rst:27900
msgid "\"``uge``\": unordered or greater than or equal"
msgstr ""

#: ../../../LangRef.rst:27901
msgid "\"``ult``\": unordered or less than"
msgstr ""

#: ../../../LangRef.rst:27902
msgid "\"``ule``\": unordered or less than or equal"
msgstr ""

#: ../../../LangRef.rst:27903
msgid "\"``une``\": unordered or not equal"
msgstr ""

#: ../../../LangRef.rst:27904
msgid "\"``uno``\": unordered (either nans)"
msgstr ""

#: ../../../LangRef.rst:27906
msgid ""
"*Ordered* means that neither argument is a NAN while *unordered* means that "
"either argument may be a NAN."
msgstr ""

#: ../../../LangRef.rst:27909
msgid ""
"The fourth argument specifies the exception behavior as described above."
msgstr ""

#: ../../../LangRef.rst:27914
msgid ""
"``op1`` and ``op2`` are compared according to the condition code given as "
"the third argument. If the arguments are vectors, then the vectors are "
"compared element by element. Each comparison performed always yields an :ref:"
"`i1 <t_integer>` result, as follows:"
msgstr ""

#: ../../../LangRef.rst:27921
msgid ""
"\"``oeq``\": yields ``true`` if both arguments are not a NAN and ``op1`` is "
"equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27923
msgid ""
"\"``ogt``\": yields ``true`` if both arguments are not a NAN and ``op1`` is "
"greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:27925
msgid ""
"\"``oge``\": yields ``true`` if both arguments are not a NAN and ``op1`` is "
"greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27927
msgid ""
"\"``olt``\": yields ``true`` if both arguments are not a NAN and ``op1`` is "
"less than ``op2``."
msgstr ""

#: ../../../LangRef.rst:27929
msgid ""
"\"``ole``\": yields ``true`` if both arguments are not a NAN and ``op1`` is "
"less than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27931
msgid ""
"\"``one``\": yields ``true`` if both arguments are not a NAN and ``op1`` is "
"not equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27933
msgid "\"``ord``\": yields ``true`` if both arguments are not a NAN."
msgstr ""

#: ../../../LangRef.rst:27934
msgid ""
"\"``ueq``\": yields ``true`` if either argument is a NAN or ``op1`` is equal "
"to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27936
msgid ""
"\"``ugt``\": yields ``true`` if either argument is a NAN or ``op1`` is "
"greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:27938
msgid ""
"\"``uge``\": yields ``true`` if either argument is a NAN or ``op1`` is "
"greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27940
msgid ""
"\"``ult``\": yields ``true`` if either argument is a NAN or ``op1`` is less "
"than ``op2``."
msgstr ""

#: ../../../LangRef.rst:27942
msgid ""
"\"``ule``\": yields ``true`` if either argument is a NAN or ``op1`` is less "
"than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27944
msgid ""
"\"``une``\": yields ``true`` if either argument is a NAN or ``op1`` is not "
"equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:27946
msgid "\"``uno``\": yields ``true`` if either argument is a NAN."
msgstr ""

#: ../../../LangRef.rst:27948
msgid ""
"The quiet comparison operation performed by '``llvm.experimental.constrained."
"fcmp``' will only raise an exception if either argument is a SNAN.  The "
"signaling comparison operation performed by '``llvm.experimental.constrained."
"fcmps``' will raise an exception if either argument is a NAN (QNAN or SNAN). "
"Such an exception does not preclude a result being produced (e.g. exception "
"might only set a flag), therefore the distinction between ordered and "
"unordered comparisons is also relevant for the '``llvm.experimental."
"constrained.fcmps``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:27959
msgid "'``llvm.experimental.constrained.fmuladd``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:27975
msgid ""
"The '``llvm.experimental.constrained.fmuladd``' intrinsic represents "
"multiply-add expressions that can be fused if the code generator determines "
"that (a) the target instruction set has support for a fused operation, and "
"(b) that the fused operation is more efficient than the equivalent, separate "
"pair of mul and add instructions."
msgstr ""

#: ../../../LangRef.rst:27984
msgid ""
"The first three arguments to the '``llvm.experimental.constrained.fmuladd``' "
"intrinsic must be floating-point or vector of floating-point values. All "
"three arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:28002
msgid "is equivalent to the expression:"
msgstr ""

#: ../../../LangRef.rst:28013
msgid ""
"except that it is unspecified whether rounding will be performed between the "
"multiplication and addition steps. Fusion is not guaranteed, even if the "
"target platform supports it. If a fused multiply-add is required, the "
"corresponding :ref:`llvm.experimental.constrained.fma <int_fma>` intrinsic "
"function should be used instead. This never sets errno, just as '``llvm."
"experimental.constrained.fma.*``'."
msgstr ""

#: ../../../LangRef.rst:28022
msgid "Constrained libm-equivalent Intrinsics"
msgstr ""

#: ../../../LangRef.rst:28024
msgid ""
"In addition to the basic floating-point operations for which constrained "
"intrinsics are described above, there are constrained versions of various "
"operations which provide equivalent behavior to a corresponding libm "
"function. These intrinsics allow the precise behavior of these operations "
"with respect to rounding mode and exception behavior to be controlled."
msgstr ""

#: ../../../LangRef.rst:28030
msgid ""
"As with the basic constrained floating-point intrinsics, the rounding mode "
"and exception behavior arguments only control the behavior of the optimizer. "
"They do not change the runtime floating-point environment."
msgstr ""

#: ../../../LangRef.rst:28036
msgid "'``llvm.experimental.constrained.sqrt``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28051
msgid ""
"The '``llvm.experimental.constrained.sqrt``' intrinsic returns the square "
"root of the specified value, returning the same value as the libm '``sqrt``' "
"functions would, but without setting ``errno``."
msgstr ""

#: ../../../LangRef.rst:28058 ../../../LangRef.rst:28211
#: ../../../LangRef.rst:28247 ../../../LangRef.rst:28283
#: ../../../LangRef.rst:28318 ../../../LangRef.rst:28354
#: ../../../LangRef.rst:28390 ../../../LangRef.rst:28461
#: ../../../LangRef.rst:28497 ../../../LangRef.rst:28533
msgid ""
"The first argument and the return type are floating-point numbers of the "
"same type."
msgstr ""

#: ../../../LangRef.rst:28067
msgid ""
"This function returns the nonnegative square root of the specified value. If "
"the value is less than negative zero, a floating-point exception occurs and "
"the return value is architecture specific."
msgstr ""

#: ../../../LangRef.rst:28073
msgid "'``llvm.experimental.constrained.pow``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28088
msgid ""
"The '``llvm.experimental.constrained.pow``' intrinsic returns the first "
"argument raised to the (positive or negative) power specified by the second "
"argument."
msgstr ""

#: ../../../LangRef.rst:28094
msgid ""
"The first two arguments and the return value are floating-point numbers of "
"the same type.  The second argument specifies the power to which the first "
"argument should be raised."
msgstr ""

#: ../../../LangRef.rst:28104
msgid ""
"This function returns the first value raised to the second power, returning "
"the same values as the libm ``pow`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28110
msgid "'``llvm.experimental.constrained.powi``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28125
msgid ""
"The '``llvm.experimental.constrained.powi``' intrinsic returns the first "
"argument raised to the (positive or negative) power specified by the second "
"argument. The order of evaluation of multiplications is not defined. When a "
"vector of floating-point type is used, the second argument remains a scalar "
"integer value."
msgstr ""

#: ../../../LangRef.rst:28134
msgid ""
"The first argument and the return value are floating-point numbers of the "
"same type.  The second argument is a 32-bit signed integer specifying the "
"power to which the first argument should be raised."
msgstr ""

#: ../../../LangRef.rst:28149
msgid "'``llvm.experimental.constrained.ldexp``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28164
msgid ""
"The '``llvm.experimental.constrained.ldexp``' performs the ldexp function."
msgstr ""

#: ../../../LangRef.rst:28190
msgid "'``llvm.experimental.constrained.sin``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28205
msgid ""
"The '``llvm.experimental.constrained.sin``' intrinsic returns the sine of "
"the first argument."
msgstr ""

#: ../../../LangRef.rst:28220
msgid ""
"This function returns the sine of the specified argument, returning the same "
"values as the libm ``sin`` functions would, and handles error conditions in "
"the same way."
msgstr ""

#: ../../../LangRef.rst:28226
msgid "'``llvm.experimental.constrained.cos``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28241
msgid ""
"The '``llvm.experimental.constrained.cos``' intrinsic returns the cosine of "
"the first argument."
msgstr ""

#: ../../../LangRef.rst:28256
msgid ""
"This function returns the cosine of the specified argument, returning the "
"same values as the libm ``cos`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28262
msgid "'``llvm.experimental.constrained.tan``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28277
msgid ""
"The '``llvm.experimental.constrained.tan``' intrinsic returns the tangent of "
"the first argument."
msgstr ""

#: ../../../LangRef.rst:28292
msgid ""
"This function returns the tangent of the specified argument, returning the "
"same values as the libm ``tan`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28297
msgid "'``llvm.experimental.constrained.asin``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28312
msgid ""
"The '``llvm.experimental.constrained.asin``' intrinsic returns the arcsine "
"of the first operand."
msgstr ""

#: ../../../LangRef.rst:28327
msgid ""
"This function returns the arcsine of the specified operand, returning the "
"same values as the libm ``asin`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28333
msgid "'``llvm.experimental.constrained.acos``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28348
msgid ""
"The '``llvm.experimental.constrained.acos``' intrinsic returns the arccosine "
"of the first operand."
msgstr ""

#: ../../../LangRef.rst:28363
msgid ""
"This function returns the arccosine of the specified operand, returning the "
"same values as the libm ``acos`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28369
msgid "'``llvm.experimental.constrained.atan``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28384
msgid ""
"The '``llvm.experimental.constrained.atan``' intrinsic returns the "
"arctangent of the first operand."
msgstr ""

#: ../../../LangRef.rst:28399
msgid ""
"This function returns the arctangent of the specified operand, returning the "
"same values as the libm ``atan`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28404
msgid "'``llvm.experimental.constrained.atan2``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28420
msgid ""
"The '``llvm.experimental.constrained.atan2``' intrinsic returns the "
"arctangent of ``<op1>`` divided by ``<op2>`` accounting for the quadrant."
msgstr ""

#: ../../../LangRef.rst:28426 ../../../LangRef.rst:28919
#: ../../../LangRef.rst:28951 ../../../LangRef.rst:28983
#: ../../../LangRef.rst:29015
msgid ""
"The first two arguments and the return value are floating-point numbers of "
"the same type."
msgstr ""

#: ../../../LangRef.rst:28435
msgid ""
"This function returns the quadrant-specific arctangent using the specified "
"operands, returning the same values as the libm ``atan2`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28440
msgid "'``llvm.experimental.constrained.sinh``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28455
msgid ""
"The '``llvm.experimental.constrained.sinh``' intrinsic returns the "
"hyperbolic sine of the first operand."
msgstr ""

#: ../../../LangRef.rst:28470
msgid ""
"This function returns the hyperbolic sine of the specified operand, "
"returning the same values as the libm ``sinh`` functions would, and handles "
"error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28476
msgid "'``llvm.experimental.constrained.cosh``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28491
msgid ""
"The '``llvm.experimental.constrained.cosh``' intrinsic returns the "
"hyperbolic cosine of the first operand."
msgstr ""

#: ../../../LangRef.rst:28506
msgid ""
"This function returns the hyperbolic cosine of the specified operand, "
"returning the same values as the libm ``cosh`` functions would, and handles "
"error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28512
msgid "'``llvm.experimental.constrained.tanh``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28527
msgid ""
"The '``llvm.experimental.constrained.tanh``' intrinsic returns the "
"hyperbolic tangent of the first operand."
msgstr ""

#: ../../../LangRef.rst:28542
msgid ""
"This function returns the hyperbolic tangent of the specified operand, "
"returning the same values as the libm ``tanh`` functions would, and handles "
"error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28547
msgid "'``llvm.experimental.constrained.exp``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28562
msgid ""
"The '``llvm.experimental.constrained.exp``' intrinsic computes the base-e "
"exponential of the specified value."
msgstr ""

#: ../../../LangRef.rst:28568 ../../../LangRef.rst:28604
#: ../../../LangRef.rst:28639 ../../../LangRef.rst:28675
#: ../../../LangRef.rst:28710 ../../../LangRef.rst:28746
#: ../../../LangRef.rst:28882 ../../../LangRef.rst:29047
#: ../../../LangRef.rst:29080 ../../../LangRef.rst:29113
#: ../../../LangRef.rst:29148 ../../../LangRef.rst:29261
msgid ""
"The first argument and the return value are floating-point numbers of the "
"same type."
msgstr ""

#: ../../../LangRef.rst:28577
msgid ""
"This function returns the same values as the libm ``exp`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28582
msgid "'``llvm.experimental.constrained.exp2``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28597
msgid ""
"The '``llvm.experimental.constrained.exp2``' intrinsic computes the base-2 "
"exponential of the specified value."
msgstr ""

#: ../../../LangRef.rst:28613
msgid ""
"This function returns the same values as the libm ``exp2`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28618
msgid "'``llvm.experimental.constrained.log``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28633
msgid ""
"The '``llvm.experimental.constrained.log``' intrinsic computes the base-e "
"logarithm of the specified value."
msgstr ""

#: ../../../LangRef.rst:28649
msgid ""
"This function returns the same values as the libm ``log`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28654
msgid "'``llvm.experimental.constrained.log10``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28669
msgid ""
"The '``llvm.experimental.constrained.log10``' intrinsic computes the base-10 "
"logarithm of the specified value."
msgstr ""

#: ../../../LangRef.rst:28684
msgid ""
"This function returns the same values as the libm ``log10`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28689
msgid "'``llvm.experimental.constrained.log2``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28704
msgid ""
"The '``llvm.experimental.constrained.log2``' intrinsic computes the base-2 "
"logarithm of the specified value."
msgstr ""

#: ../../../LangRef.rst:28719
msgid ""
"This function returns the same values as the libm ``log2`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28724
msgid "'``llvm.experimental.constrained.rint``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28739
msgid ""
"The '``llvm.experimental.constrained.rint``' intrinsic returns the first "
"argument rounded to the nearest integer. It may raise an inexact floating-"
"point exception if the argument is not an integer."
msgstr ""

#: ../../../LangRef.rst:28755
msgid ""
"This function returns the same values as the libm ``rint`` functions would, "
"and handles error conditions in the same way.  The rounding mode is "
"described, not determined, by the rounding mode argument.  The actual "
"rounding mode is determined by the runtime floating-point environment.  The "
"rounding mode argument is only intended as information to the compiler."
msgstr ""

#: ../../../LangRef.rst:28763
msgid "'``llvm.experimental.constrained.lrint``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28778
msgid ""
"The '``llvm.experimental.constrained.lrint``' intrinsic returns the first "
"argument rounded to the nearest integer. An inexact floating-point exception "
"will be raised if the argument is not an integer. If the rounded value is "
"too large to fit into the result type, an invalid exception is raised, and "
"the return value is a non-deterministic value (equivalent to `freeze "
"poison`)."
msgstr ""

#: ../../../LangRef.rst:28787
msgid ""
"The first argument is a floating-point number. The return value is an "
"integer type. Not all types are supported on all targets. The supported "
"types are the same as the ``llvm.lrint`` intrinsic and the ``lrint`` libm "
"functions."
msgstr ""

#: ../../../LangRef.rst:28798
msgid ""
"This function returns the same values as the libm ``lrint`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28801 ../../../LangRef.rst:28849
msgid ""
"The rounding mode is described, not determined, by the rounding mode "
"argument.  The actual rounding mode is determined by the runtime floating-"
"point environment.  The rounding mode argument is only intended as "
"information to the compiler."
msgstr ""

#: ../../../LangRef.rst:28806
msgid ""
"If the runtime floating-point environment is using the default rounding mode "
"then the results will be the same as the ``llvm.lrint`` intrinsic."
msgstr ""

#: ../../../LangRef.rst:28811
msgid "'``llvm.experimental.constrained.llrint``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28826
msgid ""
"The '``llvm.experimental.constrained.llrint``' intrinsic returns the first "
"argument rounded to the nearest integer. An inexact floating-point exception "
"will be raised if the argument is not an integer. If the rounded value is "
"too large to fit into the result type, an invalid exception is raised, and "
"the return value is a non-deterministic value (equivalent to `freeze "
"poison`)."
msgstr ""

#: ../../../LangRef.rst:28835
msgid ""
"The first argument is a floating-point number. The return value is an "
"integer type. Not all types are supported on all targets. The supported "
"types are the same as the ``llvm.llrint`` intrinsic and the ``llrint`` libm "
"functions."
msgstr ""

#: ../../../LangRef.rst:28846
msgid ""
"This function returns the same values as the libm ``llrint`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:28854
msgid ""
"If the runtime floating-point environment is using the default rounding mode "
"then the results will be the same as the ``llvm.llrint`` intrinsic."
msgstr ""

#: ../../../LangRef.rst:28859
msgid "'``llvm.experimental.constrained.nearbyint``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28874
msgid ""
"The '``llvm.experimental.constrained.nearbyint``' intrinsic returns the "
"first argument rounded to the nearest integer. It will not raise an inexact "
"floating-point exception if the argument is not an integer."
msgstr ""

#: ../../../LangRef.rst:28891
msgid ""
"This function returns the same values as the libm ``nearbyint`` functions "
"would, and handles error conditions in the same way.  The rounding mode is "
"described, not determined, by the rounding mode argument.  The actual "
"rounding mode is determined by the runtime floating-point environment.  The "
"rounding mode argument is only intended as information to the compiler."
msgstr ""

#: ../../../LangRef.rst:28899
msgid "'``llvm.experimental.constrained.maxnum``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28913
msgid ""
"The '``llvm.experimental.constrained.maxnum``' intrinsic returns the maximum "
"of the two arguments."
msgstr ""

#: ../../../LangRef.rst:28922 ../../../LangRef.rst:28954
#: ../../../LangRef.rst:28986 ../../../LangRef.rst:29018
msgid "The third argument specifies the exception behavior as described above."
msgstr ""

#: ../../../LangRef.rst:28927
msgid "This function follows the IEEE-754-2008 semantics for maxNum."
msgstr ""

#: ../../../LangRef.rst:28931
msgid "'``llvm.experimental.constrained.minnum``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28945
msgid ""
"The '``llvm.experimental.constrained.minnum``' intrinsic returns the minimum "
"of the two arguments."
msgstr ""

#: ../../../LangRef.rst:28959
msgid "This function follows the IEEE-754-2008 semantics for minNum."
msgstr ""

#: ../../../LangRef.rst:28963
msgid "'``llvm.experimental.constrained.maximum``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:28977
msgid ""
"The '``llvm.experimental.constrained.maximum``' intrinsic returns the "
"maximum of the two arguments, propagating NaNs and treating -0.0 as less "
"than +0.0."
msgstr ""

#: ../../../LangRef.rst:28991 ../../../LangRef.rst:29023
msgid ""
"This function follows semantics specified in the draft of IEEE 754-2019."
msgstr ""

#: ../../../LangRef.rst:28995
msgid "'``llvm.experimental.constrained.minimum``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29009
msgid ""
"The '``llvm.experimental.constrained.minimum``' intrinsic returns the "
"minimum of the two arguments, propagating NaNs and treating -0.0 as less "
"than +0.0."
msgstr ""

#: ../../../LangRef.rst:29027
msgid "'``llvm.experimental.constrained.ceil``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29041
msgid ""
"The '``llvm.experimental.constrained.ceil``' intrinsic returns the ceiling "
"of the first argument."
msgstr ""

#: ../../../LangRef.rst:29055
msgid ""
"This function returns the same values as the libm ``ceil`` functions would "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:29060
msgid "'``llvm.experimental.constrained.floor``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29074
msgid ""
"The '``llvm.experimental.constrained.floor``' intrinsic returns the floor of "
"the first argument."
msgstr ""

#: ../../../LangRef.rst:29088
msgid ""
"This function returns the same values as the libm ``floor`` functions would "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:29093
msgid "'``llvm.experimental.constrained.round``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29107
msgid ""
"The '``llvm.experimental.constrained.round``' intrinsic returns the first "
"argument rounded to the nearest integer."
msgstr ""

#: ../../../LangRef.rst:29121
msgid ""
"This function returns the same values as the libm ``round`` functions would "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:29126
msgid "'``llvm.experimental.constrained.roundeven``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29140
msgid ""
"The '``llvm.experimental.constrained.roundeven``' intrinsic returns the "
"first argument rounded to the nearest integer in floating-point format, "
"rounding halfway cases to even (that is, to the nearest value that is an "
"even integer), regardless of the current rounding direction."
msgstr ""

#: ../../../LangRef.rst:29156
msgid ""
"This function implements IEEE-754 operation ``roundToIntegralTiesToEven``. "
"It also behaves in the same way as C standard function ``roundeven`` and can "
"signal the invalid operation exception for a SNAN argument."
msgstr ""

#: ../../../LangRef.rst:29162
msgid "'``llvm.experimental.constrained.lround``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29176
msgid ""
"The '``llvm.experimental.constrained.lround``' intrinsic returns the first "
"argument rounded to the nearest integer with ties away from zero.  It will "
"raise an inexact floating-point exception if the argument is not an integer. "
"If the rounded value is too large to fit into the result type, an invalid "
"exception is raised, and the return value is a non-deterministic value "
"(equivalent to `freeze poison`)."
msgstr ""

#: ../../../LangRef.rst:29186
msgid ""
"The first argument is a floating-point number. The return value is an "
"integer type. Not all types are supported on all targets. The supported "
"types are the same as the ``llvm.lround`` intrinsic and the ``lround`` libm "
"functions."
msgstr ""

#: ../../../LangRef.rst:29196
msgid ""
"This function returns the same values as the libm ``lround`` functions would "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:29201
msgid "'``llvm.experimental.constrained.llround``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29215
msgid ""
"The '``llvm.experimental.constrained.llround``' intrinsic returns the first "
"argument rounded to the nearest integer with ties away from zero. It will "
"raise an inexact floating-point exception if the argument is not an integer. "
"If the rounded value is too large to fit into the result type, an invalid "
"exception is raised, and the return value is a non-deterministic value "
"(equivalent to `freeze poison`)."
msgstr ""

#: ../../../LangRef.rst:29225
msgid ""
"The first argument is a floating-point number. The return value is an "
"integer type. Not all types are supported on all targets. The supported "
"types are the same as the ``llvm.llround`` intrinsic and the ``llround`` "
"libm functions."
msgstr ""

#: ../../../LangRef.rst:29235
msgid ""
"This function returns the same values as the libm ``llround`` functions "
"would and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:29240
msgid "'``llvm.experimental.constrained.trunc``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29254
msgid ""
"The '``llvm.experimental.constrained.trunc``' intrinsic returns the first "
"argument rounded to the nearest integer not larger in magnitude than the "
"argument."
msgstr ""

#: ../../../LangRef.rst:29269
msgid ""
"This function returns the same values as the libm ``trunc`` functions would "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:29275
msgid "'``llvm.experimental.noalias.scope.decl``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29288 ../../../LangRef.rst:29304
msgid ""
"The ``llvm.experimental.noalias.scope.decl`` intrinsic identifies where a "
"noalias scope is declared. When the intrinsic is duplicated, a decision must "
"also be made about the scope: depending on the reason of the duplication, "
"the scope might need to be duplicated as well."
msgstr ""

#: ../../../LangRef.rst:29297
msgid ""
"The ``!id.scope.list`` argument is metadata that is a list of ``noalias`` "
"metadata references. The format is identical to that required for "
"``noalias`` metadata. This list must have exactly one element."
msgstr ""

#: ../../../LangRef.rst:29309
msgid ""
"For example, when the intrinsic is used inside a loop body, and that loop is "
"unrolled, the associated noalias scope must also be duplicated. Otherwise, "
"the noalias property it signifies would spill across loop iterations, "
"whereas it was only valid within a single iteration."
msgstr ""

#: ../../../LangRef.rst:29343
msgid ""
"Multiple calls to `@llvm.experimental.noalias.scope.decl` for the same scope "
"are possible, but one should never dominate another. Violations are pointed "
"out by the verifier as they indicate a problem in either a transformation "
"pass or the input."
msgstr ""

#: ../../../LangRef.rst:29350
msgid "Floating Point Environment Manipulation intrinsics"
msgstr ""

#: ../../../LangRef.rst:29352
msgid ""
"These functions read or write floating point environment, such as rounding "
"mode or state of floating point exceptions. Altering the floating point "
"environment requires special care. See :ref:`Floating Point Environment "
"<floatenv>`."
msgstr ""

#: ../../../LangRef.rst:29359
msgid "'``llvm.get.rounding``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29371
msgid "The '``llvm.get.rounding``' intrinsic reads the current rounding mode."
msgstr ""

#: ../../../LangRef.rst:29376
msgid ""
"The '``llvm.get.rounding``' intrinsic returns the current rounding mode. "
"Encoding of the returned values is same as the result of ``FLT_ROUNDS``, "
"specified by C standard:"
msgstr ""

#: ../../../LangRef.rst:29388
msgid ""
"Other values may be used to represent additional rounding modes, supported "
"by a target. These values are target-specific."
msgstr ""

#: ../../../LangRef.rst:29394
msgid "'``llvm.set.rounding``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29406
msgid "The '``llvm.set.rounding``' intrinsic sets current rounding mode."
msgstr ""

#: ../../../LangRef.rst:29411
msgid ""
"The argument is the required rounding mode. Encoding of rounding mode is the "
"same as used by '``llvm.get.rounding``'."
msgstr ""

#: ../../../LangRef.rst:29417
msgid ""
"The '``llvm.set.rounding``' intrinsic sets the current rounding mode. It is "
"similar to C library function 'fesetround', however this intrinsic does not "
"return any value and uses platform-independent representation of IEEE "
"rounding modes."
msgstr ""

#: ../../../LangRef.rst:29425
msgid "'``llvm.get.fpenv``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29437
msgid ""
"The '``llvm.get.fpenv``' intrinsic returns bits of the current floating-"
"point environment. The return value type is platform-specific."
msgstr ""

#: ../../../LangRef.rst:29443
msgid ""
"The '``llvm.get.fpenv``' intrinsic reads the current floating-point "
"environment and returns it as an integer value."
msgstr ""

#: ../../../LangRef.rst:29449
msgid "'``llvm.set.fpenv``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29461
msgid ""
"The '``llvm.set.fpenv``' intrinsic sets the current floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:29466
msgid ""
"The argument is an integer representing the new floating-point environment. "
"The integer type is platform-specific."
msgstr ""

#: ../../../LangRef.rst:29472
msgid ""
"The '``llvm.set.fpenv``' intrinsic sets the current floating-point "
"environment to the state specified by the argument. The state may be "
"previously obtained by a call to '``llvm.get.fpenv``' or synthesized in a "
"platform-dependent way."
msgstr ""

#: ../../../LangRef.rst:29478
msgid "'``llvm.reset.fpenv``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29490
msgid ""
"The '``llvm.reset.fpenv``' intrinsic sets the default floating-point "
"environment."
msgstr ""

#: ../../../LangRef.rst:29495
msgid ""
"The '``llvm.reset.fpenv``' intrinsic sets the current floating-point "
"environment to default state. It is similar to the call "
"'fesetenv(FE_DFL_ENV)', except it does not return any value."
msgstr ""

#: ../../../LangRef.rst:29502
msgid "'``llvm.get.fpmode``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29507
msgid ""
"The '``llvm.get.fpmode``' intrinsic returns bits of the current floating-"
"point control modes. The return value type is platform-specific."
msgstr ""

#: ../../../LangRef.rst:29517
msgid ""
"The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point "
"control modes and returns it as an integer value."
msgstr ""

#: ../../../LangRef.rst:29528
msgid ""
"The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point "
"control modes, such as rounding direction, precision, treatment of denormals "
"and so on. It is similar to the C library function 'fegetmode', however this "
"function does not store the set of control modes into memory but returns it "
"as an integer value. Interpretation of the bits in this value is target-"
"dependent."
msgstr ""

#: ../../../LangRef.rst:29535
msgid "'``llvm.set.fpmode``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29540
msgid ""
"The '``llvm.set.fpmode``' intrinsic sets the current floating-point control "
"modes."
msgstr ""

#: ../../../LangRef.rst:29549
msgid ""
"The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point "
"control modes."
msgstr ""

#: ../../../LangRef.rst:29555
msgid ""
"The argument is a set of floating-point control modes, represented as an "
"integer value in a target-dependent way."
msgstr ""

#: ../../../LangRef.rst:29561
msgid ""
"The '``llvm.set.fpmode``' intrinsic sets the current dynamic floating-point "
"control modes to the state specified by the argument, which must be obtained "
"by a call to '``llvm.get.fpmode``' or constructed in a target-specific way. "
"It is similar to the C library function 'fesetmode', however this function "
"does not read the set of control modes from memory but gets it as integer "
"value."
msgstr ""

#: ../../../LangRef.rst:29568
msgid "'``llvm.reset.fpmode``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29580
msgid ""
"The '``llvm.reset.fpmode``' intrinsic sets the default dynamic floating-"
"point control modes."
msgstr ""

#: ../../../LangRef.rst:29591
msgid ""
"The '``llvm.reset.fpmode``' intrinsic sets the current dynamic floating-"
"point environment to default state. It is similar to the C library function "
"call 'fesetmode(FE_DFL_MODE)', however this function does not return any "
"value."
msgstr ""

#: ../../../LangRef.rst:29597
msgid "Floating-Point Test Intrinsics"
msgstr ""

#: ../../../LangRef.rst:29599
msgid "These functions get properties of floating-point values."
msgstr ""

#: ../../../LangRef.rst:29605
msgid "'``llvm.is.fpclass``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29618
msgid ""
"The '``llvm.is.fpclass``' intrinsic returns a boolean value or vector of "
"boolean values depending on whether the first argument satisfies the test "
"specified by the second argument."
msgstr ""

#: ../../../LangRef.rst:29622
msgid ""
"If the first argument is a floating-point scalar, then the result type is a "
"boolean (:ref:`i1 <t_integer>`)."
msgstr ""

#: ../../../LangRef.rst:29625
msgid ""
"If the first argument is a floating-point vector, then the result type is a "
"vector of boolean with the same number of elements as the first argument."
msgstr ""

#: ../../../LangRef.rst:29631
msgid ""
"The first argument to the '``llvm.is.fpclass``' intrinsic must be :ref:"
"`floating-point <t_floating>` or :ref:`vector <t_vector>` of floating-point "
"values."
msgstr ""

#: ../../../LangRef.rst:29635
msgid ""
"The second argument specifies, which tests to perform. It must be a compile-"
"time integer constant, each bit in which specifies floating-point class:"
msgstr ""

#: ../../../LangRef.rst:29659
msgid "9"
msgstr ""

#: ../../../LangRef.rst:29665
msgid ""
"The function checks if ``op`` belongs to any of the floating-point classes "
"specified by ``test``. If ``op`` is a vector, then the check is made element "
"by element. Each check yields an :ref:`i1 <t_integer>` result, which is "
"``true``, if the element value satisfies the specified test. The argument "
"``test`` is a bit mask where each bit specifies floating-point class to "
"test. For example, the value 0x108 makes test for normal value, - bits 3 and "
"8 in it are set, which means that the function returns ``true`` if ``op`` is "
"a positive or negative normal value. The function never raises floating-"
"point exceptions. The function does not canonicalize its input value and "
"does not depend on the floating-point environment. If the floating-point "
"environment has a zeroing treatment of subnormal input values (such as "
"indicated by the ``\"denormal-fp-math\"`` attribute), a subnormal value will "
"be observed (will not be implicitly treated as zero)."
msgstr ""

#: ../../../LangRef.rst:29681
msgid "General Intrinsics"
msgstr ""

#: ../../../LangRef.rst:29683
msgid ""
"This class of intrinsics is designed to be generic and has no specific "
"purpose."
msgstr ""

#: ../../../LangRef.rst:29687
msgid "'``llvm.var.annotation``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29699
msgid "The '``llvm.var.annotation``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:29704
msgid ""
"The first argument is a pointer to a value, the second is a pointer to a "
"global string, the third is a pointer to a global string which is the source "
"file name, and the last argument is the line number."
msgstr ""

#: ../../../LangRef.rst:29711
msgid ""
"This intrinsic allows annotation of local variables with arbitrary strings. "
"This can be useful for special purpose optimizations that want to look for "
"these annotations. These have no other defined use; they are ignored by code "
"generation and optimization."
msgstr ""

#: ../../../LangRef.rst:29717
msgid "'``llvm.ptr.annotation.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29722
msgid ""
"This is an overloaded intrinsic. You can use '``llvm.ptr.annotation``' on a "
"pointer to an integer of any width. *NOTE* you must specify an address space "
"for the pointer. The identifier for the default address space is the integer "
"'``0``'."
msgstr ""

#: ../../../LangRef.rst:29735
msgid "The '``llvm.ptr.annotation``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:29740
msgid ""
"The first argument is a pointer to an integer value of arbitrary bitwidth "
"(result of some expression), the second is a pointer to a global string, the "
"third is a pointer to a global string which is the source file name, and the "
"last argument is the line number. It returns the value of the first argument."
msgstr ""

#: ../../../LangRef.rst:29748
msgid ""
"This intrinsic allows annotation of a pointer to an integer with arbitrary "
"strings. This can be useful for special purpose optimizations that want to "
"look for these annotations. These have no other defined use; transformations "
"preserve annotations on a best-effort basis but are allowed to replace the "
"intrinsic with its first argument without breaking semantics and the "
"intrinsic is completely dropped during instruction selection."
msgstr ""

#: ../../../LangRef.rst:29756
msgid "'``llvm.annotation.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29761
msgid ""
"This is an overloaded intrinsic. You can use '``llvm.annotation``' on any "
"integer bit width."
msgstr ""

#: ../../../LangRef.rst:29775
msgid "The '``llvm.annotation``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:29780
msgid ""
"The first argument is an integer value (result of some expression), the "
"second is a pointer to a global string, the third is a pointer to a global "
"string which is the source file name, and the last argument is the line "
"number. It returns the value of the first argument."
msgstr ""

#: ../../../LangRef.rst:29788
msgid ""
"This intrinsic allows annotations to be put on arbitrary expressions with "
"arbitrary strings. This can be useful for special purpose optimizations that "
"want to look for these annotations. These have no other defined use; "
"transformations preserve annotations on a best-effort basis but are allowed "
"to replace the intrinsic with its first argument without breaking semantics "
"and the intrinsic is completely dropped during instruction selection."
msgstr ""

#: ../../../LangRef.rst:29796
msgid "'``llvm.codeview.annotation``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29801
msgid ""
"This annotation emits a label at its program point and an associated "
"``S_ANNOTATION`` codeview record with some additional string metadata. This "
"is used to implement MSVC's ``__annotation`` intrinsic. It is marked "
"``noduplicate``, so calls to this intrinsic prevent inlining and should be "
"considered expensive."
msgstr ""

#: ../../../LangRef.rst:29814
msgid "The argument should be an MDTuple containing any number of MDStrings."
msgstr ""

#: ../../../LangRef.rst:29819
msgid "'``llvm.trap``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29831
msgid "The '``llvm.trap``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:29841
msgid ""
"This intrinsic is lowered to the target-dependent trap instruction. If the "
"target does not have a trap instruction, this intrinsic will be lowered to a "
"call of the ``abort()`` function."
msgstr ""

#: ../../../LangRef.rst:29848
msgid "'``llvm.debugtrap``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29860
msgid "The '``llvm.debugtrap``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:29870
msgid ""
"This intrinsic is lowered to code which is intended to cause an execution "
"trap with the intention of requesting the attention of a debugger."
msgstr ""

#: ../../../LangRef.rst:29877
msgid "'``llvm.ubsantrap``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29889
msgid "The '``llvm.ubsantrap``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:29894
msgid "An integer describing the kind of failure detected."
msgstr ""

#: ../../../LangRef.rst:29899
msgid ""
"This intrinsic is lowered to code which is intended to cause an execution "
"trap, embedding the argument into encoding of that trap somehow to "
"discriminate crashes if possible."
msgstr ""

#: ../../../LangRef.rst:29903
msgid ""
"Equivalent to ``@llvm.trap`` for targets that do not support this behavior."
msgstr ""

#: ../../../LangRef.rst:29906
msgid "'``llvm.stackprotector``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29918
msgid ""
"The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it onto "
"the stack at ``slot``. The stack slot is adjusted to ensure that it is "
"placed on the stack before local variables."
msgstr ""

#: ../../../LangRef.rst:29925
msgid ""
"The ``llvm.stackprotector`` intrinsic requires two pointer arguments. The "
"first argument is the value loaded from the stack guard "
"``@__stack_chk_guard``. The second variable is an ``alloca`` that has enough "
"space to hold the value of the guard."
msgstr ""

#: ../../../LangRef.rst:29933
msgid ""
"This intrinsic causes the prologue/epilogue inserter to force the position "
"of the ``AllocaInst`` stack slot to be before local variables on the stack. "
"This is to ensure that if a local variable on the stack is overwritten, it "
"will destroy the value of the guard. When the function exits, the guard on "
"the stack is checked against the original guard by ``llvm."
"stackprotectorcheck``. If they are different, then ``llvm."
"stackprotectorcheck`` causes the program to abort by calling the "
"``__stack_chk_fail()`` function."
msgstr ""

#: ../../../LangRef.rst:29942
msgid "'``llvm.stackguard``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29954
msgid "The ``llvm.stackguard`` intrinsic returns the system stack guard value."
msgstr ""

#: ../../../LangRef.rst:29956
msgid ""
"It should not be generated by frontends, since it is only for internal "
"usage. The reason why we create this intrinsic is that we still support IR "
"form Stack Protector in FastISel."
msgstr ""

#: ../../../LangRef.rst:29968
msgid ""
"On some platforms, the value returned by this intrinsic remains unchanged "
"between loads in the same thread. On other platforms, it returns the same "
"global variable value, if any, e.g. ``@__stack_chk_guard``."
msgstr ""

#: ../../../LangRef.rst:29972
msgid ""
"Currently some platforms have IR-level customized stack guard loading (e.g. "
"X86 Linux) that is not handled by ``llvm.stackguard()``, while they should "
"be in the future."
msgstr ""

#: ../../../LangRef.rst:29977
msgid "'``llvm.objectsize``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:29990
msgid ""
"The ``llvm.objectsize`` intrinsic is designed to provide information to the "
"optimizer to determine whether a) an operation (like memcpy) will overflow a "
"buffer that corresponds to an object, or b) that a runtime check for "
"overflow isn't necessary. An object in this context means an allocation of a "
"specific class, structure, array, or other object."
msgstr ""

#: ../../../LangRef.rst:29999
msgid ""
"The ``llvm.objectsize`` intrinsic takes four arguments. The first argument "
"is a pointer to or into the ``object``."
msgstr ""

#: ../../../LangRef.rst:30002
msgid ""
"The second argument determines whether ``llvm.objectsize`` returns the "
"minimum (if true) or maximum (if false) object size. The minimum size may be "
"any size smaller than or equal to the actual object size (including 0 if "
"unknown). The maximum size may be any size greater than or equal to the "
"actual object size (including -1 if unknown)."
msgstr ""

#: ../../../LangRef.rst:30008
msgid ""
"The third argument controls how ``llvm.objectsize`` acts when ``null`` in "
"address space 0 is used as its pointer argument. If it's ``false``, ``llvm."
"objectsize`` reports 0 bytes available when given ``null``. Otherwise, if "
"the ``null`` is in a non-zero address space or if ``true`` is given for the "
"third argument of ``llvm.objectsize``, we assume its size is unknown. The "
"fourth argument to ``llvm.objectsize`` determines if the value should be "
"evaluated at runtime."
msgstr ""

#: ../../../LangRef.rst:30016
msgid "The second, third, and fourth arguments only accept constants."
msgstr ""

#: ../../../LangRef.rst:30021
msgid ""
"The ``llvm.objectsize`` intrinsic is lowered to a value representing the "
"size of the object concerned. If the size cannot be determined, ``llvm."
"objectsize`` returns ``i32/i64 -1 or 0`` (depending on the ``min`` argument)."
msgstr ""

#: ../../../LangRef.rst:30026
msgid "'``llvm.expect``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30031
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.expect`` on any integer "
"bit width."
msgstr ""

#: ../../../LangRef.rst:30043
msgid ""
"The ``llvm.expect`` intrinsic provides information about expected (the most "
"probable) value of ``val``, which can be used by optimizers."
msgstr ""

#: ../../../LangRef.rst:30049
msgid ""
"The ``llvm.expect`` intrinsic takes two arguments. The first argument is a "
"value. The second argument is an expected value."
msgstr ""

#: ../../../LangRef.rst:30055 ../../../LangRef.rst:30089
msgid "This intrinsic is lowered to the ``val``."
msgstr ""

#: ../../../LangRef.rst:30058
msgid "'``llvm.expect.with.probability``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30063
msgid ""
"This intrinsic is similar to ``llvm.expect``. This is an overloaded "
"intrinsic. You can use ``llvm.expect.with.probability`` on any integer bit "
"width."
msgstr ""

#: ../../../LangRef.rst:30075
msgid ""
"The ``llvm.expect.with.probability`` intrinsic provides information about "
"expected value of ``val`` with probability(or confidence) ``prob``, which "
"can be used by optimizers."
msgstr ""

#: ../../../LangRef.rst:30082
msgid ""
"The ``llvm.expect.with.probability`` intrinsic takes three arguments. The "
"first argument is a value. The second argument is an expected value. The "
"third argument is a probability."
msgstr ""

#: ../../../LangRef.rst:30094
msgid "'``llvm.assume``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30106
msgid ""
"The ``llvm.assume`` allows the optimizer to assume that the provided "
"condition is true. This information can then be used in simplifying other "
"parts of the code."
msgstr ""

#: ../../../LangRef.rst:30110
msgid ""
"More complex assumptions can be encoded as :ref:`assume operand bundles "
"<assume_opbundles>`."
msgstr ""

#: ../../../LangRef.rst:30116
msgid ""
"The argument of the call is the condition which the optimizer may assume is "
"always true."
msgstr ""

#: ../../../LangRef.rst:30122
msgid ""
"The intrinsic allows the optimizer to assume that the provided condition is "
"always true whenever the control flow reaches the intrinsic call. No code is "
"generated for this intrinsic, and instructions that contribute only to the "
"provided condition are not used for code generation. If the condition is "
"violated during execution, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:30128
msgid ""
"Note that the optimizer might limit the transformations performed on values "
"used by the ``llvm.assume`` intrinsic in order to preserve the instructions "
"only used to form the intrinsic's input argument. This might prove "
"undesirable if the extra information provided by the ``llvm.assume`` "
"intrinsic does not cause sufficient overall improvement in code quality. For "
"this reason, ``llvm.assume`` should not be used to document basic "
"mathematical invariants that the optimizer can otherwise deduce or facts "
"that are of little use to the optimizer."
msgstr ""

#: ../../../LangRef.rst:30140
msgid "'``llvm.ssa.copy``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30152
msgid "The first argument is an operand which is used as the returned value."
msgstr ""

#: ../../../LangRef.rst:30157
msgid ""
"The ``llvm.ssa.copy`` intrinsic can be used to attach information to "
"operations by copying them and giving them new names.  For example, the "
"PredicateInfo utility uses it to build Extended SSA form, and attach various "
"forms of information to operands that dominate specific uses.  It is not "
"meant for general use, only for building temporary renaming forms that "
"require value splits at certain points."
msgstr ""

#: ../../../LangRef.rst:30167
msgid "'``llvm.type.test``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30180
msgid ""
"The first argument is a pointer to be tested. The second argument is a "
"metadata object representing a :doc:`type identifier <TypeMetadata>`."
msgstr ""

#: ../../../LangRef.rst:30186
msgid ""
"The ``llvm.type.test`` intrinsic tests whether the given pointer is "
"associated with the given type identifier."
msgstr ""

#: ../../../LangRef.rst:30192
msgid "'``llvm.type.checked.load``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30205
msgid ""
"The first argument is a pointer from which to load a function pointer. The "
"second argument is the byte offset from which to load the function pointer. "
"The third argument is a metadata object representing a :doc:`type identifier "
"<TypeMetadata>`."
msgstr ""

#: ../../../LangRef.rst:30213
msgid ""
"The ``llvm.type.checked.load`` intrinsic safely loads a function pointer "
"from a virtual table pointer using type metadata. This intrinsic is used to "
"implement control flow integrity in conjunction with virtual call "
"optimization. The virtual call optimization pass will optimize away ``llvm."
"type.checked.load`` intrinsics associated with devirtualized calls, thereby "
"removing the type check in cases where it is not needed to enforce the "
"control flow integrity constraint."
msgstr ""

#: ../../../LangRef.rst:30221
msgid ""
"If the given pointer is associated with a type metadata identifier, this "
"function returns true as the second element of its return value. (Note that "
"the function may also return true if the given pointer is not associated "
"with a type metadata identifier.) If the function's return value's second "
"element is true, the following rules apply to the first element:"
msgstr ""

#: ../../../LangRef.rst:30227
msgid ""
"If the given pointer is associated with the given type metadata identifier, "
"it is the function pointer loaded from the given byte offset from the given "
"pointer."
msgstr ""

#: ../../../LangRef.rst:30231
msgid ""
"If the given pointer is not associated with the given type metadata "
"identifier, it is one of the following (the choice of which is unspecified):"
msgstr ""

#: ../../../LangRef.rst:30234
msgid ""
"The function pointer that would have been loaded from an arbitrarily chosen "
"(through an unspecified mechanism) pointer associated with the type metadata."
msgstr ""

#: ../../../LangRef.rst:30238
msgid ""
"If the function has a non-void return type, a pointer to a function that "
"returns an unspecified value without causing side effects."
msgstr ""

#: ../../../LangRef.rst:30241
msgid ""
"If the function's return value's second element is false, the value of the "
"first element is undefined."
msgstr ""

#: ../../../LangRef.rst:30247
msgid "'``llvm.type.checked.load.relative``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30259
msgid ""
"The ``llvm.type.checked.load.relative`` intrinsic loads a relative pointer "
"to a function from a virtual table pointer using metadata. Otherwise, its "
"semantic is identical to the ``llvm.type.checked.load`` intrinsic."
msgstr ""

#: ../../../LangRef.rst:30263
msgid ""
"A relative pointer is a pointer to an offset. This is the offset between the "
"destination pointer and the original pointer. The address of the destination "
"pointer is obtained by loading this offset and adding it to the original "
"pointer. This calculation is the same as that of the ``llvm.load.relative`` "
"intrinsic."
msgstr ""

#: ../../../LangRef.rst:30269
msgid "'``llvm.arithmetic.fence``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30282
msgid ""
"The purpose of the ``llvm.arithmetic.fence`` intrinsic is to prevent the "
"optimizer from performing fast-math optimizations, particularly "
"reassociation, between the argument and the expression that contains the "
"argument. It can be used to preserve the parentheses in the source language."
msgstr ""

#: ../../../LangRef.rst:30291
msgid ""
"The ``llvm.arithmetic.fence`` intrinsic takes only one argument. The "
"argument and the return value are floating-point numbers, or vector floating-"
"point numbers, of the same type."
msgstr ""

#: ../../../LangRef.rst:30298
msgid ""
"This intrinsic returns the value of its operand. The optimizer can optimize "
"the argument, but the optimizer cannot hoist any component of the operand to "
"the containing context, and the optimizer cannot move the calculation of any "
"expression in the containing context into the operand."
msgstr ""

#: ../../../LangRef.rst:30305
msgid "'``llvm.donothing``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30317
msgid ""
"The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one of "
"only three intrinsics (besides ``llvm.experimental.patchpoint`` and ``llvm."
"experimental.gc.statepoint``) that can be called with an invoke instruction."
msgstr ""

#: ../../../LangRef.rst:30330
msgid ""
"This intrinsic does nothing, and it's removed by optimizers and ignored by "
"codegen."
msgstr ""

#: ../../../LangRef.rst:30334
msgid "'``llvm.experimental.deoptimize``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30346
msgid ""
"This intrinsic, together with :ref:`deoptimization operand bundles "
"<deopt_opbundles>`, allow frontends to express transfer of control and frame-"
"local state from the currently executing (typically more specialized, hence "
"faster) version of a function into another (typically more generic, hence "
"slower) version."
msgstr ""

#: ../../../LangRef.rst:30352
msgid ""
"In languages with a fully integrated managed runtime like Java and "
"JavaScript this intrinsic can be used to implement \"uncommon trap\" or "
"\"side exit\" like functionality.  In unmanaged languages like C and C++, "
"this intrinsic can be used to represent the slow paths of specialized "
"functions."
msgstr ""

#: ../../../LangRef.rst:30361
msgid ""
"The intrinsic takes an arbitrary number of arguments, whose meaning is "
"decided by the :ref:`lowering strategy<deoptimize_lowering>`."
msgstr ""

#: ../../../LangRef.rst:30367
msgid ""
"The ``@llvm.experimental.deoptimize`` intrinsic executes an attached "
"deoptimization continuation (denoted using a :ref:`deoptimization operand "
"bundle <deopt_opbundles>`) and returns the value returned by the "
"deoptimization continuation.  Defining the semantic properties of the "
"continuation itself is out of scope of the language reference -- as far as "
"LLVM is concerned, the deoptimization continuation can invoke arbitrary side "
"effects, including reading from and writing to the entire heap."
msgstr ""

#: ../../../LangRef.rst:30376
msgid ""
"Deoptimization continuations expressed using ``\"deopt\"`` operand bundles "
"always continue execution to the end of the physical frame containing them, "
"so all calls to ``@llvm.experimental.deoptimize`` must be in \"tail "
"position\":"
msgstr ""

#: ../../../LangRef.rst:30380
msgid "``@llvm.experimental.deoptimize`` cannot be invoked."
msgstr ""

#: ../../../LangRef.rst:30381
msgid "The call must immediately precede a :ref:`ret <i_ret>` instruction."
msgstr ""

#: ../../../LangRef.rst:30382
msgid ""
"The ``ret`` instruction must return the value produced by the ``@llvm."
"experimental.deoptimize`` call if there is one, or void."
msgstr ""

#: ../../../LangRef.rst:30385
msgid ""
"Note that the above restrictions imply that the return type for a call to "
"``@llvm.experimental.deoptimize`` will match the return type of its "
"immediate caller."
msgstr ""

#: ../../../LangRef.rst:30389
msgid ""
"The inliner composes the ``\"deopt\"`` continuations of the caller into the "
"``\"deopt\"`` continuations present in the inlinee, and also updates calls "
"to this intrinsic to return directly from the frame of the function it "
"inlined into."
msgstr ""

#: ../../../LangRef.rst:30393
msgid ""
"All declarations of ``@llvm.experimental.deoptimize`` must share the same "
"calling convention."
msgstr ""

#: ../../../LangRef.rst:30399 ../../../LangRef.rst:30591
#: ../../../LangRef.rst:31030 ../../../LangRef.rst:31108
#: ../../../LangRef.rst:31183 ../../../LangRef.rst:31209
#: ../../../LangRef.rst:31223 ../../../LangRef.rst:31237
#: ../../../LangRef.rst:31251 ../../../LangRef.rst:31265
#: ../../../LangRef.rst:31279 ../../../LangRef.rst:31293
#: ../../../LangRef.rst:31307 ../../../LangRef.rst:31321
#: ../../../LangRef.rst:31335 ../../../LangRef.rst:31349
#: ../../../LangRef.rst:31363 ../../../LangRef.rst:31377
#: ../../../LangRef.rst:31391 ../../../LangRef.rst:31405
#: ../../../LangRef.rst:31419 ../../../LangRef.rst:31433
#: ../../../LangRef.rst:31447
msgid "Lowering:"
msgstr ""

#: ../../../LangRef.rst:30401
msgid ""
"Calls to ``@llvm.experimental.deoptimize`` are lowered to calls to the "
"symbol ``__llvm_deoptimize`` (it is the frontend's responsibility to ensure "
"that this symbol is defined).  The call arguments to ``@llvm.experimental."
"deoptimize`` are lowered as if they were formal arguments of the specified "
"types, and not as varargs."
msgstr ""

#: ../../../LangRef.rst:30409
msgid "'``llvm.experimental.guard``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30421
msgid ""
"This intrinsic, together with :ref:`deoptimization operand bundles "
"<deopt_opbundles>`, allows frontends to express guards or checks on "
"optimistic assumptions made during compilation.  The semantics of ``@llvm."
"experimental.guard`` is defined in terms of ``@llvm.experimental."
"deoptimize`` -- its body is defined to be equivalent to:"
msgstr ""

#: ../../../LangRef.rst:30443
msgid ""
"with the optional ``[, !make.implicit !{}]`` present if and only if it is "
"present on the call site.  For more details on ``!make.implicit``, see :doc:"
"`FaultMaps`."
msgstr ""

#: ../../../LangRef.rst:30447
msgid ""
"In words, ``@llvm.experimental.guard`` executes the attached ``\"deopt\"`` "
"continuation if (but **not** only if) its first argument is ``false``.  "
"Since the optimizer is allowed to replace the ``undef`` with an arbitrary "
"value, it can optimize guard to fail \"spuriously\", i.e., without the "
"original condition being false (hence the \"not only if\"); and this allows "
"for \"check widening\" type optimizations."
msgstr ""

#: ../../../LangRef.rst:30454
msgid "``@llvm.experimental.guard`` cannot be invoked."
msgstr ""

#: ../../../LangRef.rst:30456
msgid ""
"After ``@llvm.experimental.guard`` was first added, a more general "
"formulation was found in ``@llvm.experimental.widenable.condition``. Support "
"for ``@llvm.experimental.guard`` is slowly being rephrased in terms of this "
"alternate."
msgstr ""

#: ../../../LangRef.rst:30462
msgid "'``llvm.experimental.widenable.condition``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30474
msgid ""
"This intrinsic represents a \"widenable condition\" which is boolean "
"expressions with the following property: whether this expression is `true` "
"or `false`, the program is correct and well-defined."
msgstr ""

#: ../../../LangRef.rst:30479
msgid ""
"Together with :ref:`deoptimization operand bundles <deopt_opbundles>`, "
"``@llvm.experimental.widenable.condition`` allows frontends to express "
"guards or checks on optimistic assumptions made during compilation and "
"represent them as branch instructions on special conditions."
msgstr ""

#: ../../../LangRef.rst:30485
msgid ""
"While this may appear similar in semantics to `undef`, it is very different "
"in that an invocation produces a particular, singular value. It is also "
"intended to be lowered late, and remain available for specific optimizations "
"and transforms that can benefit from its special properties."
msgstr ""

#: ../../../LangRef.rst:30499
msgid ""
"The intrinsic ``@llvm.experimental.widenable.condition()`` returns either "
"`true` or `false`. For each evaluation of a call to this intrinsic, the "
"program must be valid and correct both if it returns `true` and if it "
"returns `false`. This allows transformation passes to replace evaluations of "
"this intrinsic with either value whenever one is beneficial."
msgstr ""

#: ../../../LangRef.rst:30506
msgid ""
"When used in a branch condition, it allows us to choose between two "
"alternative correct solutions for the same problem, like in example below:"
msgstr ""

#: ../../../LangRef.rst:30521
msgid ""
"Whether the result of intrinsic's call is `true` or `false`, it should be "
"correct to pick either solution. We can switch between them by replacing the "
"result of ``@llvm.experimental.widenable.condition`` with different `i1` "
"expressions."
msgstr ""

#: ../../../LangRef.rst:30527
msgid "This is how it can be used to represent guards as widenable branches:"
msgstr ""

#: ../../../LangRef.rst:30536
msgid ""
"Can be expressed in an alternative equivalent form of explicit branch using "
"``@llvm.experimental.widenable.condition``:"
msgstr ""

#: ../../../LangRef.rst:30553
msgid ""
"So the block `guarded` is only reachable when `%cond` is `true`, and it "
"should be valid to go to the block `deopt` whenever `%cond` is `true` or "
"`false`."
msgstr ""

#: ../../../LangRef.rst:30557
msgid ""
"``@llvm.experimental.widenable.condition`` will never throw, thus it cannot "
"be invoked."
msgstr ""

#: ../../../LangRef.rst:30561
msgid "Guard widening:"
msgstr ""

#: ../../../LangRef.rst:30563
msgid ""
"When ``@llvm.experimental.widenable.condition()`` is used in condition of a "
"guard represented as explicit branch, it is legal to widen the guard's "
"condition with any additional conditions."
msgstr ""

#: ../../../LangRef.rst:30568
msgid "Guard widening looks like replacement of"
msgstr ""

#: ../../../LangRef.rst:30576
msgid "with"
msgstr ""

#: ../../../LangRef.rst:30585
msgid ""
"for this branch. Here `%any_other_cond` is an arbitrarily chosen well-"
"defined `i1` value. By making guard widening, we may impose stricter "
"conditions on `guarded` block and bail to the deopt when the new condition "
"is not met."
msgstr ""

#: ../../../LangRef.rst:30593
msgid ""
"Default lowering strategy is replacing the result of call of ``@llvm."
"experimental.widenable.condition``  with constant `true`. However it is "
"always correct to replace it with any other `i1` value. Any pass can freely "
"do it if it can benefit from non-default lowering."
msgstr ""

#: ../../../LangRef.rst:30600
msgid "'``llvm.allow.ubsan.check``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30612
msgid ""
"This intrinsic returns ``true`` if and only if the compiler opted to enable "
"the ubsan check in the current basic block."
msgstr ""

#: ../../../LangRef.rst:30615
msgid ""
"Rules to allow ubsan checks are not part of the intrinsic declaration, and "
"controlled by compiler options."
msgstr ""

#: ../../../LangRef.rst:30618
msgid ""
"This intrinsic is the ubsan specific version of ``@llvm.allow.runtime."
"check()``."
msgstr ""

#: ../../../LangRef.rst:30623
msgid "An integer describing the kind of ubsan check guarded by the intrinsic."
msgstr ""

#: ../../../LangRef.rst:30628
msgid ""
"The intrinsic ``@llvm.allow.ubsan.check()`` returns either ``true`` or "
"``false``, depending on compiler options."
msgstr ""

#: ../../../LangRef.rst:30631 ../../../LangRef.rst:30690
msgid ""
"For each evaluation of a call to this intrinsic, the program must be valid "
"and correct both if it returns ``true`` and if it returns ``false``."
msgstr ""

#: ../../../LangRef.rst:30634
msgid "When used in a branch condition, it selects one of the two paths:"
msgstr ""

#: ../../../LangRef.rst:30636
msgid "`true``: Executes the UBSan check and reports any failures."
msgstr ""

#: ../../../LangRef.rst:30638
msgid "`false`: Bypasses the check, assuming it always succeeds."
msgstr ""

#: ../../../LangRef.rst:30658
msgid "'``llvm.allow.runtime.check``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30670
msgid ""
"This intrinsic returns ``true`` if and only if the compiler opted to enable "
"runtime checks in the current basic block."
msgstr ""

#: ../../../LangRef.rst:30673
msgid ""
"Rules to allow runtime checks are not part of the intrinsic declaration, and "
"controlled by compiler options."
msgstr ""

#: ../../../LangRef.rst:30676
msgid ""
"This intrinsic is non-ubsan specific version of ``@llvm.allow.ubsan."
"check()``."
msgstr ""

#: ../../../LangRef.rst:30681
msgid ""
"A string identifying the kind of runtime check guarded by the intrinsic. The "
"string can be used to control rules to allow checks."
msgstr ""

#: ../../../LangRef.rst:30687
msgid ""
"The intrinsic ``@llvm.allow.runtime.check()`` returns either ``true`` or "
"``false``, depending on compiler options."
msgstr ""

#: ../../../LangRef.rst:30693
msgid ""
"When used in a branch condition, it allows us to choose between two "
"alternative correct solutions for the same problem."
msgstr ""

#: ../../../LangRef.rst:30696
msgid ""
"If the intrinsic is evaluated as ``true``, program should execute a guarded "
"check. If the intrinsic is evaluated as ``false``, the program should avoid "
"any unnecessary checks."
msgstr ""

#: ../../../LangRef.rst:30715
msgid "'``llvm.load.relative``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30727
msgid ""
"This intrinsic loads a 32-bit value from the address ``%ptr + %offset``, "
"adds ``%ptr`` to that value and returns it. The constant folder specifically "
"recognizes the form of this intrinsic and the constant initializers it may "
"load from; if a loaded constant initializer is known to have the form ``i32 "
"trunc(x - %ptr)``, the intrinsic call is folded to ``x``."
msgstr ""

#: ../../../LangRef.rst:30733
msgid ""
"LLVM provides that the calculation of such a constant initializer will not "
"overflow at link time under the medium code model if ``x`` is an "
"``unnamed_addr`` function. However, it does not provide this guarantee for a "
"constant initializer folded into a function body. This intrinsic can be used "
"to avoid the possibility of overflows when loading from such a constant."
msgstr ""

#: ../../../LangRef.rst:30742
msgid "'``llvm.sideeffect``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30754
msgid ""
"The ``llvm.sideeffect`` intrinsic doesn't perform any operation. Optimizers "
"treat it as having side effects, so it can be inserted into a loop to "
"indicate that the loop shouldn't be assumed to terminate (which could "
"potentially lead to the loop being optimized away entirely), even if it's an "
"infinite loop with no other side effects."
msgstr ""

#: ../../../LangRef.rst:30768
msgid ""
"This intrinsic actually does nothing, but optimizers must assume that it has "
"externally observable side effects."
msgstr ""

#: ../../../LangRef.rst:30772
msgid "'``llvm.is.constant.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30777
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.is.constant`` with any "
"argument type."
msgstr ""

#: ../../../LangRef.rst:30788
msgid ""
"The '``llvm.is.constant``' intrinsic will return true if the argument is "
"known to be a manifest compile-time constant. It is guaranteed to fold to "
"either true or false before generating machine code."
msgstr ""

#: ../../../LangRef.rst:30795
msgid ""
"This intrinsic generates no code. If its argument is known to be a manifest "
"compile-time constant value, then the intrinsic will be converted to a "
"constant true value. Otherwise, it will be converted to a constant false "
"value."
msgstr ""

#: ../../../LangRef.rst:30800
msgid ""
"In particular, note that if the argument is a constant expression which "
"refers to a global (the address of which _is_ a constant, but not manifest "
"during the compile), then the intrinsic evaluates to false."
msgstr ""

#: ../../../LangRef.rst:30805
msgid ""
"The result also intentionally depends on the result of optimization passes "
"-- e.g., the result can change depending on whether a function gets inlined "
"or not. A function's parameters are obviously not constant. However, a call "
"like ``llvm.is.constant.i32(i32 %param)`` *can* return true after the "
"function is inlined, if the value passed to the function parameter was a "
"constant."
msgstr ""

#: ../../../LangRef.rst:30816
msgid "'``llvm.ptrmask``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30828
msgid ""
"The first argument is a pointer or vector of pointers. The second argument "
"is an integer or vector of integers with the same bit width as the index "
"type size of the first argument."
msgstr ""

#: ../../../LangRef.rst:30835
msgid ""
"The ``llvm.ptrmask`` intrinsic masks out bits of the pointer according to a "
"mask. This allows stripping data from tagged pointers without converting "
"them to an integer (ptrtoint/inttoptr). As a consequence, we can preserve "
"more information to facilitate alias analysis and underlying-object "
"detection."
msgstr ""

#: ../../../LangRef.rst:30843
msgid ""
"The result of ``ptrmask(%ptr, %mask)`` is equivalent to the following "
"expansion, where ``iPtrIdx`` is the index type size of the pointer::"
msgstr ""

#: ../../../LangRef.rst:30851
msgid ""
"If the pointer index type size is smaller than the pointer type size, this "
"implies that pointer bits beyond the index size are not affected by this "
"intrinsic. For integral pointers, it behaves as if the mask were extended "
"with 1 bits to the pointer type size."
msgstr ""

#: ../../../LangRef.rst:30856
msgid ""
"Both the returned pointer(s) and the first argument are based on the same "
"underlying object (for more information on the *based on* terminology see :"
"ref:`the pointer aliasing rules <pointeraliasing>`)."
msgstr ""

#: ../../../LangRef.rst:30860
msgid ""
"The intrinsic only captures the pointer argument through the return value."
msgstr ""

#: ../../../LangRef.rst:30865
msgid "'``llvm.threadlocal.address``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30877
msgid ""
"The `llvm.threadlocal.address` intrinsic requires a global value argument "
"(a :ref:`global variable <globalvars>` or alias) that is thread local."
msgstr ""

#: ../../../LangRef.rst:30883
msgid ""
"The address of a thread local global is not a constant, since it depends on "
"the calling thread. The `llvm.threadlocal.address` intrinsic returns the "
"address of the given thread local global in the calling thread."
msgstr ""

#: ../../../LangRef.rst:30890
msgid "'``llvm.vscale``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30903
msgid ""
"The ``llvm.vscale`` intrinsic returns the value for ``vscale`` in scalable "
"vectors such as ``<vscale x 16 x i8>``."
msgstr ""

#: ../../../LangRef.rst:30909
msgid ""
"``vscale`` is a positive value that is constant throughout program "
"execution, but is unknown at compile time. If the result value does not fit "
"in the result type, then the result is a :ref:`poison value <poisonvalues>`."
msgstr ""

#: ../../../LangRef.rst:30917
msgid "'``llvm.fake.use``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30929
msgid ""
"The ``llvm.fake.use`` intrinsic is a no-op. It takes a single value as an "
"operand and is treated as a use of that operand, to force the optimizer to "
"preserve that value prior to the fake use. This is used for extending the "
"lifetimes of variables, where this intrinsic placed at the end of a "
"variable's scope helps prevent that variable from being optimized out."
msgstr ""

#: ../../../LangRef.rst:30938
msgid ""
"The ``llvm.fake.use`` intrinsic takes one argument, which may be any "
"function-local SSA value. Note that the signature is variadic so that the "
"intrinsic can take any type of argument, but passing more than one argument "
"will result in an error."
msgstr ""

#: ../../../LangRef.rst:30946
msgid ""
"This intrinsic does nothing, but optimizers must consider it a use of its "
"single operand and should try to preserve the intrinsic and its position in "
"the function."
msgstr ""

#: ../../../LangRef.rst:30952
msgid "Stack Map Intrinsics"
msgstr ""

#: ../../../LangRef.rst:30954
msgid ""
"LLVM provides experimental intrinsics to support runtime patching mechanisms "
"commonly desired in dynamic language JITs. These intrinsics are described "
"in :doc:`StackMaps`."
msgstr ""

#: ../../../LangRef.rst:30959
msgid "Element Wise Atomic Memory Intrinsics"
msgstr ""

#: ../../../LangRef.rst:30961
msgid ""
"These intrinsics are similar to the standard library memory intrinsics "
"except that they perform memory transfer as a sequence of atomic memory "
"accesses."
msgstr ""

#: ../../../LangRef.rst:30967
msgid "'``llvm.memcpy.element.unordered.atomic``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:30972
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memcpy.element.unordered."
"atomic`` on any integer bit width and for different address spaces. Not all "
"targets support all bit widths however."
msgstr ""

#: ../../../LangRef.rst:30990
msgid ""
"The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic is a "
"specialization of the '``llvm.memcpy.*``' intrinsic. It differs in that the "
"``dest`` and ``src`` are treated as arrays with elements that are exactly "
"``element_size`` bytes, and the copy between buffers uses a sequence of :ref:"
"`unordered atomic <ordering>` load/store operations that are a positive "
"integer multiple of the ``element_size`` in size."
msgstr ""

#: ../../../LangRef.rst:30999
msgid ""
"The first three arguments are the same as they are in the :ref:`@llvm.memcpy "
"<int_memcpy>` intrinsic, with the added constraint that ``len`` is required "
"to be a positive integer multiple of the ``element_size``. If ``len`` is not "
"a positive integer multiple of ``element_size``, then the behavior of the "
"intrinsic is undefined."
msgstr ""

#: ../../../LangRef.rst:31004 ../../../LangRef.rst:31159
msgid ""
"``element_size`` must be a compile-time constant positive power of two no "
"greater than target-specific atomic access size limit."
msgstr ""

#: ../../../LangRef.rst:31007
msgid ""
"For each of the input pointers ``align`` parameter attribute must be "
"specified. It must be a power of two no less than the ``element_size``. "
"Caller guarantees that both the source and destination pointers are aligned "
"to that boundary."
msgstr ""

#: ../../../LangRef.rst:31014
msgid ""
"The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic copies ``len`` "
"bytes of memory from the source location to the destination location. These "
"locations are not allowed to overlap. The memory copy is performed as a "
"sequence of load/store operations where each access is guaranteed to be a "
"multiple of ``element_size`` bytes wide and aligned at an ``element_size`` "
"boundary."
msgstr ""

#: ../../../LangRef.rst:31020 ../../../LangRef.rst:31097
msgid ""
"The order of the copy is unspecified. The same value may be read from the "
"source buffer many times, but only one write is issued to the destination "
"buffer per element. It is well defined to have concurrent reads and writes "
"to both source and destination provided those reads and writes are unordered "
"atomic when specified."
msgstr ""

#: ../../../LangRef.rst:31025 ../../../LangRef.rst:31103
msgid ""
"This intrinsic does not provide any additional ordering guarantees over "
"those provided by a set of unordered loads from the source location and "
"stores to the destination."
msgstr ""

#: ../../../LangRef.rst:31032
msgid ""
"In the most general case call to the '``llvm.memcpy.element.unordered.atomic."
"*``' is lowered to a call to the symbol "
"``__llvm_memcpy_element_unordered_atomic_*``. Where '*' is replaced with an "
"actual element size. See :ref:`RewriteStatepointsForGC intrinsic lowering "
"<RewriteStatepointsForGC_intrinsic_lowering>` for details on GC specific "
"lowering."
msgstr ""

#: ../../../LangRef.rst:31038
msgid ""
"Optimizer is allowed to inline memory copy when it's profitable to do so."
msgstr ""

#: ../../../LangRef.rst:31041
msgid "'``llvm.memmove.element.unordered.atomic``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31046
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memmove.element."
"unordered.atomic`` on any integer bit width and for different address "
"spaces. Not all targets support all bit widths however."
msgstr ""

#: ../../../LangRef.rst:31064
msgid ""
"The '``llvm.memmove.element.unordered.atomic.*``' intrinsic is a "
"specialization of the '``llvm.memmove.*``' intrinsic. It differs in that the "
"``dest`` and ``src`` are treated as arrays with elements that are exactly "
"``element_size`` bytes, and the copy between buffers uses a sequence of :ref:"
"`unordered atomic <ordering>` load/store operations that are a positive "
"integer multiple of the ``element_size`` in size."
msgstr ""

#: ../../../LangRef.rst:31074
msgid ""
"The first three arguments are the same as they are in the :ref:`@llvm."
"memmove <int_memmove>` intrinsic, with the added constraint that ``len`` is "
"required to be a positive integer multiple of the ``element_size``. If "
"``len`` is not a positive integer multiple of ``element_size``, then the "
"behavior of the intrinsic is undefined."
msgstr ""

#: ../../../LangRef.rst:31080
msgid ""
"``element_size`` must be a compile-time constant positive power of two no "
"greater than a target-specific atomic access size limit."
msgstr ""

#: ../../../LangRef.rst:31083
msgid ""
"For each of the input pointers the ``align`` parameter attribute must be "
"specified. It must be a power of two no less than the ``element_size``. "
"Caller guarantees that both the source and destination pointers are aligned "
"to that boundary."
msgstr ""

#: ../../../LangRef.rst:31091
msgid ""
"The '``llvm.memmove.element.unordered.atomic.*``' intrinsic copies ``len`` "
"bytes of memory from the source location to the destination location. These "
"locations are allowed to overlap. The memory copy is performed as a sequence "
"of load/store operations where each access is guaranteed to be a multiple of "
"``element_size`` bytes wide and aligned at an ``element_size`` boundary."
msgstr ""

#: ../../../LangRef.rst:31110
msgid ""
"In the most general case call to the '``llvm.memmove.element.unordered."
"atomic.*``' is lowered to a call to the symbol "
"``__llvm_memmove_element_unordered_atomic_*``. Where '*' is replaced with an "
"actual element size. See :ref:`RewriteStatepointsForGC intrinsic lowering "
"<RewriteStatepointsForGC_intrinsic_lowering>` for details on GC specific "
"lowering."
msgstr ""

#: ../../../LangRef.rst:31117
msgid ""
"The optimizer is allowed to inline the memory copy when it's profitable to "
"do so."
msgstr ""

#: ../../../LangRef.rst:31122
msgid "'``llvm.memset.element.unordered.atomic``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31127
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memset.element.unordered."
"atomic`` on any integer bit width and for different address spaces. Not all "
"targets support all bit widths however."
msgstr ""

#: ../../../LangRef.rst:31145
msgid ""
"The '``llvm.memset.element.unordered.atomic.*``' intrinsic is a "
"specialization of the '``llvm.memset.*``' intrinsic. It differs in that the "
"``dest`` is treated as an array with elements that are exactly "
"``element_size`` bytes, and the assignment to that array uses uses a "
"sequence of :ref:`unordered atomic <ordering>` store operations that are a "
"positive integer multiple of the ``element_size`` in size."
msgstr ""

#: ../../../LangRef.rst:31154
msgid ""
"The first three arguments are the same as they are in the :ref:`@llvm.memset "
"<int_memset>` intrinsic, with the added constraint that ``len`` is required "
"to be a positive integer multiple of the ``element_size``. If ``len`` is not "
"a positive integer multiple of ``element_size``, then the behavior of the "
"intrinsic is undefined."
msgstr ""

#: ../../../LangRef.rst:31162
msgid ""
"The ``dest`` input pointer must have the ``align`` parameter attribute "
"specified. It must be a power of two no less than the ``element_size``. "
"Caller guarantees that the destination pointer is aligned to that boundary."
msgstr ""

#: ../../../LangRef.rst:31169
msgid ""
"The '``llvm.memset.element.unordered.atomic.*``' intrinsic sets the ``len`` "
"bytes of memory starting at the destination location to the given ``value``. "
"The memory is set with a sequence of store operations where each access is "
"guaranteed to be a multiple of ``element_size`` bytes wide and aligned at an "
"``element_size`` boundary."
msgstr ""

#: ../../../LangRef.rst:31174
msgid ""
"The order of the assignment is unspecified. Only one write is issued to the "
"destination buffer per element. It is well defined to have concurrent reads "
"and writes to the destination provided those reads and writes are unordered "
"atomic when specified."
msgstr ""

#: ../../../LangRef.rst:31179
msgid ""
"This intrinsic does not provide any additional ordering guarantees over "
"those provided by a set of unordered stores to the destination."
msgstr ""

#: ../../../LangRef.rst:31185
msgid ""
"In the most general case call to the '``llvm.memset.element.unordered.atomic."
"*``' is lowered to a call to the symbol "
"``__llvm_memset_element_unordered_atomic_*``. Where '*' is replaced with an "
"actual element size."
msgstr ""

#: ../../../LangRef.rst:31189
msgid ""
"The optimizer is allowed to inline the memory assignment when it's "
"profitable to do so."
msgstr ""

#: ../../../LangRef.rst:31192
msgid "Objective-C ARC Runtime Intrinsics"
msgstr ""

#: ../../../LangRef.rst:31194
msgid ""
"LLVM provides intrinsics that lower to Objective-C ARC runtime entry points. "
"LLVM is aware of the semantics of these functions, and optimizes based on "
"that knowledge. You can read more about the details of Objective-C ARC `here "
"<https://clang.llvm.org/docs/AutomaticReferenceCounting.html>`_."
msgstr ""

#: ../../../LangRef.rst:31200
msgid "'``llvm.objc.autorelease``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31211
msgid ""
"Lowers to a call to `objc_autorelease <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-autorelease>`_."
msgstr ""

#: ../../../LangRef.rst:31214
msgid "'``llvm.objc.autoreleasePoolPop``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31225
msgid ""
"Lowers to a call to `objc_autoreleasePoolPop <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#void-objc-autoreleasepoolpop-void-pool>`_."
msgstr ""

#: ../../../LangRef.rst:31228
msgid "'``llvm.objc.autoreleasePoolPush``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31239
msgid ""
"Lowers to a call to `objc_autoreleasePoolPush <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#void-objc-autoreleasepoolpush-void>`_."
msgstr ""

#: ../../../LangRef.rst:31242
msgid "'``llvm.objc.autoreleaseReturnValue``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31253
msgid ""
"Lowers to a call to `objc_autoreleaseReturnValue <https://clang.llvm.org/"
"docs/AutomaticReferenceCounting.html#arc-runtime-objc-"
"autoreleasereturnvalue>`_."
msgstr ""

#: ../../../LangRef.rst:31256
msgid "'``llvm.objc.copyWeak``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31267
msgid ""
"Lowers to a call to `objc_copyWeak <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#void-objc-copyweak-id-dest-id-src>`_."
msgstr ""

#: ../../../LangRef.rst:31270
msgid "'``llvm.objc.destroyWeak``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31281
msgid ""
"Lowers to a call to `objc_destroyWeak <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#void-objc-destroyweak-id-object>`_."
msgstr ""

#: ../../../LangRef.rst:31284
msgid "'``llvm.objc.initWeak``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31295
msgid ""
"Lowers to a call to `objc_initWeak <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-initweak>`_."
msgstr ""

#: ../../../LangRef.rst:31298
msgid "'``llvm.objc.loadWeak``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31309
msgid ""
"Lowers to a call to `objc_loadWeak <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-loadweak>`_."
msgstr ""

#: ../../../LangRef.rst:31312
msgid "'``llvm.objc.loadWeakRetained``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31323
msgid ""
"Lowers to a call to `objc_loadWeakRetained <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-loadweakretained>`_."
msgstr ""

#: ../../../LangRef.rst:31326
msgid "'``llvm.objc.moveWeak``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31337
msgid ""
"Lowers to a call to `objc_moveWeak <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#void-objc-moveweak-id-dest-id-src>`_."
msgstr ""

#: ../../../LangRef.rst:31340
msgid "'``llvm.objc.release``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31351
msgid ""
"Lowers to a call to `objc_release <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#void-objc-release-id-value>`_."
msgstr ""

#: ../../../LangRef.rst:31354
msgid "'``llvm.objc.retain``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31365
msgid ""
"Lowers to a call to `objc_retain <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-retain>`_."
msgstr ""

#: ../../../LangRef.rst:31368
msgid "'``llvm.objc.retainAutorelease``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31379
msgid ""
"Lowers to a call to `objc_retainAutorelease <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-retainautorelease>`_."
msgstr ""

#: ../../../LangRef.rst:31382
msgid "'``llvm.objc.retainAutoreleaseReturnValue``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31393
msgid ""
"Lowers to a call to `objc_retainAutoreleaseReturnValue <https://clang.llvm."
"org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-"
"retainautoreleasereturnvalue>`_."
msgstr ""

#: ../../../LangRef.rst:31396
msgid "'``llvm.objc.retainAutoreleasedReturnValue``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31407
msgid ""
"Lowers to a call to `objc_retainAutoreleasedReturnValue <https://clang.llvm."
"org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-"
"retainautoreleasedreturnvalue>`_."
msgstr ""

#: ../../../LangRef.rst:31410
msgid "'``llvm.objc.retainBlock``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31421
msgid ""
"Lowers to a call to `objc_retainBlock <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-retainblock>`_."
msgstr ""

#: ../../../LangRef.rst:31424
msgid "'``llvm.objc.storeStrong``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31435
msgid ""
"Lowers to a call to `objc_storeStrong <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#void-objc-storestrong-id-object-id-value>`_."
msgstr ""

#: ../../../LangRef.rst:31438
msgid "'``llvm.objc.storeWeak``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31449
msgid ""
"Lowers to a call to `objc_storeWeak <https://clang.llvm.org/docs/"
"AutomaticReferenceCounting.html#arc-runtime-objc-storeweak>`_."
msgstr ""

#: ../../../LangRef.rst:31452
msgid "Preserving Debug Information Intrinsics"
msgstr ""

#: ../../../LangRef.rst:31454
msgid ""
"These intrinsics are used to carry certain debuginfo together with IR-level "
"operations. For example, it may be desirable to know the structure/union "
"name and the original user-level field indices. Such information got lost in "
"IR GetElementPtr instruction since the IR types are different from debugInfo "
"types and unions are converted to structs in IR."
msgstr ""

#: ../../../LangRef.rst:31462
msgid "'``llvm.preserve.array.access.index``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31476
msgid ""
"The '``llvm.preserve.array.access.index``' intrinsic returns the "
"getelementptr address based on array base ``base``, array dimension ``dim`` "
"and the last access index ``index`` into the array. The return type "
"``ret_type`` is a pointer type to the array element. The array ``dim`` and "
"``index`` are preserved which is more robust than getelementptr instruction "
"which may be subject to compiler transformation. The ``llvm.preserve.access."
"index`` type of metadata is attached to this call instruction to provide "
"array or pointer debuginfo type. The metadata is a ``DICompositeType`` or "
"``DIDerivedType`` representing the debuginfo version of ``type``."
msgstr ""

#: ../../../LangRef.rst:31489
msgid ""
"The ``base`` is the array base address.  The ``dim`` is the array dimension. "
"The ``base`` is a pointer if ``dim`` equals 0. The ``index`` is the last "
"access index into the array or pointer."
msgstr ""

#: ../../../LangRef.rst:31493 ../../../LangRef.rst:31562
msgid ""
"The ``base`` argument must be annotated with an :ref:`elementtype "
"<attr_elementtype>` attribute at the call-site. This attribute specifies the "
"getelementptr element type."
msgstr ""

#: ../../../LangRef.rst:31500
msgid ""
"The '``llvm.preserve.array.access.index``' intrinsic produces the same "
"result as a getelementptr with base ``base`` and access operands ``{dim's "
"0's, index}``."
msgstr ""

#: ../../../LangRef.rst:31504
msgid "'``llvm.preserve.union.access.index``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31517
msgid ""
"The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo "
"field index ``di_index`` and returns the ``base`` address. The ``llvm."
"preserve.access.index`` type of metadata is attached to this call "
"instruction to provide union debuginfo type. The metadata is a "
"``DICompositeType`` representing the debuginfo version of ``type``. The "
"return type ``type`` is the same as the ``base`` type."
msgstr ""

#: ../../../LangRef.rst:31527
msgid ""
"The ``base`` is the union base address. The ``di_index`` is the field index "
"in debuginfo."
msgstr ""

#: ../../../LangRef.rst:31532
msgid ""
"The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` "
"address."
msgstr ""

#: ../../../LangRef.rst:31535
msgid "'``llvm.preserve.struct.access.index``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:31549
msgid ""
"The '``llvm.preserve.struct.access.index``' intrinsic returns the "
"getelementptr address based on struct base ``base`` and IR struct member "
"index ``gep_index``. The ``llvm.preserve.access.index`` type of metadata is "
"attached to this call instruction to provide struct debuginfo type. The "
"metadata is a ``DICompositeType`` representing the debuginfo version of "
"``type``. The return type ``ret_type`` is a pointer type to the structure "
"member."
msgstr ""

#: ../../../LangRef.rst:31559
msgid ""
"The ``base`` is the structure base address. The ``gep_index`` is the struct "
"member index based on IR structures. The ``di_index`` is the struct member "
"index based on debuginfo."
msgstr ""

#: ../../../LangRef.rst:31569
msgid ""
"The '``llvm.preserve.struct.access.index``' intrinsic produces the same "
"result as a getelementptr with base ``base`` and access operands ``{0, "
"gep_index}``."
msgstr ""
