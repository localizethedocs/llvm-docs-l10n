# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ConvergentOperations.rst:3
msgid "Convergent Operation Semantics"
msgstr ""

#: ../../../ConvergentOperations.rst:10
msgid "Overview"
msgstr ""

#: ../../../ConvergentOperations.rst:12
msgid ""
"Some parallel execution environments execute threads in groups that allow "
"efficient communication within the group using special primitives called "
"*convergent* operations. The outcome of a convergent operation is sensitive "
"to the set of threads that executes it \"together\", i.e., convergently. "
"When control flow :ref:`diverges <convergence-and-uniformity>`, i.e., "
"threads of the same group follow different paths through the CFG, not all "
"threads of the group may be available to participate in this communication. "
"This is the defining characteristic that distinguishes convergent operations "
"from other inter-thread communication:"
msgstr ""

#: ../../../ConvergentOperations.rst:22
msgid ""
"A convergent operation involves inter-thread communication or "
"synchronization that occurs outside of the memory model, where the set of "
"threads which participate in communication is implicitly affected by control "
"flow."
msgstr ""

#: ../../../ConvergentOperations.rst:26
msgid ""
"For example, in the following GPU compute kernel, communication during the "
"convergent operation is expected to occur precisely among those threads of "
"an implementation-defined execution scope (such as workgroup or subgroup) "
"for which ``condition`` is true:"
msgstr ""

#: ../../../ConvergentOperations.rst:40
msgid ""
"In structured programming languages, there is often an intuitive and "
"unambiguous way of determining the threads that are expected to communicate. "
"However, this is not always the case even in structured programming "
"languages, and the intuition breaks down entirely in unstructured control "
"flow. This document describes the formal semantics in LLVM, i.e., how to "
"determine the set of communicating threads for convergent operations."
msgstr ""

#: ../../../ConvergentOperations.rst:47
msgid ""
"The definitions in this document leave many details open, such as how groups "
"of threads are formed in the first place. It focuses on the questions that "
"are relevant for deciding the correctness of generic program transforms and "
"convergence-related analyses such as :ref:`uniformity analysis <convergence-"
"and-uniformity>`."
msgstr ""

#: ../../../ConvergentOperations.rst:56
msgid "Convergent Operations"
msgstr ""

#: ../../../ConvergentOperations.rst:58
msgid ""
"In LLVM IR, the only way to communicate between threads as described above "
"is by calling target-defined convergent intrinsics. Hence, only a call-site "
"in LLVM IR (a :ref:`call <i_call>`, :ref:`invoke <i_invoke>`, or :ref:"
"`callbr <i_callbr>` instruction) can result in a convergent operation."
msgstr ""

#: ../../../ConvergentOperations.rst:64
msgid ""
"A function in LLVM IR is said to be *convergent* if it has the :ref:"
"`convergent <attr_convergent>` attribute."
msgstr ""

#: ../../../ConvergentOperations.rst:67
msgid ""
"A call-site in LLVM IR is said to be *convergent* if it is a direct call to "
"a convergent function or it has the :ref:`convergent <attr_convergent>` "
"attribute or a :ref:`convergencectrl operand bundle <convergencectrl>`."
msgstr ""

#: ../../../ConvergentOperations.rst:72
msgid "Informational notes:"
msgstr ""

#: ../../../ConvergentOperations.rst:74
msgid ""
"A function may have to be treated as convergent if that function, or "
"transitively, any function called from it, contains a convergent call-site. "
"A frontend generating the ``convergent`` attribute should take this into "
"account when emitting functions and function calls. But this is not always "
"the case:"
msgstr ""

#: ../../../ConvergentOperations.rst:79
msgid ""
"A non-convergent function may contain convergent operations; such operations "
"do not directly depend on the set of threads that enter the function as a "
"single communicating group. Instead, these operations depend on an "
"implementation-defined subset of threads within the body of the function, as "
"shown in :ref:`opportunistic_convergence`."
msgstr ""

#: ../../../ConvergentOperations.rst:86
msgid "Examples of Convergent Operations"
msgstr ""

#: ../../../ConvergentOperations.rst:88 ../../../ConvergentOperations.rst:234
#: ../../../ConvergentOperations.rst:982 ../../../ConvergentOperations.rst:1230
msgid "(This section is informative.)"
msgstr ""

#: ../../../ConvergentOperations.rst:91
msgid "Texture sampling in a pixel shader"
msgstr ""

#: ../../../ConvergentOperations.rst:93
msgid ""
"The following stylized pixel shader samples a texture at a given set of "
"coordinates, using the builtin function `textureSample`. Texture sampling "
"requires screen-space derivatives of the coordinates to determine the level "
"of detail (mipmap level) of the sample. They are commonly approximated by "
"taking the difference between neighboring pixels, which are computed by "
"different threads in the same group:"
msgstr ""

#: ../../../ConvergentOperations.rst:111
msgid ""
"From a purely single-threaded perspective, sinking the `textureSample` into "
"the if-statement appears legal. However, if the condition is false for some "
"neighboring pixels, then their corresponding threads will not execute "
"together in the group, making it impossible to take the difference of "
"coordinates as an approximation of the screen-space derivative. In practice, "
"the outcome will be an undefined value."
msgstr ""

#: ../../../ConvergentOperations.rst:118
msgid ""
"That is, the `textureSample` operation fits our definition of a convergent "
"operation:"
msgstr ""

#: ../../../ConvergentOperations.rst:121
msgid ""
"It communicates with a set of threads that implicitly depends on control "
"flow."
msgstr ""

#: ../../../ConvergentOperations.rst:123
msgid "Correctness depends on this set of threads."
msgstr ""

#: ../../../ConvergentOperations.rst:125 ../../../ConvergentOperations.rst:190
msgid ""
"The compiler frontend can emit IR that expresses the convergence constraints "
"as follows:"
msgstr ""

#: ../../../ConvergentOperations.rst:144
msgid ""
"The :ref:`llvm.experimental.convergence.entry <llvm.experimental.convergence."
"entry>` intrinsic is itself ``convergent``, and we expect it to communicate "
"at least among all threads of the same \"quad\" -- a group of 2x2 pixels "
"that are evaluated together for the purpose of approximating screen-space "
"derivatives. This fact is not part of the generic LLVM IR semantics; it "
"would have to be defined somewhere else, for example as part of target-"
"specific ABI definitions and/or in reference to some relevant API specs."
msgstr ""

#: ../../../ConvergentOperations.rst:152
msgid ""
"Since the ``@textureSample`` call then uses the token produced by the entry "
"intrinsic in its ``convergencectrl`` bundle, and has no additional control "
"dependencies, it must communicate among the same set of threads. This "
"indicates to generic program transforms that sinking the ``@textureSample`` "
"call is forbidden. (A program transform can still sink the call if it can "
"prove somehow, e.g. by leaning on target-specific callbacks that can analyze "
"the program with additional knowledge, that ``%condition`` is always uniform "
"across the threads referenced by the *convergence token* ``%entry``.)"
msgstr ""

#: ../../../ConvergentOperations.rst:164
msgid "Reductions inside divergent control flow"
msgstr ""

#: ../../../ConvergentOperations.rst:166
msgid ""
"The following example shows that merging common code of branches can be "
"incorrect in the face of convergent operations:"
msgstr ""

#: ../../../ConvergentOperations.rst:182
msgid ""
"The ``subgroupAdd`` computing the ``total_gains`` will be executed by the "
"subset of threads with positive ``delta`` in a subgroup (wave), and so will "
"sum up all the ``delta`` values of those threads; and similarly for the "
"``subgroupAdd`` that computes the ``total_losses``."
msgstr ""

#: ../../../ConvergentOperations.rst:187
msgid ""
"If we were to hoist and merge the ``subgroupAdd`` above the if-statement, it "
"would sum up the ``delta`` across *all* threads instead."
msgstr ""

#: ../../../ConvergentOperations.rst:215
msgid ""
"The entry intrinsic behaves like in the previous example: assuming that "
"``@example_kernel`` is an OpenCL kernel (as hinted at by the \"subgroup\" "
"terminology), we expect it to communicate among all threads within the "
"\"subgroup\". This typically maps to a SIMD vector on GPU hardware."
msgstr ""

#: ../../../ConvergentOperations.rst:220
msgid ""
"The calls to ``@subgroupAdd`` use the token produced by the entry intrinsic, "
"but they also have an additional control dependency. According to the rules "
"defined in this document, they only communicate among the subset of threads "
"that actually end up executing the respective (static) call site."
msgstr ""

#: ../../../ConvergentOperations.rst:225
msgid ""
"Hoisting them would remove the control dependency and cause them to "
"communicate among the full set of threads that the entry intrinsic "
"communicated with. Again, hoisting is allowed if it can be proven that "
"``%cc`` is always uniform among the relevant set of threads: in that case, "
"the ``@subgroupAdd`` already communicates among the full set of threads in "
"the original program."
msgstr ""

#: ../../../ConvergentOperations.rst:232
msgid "Motivating Examples of Convergence Control"
msgstr ""

#: ../../../ConvergentOperations.rst:237
msgid "Unstructured control flow"
msgstr ""

#: ../../../ConvergentOperations.rst:239
msgid ""
"Consider an example of how jump threading removes structure in a way that "
"can make semantics non-obvious without the convergence intrinsics described "
"in this document:"
msgstr ""

#: ../../../ConvergentOperations.rst:287
msgid ""
"Is the control barrier guaranteed to synchronize among the same set of "
"threads in both cases? Different implementations in the literature may give "
"different answers to this question:"
msgstr ""

#: ../../../ConvergentOperations.rst:291
msgid ""
"In an implementation that reconverges at post-dominators, threads reconverge "
"at ``mid`` in the first version, so that all threads (within a subgroup/"
"wave) that execute the control barrier do so together. In the second "
"version, threads that reach the control barrier via different paths "
"synchronize separately: the first (and only) post-dominator is ``end``, so "
"threads do not reconverge before then."
msgstr ""

#: ../../../ConvergentOperations.rst:298
msgid ""
"An implementation that sorts basic blocks topologically and ensures maximal "
"reconvergence for each basic block would behave the same way in both "
"versions."
msgstr ""

#: ../../../ConvergentOperations.rst:302
msgid ""
"We generally take the stance that reconvergence in acyclic control flow must "
"be maximal. The compiler frontend could augment the original code as follows:"
msgstr ""

#: ../../../ConvergentOperations.rst:331
msgid ""
"If S is the set of threads that the entry intrinsic communicated with, then "
"the ``@subgroupControlBarrier`` call communicates with the subset of S that "
"actually reaches the call site. This set of threads doesn't change after "
"jump-threading, so the answer to the question posed above remains the same."
msgstr ""

#: ../../../ConvergentOperations.rst:339
msgid "Opportunistic convergent operations"
msgstr ""

#: ../../../ConvergentOperations.rst:341
msgid ""
"Some programs have local regions of code that contain a sequence of "
"convergent operations where the code does not care about the exact set of "
"threads with which it is executed, but only that the set of threads is the "
"same for all the operations within the sequence. (If a subset of the "
"convergent operations in the sequence have additional, non-uniform control "
"dependencies, then this is not possible. However, the code may still require "
"that the sets of threads are logically consistent with the conditions of "
"those control dependencies.) In this case, :ref:`llvm.experimental."
"convergence.anchor <llvm.experimental.convergence.anchor>` can be used to "
"express the desired semantics."
msgstr ""

#: ../../../ConvergentOperations.rst:352
msgid ""
"The following example function could be part of a hypothetical \"append "
"buffer\" implementation, where threads conditionally write fixed-sized "
"records contiguously into a global buffer. The function "
"``@reserveSpaceInBuffer`` returns the index into the buffer at which the "
"calling thread should store its data."
msgstr ""

#: ../../../ConvergentOperations.rst:358
msgid ""
"This could be achieved by using a simple atomic operation in every thread to "
"bump an allocation counter."
msgstr ""

#: ../../../ConvergentOperations.rst:361
msgid ""
"However, the following implementation can be more performant on some "
"hardware, because it uses only a single atomic operation for an entire group "
"of threads. To do this, it first determines the total size of the group, "
"which will be the operand to the atomic operation, and then later broadcasts "
"the result of the atomic operation to all threads of the group, so that each "
"thread can compute its individual position in the buffer:"
msgstr ""

#: ../../../ConvergentOperations.rst:401
msgid ""
"The key here is that the function really doesn't care which set of threads "
"it is being called with. It takes whatever set of threads it can get. What "
"the implementation of the function cares about is that the initial "
"``@subgroupBallot`` -- which is used to retrieve the bitmask of threads that "
"executed the anchor together -- executes with the same set of threads as the "
"final ``@subgroupBroadcastFirst``. Nothing else is required for correctness "
"as far as convergence is concerned."
msgstr ""

#: ../../../ConvergentOperations.rst:409
msgid ""
"The function ``@reserveSpaceInBuffer`` itself is _not_ ``convergent``: "
"callers are free to move call sites of the function as they see fit. This "
"can change the behavior in practice, by changing the sets of threads that "
"are grouped together for the atomic operation. This can be visible in the "
"output of the program, since the order in which outputs appear in the buffer "
"is changed. However, this does not break the overall contract that "
"``@reserveSpaceInBuffer`` has with its caller -- which makes sense: the "
"order of outputs is non-deterministic anyway because of the atomic operation "
"that is involved."
msgstr ""

#: ../../../ConvergentOperations.rst:418
msgid ""
"If the function is inlined, the use of the anchor intrinsic similarly "
"indicates that certain transforms which are usually forbidden by the "
"presence of convergent operations are in fact allowed, as long as they don't "
"break up the region of code that is controlled by the anchor."
msgstr ""

#: ../../../ConvergentOperations.rst:426
msgid "Extended Cycles: Divergent Exit from a Loop"
msgstr ""

#: ../../../ConvergentOperations.rst:428
msgid ""
"High-level languages typically provide a ``break`` statement that transfers "
"control out of a loop statement. In most cases, the loop is structured and "
"hence there is no ambiguity about convergence inside the loop. But an "
"ambiguity arises when a ``break`` is control dependent on a divergent "
"condition inside the loop. Consider the following example:"
msgstr ""

#: ../../../ConvergentOperations.rst:452
msgid ""
"In this program, the call to ``convergent_op()`` is lexically \"inside\" the "
"``for`` loop. But when translated to LLVM IR, the basic block B is an "
"exiting block ending in a divergent branch, and the basic block C is an exit "
"of the loop. Thus, the call to ``convergent_op()`` is outside the loop. This "
"causes a mismatch between the programmer's expectation and the compiled "
"program. The call should be executed convergently on every iteration of the "
"loop, by threads that together take the branch to exit the loop. But when "
"compiled, all threads that take the divergent exit on different iterations "
"first converge at the beginning of basic block C and then together execute "
"the call to ``convergent_op()``."
msgstr ""

#: ../../../ConvergentOperations.rst:462
msgid ""
"In this case, :ref:`llvm.experimental.convergence.loop <llvm.experimental."
"convergence.loop>` can be used to express the desired semantics. A call to "
"this intrinsic is placed in the loop header, which tracks each iteration of "
"the loop. The token produced by this is used as a ``convergencectrl`` "
"operand to the convergent call. The semantics of the ``loop`` intrinsic "
"ensures that the convergent call is performed convergently only by those "
"threads that convergently exited the loop in a given iteration."
msgstr ""

#: ../../../ConvergentOperations.rst:499
msgid ""
"The LLVM IR version of the same program shows a cycle consisting of the "
"basic blocks ``%for``, ``%B`` and ``%D``, while ``%C`` is an exit reached by "
"the divergent branch at the end of the exiting block ``%B``. But the use of "
"convergence control tokens makes it clear that block ``%C`` must be executed "
"convergently only by those threads that convergently take the exit edge from "
"%B to ``%C``. In other words, the convergent execution of ``%C`` is governed "
"by the call to the :ref:`llvm.experimental.convergence.loop <llvm."
"experimental.convergence.loop>` intrinsic inside the cycle. The cycle is "
"effectively extended to include all uses of this token that lie outside the "
"cycle."
msgstr ""

#: ../../../ConvergentOperations.rst:513
msgid "Dynamic Instances and Convergence Tokens"
msgstr ""

#: ../../../ConvergentOperations.rst:515
msgid ""
"Every execution of an LLVM IR instruction occurs in a :ref:`dynamic instance "
"<convergence-dynamic-instances>` of the instruction. Dynamic instances are "
"the formal objects by which we talk about communicating threads in "
"convergent operations. Dynamic instances are defined for *all* operations in "
"an LLVM program, whether convergent or not. Convergence control is primarily "
"about the dynamic instances of convergent operations since they affect "
"execution of the program through inter-thread communication. The dynamic "
"instances for non-convergent operations are relevant for determining :ref:"
"`uniformity <convergence-and-uniformity>` of values."
msgstr ""

#: ../../../ConvergentOperations.rst:525
msgid ""
"Dynamic instances produced by the execution of the same *convergent "
"operation* by different threads may be :ref:`converged <convergence-"
"definition>`. When executing a convergent operation, the set of threads that "
"execute converged dynamic instances is the set of threads that communicate "
"with each other. *Convergence tokens* capture this convergence as described "
"below."
msgstr ""

#: ../../../ConvergentOperations.rst:531
msgid ""
"*Convergence tokens* are values of ``token`` type, i.e. they cannot be used "
"in ``phi`` or ``select`` instructions. A convergence token value represents "
"the dynamic instance of the instruction that produced it."
msgstr ""

#: ../../../ConvergentOperations.rst:535
msgid ""
"Convergent operations may have an optional ``convergencectrl`` operand "
"bundle with a convergence token operand to define the set of communicating "
"threads relative to the operation that defined the token."
msgstr ""

#: ../../../ConvergentOperations.rst:539
msgid ""
"Let ``U`` be a convergent operation other than a call to a convergence "
"control intrinsic, and ``D`` be the convergent operation that defines the "
"token value used as the ``convergencectrl`` operand to ``U``. Two threads "
"execute converged dynamic instances of ``U`` if and only if the token value "
"in both threads was returned by converged dynamic instances of ``D``."
msgstr ""

#: ../../../ConvergentOperations.rst:548
msgid ""
"The text defines convergence token values as representing dynamic instances. "
"But if we were to assume that converged dynamic instances produce the same "
"token value, then we could almost think of the token value as representing a "
"set of threads instead -- specifically, the set ``S`` of threads that "
"executed converged dynamic instances of the defining instruction ``D``."
msgstr ""

#: ../../../ConvergentOperations.rst:554
msgid ""
"In this intuitive picture, when a convergence token value ``T`` is used by a "
"``convergencectrl`` bundle on an instruction ``I``, then the set of threads "
"that communicates in ``I`` is a subset of the set ``S`` represented by the "
"token value. Specifically, it is the subset of threads that ends up "
"executing ``I`` while using the token value."
msgstr ""

#: ../../../ConvergentOperations.rst:560
msgid ""
"This by itself wouldn't quite work as a definition: what if ``I`` is "
"executed multiple times by the same threads? Which execution of ``I`` in "
"thread 1 communicates with which execution of ``I`` in thread 2? Leaning on "
"the notion of dynamic instances gives a robust answer to this question as "
"long as ``D`` and ``I`` are at the same loop (or cycle) nesting level."
msgstr ""

#: ../../../ConvergentOperations.rst:566
msgid ""
"The case where ``D`` and ``I`` are at different loop nesting levels is "
"forbidden by the :ref:`static rules <convergence_static_rules>` -- handling "
"that case is the purpose of :ref:`llvm.experimental.convergence.loop <llvm."
"experimental.convergence.loop>`."
msgstr ""

#: ../../../ConvergentOperations.rst:574
msgid "Convergence Control Intrinsics"
msgstr ""

#: ../../../ConvergentOperations.rst:576
msgid ""
"This section describes target-independent intrinsics that can be used to "
"produce convergence tokens."
msgstr ""

#: ../../../ConvergentOperations.rst:579
msgid ""
"Behaviour is undefined if a convergence control intrinsic is called "
"indirectly."
msgstr ""

#: ../../../ConvergentOperations.rst:585
msgid "``llvm.experimental.convergence.entry``"
msgstr ""

#: ../../../ConvergentOperations.rst:591
msgid ""
"This intrinsic is used to tie the dynamic instances inside a function to "
"those in the caller."
msgstr ""

#: ../../../ConvergentOperations.rst:594
msgid ""
"If the function is called from outside the scope of LLVM, the convergence of "
"dynamic instances of this intrinsic is environment-defined. For example:"
msgstr ""

#: ../../../ConvergentOperations.rst:597
msgid ""
"In an OpenCL *kernel launch*, the maximal set of threads that can "
"communicate outside the memory model is a *workgroup*. Hence, a suitable "
"choice is to specify that all the threads from a single workgroup in OpenCL "
"execute converged dynamic instances of this intrinsic."
msgstr ""

#: ../../../ConvergentOperations.rst:602
msgid ""
"In a C/C++ program, threads are launched independently and can communicate "
"only through the memory model. Hence the dynamic instances of this intrinsic "
"in a C/C++ program are never converged."
msgstr ""

#: ../../../ConvergentOperations.rst:605
msgid ""
"If the function is called from a call-site in LLVM IR, then two threads "
"execute converged dynamic instances of this intrinsic if and only if both "
"threads entered the function by executing converged dynamic instances of the "
"call-site."
msgstr ""

#: ../../../ConvergentOperations.rst:610
msgid ""
"This intrinsic can occur at most once in a function, and only in the entry "
"block of the function. If this intrinsic occurs in a basic block, then it "
"must precede any other convergent operation in the same basic block."
msgstr ""

#: ../../../ConvergentOperations.rst:614
msgid "It is an error if this intrinsic appears in a non-convergent function."
msgstr ""

#: ../../../ConvergentOperations.rst:616
msgid ""
"It is an error to specify a ``convergencectrl`` operand bundle at a call to "
"this intrinsic."
msgstr ""

#: ../../../ConvergentOperations.rst:619
msgid ""
"Function inlining substitutes this intrinsic with the token from the operand "
"bundle. For example:"
msgstr ""

#: ../../../ConvergentOperations.rst:652
msgid "``llvm.experimental.convergence.loop``"
msgstr ""

#: ../../../ConvergentOperations.rst:658
msgid ""
"This intrinsic represents the place where an imaginary counter is "
"incremented for determining convergence inside a control flow cycle."
msgstr ""

#: ../../../ConvergentOperations.rst:661
msgid ""
"Let ``U`` be a call to this intrinsic and ``D`` be the convergent operation "
"that defines the token value used as the ``convergencectrl`` operand to "
"``U``. Two threads execute converged dynamic instances of ``U`` if and only "
"if:"
msgstr ""

#: ../../../ConvergentOperations.rst:665
msgid ""
"The token value in both threads was returned by converged dynamic instances "
"of ``D``, and,"
msgstr ""

#: ../../../ConvergentOperations.rst:667
msgid ""
"There is an integer *n* such that both threads execute ``U`` for the *n*'th "
"time with that token value."
msgstr ""

#: ../../../ConvergentOperations.rst:670
msgid ""
"It is an error to omit the ``convergencectrl`` operand bundle on a call to "
"this intrinsic."
msgstr ""

#: ../../../ConvergentOperations.rst:673
msgid ""
"If this intrinsic occurs in a basic block, then it must precede any other "
"convergent operation in the same basic block."
msgstr ""

#: ../../../ConvergentOperations.rst:678
msgid "**Heart of a Cycle:**"
msgstr ""

#: ../../../ConvergentOperations.rst:680
msgid ""
"If a :ref:`cycle <cycle-terminology>` ``C`` contains an occurrence ``H`` of "
"this intrinsic whose token operand is defined outside ``C``, then ``H`` is "
"called the heart of ``C``."
msgstr ""

#: ../../../ConvergentOperations.rst:686
msgid ""
"The static rules for cycles imply that a heart can occur only in the header "
"of a natural loop. This ensures that the heart closely represents the "
"intuitive notion of a loop iteration. If this restriction is relaxed, the "
"resulting semantics provides a new notion of \"cycle iteration\" even for "
"irreducible cycles. But this allows a natural loop to have a heart in a node "
"other than its header, which has interesting consequences on the meaning of "
"a loop iteration in terms of convergence. For now, we disallow this "
"situation since its practical application is very rare."
msgstr ""

#: ../../../ConvergentOperations.rst:698
msgid "``llvm.experimental.convergence.anchor``"
msgstr ""

#: ../../../ConvergentOperations.rst:704
msgid ""
"This intrinsic produces an initial convergence token that is independent of "
"any \"outer scope\". The set of threads executing converged dynamic "
"instances of this intrinsic is implementation-defined."
msgstr ""

#: ../../../ConvergentOperations.rst:708
msgid ""
"It is an error to pass a ``convergencectrl`` operand bundle at a call to "
"this intrinsic."
msgstr ""

#: ../../../ConvergentOperations.rst:713
msgid ""
"The expectation is that all threads within a group that \"happen to be "
"active at the same time\" will execute converged dynamic instances, so that "
"programs can detect the maximal set of threads that can communicate "
"efficiently within some local region of the program."
msgstr ""

#: ../../../ConvergentOperations.rst:721
msgid "Uncontrolled Convergent Operations"
msgstr ""

#: ../../../ConvergentOperations.rst:723
msgid ""
"Convergent operations with an explicit ``convergencectrl`` operand bundle "
"are called *controlled convergent operations*. All other convergent "
"operations are said to be *uncontrolled*."
msgstr ""

#: ../../../ConvergentOperations.rst:727
msgid ""
"An uncontrolled convergent operation is said to have *implicit convergence "
"control* determined by the ``convergent`` attribute alone. The semantics of "
"the ``convergent`` attribute as implemented in LLVM differs from the "
"documented semantics. The implementation tries to follow common intuition "
"about convergent operations, which remains under-specified. As such, it is "
"not possible to fully translate implicit convergence control into explicit "
"convergence control tokens, and these two modes cannot be mixed in the same "
"function."
msgstr ""

#: ../../../ConvergentOperations.rst:735
msgid ""
"If a function contains a controlled convergent operation, then all "
"convergent operations in that function must either be controlled operations "
"or calls to the convergence control intrinsics."
msgstr ""

#: ../../../ConvergentOperations.rst:740
msgid "Inferring Tokens"
msgstr ""

#: ../../../ConvergentOperations.rst:742
msgid "(This section is informational)"
msgstr ""

#: ../../../ConvergentOperations.rst:744
msgid ""
"Sometimes, it may be necessary to reinterpret the implicit convergence "
"control in terms of explicit convergence control tokens. For example, this "
"may happen when a function call is inlined, and either the caller or the "
"callee contains uncontrolled convergent operations."
msgstr ""

#: ../../../ConvergentOperations.rst:749
msgid ""
"Some uses of uncontrolled convergent operations may need to satisfy the "
"following property:"
msgstr ""

#: ../../../ConvergentOperations.rst:752
msgid ""
"For an environment-defined group of threads (such as an OpenCL workgroup or "
"subgroup), if one thread in the group executes a convergent operation, then "
"all threads in the group do so convergently with that thread."
msgstr ""

#: ../../../ConvergentOperations.rst:756
msgid ""
"In terms of explicit convergence control, this means that the "
"``convergencectrl`` operand on each convergent operation ``X`` must "
"ultimately originate from a call to the :ref:`llvm.experimental.convergence."
"entry <llvm.experimental.convergence.entry>` intrinsic. This preserves the "
"possibility that the group of threads that converge on reaching ``X`` is the "
"same group that originally started executing the program in convergence. In "
"comparison, the :ref:`llvm.experimental.convergence.anchor <llvm."
"experimental.convergence.anchor>` intrinsic captures an implementation-"
"defined group of threads, which is insufficient to support the above "
"property."
msgstr ""

#: ../../../ConvergentOperations.rst:767
msgid ""
"One way to approximate implicit convergence control in terms of explicit "
"convergence control tokens is the following procedure, which preserves the "
"above mentioned property:"
msgstr ""

#: ../../../ConvergentOperations.rst:771
msgid "Convert every irreducible cycle into a reducible cycle."
msgstr ""

#: ../../../ConvergentOperations.rst:772
msgid ""
"Insert a call to :ref:`llvm.experimental.convergence.entry <llvm."
"experimental.convergence.entry>` at the start of the entry block of the "
"function."
msgstr ""

#: ../../../ConvergentOperations.rst:775
msgid ""
"Insert a call to :ref:`llvm.experimental.convergence.loop <llvm.experimental."
"convergence.loop>` at the start of every loop header. If this loop is an "
"outermost loop, the ``convergencectrl`` operand is the call to :ref:`llvm."
"experimental.convergence.entry <llvm.experimental.convergence.entry>` in the "
"entry block of the function. Otherwise, the ``convergencectrl`` operand is "
"the call to :ref:`llvm.experimental.convergence.loop <llvm.experimental."
"convergence.loop>` in the parent loop's header."
msgstr ""

#: ../../../ConvergentOperations.rst:783
msgid ""
"For each uncontrolled convergent operation ``X``, add a ``convergencectrl`` "
"operand bundle using the token defined by a definition ``D`` that is a :ref:"
"`sibling <cycle-sibling>` to this operation. ``D`` always dominates ``X`` "
"--- if ``X`` is not in any cycle, then ``D`` is a call to :ref:`llvm."
"experimental.convergence.entry <llvm.experimental.convergence.entry>`; "
"otherwise ``D`` is the heart of the parent cycle of ``X``."
msgstr ""

#: ../../../ConvergentOperations.rst:794
msgid "Static Rules"
msgstr ""

#: ../../../ConvergentOperations.rst:796
msgid ""
"A *well-formed* program in LLVM IR must satisfy the following static rules "
"about cycles and convergence regions."
msgstr ""

#: ../../../ConvergentOperations.rst:800
msgid "Closed Paths"
msgstr ""

#: ../../../ConvergentOperations.rst:802
msgid ""
"A :ref:`closed path <cycle-closed-path>` in a CFG is a connected sequence of "
"nodes and edges in the CFG whose start and end points are the same."
msgstr ""

#: ../../../ConvergentOperations.rst:805
msgid ""
"Every closed path in the CFG that contains a use of a convergence token T "
"other than a use by :ref:`llvm.experimental.convergence.loop <llvm."
"experimental.convergence.loop>` must also contain the definition of T."
msgstr ""

#: ../../../ConvergentOperations.rst:810
msgid ""
"Every closed path in the CFG that contains two different uses of a "
"convergence token T must also contain the definition of T."
msgstr ""

#: ../../../ConvergentOperations.rst:813
msgid ""
"Every closed path in the CFG that contains uses of two different convergence "
"tokens T1 and T2 must also contain the definition of at least one of them."
msgstr ""

#: ../../../ConvergentOperations.rst:816
msgid ""
"Taken together, these rules imply that for every closed path C, there can be "
"at most one convergence token T which is used in C but defined outside of "
"it, and that T can be used only once in C, and only by ``llvm.experimental."
"convergence.loop``."
msgstr ""

#: ../../../ConvergentOperations.rst:820
msgid ""
"In every closed path that contains a use U of a token T but not the "
"definition of T, U must dominate all nodes in the closed path."
msgstr ""

#: ../../../ConvergentOperations.rst:823
msgid ""
"This implies that ``llvm.experimental.convergence.loop`` can appear as a "
"heart only in the header of a natural loop."
msgstr ""

#: ../../../ConvergentOperations.rst:826
msgid ""
"**Sufficient Conditions:** From the :ref:`properties of cycles <cycle-closed-"
"path>`, it is sufficient to prove the above properties for cycles instead of "
"closed paths. Briefly, any closed path that violates one or more of the "
"above static rules is contained in a cycle that also violates the same "
"rule(s)."
msgstr ""

#: ../../../ConvergentOperations.rst:835
msgid "Convergence Regions"
msgstr ""

#: ../../../ConvergentOperations.rst:837
msgid ""
"The *convergence region* of a convergence token T is the minimal region in "
"which T is live and used, i.e., the set of program points dominated by the "
"definition D of T from which a use of T can be reached."
msgstr ""

#: ../../../ConvergentOperations.rst:841
msgid ""
"The following static rule about convergence regions must be satisfied by "
"valid programs:"
msgstr ""

#: ../../../ConvergentOperations.rst:844
msgid ""
"If a convergence region R for a token T1 contains a use of a convergence "
"token T2, then R must also contain the definition of T2. (In other words, "
"convergence regions must be reasonably nested.)"
msgstr ""

#: ../../../ConvergentOperations.rst:850
msgid ""
"For brevity, this document uses the term \"convergence region of a token "
"definition ``D``\" to actually refer to the convergence region of the token "
"``T`` defined by ``D``."
msgstr ""

#: ../../../ConvergentOperations.rst:857
msgid "Inferring non-convergence"
msgstr ""

#: ../../../ConvergentOperations.rst:859
msgid ""
"When the target or the environment guarantees that threads do not "
"communicate using convergent operations or that threads never diverge, the "
"dynamic instances in the program are irrelevant and an optimizer may remove "
"any occurrence of the ``convergent`` attribute on a call-site or a function "
"and any explicit ``convergencectrl`` operand bundle at a call-site."
msgstr ""

#: ../../../ConvergentOperations.rst:866
msgid ""
"An optimizer may remove the ``convergent`` attribute and any explicit "
"``convergencectrl`` operand bundle from a call-site if it can prove that the "
"execution of this call-site always results in a call to a non-convergent "
"function."
msgstr ""

#: ../../../ConvergentOperations.rst:871
msgid ""
"An optimizer may remove the ``convergent`` attribute on a function if it can "
"prove that the function does not contain a call to :ref:`llvm.experimental."
"convergence.entry <llvm.experimental.convergence.entry>`, or any "
"uncontrolled convergent operations."
msgstr ""

#: ../../../ConvergentOperations.rst:878
msgid "Memory Model Non-Interaction"
msgstr ""

#: ../../../ConvergentOperations.rst:880
msgid ""
"The fact that an operation is convergent has no effect on how it is treated "
"for memory model purposes. In particular, an operation that is "
"``convergent`` and ``readnone`` does not introduce additional ordering "
"constraints as far as the memory model is concerned. There is no implied "
"barrier, neither in the memory barrier sense nor in the control barrier "
"sense of synchronizing the execution of threads."
msgstr ""

#: ../../../ConvergentOperations.rst:887
msgid ""
"Informational note: Threads that execute converged dynamic instances do not "
"necessarily do so at the same time."
msgstr ""

#: ../../../ConvergentOperations.rst:892
msgid "Other Interactions"
msgstr ""

#: ../../../ConvergentOperations.rst:894
msgid ""
"A function can be both ``convergent`` and ``speculatable``, indicating that "
"the function does not have undefined behavior and has no effects besides "
"calculating its result, but is still affected by the set of threads "
"executing this function. This typically prevents speculation of calls to the "
"function unless the constraint imposed by ``convergent`` is further relaxed "
"by some other means."
msgstr ""

#: ../../../ConvergentOperations.rst:902
msgid "Controlled Maximal Convergence"
msgstr ""

#: ../../../ConvergentOperations.rst:904
msgid ""
"The :ref:`converged-with relation <convergence-definition>` over dynamic "
"instances of each controlled convergent operation is completely defined by "
"the semantics of convergence tokens. But the implementation-defined "
"convergence at a call to :ref:`llvm.experimental.convergence.anchor <llvm."
"experimental.convergence.anchor>` also depends on the cycle hierarchy chosen "
"if it occurs inside an irreducible cycle."
msgstr ""

#: ../../../ConvergentOperations.rst:911
msgid ""
"When the token defined by a convergent operation ``D`` is used at another "
"convergent operation ``U``, the implementation must ensure that the threads "
"that converge at ``U`` are all the threads that reached ``U`` after "
"converging at ``D``. On most implementations, it is reasonable to assume "
"that only these threads are converged at every node they reach on any path "
"from ``D`` to ``U``. In other words, the converged-with relation at ``D`` "
"produces groups of threads that can converge only within each group, while "
"inside the convergence region of ``D``."
msgstr ""

#: ../../../ConvergentOperations.rst:920
msgid ""
"All this affects the :ref:`maximal converged-with relation <convergence-"
"maximal>` over dynamic instances and in turn the :ref:`m-converged property "
"<uniformity-analysis>` of static instances in the convergence region of "
"``D``."
msgstr ""

#: ../../../ConvergentOperations.rst:927
msgid "**Controlled Maximal converged-with Relation**"
msgstr ""

#: ../../../ConvergentOperations.rst:929
msgid ""
"Dynamic instances of a *convergent operation* are related in the controlled "
"maximal converged-with relation according to the semantics of the "
"convergence control tokens."
msgstr ""

#: ../../../ConvergentOperations.rst:932
msgid ""
"Dynamic instances ``X1`` and ``X2`` produced by different threads for the "
"same *non-convergent operation* ``X`` are related in the controlled maximal "
"converged-with relation if and only if:"
msgstr ""

#: ../../../ConvergentOperations.rst:936
msgid ""
"Both threads executed converged dynamic instances of every token definition "
"``D`` such that ``X`` is in the convergence region of ``D``, and,"
msgstr ""

#: ../../../ConvergentOperations.rst:939
msgid ""
"Either ``X`` is not contained in any cycle, or, for every cycle ``C`` with "
"header ``H`` that contains ``X``:"
msgstr ""

#: ../../../ConvergentOperations.rst:942
msgid ""
"every dynamic instance ``H1`` of ``H`` that precedes ``X1`` in the "
"respective thread is convergence-before ``X2``, and,"
msgstr ""

#: ../../../ConvergentOperations.rst:944
msgid ""
"every dynamic instance ``H2`` of ``H`` that precedes ``X2`` in the "
"respective thread is convergence-before ``X1``,"
msgstr ""

#: ../../../ConvergentOperations.rst:946
msgid "without assuming that ``X1`` is converged with ``X2``."
msgstr ""

#: ../../../ConvergentOperations.rst:950
msgid "**Controlled m-converged Static Instances**"
msgstr ""

#: ../../../ConvergentOperations.rst:952
msgid ""
"A node ``X`` in a given CFG is reported to be m-converged if and only if:"
msgstr ""

#: ../../../ConvergentOperations.rst:954
msgid ""
"For any token definition ``D`` such that ``X`` is inside the convergence "
"region of ``D``, ``D`` itself is m-converged, and,"
msgstr ""

#: ../../../ConvergentOperations.rst:956
msgid ""
"Every cycle that contains ``X`` satisfies the following necessary conditions:"
msgstr ""

#: ../../../ConvergentOperations.rst:959
msgid ""
"Every divergent branch inside the cycle satisfies the :ref:`diverged entry "
"criterion<convergence-diverged-entry>`, and,"
msgstr ""

#: ../../../ConvergentOperations.rst:961
msgid ""
"There are no :ref:`diverged paths reaching the cycle<convergence-diverged-"
"outside>` from a divergent branch outside it."
msgstr ""

#: ../../../ConvergentOperations.rst:965
msgid "Temporal Divergence at Cycle Exit"
msgstr ""

#: ../../../ConvergentOperations.rst:967
msgid ""
"When a cycle has a divergent exit, maximal convergence assumes that all "
"threads converge at the exit block. But if a controlled convergent operation "
"outside the cycle uses a token defined by an operation ``D`` inside the "
"cycle, the convergence region of ``D`` now extends outside the cycle. If two "
"threads executed converged dynamic instances of ``D`` before exiting the "
"cycle, then they continue to execute converged dynamic instances of nodes in "
"the convergence region of ``D`` outside the cycle. Thus, for a value ``V`` "
"defined inside the cycle, any use ``U`` of ``V`` within the convergence "
"region of ``T`` uses the output of converged dynamic instances of ``V``. If "
"``V`` is uniform, then its use at such a ``U`` is also uniform. In other "
"words, temporal divergence applies only to a use of ``V`` that is outside "
"the convergence region of ``D``."
msgstr ""

#: ../../../ConvergentOperations.rst:980
msgid "Rationales for Static rules about cycles"
msgstr ""

#: ../../../ConvergentOperations.rst:986
msgid ""
"For convenience, we use the operator ``==`` to represent the relation "
"``converged-with`` and the operator ``!=`` to represent its negation."
msgstr ""

#: ../../../ConvergentOperations.rst:989
msgid ""
"Consider a loop with (incorrect!) convergence control as in the following "
"pseudocode:"
msgstr ""

#: ../../../ConvergentOperations.rst:1003
msgid "This code is forbidden by the first static rule about cycles."
msgstr ""

#: ../../../ConvergentOperations.rst:1005
msgid ""
"A first formal argument why we have to do this is that the dynamic rule for "
"deciding whether two threads execute converged dynamic instances of "
"``@convergent.op`` leads to a logical contradiction in this code. Assume two "
"threads execute converged dynamic instances of the anchor followed by two "
"iterations of the loop. Thread 1 executes dynamic instances I1 and I2 of "
"``@convergent.op``, thread 2 executes dynamic instances J1 and J2. Using all "
"the rules, we can deduce:"
msgstr ""

#: ../../../ConvergentOperations.rst:1013
msgid "``I1 != I2`` and ``J1 != J2`` by the basic rules of dynamic instances."
msgstr ""

#: ../../../ConvergentOperations.rst:1015
msgid ""
"``I1 == J1`` by the first dynamic rule about controlled convergent "
"operations: both threads execute the same static instruction while using a "
"convergence token value produced by converged dynamic instances of an "
"instruction (the anchor)."
msgstr ""

#: ../../../ConvergentOperations.rst:1020
msgid "``I1 == J2`` by the same argument. Also, ``I2 == J1`` and ``I2 == J2``."
msgstr ""

#: ../../../ConvergentOperations.rst:1022
msgid ""
"The fact that one may be *intuitively* tempted to think of ``I1`` and ``J2`` "
"as being executed in different loop iterations is completely irrelevant for "
"the *formal* argument. There is no mechanism in LLVM IR semantics for "
"forming associations between loop iterations in different threads, *except* "
"for the rules defined in this document -- and the rules in this document "
"require a loop heart intrinsic for talking about loop iterations."
msgstr ""

#: ../../../ConvergentOperations.rst:1029
msgid ""
"By transitivity, we have ``I1 == I2`` and ``J1 == J2``. That is a "
"contradiction."
msgstr ""

#: ../../../ConvergentOperations.rst:1032
msgid ""
"This problem goes away by inserting a loop heart intrinsic as follows, which "
"establishes a relationship between loop iterations across threads."
msgstr ""

#: ../../../ConvergentOperations.rst:1045
msgid ""
"In the same scenario of two threads executing converged dynamic instances of "
"the anchor and then two iterations of the loop, the dynamic rule about loop "
"heart intrinsics implies that both threads execute the converged dynamic "
"instances of the loop heart intrinsic in their respective first iterations "
"and then again in their respective second iterations of the loop."
msgstr ""

#: ../../../ConvergentOperations.rst:1051
msgid ""
"This then implies that they execute converged dynamic instances ``I1 == J1`` "
"of the ``@convergent.op`` in their first iterations and then ``I2 == J2`` in "
"their second iterations. The rule is an \"if and only if\" rule, so it also "
"implies that ``I1 != J2`` and ``I2 != J1``, because those executions see "
"token values of ``%loop`` originating from non-converged dynamic instances "
"of the loop intrinsic."
msgstr ""

#: ../../../ConvergentOperations.rst:1058
msgid ""
"One may ask whether we could change the dynamic rule instead of adding the "
"static rule about cycles. That is impractical due to deeper difficulties. "
"Consider the following loop, again with incorrect convergence control:"
msgstr ""

#: ../../../ConvergentOperations.rst:1083
msgid ""
"Assume two threads execute converged dynamic instances of the anchor "
"followed by this sequence of basic blocks:"
msgstr ""

#: ../../../ConvergentOperations.rst:1091
msgid ""
"That is, both threads execute two iterations of the loop, but they execute "
"the different convergent operations in different iterations. Without forming "
"a relation between loop iterations across the threads, there is no "
"reasonable way of defining which dynamic instances of the convergent "
"operations should be the same across the threads, if any."
msgstr ""

#: ../../../ConvergentOperations.rst:1097
msgid ""
"Again, this can be addressed by adding a loop heart intrinsic, most "
"naturally as:"
msgstr ""

#: ../../../ConvergentOperations.rst:1120
msgid ""
"Let ``%loop(i;j)`` be the dynamic instance of ``j``-th execution of the loop "
"heart intrinsic by thread ``i``, and analogously ``@op.k(i)`` and ``@op."
"k(i)`` the dynamic instances of the execution of ``@convergent.op.k`` by "
"thread ``i``. Then we have:"
msgstr ""

#: ../../../ConvergentOperations.rst:1125
msgid ""
"``%loop(1;j) == %loop(2;j)`` for ``j = 1, 2`` because of the dynamic rule "
"about loop heart intrinsics."
msgstr ""

#: ../../../ConvergentOperations.rst:1128
msgid ""
"``%loop(i;1) != %loop(i;2)`` for ``i = 1, 2`` because of the basic rule that "
"different executions by the same thread happen in different dynamic "
"instances."
msgstr ""

#: ../../../ConvergentOperations.rst:1132
msgid ""
"``@op.1(1) != @op.1(2)``, since ``@op.1(1)`` uses the token value of "
"``%loop`` referring to ``%loop(1;1)`` and ``@op.1(2)`` uses that referring "
"to ``%loop(2;2) == %loop(1;2)``, which is different from ``%loop(1;1)``."
msgstr ""

#: ../../../ConvergentOperations.rst:1137
msgid "Similarly, ``@op.2(1) != @op.2(2)``."
msgstr ""

#: ../../../ConvergentOperations.rst:1139
msgid ""
"However, loop heart intrinsics could be inserted differently, at the cost of "
"also inserting a free-standing anchor:"
msgstr ""

#: ../../../ConvergentOperations.rst:1163
msgid ""
"This leads to the \"unnatural counting of loop iterations\" that is also "
"mentioned elsewhere. Let ``%loop(i)`` be the dynamic instance of the "
"execution of the loop heart intrinsic by thread ``i`` (each thread executes "
"it only once), and let ``@op.k(i)`` be as before. Then:"
msgstr ""

#: ../../../ConvergentOperations.rst:1168
msgid ""
"``%loop(1) == %loop(2)`` because of the dynamic rule about loop heart "
"intrinsics."
msgstr ""

#: ../../../ConvergentOperations.rst:1171
msgid ""
"``@op.1(1) == @op.1(2)`` because ``@op.1(i)`` uses the value of ``%loop`` "
"referring to ``%loop(i)``, and ``%loop(1) == %loop(2)``."
msgstr ""

#: ../../../ConvergentOperations.rst:1174
msgid ""
"Whether ``@op.2(1) == @op.2(2)`` is implementation-defined because of the "
"use of the ``%free`` anchor intrinsic."
msgstr ""

#: ../../../ConvergentOperations.rst:1177
msgid ""
"In practice, they almost certainly have to be non-converged dynamic "
"instances. Consider that if an implementation strictly follows the order of "
"instructions given in the program, the executions of the threads can be "
"\"aligned\" as follows:"
msgstr ""

#: ../../../ConvergentOperations.rst:1187
msgid ""
"So then ``@op.2(1)`` physically executes later than ``@op.2(2)`` and there "
"can be no communication between the threads, which means they execute non-"
"converged dynamic instances."
msgstr ""

#: ../../../ConvergentOperations.rst:1191
msgid ""
"That said, it is conceivable that there aren't actually any data or other "
"dependencies that would enforce this execution order. In that case, a highly "
"out-of-order implementation could potentially allow communication. That's "
"why the rules defined in this document are silent about whether ``@op.2(1) "
"== @op.2(2)`` or not."
msgstr ""

#: ../../../ConvergentOperations.rst:1197
msgid ""
"This type of convergence control seems relatively unlikely to appear in real "
"programs. Its possibility is simply a logical consequence of the model."
msgstr ""

#: ../../../ConvergentOperations.rst:1200
msgid ""
"An equivalent issue arises if the convergent operations are replaced by "
"nested loops with loop heart intrinsics that directly refer to ``%anchor``, "
"hence the variants of the static rules about cycles that apply to them:"
msgstr ""

#: ../../../ConvergentOperations.rst:1222
msgid ""
"There is a cycle (closed walk in the CFG) that goes through both loop heart "
"intrinsics using ``%anchor`` but not through the definition of ``%anchor``, "
"so this code is invalid."
msgstr ""

#: ../../../ConvergentOperations.rst:1228
msgid "Examples for the Correctness of Program Transforms"
msgstr ""

#: ../../../ConvergentOperations.rst:1232
msgid ""
"As implied by the rules in the previous sections, program transforms are "
"correct with respect to convergent operations if they preserve or refine "
"their semantics. This means that the set of communicating threads in the "
"transformed program must have been possible in the original program."
msgstr ""

#: ../../../ConvergentOperations.rst:1237
msgid ""
"Program transforms with a single-threaded focus are generally conservatively "
"correct if they do not sink or hoist convergent operations across a branch. "
"This applies even to program transforms that change the control flow graph."
msgstr ""

#: ../../../ConvergentOperations.rst:1241
msgid ""
"For example, unrolling a loop that does not contain convergent operations "
"cannot break any of the guarantees required for convergent operations "
"outside of the loop."
msgstr ""

#: ../../../ConvergentOperations.rst:1247
msgid "Loop unrolling examples"
msgstr ""

#: ../../../ConvergentOperations.rst:1249
msgid "We consider three kinds of loop unrolling here:"
msgstr ""

#: ../../../ConvergentOperations.rst:1251
msgid ""
"Partial unrolling with no known trip multiple, so a \"tail\" is required to "
"collect the remaining elements."
msgstr ""

#: ../../../ConvergentOperations.rst:1253
msgid "Partial unrolling by a trip multiple, so no \"tail\" is required."
msgstr ""

#: ../../../ConvergentOperations.rst:1254
msgid "Full unrolling, which eliminates the loop."
msgstr ""

#: ../../../ConvergentOperations.rst:1256
msgid ""
"The first kind is forbidden when ``@llvm.experimental.convergence.loop`` is "
"used. We illustrate the reasoning with some examples."
msgstr ""

#: ../../../ConvergentOperations.rst:1259
msgid ""
"First, an arbitrary loop that contains convergent operations *can* be "
"unrolled in all of these ways, even with \"tail\", if all convergent "
"operations refer back to an anchor inside the loop. For example (in pseudo-"
"code):"
msgstr ""

#: ../../../ConvergentOperations.rst:1271
msgid "This can be unrolled to:"
msgstr ""

#: ../../../ConvergentOperations.rst:1288
msgid ""
"This is likely to change the behavior of the convergent operation if there "
"are threads whose initial counter value is not a multiple of 2. In "
"particular, all threads with an odd trip count are now likely to execute the "
"convergent operation in their respective final iterations together because "
"the underlying implementation is likely to try to group as many threads "
"together as possible for the execution of the \"tail\"."
msgstr ""

#: ../../../ConvergentOperations.rst:1295
msgid ""
"This change is allowed because the anchor intrinsic has implementation-"
"defined convergence behavior and the loop unrolling transform is considered "
"to be part of the implementation. Another way of reasoning is that while the "
"*likely* behavior of the code has changed, the *guarantees* about its "
"behavior have remained the same."
msgstr ""

#: ../../../ConvergentOperations.rst:1301
msgid ""
"If the loop contains uncontrolled convergent operations, this kind of "
"unrolling is forbidden."
msgstr ""

#: ../../../ConvergentOperations.rst:1304
msgid ""
"Unrolling a loop with convergent operations that refer to tokens produced "
"outside the loop is forbidden when a \"tail\" or \"remainder\" would have to "
"be introduced. Consider:"
msgstr ""

#: ../../../ConvergentOperations.rst:1320
msgid ""
"To understand why unrolling is forbidden, consider two threads that execute "
"converged dynamic instances of the anchor and then proceed with 3 and 4 loop "
"iterations, respectively:"
msgstr ""

#: ../../../ConvergentOperations.rst:1329
msgid ""
"By the dynamic rule on loop heart intrinsics, these threads execute "
"converged dynamic instances of the loop intrinsic for the first 3 "
"iterations, and then thread 2 executes another dynamic instance by itself."
msgstr ""

#: ../../../ConvergentOperations.rst:1333
msgid ""
"By the dynamic rule on general convergent operations, the threads execute "
"converged dynamic instances of the ``@convergent.operation`` in the first 3 "
"iterations (that is, the dynamic instance executed by thread 1 in iteration "
"*n* is the same as that executed by thread 2 in iteration *n*, for *n = "
"1,2,3*; the dynamic instance executed in iteration 1 is different from that "
"in iteration 2, etc.)."
msgstr ""

#: ../../../ConvergentOperations.rst:1340
msgid ""
"Now assume that the loop is unrolled by a factor of 2, which requires a "
"remainder as follows:"
msgstr ""

#: ../../../ConvergentOperations.rst:1362
msgid ""
"First of all, note some interesting problems surrounding the loop intrinsic:"
msgstr ""

#: ../../../ConvergentOperations.rst:1364
msgid ""
"It is *not* duplicated inside the unrolled loop. This is to comply with the :"
"ref:`convergence_static_rules`."
msgstr ""

#: ../../../ConvergentOperations.rst:1367
msgid ""
"It is unclear whether the loop intrinsic ought to be duplicated in the "
"remainder, or whether the final ``@convergent.operation`` in D should just "
"refer to either ``%inner`` (which is possible in SSA form) or directly to "
"``%outer``. The decision made here is arbitrary and doesn't change the "
"argument that follows. Ultimately, it simply doesn't matter because the "
"transform is incorrect either way."
msgstr ""

#: ../../../ConvergentOperations.rst:1374
msgid "The threads now execute the following sequences of blocks:"
msgstr ""

#: ../../../ConvergentOperations.rst:1381
msgid ""
"Analogous to the argument above, they execute converged dynamic instances of "
"the ``%inner`` intrinsic and the ``@convergent.operation`` in the first "
"iteration of the unrolled loop, which corresponds to the first 2 iterations "
"of the original loop."
msgstr ""

#: ../../../ConvergentOperations.rst:1386
msgid ""
"However, they execute different static calls to ``@convergent.operation`` "
"for the 3rd iteration of the original loop. In thread 1, that iteration "
"corresponds to the call in the remainder, while in thread 2 it corresponds "
"to the first call to ``@convergent.operation`` in the unrolled loop. "
"Therefore, they execute non-converged dynamic instances, which means that "
"the set of communicating threads for the 3rd iteration of the original loop "
"is different. This is why the unrolling is incorrect."
msgstr ""

#: ../../../ConvergentOperations.rst:1394
msgid ""
"On the other hand, unrolling without \"tail\" is allowed. For example, "
"assuming that the trip counter is known to be a multiple of 2, we can unroll "
"the loop as follows:"
msgstr ""

#: ../../../ConvergentOperations.rst:1408
msgid "Note again that the loop intrinsic is not duplicated."
msgstr ""

#: ../../../ConvergentOperations.rst:1410
msgid ""
"The :ref:`llvm.experimental.convergence.loop <llvm.experimental.convergence."
"loop>` intrinsic is typically expected to appear in the header of a natural "
"loop. However, it can also appear in non-header blocks of a loop. In that "
"case, the loop can generally not be unrolled."
msgstr ""

#: ../../../ConvergentOperations.rst:1418
msgid "Hoisting and sinking"
msgstr ""

#: ../../../ConvergentOperations.rst:1420
msgid ""
"In general, hoisting and sinking of convergent operations is forbidden. This "
"is because moving the operation to a different point in control flow "
"generally changes the set of threads that reach the operation and therefore, "
"the set of threads that execute converged dynamic instances of the "
"operation. By definition, this changes the set of threads that participate "
"in the communication of the convergent operation, which will typically "
"change its result."
msgstr ""

#: ../../../ConvergentOperations.rst:1428
msgid ""
"There are a number of exceptions, though most of them require additional "
"knowledge."
msgstr ""

#: ../../../ConvergentOperations.rst:1431
msgid ""
"For example, hoisting and sinking across *uniform* conditional branches -- i."
"e., conditional branches where within every possible relevant set of "
"threads, all threads will always take the same direction -- is generally "
"allowed. See the end of the :ref:`example of reductions inside control flow "
"<convergence_example_reductions>` for a brief discussion."
msgstr ""

#: ../../../ConvergentOperations.rst:1437
msgid ""
"Some convergent operations can be hoisted but not sunk, or vice versa. A "
"simple example is the ``subgroupShuffle(data, id)`` operation. It returns "
"the ``data`` operand of the thread identified by ``id``, where thread IDs "
"are fixed and assigned to each thread at launch. The result is undefined (or "
"perhaps there is UB, depending on the language and environment) if thread "
"``id`` is not in the communicating set of threads. So hoisting is allowed in "
"the following pseudo-code example:"
msgstr ""

#: ../../../ConvergentOperations.rst:1460
msgid ""
"After hoisting the calls to ``@subgroupShuffle``, the communicating set of "
"threads is the union of the two sets of threads in the original program, so "
"``%id`` can only go \"out of range\" after hoisting if it did so in the "
"original program."
msgstr ""

#: ../../../ConvergentOperations.rst:1465
msgid ""
"However, speculative execution of ``@subgroupShuffle`` in the following "
"program may be forbidden:"
msgstr ""

#: ../../../ConvergentOperations.rst:1480
msgid ""
"There is no guarantee about the value of ``%id`` in the threads where "
"``condition`` is false. If ``@subgroupShuffle`` is defined to have UB when "
"``%id`` is outside of the set of communicating threads, then speculating and "
"hoisting ``@subgroupShuffle`` might introduce UB."
msgstr ""

#: ../../../ConvergentOperations.rst:1485
msgid ""
"On the other hand, if ``@subgroupShuffle`` is defined such that it merely "
"produces an undefined value or poison as a result when ``%id`` is \"out of "
"range\", then speculating is okay."
msgstr ""

#: ../../../ConvergentOperations.rst:1489
msgid ""
"Even though :ref:`llvm.experimental.convergence.anchor <llvm.experimental."
"convergence.anchor>` is marked as ``convergent``, it can be sunk in some "
"cases. For example, in pseudo-code:"
msgstr ""

#: ../../../ConvergentOperations.rst:1501
msgid ""
"Assuming that ``%tok`` is only used inside the conditional block, the anchor "
"can be sunk. The rationale is two-fold. First, the anchor has implementation-"
"defined behavior, and the sinking is part of the implementation. Second, "
"already in the original program, the set of threads that communicates in the "
"``@convergent.operation`` is automatically a subset of the threads for which "
"``condition`` is true."
msgstr ""

#: ../../../ConvergentOperations.rst:1508
msgid "Anchors can be hoisted in acyclic control flow. For example:"
msgstr ""

#: ../../../ConvergentOperations.rst:1520
msgid "The anchors can be hoisted, resulting in:"
msgstr ""

#: ../../../ConvergentOperations.rst:1531
msgid ""
"The behavior is unchanged, since each of the static convergent operations "
"only ever communicates with threads that have the same ``condition`` value. "
"By contrast, hoisting the convergent operations themselves is forbidden."
msgstr ""

#: ../../../ConvergentOperations.rst:1535
msgid ""
"Hoisting and sinking anchors out of and into loops is forbidden. For example:"
msgstr ""

#: ../../../ConvergentOperations.rst:1544
msgid ""
"Hoisting the anchor would make the program invalid according to the static "
"validity rules. Conversely:"
msgstr ""

#: ../../../ConvergentOperations.rst:1556
msgid ""
"The program would stay valid if the anchor was sunk into the loop, but its "
"behavior could end up being different. If the anchor is inside the loop, "
"then each loop iteration has a new dynamic instance of the anchor, and the "
"set of threads participating in those dynamic instances of the anchor could "
"be different in arbitrary implementation-defined ways. Via the dynamic rules "
"about dynamic instances of convergent operations, this then implies that the "
"set of threads executing ``@convergent.operation`` could be different in "
"each loop iteration in arbitrary implementation-defined ways."
msgstr ""

#: ../../../ConvergentOperations.rst:1565
msgid ""
"Convergent operations can be sunk together with their anchor. Again in "
"pseudo-code:"
msgstr ""

#: ../../../ConvergentOperations.rst:1577
msgid ""
"Assuming that ``%tok``, ``%a``, and ``%b`` are only used inside the "
"conditional block, all can be sunk together:"
msgstr ""

#: ../../../ConvergentOperations.rst:1589
msgid ""
"The rationale is that the anchor intrinsic has implementation-defined "
"behavior, and the sinking transform is considered to be part of the "
"implementation: the sinking will restrict the set of communicating threads "
"to those for which ``condition`` is true, but that could have happened in "
"the original program anyway for some arbitrary other reason."
msgstr ""

#: ../../../ConvergentOperations.rst:1595
msgid ""
"However, sinking *only* the convergent operation producing ``%b`` would be "
"incorrect. That would allow threads for which ``condition`` is false to "
"communicate at ``%a``, but not at ``%b``, which the original program doesn't "
"allow."
msgstr ""

#: ../../../ConvergentOperations.rst:1600
msgid ""
"Note that the entry intrinsic behaves differently. Sinking the convergent "
"operations is forbidden in the following snippet:"
msgstr ""
