# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CommandGuide/FileCheck.rst:2
msgid "FileCheck - Flexible pattern matching file verifier"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:7
msgid "SYNOPSIS"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:9
msgid ""
":program:`FileCheck` *match-filename* [*--check-prefix=XXX*] [*--strict-"
"whitespace*]"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:12
msgid "DESCRIPTION"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:14
msgid ""
":program:`FileCheck` reads two files (one from standard input, and one "
"specified on the command line) and uses one to verify the other.  This "
"behavior is particularly useful for the testsuite, which wants to verify "
"that the output of some tool (e.g. :program:`llc`) contains the expected "
"information (for example, a movsd from esp or whatever is interesting).  "
"This is similar to using :program:`grep`, but it is optimized for matching "
"multiple different inputs in one file in a specific order."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:22
msgid ""
"The ``match-filename`` file specifies the file that contains the patterns to "
"match.  The file to verify is read from standard input unless the :option:`--"
"input-file` option is used."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:27
msgid "OPTIONS"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:29
msgid ""
"Options are parsed from the environment variable ``FILECHECK_OPTS`` and from "
"the command line."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:34
msgid "Print a summary of command line options."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:38
msgid ""
"FileCheck searches the contents of ``match-filename`` for patterns to "
"match.  By default, these patterns are prefixed with \"``CHECK:``\". If "
"you'd like to use a different prefix (e.g. because the same input file is "
"checking multiple different tool or options), the :option:`--check-prefix` "
"argument allows you to specify (without the trailing \"``:``\") one or more "
"prefixes to match. Multiple prefixes are useful for tests which might change "
"for different run options, but most lines remain the same."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:46
msgid ""
"FileCheck does not permit duplicate prefixes, even if one is a check prefix "
"and one is a comment prefix (see :option:`--comment-prefixes` below)."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:51
msgid ""
"An alias of :option:`--check-prefix` that allows multiple prefixes to be "
"specified as a comma separated list."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:56
msgid ""
"By default, FileCheck ignores any occurrence in ``match-filename`` of any "
"check prefix if it is preceded on the same line by \"``COM:``\" or \"``RUN:"
"``\". See the section `The \"COM:\" directive`_ for usage details."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:60
msgid ""
"These default comment prefixes can be overridden by :option:`--comment-"
"prefixes` if they are not appropriate for your testing environment. However, "
"doing so is not recommended in LLVM's LIT-based test suites, which should be "
"easier to maintain if they all follow a consistent comment style. In that "
"case, consider proposing a change to the default comment prefixes instead."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:69
msgid ""
"This option controls the behavior when using more than one prefix as "
"specified by :option:`--check-prefix` or :option:`--check-prefixes`, and "
"some of these prefixes are missing in the test file. If true, this is "
"allowed, if false, FileCheck will report an error, listing the missing "
"prefixes. The default value is false."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:77
msgid "File to check (defaults to stdin)."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:81
msgid ""
"By default, FileCheck allows matches of anywhere on a line. This option will "
"require all positive matches to cover an entire line. Leading and trailing "
"whitespace is ignored, unless :option:`--strict-whitespace` is also "
"specified. (Note: negative matches from ``CHECK-NOT`` are not affected by "
"this option!)"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:87
msgid ""
"Passing this option is equivalent to inserting ``{{^ *}}`` or ``{{^}}`` "
"before, and ``{{ *$}}`` or ``{{$}}`` after every positive check pattern."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:93
msgid ""
"By default, FileCheck canonicalizes input horizontal whitespace (spaces and "
"tabs) which causes it to ignore these differences (a space will match a "
"tab). The :option:`--strict-whitespace` argument disables this behavior. End-"
"of-line sequences are canonicalized to UNIX-style ``\\n`` in all modes."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:100
msgid ""
"By default, FileCheck uses case-sensitive matching. This option causes "
"FileCheck to use case-insensitive matching."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:105
msgid ""
"Adds implicit negative checks for the specified patterns between positive "
"checks. The option allows writing stricter tests without stuffing them with "
"``CHECK-NOT``\\ s."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:109
msgid ""
"For example, \"``--implicit-check-not warning:``\" can be useful when "
"testing diagnostic messages from tools that don't have an option similar to "
"``clang -verify``. With this option FileCheck will verify that input does "
"not contain warnings not covered by any ``CHECK:`` patterns."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:116
msgid ""
"Dump input to stderr, adding annotations representing currently enabled "
"diagnostics.  When there are multiple occurrences of this option, the "
"``<value>`` that appears earliest in the list below has precedence.  The "
"default is ``fail``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:121
msgid "``help``   - Explain input dump and quit"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:122
msgid "``always`` - Always dump input"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:123
msgid "``fail``   - Dump input on failure"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:124
msgid "``never``  - Never dump input"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:128
msgid ""
"In the dump requested by ``--dump-input``, print ``<N>`` input lines before "
"and ``<N>`` input lines after any lines specified by ``--dump-input-"
"filter``. When there are multiple occurrences of this option, the largest "
"specified ``<N>`` has precedence.  The default is 5."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:135
msgid ""
"In the dump requested by ``--dump-input``, print only input lines of kind "
"``<value>`` plus any context specified by ``--dump-input-context``.  When "
"there are multiple occurrences of this option, the ``<value>`` that appears "
"earliest in the list below has precedence.  The default is ``error`` when "
"``--dump-input=fail``, and it's ``all`` when ``--dump-input=always``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:141
msgid "``all``             - All input lines"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:142
msgid "``annotation-full`` - Input lines with annotations"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:143
msgid "``annotation``      - Input lines with starting points of annotations"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:144
msgid ""
"``error``           - Input lines with starting points of error annotations"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:148
msgid "Enables scope for regex variables."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:150
msgid ""
"Variables with names that start with ``$`` are considered global and remain "
"set throughout the file."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:153
msgid ""
"All other variables get undefined after each encountered ``CHECK-LABEL``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:157
msgid ""
"Sets a filecheck pattern variable ``VAR`` with value ``VALUE`` that can be "
"used in ``CHECK:`` lines."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:162
msgid ""
"Sets a filecheck numeric variable ``NUMVAR`` of matching format ``FMT`` to "
"the result of evaluating ``<NUMERIC EXPRESSION>`` that can be used in "
"``CHECK:`` lines.  See section ``FileCheck Numeric Variables and "
"Expressions`` for details on supported numeric expressions."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:170
msgid "Show the version number of this program."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:174
msgid ""
"Print good directive pattern matches.  However, if ``-dump-input=fail`` or "
"``-dump-input=always``, add those matches as input annotations instead."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:179
msgid ""
"Print information helpful in diagnosing internal FileCheck issues, such as "
"discarded overlapping ``CHECK-DAG:`` matches, implicit EOF pattern matches, "
"and ``CHECK-NOT:`` patterns that do not have matches.  Implies ``-v``. "
"However, if ``-dump-input=fail`` or ``-dump-input=always``, just add that "
"information as input annotations instead."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:187
msgid ""
"Enable overlapping among matches in a group of consecutive ``CHECK-DAG:`` "
"directives.  This option is deprecated and is only provided for convenience "
"as old tests are migrated to the new non-overlapping ``CHECK-DAG:`` "
"implementation."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:194
msgid "Allow checking empty input. By default, empty input is rejected."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:198
msgid "Use colors in output (autodetected by default)."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:201
msgid "EXIT STATUS"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:203
msgid ""
"If :program:`FileCheck` verifies that the file matches the expected "
"contents, it exits with 0.  Otherwise, if not, or if an error occurs, it "
"will exit with a non-zero value."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:208
msgid "TUTORIAL"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:210
msgid ""
"FileCheck is typically used from LLVM regression tests, being invoked on the "
"RUN line of the test.  A simple example of using FileCheck from a RUN line "
"looks like this:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:218
msgid ""
"This syntax says to pipe the current file (\"``%s``\") into ``llvm-as``, "
"pipe that into ``llc``, then pipe the output of ``llc`` into ``FileCheck``.  "
"This means that FileCheck will be verifying its standard input (the llc "
"output) against the filename argument specified (the original ``.ll`` file "
"specified by \"``%s``\").  To see how this works, let's look at the rest of "
"the ``.ll`` file (after the RUN line):"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:243
msgid ""
"Here you can see some \"``CHECK:``\" lines specified in comments.  Now you "
"can see how the file is piped into ``llvm-as``, then ``llc``, and the "
"machine code output is what we are verifying.  FileCheck checks the machine "
"code output to verify that it matches what the \"``CHECK:``\" lines specify."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:248
msgid ""
"The syntax of the \"``CHECK:``\" lines is very simple: they are fixed "
"strings that must occur in order.  FileCheck defaults to ignoring horizontal "
"whitespace differences (e.g. a space is allowed to match a tab) but "
"otherwise, the contents of the \"``CHECK:``\" line is required to match some "
"thing in the test file exactly."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:253
msgid ""
"One nice thing about FileCheck (compared to grep) is that it allows merging "
"test cases together into logical groups.  For example, because the test "
"above is checking for the \"``sub1:``\" and \"``inc4:``\" labels, it will "
"not match unless there is a \"``subl``\" in between those labels.  If it "
"existed somewhere else in the file, that would not count: \"``grep subl``\" "
"matches if \"``subl``\" exists anywhere in the file."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:261
msgid "The FileCheck -check-prefix option"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:263
msgid ""
"The FileCheck `-check-prefix` option allows multiple test configurations to "
"be driven from one `.ll` file.  This is useful in many circumstances, for "
"example, testing different architectural variants with :program:`llc`.  "
"Here's a simple example:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:285
msgid ""
"In this case, we're testing that we get the expected code generation with "
"both 32-bit and 64-bit code generation."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:289
msgid "The \"COM:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:291
msgid ""
"Sometimes you want to disable a FileCheck directive without removing it "
"entirely, or you want to write comments that mention a directive by name. "
"The \"``COM:``\" directive makes it easy to do this. For example, you might "
"have:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:306
msgid ""
"Without \"``COM:``\", you would need to use some combination of rewording "
"and directive syntax mangling to prevent FileCheck from recognizing the "
"commented occurrences of \"``X32:``\" and \"``X64:``\" above as directives. "
"Moreover, FileCheck diagnostics have been proposed that might complain about "
"the above occurrences of \"``X64``\" that don't have the trailing \"``:``\" "
"because they look like directive typos. Dodging all these problems can be "
"tedious for a test author, and directive syntax mangling can make the "
"purpose of test code unclear. \"``COM:``\" avoids all these problems."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:315
msgid "A few important usage notes:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:317
msgid ""
"\"``COM:``\" within another directive's pattern does *not* comment out the "
"remainder of the pattern. For example:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:324
msgid ""
"If you need to temporarily comment out part of a directive's pattern, move "
"it to another line. The reason is that FileCheck parses \"``COM:``\" in the "
"same manner as any other directive: only the first directive on the line is "
"recognized as a directive."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:329
msgid ""
"For the sake of LIT, FileCheck treats \"``RUN:``\" just like \"``COM:``\". "
"If this is not suitable for your test environment, see :option:`--comment-"
"prefixes`."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:332
msgid ""
"FileCheck does not recognize \"``COM``\", \"``RUN``\", or any user-defined "
"comment prefix as a comment directive if it's combined with one of the usual "
"check directive suffixes, such as \"``-NEXT:``\" or \"``-NOT:``\", discussed "
"below. FileCheck treats such a combination as plain text instead. If it "
"needs to act as a comment directive for your test environment, define it as "
"such with :option:`--comment-prefixes`."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:340
msgid "The \"CHECK-NEXT:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:342
msgid ""
"Sometimes you want to match lines and would like to verify that matches "
"happen on exactly consecutive lines with no other lines in between them.  In "
"this case, you can use \"``CHECK:``\" and \"``CHECK-NEXT:``\" directives to "
"specify this.  If you specified a custom check prefix, just use \"``<PREFIX>-"
"NEXT:``\". For example, something like this works as you'd expect:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:368
msgid ""
"\"``CHECK-NEXT:``\" directives reject the input unless there is exactly one "
"newline between it and the previous directive.  A \"``CHECK-NEXT:``\" cannot "
"be the first directive in a file."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:373
msgid "The \"CHECK-SAME:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:375
msgid ""
"Sometimes you want to match lines and would like to verify that matches "
"happen on the same line as the previous match.  In this case, you can use "
"\"``CHECK:``\" and \"``CHECK-SAME:``\" directives to specify this.  If you "
"specified a custom check prefix, just use \"``<PREFIX>-SAME:``\"."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:380
msgid ""
"\"``CHECK-SAME:``\" is particularly powerful in conjunction with \"``CHECK-"
"NOT:``\" (described below)."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:383
msgid "For example, the following works like you'd expect:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:393
msgid ""
"\"``CHECK-SAME:``\" directives reject the input if there are any newlines "
"between it and the previous directive."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:396
msgid ""
"\"``CHECK-SAME:``\" is also useful to avoid writing matchers for irrelevant "
"fields. For example, suppose you're writing a test which parses a tool that "
"generates output like this:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:420
msgid ""
"To write a test that verifies ``foo`` has the value ``1``, you might first "
"write this:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:428
msgid ""
"However, this would be a bad test: if the value for ``foo`` changes, the "
"test would still pass because the \"``CHECK: Value: 1``\" line would match "
"the value from ``baz``. To fix this, you could add ``CHECK-NEXT`` matchers "
"for every ``FieldN:`` line, but that would be verbose, and need to be "
"updated when ``Field4`` is added. A more succinct way to write the test "
"using the \"``CHECK-SAME:``\" matcher would be as follows:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:441
msgid ""
"This verifies that the *next* time \"``Value:``\" appears in the output, it "
"has the value ``1``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:444
msgid "Note: a \"``CHECK-SAME:``\" cannot be the first directive in a file."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:447
msgid "The \"CHECK-EMPTY:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:449
msgid ""
"If you need to check that the next line has nothing on it, not even "
"whitespace, you can use the \"``CHECK-EMPTY:``\" directive."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:461
msgid ""
"Just like \"``CHECK-NEXT:``\" the directive will fail if there is more than "
"one newline before it finds the next blank line, and it cannot be the first "
"directive in a file."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:466
msgid "The \"CHECK-NOT:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:468
msgid ""
"The \"``CHECK-NOT:``\" directive is used to verify that a string doesn't "
"occur between two matches (or before the first match, or after the last "
"match).  For example, to verify that a load is removed by a transformation, "
"a test like this can be used:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:489
msgid "The \"CHECK-COUNT:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:491
msgid ""
"If you need to match multiple lines with the same pattern over and over "
"again you can repeat a plain ``CHECK:`` as many times as needed. If that "
"looks too boring you can instead use a counted check \"``CHECK-COUNT-<num>:"
"``\", where ``<num>`` is a positive decimal number. It will match the "
"pattern exactly ``<num>`` times, no more and no less. If you specified a "
"custom check prefix, just use \"``<PREFIX>-COUNT-<num>:``\" for the same "
"effect. Here is a simple example:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:512
msgid "The \"CHECK-DAG:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:514
msgid ""
"If it's necessary to match strings that don't occur in a strictly sequential "
"order, \"``CHECK-DAG:``\" could be used to verify them between two matches "
"(or before the first match, or after the last match). For example, clang "
"emits vtable globals in reverse order. Using ``CHECK-DAG:``, we can keep the "
"checks in the natural order:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:532
msgid ""
"``CHECK-NOT:`` directives could be mixed with ``CHECK-DAG:`` directives to "
"exclude strings between the surrounding ``CHECK-DAG:`` directives. As a "
"result, the surrounding ``CHECK-DAG:`` directives cannot be reordered, i.e. "
"all occurrences matching ``CHECK-DAG:`` before ``CHECK-NOT:`` must not fall "
"behind occurrences matching ``CHECK-DAG:`` after ``CHECK-NOT:``. For example,"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:544
msgid ""
"This case will reject input strings where ``BEFORE`` occurs after ``AFTER``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:546
msgid ""
"With captured variables, ``CHECK-DAG:`` is able to match valid topological "
"orderings of a DAG with edges from the definition of a variable to its use. "
"It's useful, e.g., when your test cases need to match different output "
"sequences from the instruction scheduler. For example,"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:557
msgid ""
"In this case, any order of that two ``add`` instructions will be allowed."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:559
msgid ""
"If you are defining `and` using variables in the same ``CHECK-DAG:`` block, "
"be aware that the definition rule can match `after` its use."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:562
msgid "So, for instance, the code below will pass:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:571
msgid "While this other code, will not:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:580
msgid ""
"While this can be very useful, it's also dangerous, because in the case of "
"register sequence, you must have a strong order (read before write, copy "
"before use, etc). If the definition your test is looking for doesn't match "
"(because of a bug in the compiler), it may match further away from the use, "
"and mask real bugs away."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:586
msgid ""
"In those cases, to enforce the order, use a non-DAG directive between DAG-"
"blocks."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:588
msgid ""
"A ``CHECK-DAG:`` directive skips matches that overlap the matches of any "
"preceding ``CHECK-DAG:`` directives in the same ``CHECK-DAG:`` block.  Not "
"only is this non-overlapping behavior consistent with other directives, but "
"it's also necessary to handle sets of non-unique strings or patterns.  For "
"example, the following directives look for unordered log entries for two "
"tasks in a parallel program, such as the OpenMP runtime:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:603
msgid ""
"The second pair of directives is guaranteed not to match the same log "
"entries as the first pair even though the patterns are identical and even if "
"the text of the log entries is identical because the thread ID manages to be "
"reused."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:608
msgid "The \"CHECK-LABEL:\" directive"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:610
msgid ""
"Sometimes in a file containing multiple tests divided into logical blocks, "
"one or more ``CHECK:`` directives may inadvertently succeed by matching "
"lines in a later block. While an error will usually eventually be generated, "
"the check flagged as causing the error may not actually bear any "
"relationship to the actual source of the problem."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:616
msgid ""
"In order to produce better error messages in these cases, the \"``CHECK-"
"LABEL:``\" directive can be used. It is treated identically to a normal "
"``CHECK`` directive except that FileCheck makes an additional assumption "
"that a line matched by the directive cannot also be matched by any other "
"check present in ``match-filename``; this is intended to be used for lines "
"containing labels or other unique identifiers. Conceptually, the presence of "
"``CHECK-LABEL`` divides the input stream into separate blocks, each of which "
"is processed independently, preventing a ``CHECK:`` directive in one block "
"matching a line in another block. If ``--enable-var-scope`` is in effect, "
"all local variables are cleared at the beginning of the block."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:627
msgid "For example,"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:648
msgid ""
"The use of ``CHECK-LABEL:`` directives in this case ensures that the three "
"``CHECK:`` directives only accept lines corresponding to the body of the "
"``@C_ctor_base`` function, even if the patterns match lines found later in "
"the file. Furthermore, if one of these three ``CHECK:`` directives fail, "
"FileCheck will recover by continuing to the next block, allowing multiple "
"test failures to be detected in a single invocation."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:655
msgid ""
"There is no requirement that ``CHECK-LABEL:`` directives contain strings "
"that correspond to actual syntactic labels in a source or output language: "
"they must simply uniquely match a single line in the file being verified."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:659
msgid ""
"``CHECK-LABEL:`` directives cannot contain variable definitions or uses."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:662
msgid "Directive modifiers"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:664
msgid ""
"A directive modifier can be append to a directive by following the directive "
"with ``{<modifier>}`` where the only supported value for ``<modifier>`` is "
"``LITERAL``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:668
msgid ""
"The ``LITERAL`` directive modifier can be used to perform a literal match. "
"The modifier results in the directive not recognizing any syntax to perform "
"regex matching, variable capture or any substitutions. This is useful when "
"the text to match would require excessive escaping otherwise. For example, "
"the following will perform literal matches rather than considering these as "
"regular expressions:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:686
msgid "FileCheck Regex Matching Syntax"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:688
msgid ""
"All FileCheck directives take a pattern to match. For most uses of "
"FileCheck, fixed string matching is perfectly sufficient.  For some things, "
"a more flexible form of matching is desired.  To support this, FileCheck "
"allows you to specify regular expressions in matching strings, surrounded by "
"double braces: ``{{yourregex}}``. FileCheck implements a POSIX regular "
"expression matcher; it supports Extended POSIX regular expressions (ERE). "
"Because we want to use fixed string matching for a majority of what we do, "
"FileCheck has been designed to support mixing and matching fixed string "
"matching with regular expressions.  This allows you to write things like "
"this:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:702
msgid ""
"In this case, any offset from the ESP register will be allowed, and any xmm "
"register will be allowed."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:705
msgid ""
"Because regular expressions are enclosed with double braces, they are "
"visually distinct, and you don't need to use escape characters within the "
"double braces like you would in C.  In the rare case that you want to match "
"double braces explicitly from the input, you can use something ugly like "
"``{{[}][}]}}`` as your pattern.  Or if you are using the repetition count "
"syntax, for example ``[[:xdigit:]]{8}`` to match exactly 8 hex digits, you "
"would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid "
"confusion with FileCheck's closing double-brace."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:715
msgid "FileCheck String Substitution Blocks"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:717
msgid ""
"It is often useful to match a pattern and then verify that it occurs again "
"later in the file.  For codegen tests, this can be useful to allow any "
"register, but verify that that register is used consistently later.  To do "
"this, :program:`FileCheck` supports string substitution blocks that allow "
"string variables to be defined and substituted into patterns.  Here is a "
"simple example:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:730
msgid ""
"The first check line matches a regex ``%[a-z]+`` and captures it into the "
"string variable ``REGISTER``.  The second line verifies that whatever is in "
"``REGISTER`` occurs later in the file after an \"``andw``\". :program:"
"`FileCheck` string substitution blocks are always contained in ``[[ ]]`` "
"pairs, and string variable names can be formed with the regex ``\\$[a-zA-Z_]"
"[a-zA-Z0-9_]*``.  If a colon follows the name, then it is a definition of "
"the variable; otherwise, it is a substitution."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:738
msgid ""
":program:`FileCheck` variables can be defined multiple times, and "
"substitutions always get the latest value.  Variables can also be "
"substituted later on the same line they were defined on. For example:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:746
msgid ""
"Can be useful if you want the operands of ``op`` to be the same register, "
"and don't care exactly which register it is."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:749
msgid ""
"If ``--enable-var-scope`` is in effect, variables with names that start with "
"``$`` are considered to be global. All others variables are local.  All "
"local variables get undefined at the beginning of each CHECK-LABEL block. "
"Global variables are not affected by CHECK-LABEL. This makes it easier to "
"ensure that individual tests are not affected by variables set in preceding "
"tests."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:757
msgid "FileCheck Numeric Substitution Blocks"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:759
msgid ""
":program:`FileCheck` also supports numeric substitution blocks that allow "
"defining numeric variables and checking for numeric values that satisfy a "
"numeric expression constraint based on those variables via a numeric "
"substitution. This allows ``CHECK:`` directives to verify a numeric relation "
"between two numbers, such as the need for consecutive registers to be used."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:765
msgid ""
"The syntax to capture a numeric value is ``[[#%<fmtspec>,<NUMVAR>:]]`` where:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:768
msgid ""
"``%<fmtspec>,`` is an optional format specifier to indicate what number "
"format to match and the minimum number of digits to expect."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:771
msgid ""
"``<NUMVAR>:`` is an optional definition of variable ``<NUMVAR>`` from the "
"captured value."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:774
msgid ""
"The syntax of ``<fmtspec>`` is: ``#.<precision><conversion specifier>`` "
"where:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:776
msgid ""
"``#`` is an optional flag available for hex values (see ``<conversion "
"specifier>`` below) which requires the value matched to be prefixed by "
"``0x``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:779
msgid ""
"``.<precision>`` is an optional printf-style precision specifier in which "
"``<precision>`` indicates the minimum number of digits that the value "
"matched must have, expecting leading zeros if needed."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:783
msgid ""
"``<conversion specifier>`` is an optional scanf-style conversion specifier "
"to indicate what number format to match (e.g. hex number).  Currently "
"accepted format specifiers are ``%u``, ``%d``, ``%x`` and ``%X``.  If "
"absent, the format specifier defaults to ``%u``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:789
#: ../../../CommandGuide/FileCheck.rst:859
msgid "For example:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:795
msgid ""
"would match ``mov r5, 0x0000FEFE`` and set ``REG`` to the value ``5`` and "
"``ADDR`` to the value ``0xFEFE``. Note that due to the precision it would "
"fail to match ``mov r5, 0xFEFE``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:799
msgid ""
"As a result of the numeric variable definition being optional, it is "
"possible to only check that a numeric value is present in a given format. "
"This can be useful when the value itself is not useful, for instance:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:807
msgid "to check that a value is synthesized rather than moved around."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:810
msgid ""
"The syntax of a numeric substitution is ``[[#%<fmtspec>, <constraint> "
"<expr>]]`` where:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:813
msgid ""
"``<fmtspec>`` is the same format specifier as for defining a variable but in "
"this context indicating how a numeric expression value should be matched "
"against. If absent, both components of the format specifier are inferred "
"from the matching format of the numeric variable(s) used by the expression "
"constraint if any, and defaults to ``%u`` if no numeric variable is used, "
"denoting that the value should be unsigned with no leading zeros. In case of "
"conflict between format specifiers of several numeric variables, the "
"conversion specifier becomes mandatory but the precision specifier remains "
"optional."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:823
msgid ""
"``<constraint>`` is the constraint describing how the value to match must "
"relate to the value of the numeric expression. The only currently accepted "
"constraint is ``==`` for an exact match and is the default if "
"``<constraint>`` is not provided. No matching constraint must be specified "
"when the ``<expr>`` is empty."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:829
msgid ""
"``<expr>`` is an expression. An expression is in turn recursively defined as:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:832
msgid "a numeric operand, or"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:833
msgid "an expression followed by an operator and a numeric operand."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:835
msgid ""
"A numeric operand is a previously defined numeric variable, an integer "
"literal, or a function. Spaces are accepted before, after and between any of "
"these elements. Numeric operands have 64-bit precision. Overflow and "
"underflow are rejected. There is no support for operator precedence, but "
"parentheses can be used to change the evaluation order."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:841
msgid "The supported operators are:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:843
msgid "``+`` - Returns the sum of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:844
msgid "``-`` - Returns the difference of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:846
msgid "The syntax of a function call is ``<name>(<arguments>)`` where:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:848
msgid "``name`` is a predefined string literal. Accepted values are:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:850
msgid "add - Returns the sum of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:851
msgid "div - Returns the quotient of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:852
msgid "max - Returns the largest of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:853
msgid "min - Returns the smallest of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:854
msgid "mul - Returns the product of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:855
msgid "sub - Returns the difference of its two operands."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:857
msgid "``<arguments>`` is a comma separated list of expressions."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:868
msgid "The above example would match the text:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:876
msgid "but would not match the text:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:884
msgid ""
"Due to ``7`` being unequal to ``5 + 1`` and ``a0463443`` being unequal to "
"``a0463440 + 7``."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:888
msgid ""
"A numeric variable can also be defined to the result of a numeric "
"expression, in which case the numeric expression constraint is checked and "
"if verified the variable is assigned to the value. The unified syntax for "
"both checking a numeric expression and capturing its value into a numeric "
"variable is thus ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each "
"element as described previously. One can use this syntax to make a testcase "
"more self-describing by using variables instead of values:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:901
msgid "which would match:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:908
msgid ""
"The ``--enable-var-scope`` option has the same effect on numeric variables "
"as on string variables."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:911
msgid ""
"Important note: In its current implementation, an expression cannot use a "
"numeric variable defined earlier in the same CHECK directive."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:915
msgid "FileCheck Pseudo Numeric Variables"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:917
msgid ""
"Sometimes there's a need to verify output that contains line numbers of the "
"match file, e.g. when testing compiler diagnostics.  This introduces a "
"certain fragility of the match file structure, as \"``CHECK:``\" lines "
"contain absolute line numbers in the same file, which have to be updated "
"whenever line numbers change due to text addition or deletion."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:923
msgid ""
"To support this case, FileCheck expressions understand the ``@LINE`` pseudo "
"numeric variable which evaluates to the line number of the CHECK pattern "
"where it is found."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:927
msgid ""
"This way match patterns can be put near the relevant test lines and include "
"relative line number references, for example:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:938
msgid ""
"To support legacy uses of ``@LINE`` as a special string variable, :program:"
"`FileCheck` also accepts the following uses of ``@LINE`` with string "
"substitution block syntax: ``[[@LINE]]``, ``[[@LINE+<offset>]]`` and "
"``[[@LINE-<offset>]]`` without any spaces inside the brackets and where "
"``offset`` is an integer."
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:945
msgid "Matching Newline Characters"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:947
msgid ""
"To match newline characters in regular expressions the character class ``[[:"
"space:]]`` can be used. For example, the following pattern:"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:954
msgid "matches output of the form (from llvm-dwarfdump):"
msgstr ""

#: ../../../CommandGuide/FileCheck.rst:961
msgid ""
"letting us set the :program:`FileCheck` variable ``DLOC`` to the desired "
"value ``0x00000233``, extracted from the line immediately preceding "
"\"``intd``\"."
msgstr ""
