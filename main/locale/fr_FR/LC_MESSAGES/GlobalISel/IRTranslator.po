# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../GlobalISel/IRTranslator.rst:4
msgid "IRTranslator"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:9
msgid ""
"This pass translates the input LLVM-IR ``Function`` to a :doc:`GMIR` "
"``MachineFunction``. This is typically a direct translation but does "
"occasionally get a bit more involved. For example:"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:17
msgid "becomes:"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:23
msgid "whereas"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:29
msgid "is translated according to the ABI rules of the target."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:33
msgid ""
"The currently implemented portion of the :doc:`../LangRef` is sufficient for "
"many compilations but it is not 100% complete. Users seeking to compile LLVM-"
"IR containing some of the rarer features may need to implement the "
"translation."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:39
msgid "Target Intrinsics"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:41
msgid ""
"There has been some (off-list) debate about whether to add target hooks for "
"translating target intrinsics. Among those who discussed it, it was "
"generally agreed that the IRTranslator should be able to lower target "
"intrinsics in a customizable way but no work has happened to implement this "
"at the time of writing."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:50
msgid "Translating Function Calls"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:52
msgid ""
"The ``IRTranslator`` also implements the ABI's calling convention by "
"lowering calls, returns, and arguments to the appropriate physical register "
"usage and instruction sequences. This is achieved using the ``CallLowering`` "
"interface, which provides several hooks that targets should implement: "
"``lowerFormalArguments``, ``lowerReturn``, ``lowerCall`` etc."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:58
msgid ""
"In essence, all of these hooks need to find a way to move the argument/"
"return values between the virtual registers used in the rest of the function "
"and either physical registers or the stack, as dictated by the ABI. This may "
"involve splitting large types into smaller ones, introducing sign/zero "
"extensions etc. In order to share as much of this code as possible between "
"the different backends, ``CallLowering`` makes available a few helpers and "
"interfaces:"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:65
msgid ""
"``ArgInfo`` - used for formal arguments, but also return values, actual "
"arguments and call results; contains info such as the IR type, the virtual "
"registers etc; large values will likely have to be split into several "
"``ArgInfo`` objects (``CallLowering::splitToValueTypes`` can help with that);"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:70
msgid ""
"``ValueAssigner`` - uses a ``CCAssignFn``, usually generated by TableGen "
"(see :ref:`backend-calling-convs`), to decide where to put each ``ArgInfo`` "
"(physical register or stack); backends can use the provided "
"``IncomingValueAssigner`` (for formal arguments and call results) and "
"``OutgoingValueAssigner`` (for actual arguments and function returns), but "
"it's also possible to subclass them;"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:77
msgid ""
"``ValueHandler`` - inserts the necessary instructions for putting each value "
"where it belongs; it has pure virtual methods for assigning values to "
"registers or to addresses, and a host of other helpers;"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:81
msgid ""
"``determineAndHandleAssignments`` (or for more fine grained control, "
"``determineAssignments`` and ``handleAssignments``) - contains some "
"boilerplate for invoking a given ``ValueAssigner`` and ``ValueHandler`` on a "
"series of ``ArgInfo`` objects."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:89
msgid "Aggregates"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:93
msgid ""
"This has changed since it was written and is no longer accurate. It has not "
"been refreshed in this pass of improving the documentation as I haven't "
"worked much in this part of the codebase and it should have attention from "
"someone more knowledgeable about it."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:98
msgid ""
"Aggregates are lowered into multiple virtual registers, similar to "
"SelectionDAG's multiple vregs via ``GetValueVTs``."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:101
msgid ""
"``TODO``: As some of the bits are undef (padding), we should consider "
"augmenting the representation with additional metadata (in effect, caching "
"computeKnownBits information on vregs). See `PR26161 <https://llvm.org/"
"PR26161>`_: [GlobalISel] Value to vreg during IR to MachineInstr translation "
"for aggregate type"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:111
msgid "Translation of Constants"
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:113
msgid ""
"Constant operands are translated as a use of a virtual register that is "
"defined by a ``G_CONSTANT`` or ``G_FCONSTANT`` instruction. These "
"instructions are placed in the entry block to allow them to be subject to "
"the continuous CSE implementation (``CSEMIRBuilder``). Their debug location "
"information is removed to prevent this from confusing debuggers."
msgstr ""

#: ../../../GlobalISel/IRTranslator.rst:119
msgid ""
"This is beneficial as it allows us to fold constants into immediate operands "
"during :ref:`instructionselect`, while still avoiding redundant "
"materializations for expensive non-foldable constants. However, this can "
"lead to unnecessary spills and reloads in an -O0 pipeline, as these virtual "
"registers can have long live ranges. This can be mitigated by running a "
"`localizer <https://github.com/llvm/llvm-project/blob/main/llvm/lib/CodeGen/"
"GlobalISel/Localizer.cpp>`_ after the translator."
msgstr ""
