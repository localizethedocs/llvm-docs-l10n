# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../MemoryModelRelaxationAnnotations.rst:3
msgid "Memory Model Relaxation Annotations"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:9
msgid "Introduction"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:11
msgid ""
"Memory Model Relaxation Annotations (MMRAs) are target-defined properties on "
"instructions that can be used to selectively relax constraints placed by the "
"memory model. For example:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:15
msgid ""
"The use of ``VulkanMemoryModel`` in a SPIRV program allows certain memory "
"operations to be reordered across ``acquire`` or ``release`` operations."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:18
msgid ""
"OpenCL APIs expose primitives to only fence a specific set of address "
"spaces. Carrying that information to the backend can enable the use of "
"faster synchronization instructions, rather than fencing all address spaces "
"everytime."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:23
msgid ""
"MMRAs offer an opt-in system for targets to relax the default LLVM memory "
"model. As such, they are attached to an operation using LLVM metadata which "
"can always be dropped without affecting correctness."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:29
msgid "Definitions"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:33
msgid "memory operation"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:32
msgid ""
"A load, a store, an atomic, or a function call that is marked as accessing "
"memory."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:37
msgid "synchronizing operation"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:36
msgid ""
"An instruction that synchronizes memory with other threads (e.g. an atomic "
"or a fence)."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:100
msgid "tag"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:40
msgid ""
"Metadata attached to a memory or synchronizing operation that represents "
"some target-defined property regarding memory synchronization."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:44
msgid ""
"An operation may have multiple tags that each represent a different property."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:47
msgid ""
"A tag is composed of a pair of metadata string: a *prefix* and a *suffix*."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:49
msgid ""
"In LLVM IR, the pair is represented using a metadata tuple. In other cases "
"(comments, documentation, etc.), we may use the ``prefix:suffix`` notation. "
"For example:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:54
msgid "Example: Tags in Metadata"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:63
msgid ""
"The only semantics relevant to the optimizer is the \"compatibility\" "
"relation defined below. All other semantics are target defined."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:67
msgid ""
"Tags can also be organised in lists to allow operations to specify all of "
"the tags they belong to. Such a list is referred to as a \"set of tags\"."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:71
msgid "Example: Set of Tags in Metadata"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:80
msgid ""
"If an operation does not have MMRA metadata, it's treated as if it has an "
"empty list (``!{}``) of tags."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:83
msgid ""
"Note that it is not an error if a tag is not recognized by the instruction "
"it is applied to, or by the current target. Such tags are simply ignored."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:87
msgid ""
"Both synchronizing operations and memory operations can have zero or more "
"tags attached to them using the ``!mmra`` syntax."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:90
msgid ""
"For the sake of readability in examples below, we use a (non-functional) "
"short syntax to represent MMMRA metadata:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:93
msgid "Short Syntax Example"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:99
msgid ""
"These two notations can be used in this document and are strictly "
"equivalent. However, only the second version is functional."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:113
msgid "compatibility"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:103
msgid ""
"Two sets of tags are said to be *compatible* iff, for every unique tag "
"prefix P present in at least one set:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:106
msgid "the other set contains no tag with prefix P, or"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:107
msgid "at least one tag with prefix P is common to both sets."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:109
msgid ""
"The above definition implies that an empty set is always compatible with any "
"other set. This is an important property as it ensures that if a transform "
"drops the metadata on an operation, it can never affect correctness. In "
"other words, the memory model cannot be relaxed further by deleting metadata "
"from instructions."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:118
msgid "The *happens-before* Relation"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:120
msgid ""
"Compatibility checks can be used to opt out of the *happens-before* relation "
"established between two instructions."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:138
msgid "Ordering"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:124
msgid ""
"When two instructions' metadata are not compatible, any program order "
"between them are not in *happens-before*."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:127
msgid ""
"For example, consider two tags ``foo:bar`` and ``foo:baz`` exposed by a "
"target:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:136
msgid ""
"In the above figure, ``A`` is compatible with ``X``, and hence ``A`` happens-"
"before ``X``. But ``B`` is not compatible with ``X``, and hence it is not "
"happens-before ``X``."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:151
msgid "Synchronization"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:141
msgid ""
"If an synchronizing operation has one or more tags, then whether it "
"synchronizes-with and participates in the  ``seq_cst`` order with other "
"operations is target dependent."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:145
msgid ""
"Whether the following example synchronizes with another sequence depends on "
"the target-defined semantics of ``foo:bar`` and ``foo:bux``."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:154
msgid "Examples"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:167
msgid "Example 1:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:162
msgid ""
"A and B are not ordered relative to each other (no *happens-before*) because "
"their sets of tags are not compatible."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:165
msgid ""
"Note that the ``sync-as`` value does not have to match the ``addrspace`` "
"value. e.g. In Example 1, a store-release to a location in ``addrspace(1)`` "
"wants to only synchronize with operations happening in ``addrspace(0)``."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:178
msgid "Example 2:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:175
#: ../../../MemoryModelRelaxationAnnotations.rst:186
msgid ""
"The ordering of A and B is unaffected because their set of tags are "
"compatible."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:178
msgid ""
"Note that A and B may or may not be in *happens-before* due to other reasons."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:187
msgid "Example 3:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:196
msgid "Example 4:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:195
msgid ""
"A and B do not have to be ordered relative to each other (no *happens-"
"before*) because their sets of tags are not compatible."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:199
msgid "Use-cases"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:202
msgid "SPIRV ``NonPrivatePointer``"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:204
msgid ""
"MMRAs can support the SPIRV capability ``VulkanMemoryModel``, where "
"synchronizing operations only affect memory operations that specify "
"``NonPrivatePointer`` semantics."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:208
msgid ""
"The example below is generated from a SPIRV program using the following "
"recipe:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:211
msgid "Add ``vulkan:nonprivate`` to every synchronizing operation."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:212
msgid ""
"Add ``vulkan:nonprivate`` to every non-atomic memory operation that is "
"marked ``NonPrivatePointer``."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:214
msgid ""
"Add ``vulkan:private`` to tags of every non-atomic memory operation that is "
"not marked ``NonPrivatePointer``."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:229
msgid ""
"Compatibility ensures that operation ``A`` is ordered relative to ``X`` "
"while operation ``D`` is ordered relative to ``Y``. If ``X`` synchronizes "
"with ``Y``, then ``A`` happens-before ``D``. No such relation can be "
"inferred about operations ``B`` and ``C``."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:235
msgid ""
"The `Vulkan Memory Model <https://registry.khronos.org/vulkan/specs/1.3-"
"extensions/html/vkspec.html#memory-model-non-private>`_ considers all atomic "
"operation non-private."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:238
msgid ""
"Whether ``vulkan:nonprivate`` would be specified on atomic operations is an "
"implementation detail, as an atomic operation is always ``nonprivate``. The "
"implementation may choose to be explicit and emit IR with ``vulkan:"
"nonprivate`` on every atomic operation, or it could choose to only emit "
"``vulkan::private`` and assume ``vulkan:nonprivate`` by default."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:245
msgid ""
"Operations marked with ``vulkan:private`` effectively opt out of the happens-"
"before order in a SPIRV program since they are incompatible with every "
"synchronizing operation. Note that SPIRV operations that are not marked "
"``NonPrivatePointer`` are not entirely private to the thread --- they are "
"implicitly synchronized at the start or end of a thread by the Vulkan "
"*system-synchronizes-with* relationship. This example assumes that the "
"target-defined semantics of ``vulkan:private`` correctly implements this "
"property."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:254
msgid ""
"This scheme is general enough to express the interoperability of SPIRV "
"programs with other environments."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:267
msgid ""
"In the above example, thread ``T1`` originates from a SPIRV program while "
"thread ``T2`` originates from a non-SPIRV program. Whether ``X`` can "
"synchronize with ``Y`` is target defined.  If ``X`` synchronizes with ``Y``, "
"then ``A`` happens before ``B`` (because A/X and Y/B are compatible)."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:274
msgid "Implementation Example"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:276
msgid ""
"Consider the implementation of SPIRV ``NonPrivatePointer`` on a target where "
"all memory operations are cached, and the entire cache is flushed or "
"invalidated at a ``release`` or ``acquire`` respectively. A possible scheme "
"is that when translating a SPIRV program, memory operations marked "
"``NonPrivatePointer`` should not be cached, and the cache contents should "
"not be touched during an ``acquire`` and ``release`` operation."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:284
msgid ""
"This could be implemented using the tags that share the ``vulkan:`` prefix, "
"as follows:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:287
msgid "For memory operations:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:289
msgid "Operations with ``vulkan:nonprivate`` should bypass the cache."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:290
msgid "Operations with ``vulkan:private`` should be cached."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:291
msgid ""
"Operations that specify neither or both should conservatively bypass the "
"cache to ensure correctness."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:294
msgid "For synchronizing operations:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:296
msgid ""
"Operations with ``vulkan:nonprivate`` should not flush or invalidate the "
"cache."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:298
msgid ""
"Operations with ``vulkan:private`` should flush or invalidate the cache."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:299
msgid ""
"Operations that specify neither or both should conservatively flush or "
"invalidate the cache to ensure correctness."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:303
msgid ""
"In such an implementation, dropping the metadata on an operation, while not "
"affecting correctness, may have big performance implications. e.g. an "
"operation bypasses the cache when it shouldn't."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:308
msgid "Memory Types"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:310
msgid ""
"MMRAs may express the selective synchronization of different memory types."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:313
msgid ""
"As an example, a target may expose an ``sync-as:<N>`` tag to pass "
"information about which address spaces are synchronized by the execution of "
"a synchronizing operation."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:318
msgid ""
"Address spaces are used here as a common example, but this concept can apply "
"for other \"memory types\". What \"memory types\" means here is up to the "
"target."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:337
msgid ""
"In the above figure, ``X`` and ``Y`` are atomic operations on a location in "
"the ``global``  address space. If ``X`` synchronizes with ``Y``, then ``B`` "
"happens-before ``C`` in the ``local`` address space. But no such statement "
"can be made about operations ``A`` and ``D``, although they are performed on "
"a location in the ``global`` address space."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:345
msgid "Implementation Example: Adding Address Space Information to Fences"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:347
msgid ""
"Languages such as OpenCL C provide fence operations such as "
"``atomic_work_item_fence`` that can take an explicit address space to fence."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:351
msgid ""
"By default, LLVM has no means to carry that information in the IR, so the "
"information is lost during lowering to LLVM IR. This means that targets such "
"as AMDGPU have to conservatively emit instructions to fence all address "
"spaces in all cases, which can have a noticeable performance impact in high-"
"performance applications."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:357
msgid ""
"MMRAs may be used to preserve that information at the IR level, all the way "
"through code generation. For example, a fence that only affects the global "
"address space ``addrspace(1)`` may be lowered as"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:365
msgid ""
"and the target may use the presence of ``sync-as:1`` to infer that it must "
"only emit instruction to fence the global address space."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:368
msgid ""
"Note that as MMRAs are opt in, a fence that does not have MMRA metadata "
"could still be lowered conservatively, so this optimization would only apply "
"if the front-end emits the MMRA metadata on the fence instructions."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:373
msgid "Additional Topics"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:377
msgid "The following sections are informational."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:380
msgid "Performance Impact"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:382
msgid ""
"MMRAs are a way to capture optimization opportunities in the program. But "
"when an operation mentions no tags or conflicting tags, the target may need "
"to produce conservative code to ensure correctness at the cost of "
"performance. This can happen in the following situations:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:387
msgid ""
"When a target first introduces MMRAs, the frontend might not have been "
"updated to emit them."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:389
msgid "An optimization may drop MMRA metadata."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:390
msgid "An optimization may add arbitrary tags to an operation."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:392
msgid ""
"Note that targets can always choose to ignore (or even drop) MMRAs and "
"revert to the default behavior/codegen heuristics without affecting "
"correctness."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:397
msgid "Consequences of the Absence of *happens-before*"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:399
msgid ""
"In the :ref:`happens-before<HappensBefore>` section, we defined how an "
"*happens-before* relation between two instruction can be broken by "
"leveraging compatibility between MMRAs. When the instructions are "
"incompatible and there is no *happens-before* relation, we say that the "
"instructions \"do not have to be ordered relative to each other\"."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:406
msgid ""
"\"Ordering\" in this context is a very broad term which covers both static "
"and runtime aspects."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:409
msgid ""
"When there is no ordering constraint, we *could* statically reorder the "
"instructions in an optimizer transform if the reordering does not break "
"other constraints as single location coherence. Static reordering is one "
"consequence of breaking *happens-before*, but is not the most interesting "
"one."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:415
msgid ""
"Run-time consequences are more interesting. When there is an *happens-"
"before* relation between instructions, the target has to emit "
"synchronization code to ensure other threads will observe the effects of the "
"instructions in the right order."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:420
msgid ""
"For instance, the target may have to wait for previous loads & stores to "
"finish before starting a fence-release, or there may be a need to flush a "
"memory cache before executing the next instruction. In the absence of "
"*happens-before*, there is no such requirement and no waiting or flushing is "
"required. This may noticeably speed up execution in some cases."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:428
msgid "Combining Operations"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:430
msgid ""
"If a pass can combine multiple memory or synchronizing operations into one, "
"it needs to be able to combine MMRAs. One possible way to achieve this is by "
"doing a prefix-wise union of the tag sets."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:434
msgid ""
"Let A and B be two tags set, and U be the prefix-wise union of A and B. For "
"every unique tag prefix P present in A or B:"
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:437
msgid ""
"If either A or B has no tags with prefix P, no tags with prefix P are added "
"to U."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:439
msgid ""
"If both A and B have at least one tag with prefix P, all tags with prefix P "
"from both sets are added to U."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:442
msgid ""
"Passes should avoid aggressively combining MMRAs, as this can result in "
"significant losses of information. While this cannot affect correctness, it "
"may affect performance."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:446
msgid ""
"As a general rule of thumb, common passes such as SimplifyCFG that "
"aggressively combine/reorder operations should only combine instructions "
"that have identical sets of tags. Passes that combine less frequently, or "
"that are well aware of the cost of combining the MMRAs can use the prefix-"
"wise union described above."
msgstr ""

#: ../../../MemoryModelRelaxationAnnotations.rst:452
msgid "Examples:"
msgstr ""
