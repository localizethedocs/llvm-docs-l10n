# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TableGen/index.rst:3
msgid "TableGen"
msgstr ""

#: ../../../TableGen/index.rst:17
msgid "Introduction"
msgstr ""

#: ../../../TableGen/index.rst:19
msgid ""
"TableGen's purpose is to help a human develop and maintain records of domain-"
"specific information.  Because there may be a large number of these records, "
"it is specifically designed to allow writing flexible descriptions and for "
"common features of these records to be factored out.  This reduces the "
"amount of duplication in the description, reduces the chance of error, and "
"makes it easier to structure domain specific information."
msgstr ""

#: ../../../TableGen/index.rst:26
msgid ""
"The core part of TableGen parses a file, instantiates the declarations, and "
"hands the result off to a domain-specific `backend`_ for processing."
msgstr ""

#: ../../../TableGen/index.rst:29
msgid ""
"The current major users of TableGen are :doc:`../CodeGenerator` and the "
"`Clang diagnostics and attributes <http://clang.llvm.org/docs/UsersManual."
"html#controlling-errors-and-warnings>`_."
msgstr ""

#: ../../../TableGen/index.rst:33
msgid ""
"Note that if you work on TableGen much, and use emacs or vim, that you can "
"find an emacs \"TableGen mode\" and a vim language file in the ``llvm/utils/"
"emacs`` and ``llvm/utils/vim`` directories of your LLVM distribution, "
"respectively."
msgstr ""

#: ../../../TableGen/index.rst:41
msgid "The TableGen program"
msgstr ""

#: ../../../TableGen/index.rst:43
msgid ""
"TableGen files are interpreted by the TableGen program: `llvm-tblgen` "
"available on your build directory under `bin`. It is not installed in the "
"system (or where your sysroot is set to), since it has no use beyond LLVM's "
"build process."
msgstr ""

#: ../../../TableGen/index.rst:48
msgid "Running TableGen"
msgstr ""

#: ../../../TableGen/index.rst:50
msgid ""
"TableGen runs just like any other LLVM tool.  The first (optional) argument "
"specifies the file to read.  If a filename is not specified, ``llvm-tblgen`` "
"reads from standard input."
msgstr ""

#: ../../../TableGen/index.rst:54
msgid ""
"To be useful, one of the `backends`_ must be used.  These backends are "
"selectable on the command line (type '``llvm-tblgen -help``' for a list).  "
"For example, to get a list of all of the definitions that subclass a "
"particular type (which can be useful for building up an enum list of these "
"records), use the ``-print-enums`` option:"
msgstr ""

#: ../../../TableGen/index.rst:79
msgid "The default backend prints out all of the records."
msgstr ""

#: ../../../TableGen/index.rst:81
msgid ""
"If you plan to use TableGen, you will most likely have to write a `backend`_ "
"that extracts the information specific to what you need and formats it in "
"the appropriate way."
msgstr ""

#: ../../../TableGen/index.rst:86
msgid "Example"
msgstr ""

#: ../../../TableGen/index.rst:88
msgid ""
"With no other arguments, `llvm-tblgen` parses the specified file and prints "
"out all of the classes, then all of the definitions.  This is a good way to "
"see what the various definitions expand to fully.  Running this on the ``X86."
"td`` file prints this (at the time of this writing):"
msgstr ""

#: ../../../TableGen/index.rst:143
msgid ""
"This definition corresponds to the 32-bit register-register ``add`` "
"instruction of the x86 architecture.  ``def ADD32rr`` defines a record named "
"``ADD32rr``, and the comment at the end of the line indicates the "
"superclasses of the definition.  The body of the record contains all of the "
"data that TableGen assembled for the record, indicating that the instruction "
"is part of the \"X86\" namespace, the pattern indicating how the instruction "
"is selected by the code generator, that it is a two-address instruction, has "
"a particular encoding, etc.  The contents and semantics of the information "
"in the record are specific to the needs of the X86 backend, and are only "
"shown as an example."
msgstr ""

#: ../../../TableGen/index.rst:153
msgid ""
"As you can see, a lot of information is needed for every instruction "
"supported by the code generator, and specifying it all manually would be "
"unmaintainable, prone to bugs, and tiring to do in the first place.  Because "
"we are using TableGen, all of the information was derived from the following "
"definition:"
msgstr ""

#: ../../../TableGen/index.rst:168
msgid ""
"This definition makes use of the custom class ``I`` (extended from the "
"custom class ``X86Inst``), which is defined in the X86-specific TableGen "
"file, to factor out the common features that instructions of its class "
"share.  A key feature of TableGen is that it allows the end-user to define "
"the abstractions they prefer to use when describing their information."
msgstr ""

#: ../../../TableGen/index.rst:174
msgid ""
"Each ``def`` record has a special entry called \"NAME\".  This is the name "
"of the record (\"``ADD32rr``\" above).  In the general case ``def`` names "
"can be formed from various kinds of string processing expressions and "
"``NAME`` resolves to the final value obtained after resolving all of those "
"expressions.  The user may refer to ``NAME`` anywhere she desires to use the "
"ultimate name of the ``def``. ``NAME`` should not be defined anywhere else "
"in user code to avoid conflicts."
msgstr ""

#: ../../../TableGen/index.rst:182
msgid "Syntax"
msgstr ""

#: ../../../TableGen/index.rst:184
msgid ""
"TableGen has a syntax that is loosely based on C++ templates, with built-in "
"types and specification. In addition, TableGen's syntax introduces some "
"automation concepts like multiclass, foreach, let, etc."
msgstr ""

#: ../../../TableGen/index.rst:189
msgid "Basic concepts"
msgstr ""

#: ../../../TableGen/index.rst:191
msgid ""
"TableGen files consist of two key parts: 'classes' and 'definitions', both "
"of which are considered 'records'."
msgstr ""

#: ../../../TableGen/index.rst:194
msgid ""
"**TableGen records** have a unique name, a list of values, and a list of "
"superclasses.  The list of values is the main data that TableGen builds for "
"each record; it is this that holds the domain specific information for the "
"application.  The interpretation of this data is left to a specific "
"`backend`_, but the structure and format rules are taken care of and are "
"fixed by TableGen."
msgstr ""

#: ../../../TableGen/index.rst:201
msgid ""
"**TableGen definitions** are the concrete form of 'records'.  These "
"generally do not have any undefined values, and are marked with the "
"'``def``' keyword."
msgstr ""

#: ../../../TableGen/index.rst:209
msgid ""
"In this example, FeatureFPARMv8 is ``SubtargetFeature`` record initialised "
"with some values. The names of the classes are defined via the keyword "
"`class` either on the same file or some other included. Most target TableGen "
"files include the generic ones in ``include/llvm/Target``."
msgstr ""

#: ../../../TableGen/index.rst:214
msgid ""
"**TableGen classes** are abstract records that are used to build and "
"describe other records.  These classes allow the end-user to build "
"abstractions for either the domain they are targeting (such as \"Register\", "
"\"RegisterClass\", and \"Instruction\" in the LLVM code generator) or for "
"the implementor to help factor out common properties of records (such as "
"\"FPInst\", which is used to represent floating point instructions in the "
"X86 backend).  TableGen keeps track of all of the classes that are used to "
"build up a definition, so the backend can find all definitions of a "
"particular class, such as \"Instruction\"."
msgstr ""

#: ../../../TableGen/index.rst:228
msgid ""
"Here, the class ProcNoItin, receiving parameters `Name` of type `string` and "
"a list of target features is specializing the class Processor by passing the "
"arguments down as well as hard-coding NoItineraries."
msgstr ""

#: ../../../TableGen/index.rst:232
msgid ""
"**TableGen multiclasses** are groups of abstract records that are "
"instantiated all at once.  Each instantiation can result in multiple "
"TableGen definitions. If a multiclass inherits from another multiclass, the "
"definitions in the sub-multiclass become part of the current multiclass, as "
"if they were declared in the current multiclass."
msgstr ""

#: ../../../TableGen/index.rst:258
msgid ""
"See the :doc:`TableGen Language Introduction <LangIntro>` for more generic "
"information on the usage of the language, and the :doc:`TableGen Language "
"Reference <LangRef>` for more in-depth description of the formal language "
"specification."
msgstr ""

#: ../../../TableGen/index.rst:267
msgid "TableGen backends"
msgstr ""

#: ../../../TableGen/index.rst:269
msgid ""
"TableGen files have no real meaning without a back-end. The default "
"operation of running ``llvm-tblgen`` is to print the information in a "
"textual format, but that's only useful for debugging of the TableGen files "
"themselves. The power in TableGen is, however, to interpret the source files "
"into an internal representation that can be generated into anything you want."
msgstr ""

#: ../../../TableGen/index.rst:275
msgid ""
"Current usage of TableGen is to create huge include files with tables that "
"you can either include directly (if the output is in the language you're "
"coding), or be used in pre-processing via macros surrounding the include of "
"the file."
msgstr ""

#: ../../../TableGen/index.rst:279
msgid ""
"Direct output can be used if the back-end already prints a table in C format "
"or if the output is just a list of strings (for error and warning messages). "
"Pre-processed output should be used if the same information needs to be used "
"in different contexts (like Instruction names), so your back-end should "
"print a meta-information list that can be shaped into different compile-time "
"formats."
msgstr ""

#: ../../../TableGen/index.rst:285
msgid "See the `TableGen BackEnds <BackEnds.html>`_ for more information."
msgstr ""

#: ../../../TableGen/index.rst:288
msgid "TableGen Deficiencies"
msgstr ""

#: ../../../TableGen/index.rst:290
msgid ""
"Despite being very generic, TableGen has some deficiencies that have been "
"pointed out numerous times. The common theme is that, while TableGen allows "
"you to build Domain-Specific-Languages, the final languages that you create "
"lack the power of other DSLs, which in turn increase considerably the size "
"and complexity of TableGen files."
msgstr ""

#: ../../../TableGen/index.rst:296
msgid ""
"At the same time, TableGen allows you to create virtually any meaning of the "
"basic concepts via custom-made back-ends, which can pervert the original "
"design and make it very hard for newcomers to understand the evil TableGen "
"file."
msgstr ""

#: ../../../TableGen/index.rst:301
msgid ""
"There are some in favour of extending the semantics even more, but making "
"sure back-ends adhere to strict rules. Others are suggesting we should move "
"to less, more powerful DSLs designed with specific purposes, or even re-"
"using existing DSLs."
msgstr ""

#: ../../../TableGen/index.rst:306
msgid ""
"Either way, this is a discussion that will likely span across several years, "
"if not decades. You can read more in the `TableGen Deficiencies "
"<Deficiencies.html>`_ document."
msgstr ""
