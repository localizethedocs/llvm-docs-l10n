
<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1. Kaleidoscope: Tutorial Introduction and the Lexer &#8212; LLVM 3.9 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../_static/llvm-theme.css?v=4c4af0c1" />
    <script src="../_static/documentation_options.js?v=e0098335"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/llvm-docs-l10n/tutorial/LangImpl01.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="2. Kaleidoscope: Implementing a Parser and AST" href="LangImpl02.html" />
    <link rel="prev" title="LLVM Tutorial: Table of Contents" href="index.html" />
<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="LangImpl02.html" title="2. Kaleidoscope: Implementing a Parser and AST"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="index.html" title="LLVM Tutorial: Table of Contents"
             accesskey="P">上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">LLVM Tutorial: Table of Contents</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">1. </span>Kaleidoscope: Tutorial Introduction and the Lexer</a></li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="kaleidoscope-tutorial-introduction-and-the-lexer">
<h1><span class="section-number">1. </span>Kaleidoscope: Tutorial Introduction and the Lexer<a class="headerlink" href="#kaleidoscope-tutorial-introduction-and-the-lexer" title="連結到這個標頭">¶</a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#tutorial-introduction" id="id2">Tutorial Introduction</a></p></li>
<li><p><a class="reference internal" href="#the-basic-language" id="id3">The Basic Language</a></p></li>
<li><p><a class="reference internal" href="#the-lexer" id="id4">The Lexer</a></p></li>
</ul>
</nav>
<section id="tutorial-introduction">
<h2><a class="toc-backref" href="#id2" role="doc-backlink"><span class="section-number">1.1. </span>Tutorial Introduction</a><a class="headerlink" href="#tutorial-introduction" title="連結到這個標頭">¶</a></h2>
<p>Welcome to the &quot;Implementing a language with LLVM&quot; tutorial. This
tutorial runs through the implementation of a simple language, showing
how fun and easy it can be. This tutorial will get you up and started as
well as help to build a framework you can extend to other languages. The
code in this tutorial can also be used as a playground to hack on other
LLVM specific things.</p>
<p>The goal of this tutorial is to progressively unveil our language,
describing how it is built up over time. This will let us cover a fairly
broad range of language design and LLVM-specific usage issues, showing
and explaining the code for it all along the way, without overwhelming
you with tons of details up front.</p>
<p>It is useful to point out ahead of time that this tutorial is really
about teaching compiler techniques and LLVM specifically, <em>not</em> about
teaching modern and sane software engineering principles. In practice,
this means that we'll take a number of shortcuts to simplify the
exposition. For example, the code uses global variables
all over the place, doesn't use nice design patterns like
<a class="reference external" href="http://en.wikipedia.org/wiki/Visitor_pattern">visitors</a>, etc... but
it is very simple. If you dig in and use the code as a basis for future
projects, fixing these deficiencies shouldn't be hard.</p>
<p>I've tried to put this tutorial together in a way that makes chapters
easy to skip over if you are already familiar with or are uninterested
in the various pieces. The structure of the tutorial is:</p>
<ul class="simple">
<li><p><a class="reference external" href="#language">Chapter #1</a>: Introduction to the Kaleidoscope
language, and the definition of its Lexer - This shows where we are
going and the basic functionality that we want it to do. In order to
make this tutorial maximally understandable and hackable, we choose
to implement everything in C++ instead of using lexer and parser
generators. LLVM obviously works just fine with such tools, feel free
to use one if you prefer.</p></li>
<li><p><a class="reference external" href="LangImpl02.html">Chapter #2</a>: Implementing a Parser and AST -
With the lexer in place, we can talk about parsing techniques and
basic AST construction. This tutorial describes recursive descent
parsing and operator precedence parsing. Nothing in Chapters 1 or 2
is LLVM-specific, the code doesn't even link in LLVM at this point.
:)</p></li>
<li><p><a class="reference external" href="LangImpl03.html">Chapter #3</a>: Code generation to LLVM IR - With
the AST ready, we can show off how easy generation of LLVM IR really
is.</p></li>
<li><p><a class="reference external" href="LangImpl04.html">Chapter #4</a>: Adding JIT and Optimizer Support
- Because a lot of people are interested in using LLVM as a JIT,
we'll dive right into it and show you the 3 lines it takes to add JIT
support. LLVM is also useful in many other ways, but this is one
simple and &quot;sexy&quot; way to show off its power. :)</p></li>
<li><p><a class="reference external" href="LangImpl05.html">Chapter #5</a>: Extending the Language: Control
Flow - With the language up and running, we show how to extend it
with control flow operations (if/then/else and a 'for' loop). This
gives us a chance to talk about simple SSA construction and control
flow.</p></li>
<li><p><a class="reference external" href="LangImpl06.html">Chapter #6</a>: Extending the Language:
User-defined Operators - This is a silly but fun chapter that talks
about extending the language to let the user program define their own
arbitrary unary and binary operators (with assignable precedence!).
This lets us build a significant piece of the &quot;language&quot; as library
routines.</p></li>
<li><p><a class="reference external" href="LangImpl07.html">Chapter #7</a>: Extending the Language: Mutable
Variables - This chapter talks about adding user-defined local
variables along with an assignment operator. The interesting part
about this is how easy and trivial it is to construct SSA form in
LLVM: no, LLVM does <em>not</em> require your front-end to construct SSA
form!</p></li>
<li><p><a class="reference external" href="LangImpl08.html">Chapter #8</a>: Compiling to Object Files - This
chapter explains how to take LLVM IR and compile it down to object
files.</p></li>
<li><p><a class="reference external" href="LangImpl09.html">Chapter #9</a>: Extending the Language: Debug
Information - Having built a decent little programming language with
control flow, functions and mutable variables, we consider what it
takes to add debug information to standalone executables. This debug
information will allow you to set breakpoints in Kaleidoscope
functions, print out argument variables, and call functions - all
from within the debugger!</p></li>
<li><p><a class="reference external" href="LangImpl10.html">Chapter #10</a>: Conclusion and other useful LLVM
tidbits - This chapter wraps up the series by talking about
potential ways to extend the language, but also includes a bunch of
pointers to info about &quot;special topics&quot; like adding garbage
collection support, exceptions, debugging, support for &quot;spaghetti
stacks&quot;, and a bunch of other tips and tricks.</p></li>
</ul>
<p>By the end of the tutorial, we'll have written a bit less than 1000 lines
of non-comment, non-blank, lines of code. With this small amount of
code, we'll have built up a very reasonable compiler for a non-trivial
language including a hand-written lexer, parser, AST, as well as code
generation support with a JIT compiler. While other systems may have
interesting &quot;hello world&quot; tutorials, I think the breadth of this
tutorial is a great testament to the strengths of LLVM and why you
should consider it if you're interested in language or compiler design.</p>
<p>A note about this tutorial: we expect you to extend the language and
play with it on your own. Take the code and go crazy hacking away at it,
compilers don't need to be scary creatures - it can be a lot of fun to
play with languages!</p>
</section>
<section id="the-basic-language">
<h2><a class="toc-backref" href="#id3" role="doc-backlink"><span class="section-number">1.2. </span>The Basic Language</a><a class="headerlink" href="#the-basic-language" title="連結到這個標頭">¶</a></h2>
<p>This tutorial will be illustrated with a toy language that we'll call
&quot;<a class="reference external" href="http://en.wikipedia.org/wiki/Kaleidoscope">Kaleidoscope</a>&quot; (derived
from &quot;meaning beautiful, form, and view&quot;). Kaleidoscope is a procedural
language that allows you to define functions, use conditionals, math,
etc. Over the course of the tutorial, we'll extend Kaleidoscope to
support the if/then/else construct, a for loop, user defined operators,
JIT compilation with a simple command line interface, etc.</p>
<p>Because we want to keep things simple, the only datatype in Kaleidoscope
is a 64-bit floating point type (aka 'double' in C parlance). As such,
all values are implicitly double precision and the language doesn't
require type declarations. This gives the language a very nice and
simple syntax. For example, the following simple example computes
<a class="reference external" href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers:</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute the x&#39;th fibonacci number.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fib</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="n">then</span>
    <span class="mi">1</span>
  <span class="k">else</span>
    <span class="n">fib</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># This expression will compute the 40th number.</span>
<span class="n">fib</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>We also allow Kaleidoscope to call into standard library functions (the
LLVM JIT makes this completely trivial). This means that you can use the
'extern' keyword to define a function before you use it (this is also
useful for mutually recursive functions). For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">sin</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">cos</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">atan2</span><span class="p">(</span><span class="n">arg1</span> <span class="n">arg2</span><span class="p">);</span>

<span class="n">atan2</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mf">.4</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
</pre></div>
</div>
<p>A more interesting example is included in Chapter 6 where we write a
little Kaleidoscope application that <a class="reference external" href="LangImpl06.html#kicking-the-tires">displays a Mandelbrot
Set</a> at various levels of magnification.</p>
<p>Lets dive into the implementation of this language!</p>
</section>
<section id="the-lexer">
<h2><a class="toc-backref" href="#id4" role="doc-backlink"><span class="section-number">1.3. </span>The Lexer</a><a class="headerlink" href="#the-lexer" title="連結到這個標頭">¶</a></h2>
<p>When it comes to implementing a language, the first thing needed is the
ability to process a text file and recognize what it says. The
traditional way to do this is to use a
&quot;<a class="reference external" href="http://en.wikipedia.org/wiki/Lexical_analysis">lexer</a>&quot; (aka
'scanner') to break the input up into &quot;tokens&quot;. Each token returned by
the lexer includes a token code and potentially some metadata (e.g. the
numeric value of a number). First, we define the possibilities:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span>
<span class="c1">// of these for known things.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">Token</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">tok_eof</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>

<span class="w">  </span><span class="c1">// commands</span>
<span class="w">  </span><span class="n">tok_def</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-2</span><span class="p">,</span>
<span class="w">  </span><span class="n">tok_extern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-3</span><span class="p">,</span>

<span class="w">  </span><span class="c1">// primary</span>
<span class="w">  </span><span class="n">tok_identifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-4</span><span class="p">,</span>
<span class="w">  </span><span class="n">tok_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-5</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">IdentifierStr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Filled in if tok_identifier</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">NumVal</span><span class="p">;</span><span class="w">             </span><span class="c1">// Filled in if tok_number</span>
</pre></div>
</div>
<p>Each token returned by our lexer will either be one of the Token enum
values or it will be an 'unknown' character like '+', which is returned
as its ASCII value. If the current token is an identifier, the
<code class="docutils literal notranslate"><span class="pre">IdentifierStr</span></code> global variable holds the name of the identifier. If
the current token is a numeric literal (like 1.0), <code class="docutils literal notranslate"><span class="pre">NumVal</span></code> holds its
value. Note that we use global variables for simplicity, this is not the
best choice for a real language implementation :).</p>
<p>The actual implementation of the lexer is a single function named
<code class="docutils literal notranslate"><span class="pre">gettok</span></code>. The <code class="docutils literal notranslate"><span class="pre">gettok</span></code> function is called to return the next token
from standard input. Its definition starts as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// gettok - Return the next token from standard input.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">gettok</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">LastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Skip any whitespace.</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span>
<span class="w">    </span><span class="n">LastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getchar</span><span class="p">();</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gettok</span></code> works by calling the C <code class="docutils literal notranslate"><span class="pre">getchar()</span></code> function to read
characters one at a time from standard input. It eats them as it
recognizes them and stores the last character read, but not processed,
in LastChar. The first thing that it has to do is ignore whitespace
between tokens. This is accomplished with the loop above.</p>
<p>The next thing <code class="docutils literal notranslate"><span class="pre">gettok</span></code> needs to do is recognize identifiers and
specific keywords like &quot;def&quot;. Kaleidoscope does this with this simple
loop:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// identifier: [a-zA-Z][a-zA-Z0-9]*</span>
<span class="w">  </span><span class="n">IdentifierStr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LastChar</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">isalnum</span><span class="p">((</span><span class="n">LastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getchar</span><span class="p">())))</span>
<span class="w">    </span><span class="n">IdentifierStr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">LastChar</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IdentifierStr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;def&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tok_def</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IdentifierStr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;extern&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tok_extern</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">tok_identifier</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that this code sets the '<code class="docutils literal notranslate"><span class="pre">IdentifierStr</span></code>' global whenever it
lexes an identifier. Also, since language keywords are matched by the
same loop, we handle them here inline. Numeric values are similar:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">LastChar</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// Number: [0-9.]+</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">NumStr</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NumStr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">LastChar</span><span class="p">;</span>
<span class="w">    </span><span class="n">LastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getchar</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">LastChar</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">);</span>

<span class="w">  </span><span class="n">NumVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strtod</span><span class="p">(</span><span class="n">NumStr</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">tok_number</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is all pretty straight-forward code for processing input. When
reading a numeric value from input, we use the C <code class="docutils literal notranslate"><span class="pre">strtod</span></code> function to
convert it to a numeric value that we store in <code class="docutils literal notranslate"><span class="pre">NumVal</span></code>. Note that
this isn't doing sufficient error checking: it will incorrectly read
&quot;1.23.45.67&quot; and handle it as if you typed in &quot;1.23&quot;. Feel free to
extend it :). Next we handle comments:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">LastChar</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;#&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Comment until end of line.</span>
<span class="w">  </span><span class="k">do</span>
<span class="w">    </span><span class="n">LastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getchar</span><span class="p">();</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">LastChar</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EOF</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">LastChar</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">LastChar</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\r&#39;</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">LastChar</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EOF</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">gettok</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We handle comments by skipping to the end of the line and then return
the next token. Finally, if the input doesn't match one of the above
cases, it is either an operator character like '+' or the end of the
file. These are handled with this code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Check for end of file.  Don&#39;t eat the EOF.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">LastChar</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EOF</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tok_eof</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Otherwise, just return the character as its ascii value.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ThisChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LastChar</span><span class="p">;</span>
<span class="w">  </span><span class="n">LastChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getchar</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ThisChar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this, we have the complete lexer for the basic Kaleidoscope
language (the <a class="reference external" href="LangImpl02.html#full-code-listing">full code listing</a> for the Lexer
is available in the <a class="reference external" href="LangImpl02.html">next chapter</a> of the tutorial).
Next we'll <a class="reference external" href="LangImpl02.html">build a simple parser that uses this to build an Abstract
Syntax Tree</a>. When we have that, we'll include a
driver so that you can use the lexer and parser together.</p>
<p><a class="reference external" href="LangImpl02.html">Next: Implementing a Parser and AST</a></p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="LangImpl02.html" title="2. Kaleidoscope: Implementing a Parser and AST"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="index.html" title="LLVM Tutorial: Table of Contents"
             >上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >LLVM Tutorial: Table of Contents</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">1. </span>Kaleidoscope: Tutorial Introduction and the Lexer</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; 版權所有 2003-2025, LLVM Project.
      最後更新於 2025-11-11。
      使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3 建立。
    </div>
  </body>
</html>