
<!DOCTYPE html>

<html lang="zh-TW" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Auto-Vectorization in LLVM &#8212; LLVM 3.9 說明文件</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=4c4af0c1" />
    <script src="_static/documentation_options.js?v=e0098335"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/llvm-docs-l10n/Vectorizers.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜尋" href="search.html" />
    <link rel="next" title="Writing an LLVM Backend" href="WritingAnLLVMBackend.html" />
    <link rel="prev" title="Source Level Debugging with LLVM" href="SourceLevelDebugging.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="WritingAnLLVMBackend.html" title="Writing an LLVM Backend"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="SourceLevelDebugging.html" title="Source Level Debugging with LLVM"
             accesskey="P">上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Auto-Vectorization in LLVM</a></li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="auto-vectorization-in-llvm">
<h1>Auto-Vectorization in LLVM<a class="headerlink" href="#auto-vectorization-in-llvm" title="連結到這個標頭">¶</a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#the-loop-vectorizer" id="id3">The Loop Vectorizer</a></p>
<ul>
<li><p><a class="reference internal" href="#usage" id="id4">Usage</a></p>
<ul>
<li><p><a class="reference internal" href="#command-line-flags" id="id5">Command line flags</a></p></li>
<li><p><a class="reference internal" href="#pragma-loop-hint-directives" id="id6">Pragma loop hint directives</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#diagnostics" id="id7">Diagnostics</a></p></li>
<li><p><a class="reference internal" href="#features" id="id8">Features</a></p>
<ul>
<li><p><a class="reference internal" href="#loops-with-unknown-trip-count" id="id9">Loops with unknown trip count</a></p></li>
<li><p><a class="reference internal" href="#runtime-checks-of-pointers" id="id10">Runtime Checks of Pointers</a></p></li>
<li><p><a class="reference internal" href="#reductions" id="id11">Reductions</a></p></li>
<li><p><a class="reference internal" href="#inductions" id="id12">Inductions</a></p></li>
<li><p><a class="reference internal" href="#if-conversion" id="id13">If Conversion</a></p></li>
<li><p><a class="reference internal" href="#pointer-induction-variables" id="id14">Pointer Induction Variables</a></p></li>
<li><p><a class="reference internal" href="#reverse-iterators" id="id15">Reverse Iterators</a></p></li>
<li><p><a class="reference internal" href="#scatter-gather" id="id16">Scatter / Gather</a></p></li>
<li><p><a class="reference internal" href="#vectorization-of-mixed-types" id="id17">Vectorization of Mixed Types</a></p></li>
<li><p><a class="reference internal" href="#global-structures-alias-analysis" id="id18">Global Structures Alias Analysis</a></p></li>
<li><p><a class="reference internal" href="#vectorization-of-function-calls" id="id19">Vectorization of function calls</a></p></li>
<li><p><a class="reference internal" href="#partial-unrolling-during-vectorization" id="id20">Partial unrolling during vectorization</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#performance" id="id21">Performance</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-slp-vectorizer" id="id22">The SLP Vectorizer</a></p>
<ul>
<li><p><a class="reference internal" href="#details" id="id23">Details</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id24">Usage</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>LLVM has two vectorizers: The <a class="reference internal" href="#loop-vectorizer"><span class="std std-ref">Loop Vectorizer</span></a>,
which operates on Loops, and the <a class="reference internal" href="#slp-vectorizer"><span class="std std-ref">SLP Vectorizer</span></a>. These vectorizers
focus on different optimization opportunities and use different techniques.
The SLP vectorizer merges multiple scalars that are found in the code into
vectors while the Loop Vectorizer widens instructions in loops
to operate on multiple consecutive iterations.</p>
<p>Both the Loop Vectorizer and the SLP Vectorizer are enabled by default.</p>
<section id="the-loop-vectorizer">
<span id="loop-vectorizer"></span><h2><a class="toc-backref" href="#id3" role="doc-backlink">The Loop Vectorizer</a><a class="headerlink" href="#the-loop-vectorizer" title="連結到這個標頭">¶</a></h2>
<section id="usage">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Usage</a><a class="headerlink" href="#usage" title="連結到這個標頭">¶</a></h3>
<p>The Loop Vectorizer is enabled by default, but it can be disabled
through clang using the command line flag:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang<span class="w"> </span>...<span class="w"> </span>-fno-vectorize<span class="w">  </span>file.c
</pre></div>
</div>
<section id="command-line-flags">
<h4><a class="toc-backref" href="#id5" role="doc-backlink">Command line flags</a><a class="headerlink" href="#command-line-flags" title="連結到這個標頭">¶</a></h4>
<p>The loop vectorizer uses a cost model to decide on the optimal vectorization factor
and unroll factor. However, users of the vectorizer can force the vectorizer to use
specific values. Both 'clang' and 'opt' support the flags below.</p>
<p>Users can control the vectorization SIMD width using the command line flag &quot;-force-vector-width&quot;.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang<span class="w">  </span>-mllvm<span class="w"> </span>-force-vector-width<span class="o">=</span><span class="m">8</span><span class="w"> </span>...
<span class="gp">$ </span>opt<span class="w"> </span>-loop-vectorize<span class="w"> </span>-force-vector-width<span class="o">=</span><span class="m">8</span><span class="w"> </span>...
</pre></div>
</div>
<p>Users can control the unroll factor using the command line flag &quot;-force-vector-unroll&quot;</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang<span class="w">  </span>-mllvm<span class="w"> </span>-force-vector-unroll<span class="o">=</span><span class="m">2</span><span class="w"> </span>...
<span class="gp">$ </span>opt<span class="w"> </span>-loop-vectorize<span class="w"> </span>-force-vector-unroll<span class="o">=</span><span class="m">2</span><span class="w"> </span>...
</pre></div>
</div>
</section>
<section id="pragma-loop-hint-directives">
<h4><a class="toc-backref" href="#id6" role="doc-backlink">Pragma loop hint directives</a><a class="headerlink" href="#pragma-loop-hint-directives" title="連結到這個標頭">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">loop</span></code> directive allows loop vectorization hints to be
specified for the subsequent for, while, do-while, or c++11 range-based for
loop. The directive allows vectorization and interleaving to be enabled or
disabled. Vector width as well as interleave count can also be manually
specified. The following example explicitly enables vectorization and
interleaving:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize(enable) interleave(enable)</span>
<span class="k">while</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following example implicitly enables vectorization and interleaving by
specifying a vector width and interleaving count:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize_width(2) interleave_count(2)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See the Clang
<a class="reference external" href="http://clang.llvm.org/docs/LanguageExtensions.html#extensions-for-loop-hint-optimizations">language extensions</a>
for details.</p>
</section>
</section>
<section id="diagnostics">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Diagnostics</a><a class="headerlink" href="#diagnostics" title="連結到這個標頭">¶</a></h3>
<p>Many loops cannot be vectorized including loops with complicated control flow,
unvectorizable types, and unvectorizable calls. The loop vectorizer generates
optimization remarks which can be queried using command line options to identify
and diagnose loops that are skipped by the loop-vectorizer.</p>
<p>Optimization remarks are enabled using:</p>
<p><code class="docutils literal notranslate"><span class="pre">-Rpass=loop-vectorize</span></code> identifies loops that were successfully vectorized.</p>
<p><code class="docutils literal notranslate"><span class="pre">-Rpass-missed=loop-vectorize</span></code> identifies loops that failed vectorization and
indicates if vectorization was specified.</p>
<p><code class="docutils literal notranslate"><span class="pre">-Rpass-analysis=loop-vectorize</span></code> identifies the statements that caused
vectorization to fail.</p>
<p>Consider the following loop:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize(enable)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The command line <code class="docutils literal notranslate"><span class="pre">-Rpass-missed=loop-vectorized</span></code> prints the remark:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">no_switch.cpp:4:5: remark: loop not vectorized: vectorization is explicitly enabled [-Rpass-missed=loop-vectorize]</span>
</pre></div>
</div>
<p>And the command line <code class="docutils literal notranslate"><span class="pre">-Rpass-analysis=loop-vectorize</span></code> indicates that the
switch statement cannot be vectorized.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">no_switch.cpp:4:5: remark: loop not vectorized: loop contains a switch statement [-Rpass-analysis=loop-vectorize]</span>
<span class="go">  switch(A[i]) {</span>
<span class="go">  ^</span>
</pre></div>
</div>
<p>To ensure line and column numbers are produced include the command line options
<code class="docutils literal notranslate"><span class="pre">-gline-tables-only</span></code> and <code class="docutils literal notranslate"><span class="pre">-gcolumn-info</span></code>. See the Clang <a class="reference external" href="http://clang.llvm.org/docs/UsersManual.html#options-to-emit-optimization-reports">user manual</a>
for details</p>
</section>
<section id="features">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Features</a><a class="headerlink" href="#features" title="連結到這個標頭">¶</a></h3>
<p>The LLVM Loop Vectorizer has a number of features that allow it to vectorize
complex loops.</p>
<section id="loops-with-unknown-trip-count">
<h4><a class="toc-backref" href="#id9" role="doc-backlink">Loops with unknown trip count</a><a class="headerlink" href="#loops-with-unknown-trip-count" title="連結到這個標頭">¶</a></h4>
<p>The Loop Vectorizer supports loops with an unknown trip count.
In the loop below, the iteration <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">finish</span></code> points are unknown,
and the Loop Vectorizer has a mechanism to vectorize loops that do not start
at zero. In this example, 'n' may not be a multiple of the vector width, and
the vectorizer has to execute the last few iterations as scalar code. Keeping
a scalar copy of the loop increases the code size.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">K</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="runtime-checks-of-pointers">
<h4><a class="toc-backref" href="#id10" role="doc-backlink">Runtime Checks of Pointers</a><a class="headerlink" href="#runtime-checks-of-pointers" title="連結到這個標頭">¶</a></h4>
<p>In the example below, if the pointers A and B point to consecutive addresses,
then it is illegal to vectorize the code because some elements of A will be
written before they are read from array B.</p>
<p>Some programmers use the 'restrict' keyword to notify the compiler that the
pointers are disjointed, but in our example, the Loop Vectorizer has no way of
knowing that the pointers A and B are unique. The Loop Vectorizer handles this
loop by placing code that checks, at runtime, if the arrays A and B point to
disjointed memory locations. If arrays A and B overlap, then the scalar version
of the loop is executed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">K</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="reductions">
<h4><a class="toc-backref" href="#id11" role="doc-backlink">Reductions</a><a class="headerlink" href="#reductions" title="連結到這個標頭">¶</a></h4>
<p>In this example the <code class="docutils literal notranslate"><span class="pre">sum</span></code> variable is used by consecutive iterations of
the loop. Normally, this would prevent vectorization, but the vectorizer can
detect that 'sum' is a reduction variable. The variable 'sum' becomes a vector
of integers, and at the end of the loop the elements of the array are added
together to create the correct result. We support a number of different
reduction operations, such as addition, multiplication, XOR, AND and OR.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We support floating point reduction operations when <cite>-ffast-math</cite> is used.</p>
</section>
<section id="inductions">
<h4><a class="toc-backref" href="#id12" role="doc-backlink">Inductions</a><a class="headerlink" href="#inductions" title="連結到這個標頭">¶</a></h4>
<p>In this example the value of the induction variable <code class="docutils literal notranslate"><span class="pre">i</span></code> is saved into an
array. The Loop Vectorizer knows to vectorize induction variables.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="if-conversion">
<h4><a class="toc-backref" href="#id13" role="doc-backlink">If Conversion</a><a class="headerlink" href="#if-conversion" title="連結到這個標頭">¶</a></h4>
<p>The Loop Vectorizer is able to &quot;flatten&quot; the IF statement in the code and
generate a single stream of instructions. The Loop Vectorizer supports any
control flow in the innermost loop. The innermost loop may contain complex
nesting of IFs, ELSEs and even GOTOs.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="pointer-induction-variables">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">Pointer Induction Variables</a><a class="headerlink" href="#pointer-induction-variables" title="連結到這個標頭">¶</a></h4>
<p>This example uses the &quot;accumulate&quot; function of the standard c++ library. This
loop uses C++ iterators, which are pointers, and not integer indices.
The Loop Vectorizer detects pointer induction variables and can vectorize
this loop. This feature is important because many C++ programs use iterators.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="reverse-iterators">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Reverse Iterators</a><a class="headerlink" href="#reverse-iterators" title="連結到這個標頭">¶</a></h4>
<p>The Loop Vectorizer can vectorize loops that count backwards.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="scatter-gather">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">Scatter / Gather</a><a class="headerlink" href="#scatter-gather" title="連結到這個標頭">¶</a></h4>
<p>The Loop Vectorizer can vectorize code that becomes a sequence of scalar instructions
that scatter/gathers memory.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">intptr_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In many situations the cost model will inform LLVM that this is not beneficial
and LLVM will only vectorize such code if forced with &quot;-mllvm -force-vector-width=#&quot;.</p>
</section>
<section id="vectorization-of-mixed-types">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Vectorization of Mixed Types</a><a class="headerlink" href="#vectorization-of-mixed-types" title="連結到這個標頭">¶</a></h4>
<p>The Loop Vectorizer can vectorize programs with mixed types. The Vectorizer
cost model can estimate the cost of the type conversion and decide if
vectorization is profitable.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="global-structures-alias-analysis">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Global Structures Alias Analysis</a><a class="headerlink" href="#global-structures-alias-analysis" title="連結到這個標頭">¶</a></h4>
<p>Access to global structures can also be vectorized, with alias analysis being
used to make sure accesses don't alias. Run-time checks can also be added on
pointer access to structure members.</p>
<p>Many variations are supported, but some that rely on undefined behaviour being
ignored (as other compilers do) are still being left un-vectorized.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">Foo</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">.</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="vectorization-of-function-calls">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Vectorization of function calls</a><a class="headerlink" href="#vectorization-of-function-calls" title="連結到這個標頭">¶</a></h4>
<p>The Loop Vectorize can vectorize intrinsic math functions.
See the table below for a list of these functions.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>pow</p></td>
<td><p>exp</p></td>
<td><p>exp2</p></td>
</tr>
<tr class="row-even"><td><p>sin</p></td>
<td><p>cos</p></td>
<td><p>sqrt</p></td>
</tr>
<tr class="row-odd"><td><p>log</p></td>
<td><p>log2</p></td>
<td><p>log10</p></td>
</tr>
<tr class="row-even"><td><p>fabs</p></td>
<td><p>floor</p></td>
<td><p>ceil</p></td>
</tr>
<tr class="row-odd"><td><p>fma</p></td>
<td><p>trunc</p></td>
<td><p>nearbyint</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>fmuladd</p></td>
</tr>
</tbody>
</table>
<p>The loop vectorizer knows about special instructions on the target and will
vectorize a loop containing a function call that maps to the instructions. For
example, the loop below will be vectorized on Intel x86 if the SSE4.1 roundps
instruction is available.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">floorf</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="partial-unrolling-during-vectorization">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Partial unrolling during vectorization</a><a class="headerlink" href="#partial-unrolling-during-vectorization" title="連結到這個標頭">¶</a></h4>
<p>Modern processors feature multiple execution units, and only programs that contain a
high degree of parallelism can fully utilize the entire width of the machine.
The Loop Vectorizer increases the instruction level parallelism (ILP) by
performing partial-unrolling of loops.</p>
<p>In the example below the entire array is accumulated into the variable 'sum'.
This is inefficient because only a single execution port can be used by the processor.
By unrolling the code the Loop Vectorizer allows two or more execution ports
to be used simultaneously.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The Loop Vectorizer uses a cost model to decide when it is profitable to unroll loops.
The decision to unroll the loop depends on the register pressure and the generated code size.</p>
</section>
</section>
<section id="performance">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Performance</a><a class="headerlink" href="#performance" title="連結到這個標頭">¶</a></h3>
<p>This section shows the execution time of Clang on a simple benchmark:
<a class="reference external" href="http://llvm.org/viewvc/llvm-project/test-suite/trunk/SingleSource/UnitTests/Vectorizer/">gcc-loops</a>.
This benchmarks is a collection of loops from the GCC autovectorization
<a class="reference external" href="http://gcc.gnu.org/projects/tree-ssa/vectorization.html">page</a> by Dorit Nuzman.</p>
<p>The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without loop vectorization at -O3, tuned for &quot;corei7-avx&quot;, running on a Sandybridge iMac.
The Y-axis shows the time in msec. Lower is better. The last column shows the geomean of all the kernels.</p>
<img alt="_images/gcc-loops.png" src="_images/gcc-loops.png" />
<p>And Linpack-pc with the same configuration. Result is Mflops, higher is better.</p>
<img alt="_images/linpack-pc.png" src="_images/linpack-pc.png" />
</section>
</section>
<section id="the-slp-vectorizer">
<span id="slp-vectorizer"></span><h2><a class="toc-backref" href="#id22" role="doc-backlink">The SLP Vectorizer</a><a class="headerlink" href="#the-slp-vectorizer" title="連結到這個標頭">¶</a></h2>
<section id="details">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Details</a><a class="headerlink" href="#details" title="連結到這個標頭">¶</a></h3>
<p>The goal of SLP vectorization (a.k.a. superword-level parallelism) is
to combine similar independent instructions
into vector instructions. Memory accesses, arithmetic operations, comparison
operations, PHI-nodes, can all be vectorized using this technique.</p>
<p>For example, the following function performs very similar operations on its
inputs (a1, b1) and (a2, b2). The basic-block vectorizer may combine these
into vector operations.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a1</span><span class="o">*</span><span class="p">(</span><span class="n">a1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b1</span><span class="p">)</span><span class="o">/</span><span class="n">b1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">50</span><span class="o">*</span><span class="n">b1</span><span class="o">/</span><span class="n">a1</span><span class="p">;</span>
<span class="w">  </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a2</span><span class="o">*</span><span class="p">(</span><span class="n">a2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b2</span><span class="p">)</span><span class="o">/</span><span class="n">b2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">50</span><span class="o">*</span><span class="n">b2</span><span class="o">/</span><span class="n">a2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The SLP-vectorizer processes the code bottom-up, across basic blocks, in search of scalars to combine.</p>
</section>
<section id="id2">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Usage</a><a class="headerlink" href="#id2" title="連結到這個標頭">¶</a></h3>
<p>The SLP Vectorizer is enabled by default, but it can be disabled
through clang using the command line flag:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang<span class="w"> </span>-fno-slp-vectorize<span class="w"> </span>file.c
</pre></div>
</div>
<p>LLVM has a second basic block vectorization phase
which is more compile-time intensive (The BB vectorizer). This optimization
can be enabled through clang using the command line flag:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang<span class="w"> </span>-fslp-vectorize-aggressive<span class="w"> </span>file.c
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="WritingAnLLVMBackend.html" title="Writing an LLVM Backend"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="SourceLevelDebugging.html" title="Source Level Debugging with LLVM"
             >上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Auto-Vectorization in LLVM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; 版權所有 2003-2025, LLVM Project.
      最後更新於 2025-10-28。
      使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3 建立。
    </div>
  </body>
</html>