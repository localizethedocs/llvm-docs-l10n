
<!DOCTYPE html>

<html lang="zh-TW" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Coroutines in LLVM &#8212; LLVM 4 說明文件</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=4c4af0c1" />
    <script src="_static/documentation_options.js?v=5178651c"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/llvm-docs-l10n/Coroutines.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜尋" href="search.html" />
    <link rel="next" title="Global Instruction Selection" href="GlobalISel.html" />
    <link rel="prev" title="Machine IR (MIR) Format Reference Manual" href="MIRLangRef.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="GlobalISel.html" title="Global Instruction Selection"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="MIRLangRef.html" title="Machine IR (MIR) Format Reference Manual"
             accesskey="P">上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Coroutines in LLVM</a></li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="coroutines-in-llvm">
<h1>Coroutines in LLVM<a class="headerlink" href="#coroutines-in-llvm" title="連結到這個標頭">¶</a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id46">簡介</a></p></li>
<li><p><a class="reference internal" href="#coroutines-by-example" id="id47">Coroutines by Example</a></p>
<ul>
<li><p><a class="reference internal" href="#coroutine-representation" id="id48">Coroutine Representation</a></p></li>
<li><p><a class="reference internal" href="#coroutine-transformation" id="id49">Coroutine Transformation</a></p></li>
<li><p><a class="reference internal" href="#avoiding-heap-allocations" id="id50">Avoiding Heap Allocations</a></p></li>
<li><p><a class="reference internal" href="#multiple-suspend-points" id="id51">Multiple Suspend Points</a></p></li>
<li><p><a class="reference internal" href="#distinct-save-and-suspend" id="id52">Distinct Save and Suspend</a></p></li>
<li><p><a class="reference internal" href="#coroutine-promise" id="id53">Coroutine Promise</a></p></li>
<li><p><a class="reference internal" href="#final-suspend" id="id54">Final Suspend</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#intrinsics" id="id55">Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#coroutine-manipulation-intrinsics" id="id56">Coroutine Manipulation Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-coro-destroy-intrinsic" id="id57">'llvm.coro.destroy' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-resume-intrinsic" id="id58">'llvm.coro.resume' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-done-intrinsic" id="id59">'llvm.coro.done' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-promise-intrinsic" id="id60">'llvm.coro.promise' Intrinsic</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#coroutine-structure-intrinsics" id="id61">Coroutine Structure Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-coro-size-intrinsic" id="id62">'llvm.coro.size' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-begin-intrinsic" id="id63">'llvm.coro.begin' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-free-intrinsic" id="id64">'llvm.coro.free' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-alloc-intrinsic" id="id65">'llvm.coro.alloc' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-frame-intrinsic" id="id66">'llvm.coro.frame' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-id-intrinsic" id="id67">'llvm.coro.id' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-end-intrinsic" id="id68">'llvm.coro.end' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-suspend-intrinsic" id="id69">'llvm.coro.suspend' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-save-intrinsic" id="id70">'llvm.coro.save' Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-param-intrinsic" id="id71">'llvm.coro.param' Intrinsic</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#coroutine-transformation-passes" id="id72">Coroutine Transformation Passes</a></p>
<ul>
<li><p><a class="reference internal" href="#coroearly" id="id73">CoroEarly</a></p></li>
<li><p><a class="reference internal" href="#corosplit" id="id74">CoroSplit</a></p></li>
<li><p><a class="reference internal" href="#coroelide" id="id75">CoroElide</a></p></li>
<li><p><a class="reference internal" href="#corocleanup" id="id76">CoroCleanup</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#areas-requiring-attention" id="id77">Areas Requiring Attention</a></p></li>
</ul>
</nav>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>This is a work in progress. Compatibility across LLVM releases is not
guaranteed.</p>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id46" role="doc-backlink">簡介</a><a class="headerlink" href="#introduction" title="連結到這個標頭">¶</a></h2>
<p id="coroutine-handle">LLVM coroutines are functions that have one or more <a class="reference internal" href="#suspend-points">suspend points</a>.
When a suspend point is reached, the execution of a coroutine is suspended and
control is returned back to its caller. A suspended coroutine can be resumed
to continue execution from the last suspend point or it can be destroyed.</p>
<p>In the following example, we call function <cite>f</cite> (which may or may not be a
coroutine itself) that returns a handle to a suspended coroutine
(<strong>coroutine handle</strong>) that is used by <cite>main</cite> to resume the coroutine twice and
then destroy it:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.destroy</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="coroutine-frame">In addition to the function stack frame which exists when a coroutine is
executing, there is an additional region of storage that contains objects that
keep the coroutine state when a coroutine is suspended. This region of storage
is called <strong>coroutine frame</strong>. It is created when a coroutine is called and
destroyed when a coroutine runs to completion or destroyed by a call to
the <a class="reference internal" href="#coro-destroy">coro.destroy</a> intrinsic.</p>
<p>An LLVM coroutine is represented as an LLVM function that has calls to
<a class="reference internal" href="#coroutine-intrinsics">coroutine intrinsics</a> defining the structure of the coroutine.
After lowering, a coroutine is split into several
functions that represent three different ways of how control can enter the
coroutine:</p>
<ol class="arabic simple">
<li><p>a ramp function, which represents an initial invocation of the coroutine that
creates the coroutine frame and executes the coroutine code until it
encounters a suspend point or reaches the end of the function;</p></li>
<li><p>a coroutine resume function that is invoked when the coroutine is resumed;</p></li>
<li><p>a coroutine destroy function that is invoked when the coroutine is destroyed.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Splitting out resume and destroy functions are just one of the
possible ways of lowering the coroutine. We chose it for initial
implementation as it matches closely the mental model and results in
reasonably nice code.</p>
</div>
</section>
<section id="coroutines-by-example">
<h2><a class="toc-backref" href="#id47" role="doc-backlink">Coroutines by Example</a><a class="headerlink" href="#coroutines-by-example" title="連結到這個標頭">¶</a></h2>
<section id="coroutine-representation">
<h3><a class="toc-backref" href="#id48" role="doc-backlink">Coroutine Representation</a><a class="headerlink" href="#coroutine-representation" title="連結到這個標頭">¶</a></h3>
<p>Let's look at an example of an LLVM coroutine with the behavior sketched
by the following pseudo-code.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">print</span><span class="p">(</span><span class="n">n</span><span class="o">++</span><span class="p">);</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">suspend</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// returns a coroutine handle on first suspend</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This coroutine calls some function <cite>print</cite> with value <cite>n</cite> as an argument and
suspends execution. Every time this coroutine resumes, it calls <cite>print</cite> again with an argument one bigger than the last time. This coroutine never completes by itself and must be destroyed explicitly. If we use this coroutine with
a <cite>main</cite> shown in the previous section. It will call <cite>print</cite> with values 4, 5
and 6 after which the coroutine will be destroyed.</p>
<p>The LLVM IR for this coroutine looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>define i8* @f(i32 %n) {
entry:
  %id = call token @llvm.coro.id(i32 0, i8* null, i8* null, i8* null)
  %size = call i32 @llvm.coro.size.i32()
  %alloc = call i8* @malloc(i32 %size)
  %hdl = call noalias i8* @llvm.coro.begin(token %id, i8* %alloc)
  br label %loop
loop:
  %n.val = phi i32 [ %n, %entry ], [ %inc, %loop ]
  %inc = add nsw i32 %n.val, 1
  call void @print(i32 %n.val)
  %0 = call i8 @llvm.coro.suspend(token none, i1 false)
  switch i8 %0, label %suspend [i8 0, label %loop
                                i8 1, label %cleanup]
cleanup:
  %mem = call i8* @llvm.coro.free(token %id, i8* %hdl)
  call void @free(i8* %mem)
  br label %suspend
suspend:
  call void @llvm.coro.end(i8* %hdl, i1 false)
  ret i8* %hdl
}
</pre></div>
</div>
<p>The <cite>entry</cite> block establishes the coroutine frame. The <a class="reference internal" href="#coro-size">coro.size</a> intrinsic is
lowered to a constant representing the size required for the coroutine frame.
The <a class="reference internal" href="#coro-begin">coro.begin</a> intrinsic initializes the coroutine frame and returns the
coroutine handle. The second parameter of <cite>coro.begin</cite> is given a block of memory
to be used if the coroutine frame needs to be allocated dynamically.
The <a class="reference internal" href="#coro-id">coro.id</a> intrinsic serves as coroutine identity useful in cases when the
<a class="reference internal" href="#coro-begin">coro.begin</a> intrinsic get duplicated by optimization passes such as
jump-threading.</p>
<p>The <cite>cleanup</cite> block destroys the coroutine frame. The <a class="reference internal" href="#coro-free">coro.free</a> intrinsic,
given the coroutine handle, returns a pointer of the memory block to be freed or
<cite>null</cite> if the coroutine frame was not allocated dynamically. The <cite>cleanup</cite>
block is entered when coroutine runs to completion by itself or destroyed via
call to the <a class="reference internal" href="#coro-destroy">coro.destroy</a> intrinsic.</p>
<p>The <cite>suspend</cite> block contains code to be executed when coroutine runs to
completion or suspended. The <a class="reference internal" href="#coro-end">coro.end</a> intrinsic marks the point where
a coroutine needs to return control back to the caller if it is not an initial
invocation of the coroutine.</p>
<p>The <cite>loop</cite> blocks represents the body of the coroutine. The <a class="reference internal" href="#coro-suspend">coro.suspend</a>
intrinsic in combination with the following switch indicates what happens to
control flow when a coroutine is suspended (default case), resumed (case 0) or
destroyed (case 1).</p>
</section>
<section id="coroutine-transformation">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">Coroutine Transformation</a><a class="headerlink" href="#coroutine-transformation" title="連結到這個標頭">¶</a></h3>
<p>One of the steps of coroutine lowering is building the coroutine frame. The
def-use chains are analyzed to determine which objects need be kept alive across
suspend points. In the coroutine shown in the previous section, use of virtual register
<cite>%n.val</cite> is separated from the definition by a suspend point, therefore, it
cannot reside on the stack frame since the latter goes away once the coroutine
is suspended and control is returned back to the caller. An i32 slot is
allocated in the coroutine frame and <cite>%n.val</cite> is spilled and reloaded from that
slot as needed.</p>
<p>We also store addresses of the resume and destroy functions so that the
<cite>coro.resume</cite> and <cite>coro.destroy</cite> intrinsics can resume and destroy the coroutine
when its identity cannot be determined statically at compile time. For our
example, the coroutine frame will be:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%f.frame = type { void (%f.frame*)*, void (%f.frame*)*, i32 }
</pre></div>
</div>
<p>After resume and destroy parts are outlined, function <cite>f</cite> will contain only the
code responsible for creation and initialization of the coroutine frame and
execution of the coroutine until a suspend point is reached:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>define i8* @f(i32 %n) {
entry:
  %id = call token @llvm.coro.id(i32 0, i8* null, i8* null, i8* null)
  %alloc = call noalias i8* @malloc(i32 24)
  %0 = call noalias i8* @llvm.coro.begin(token %id, i8* %alloc)
  %frame = bitcast i8* %0 to %f.frame*
  %1 = getelementptr %f.frame, %f.frame* %frame, i32 0, i32 0
  store void (%f.frame*)* @f.resume, void (%f.frame*)** %1
  %2 = getelementptr %f.frame, %f.frame* %frame, i32 0, i32 1
  store void (%f.frame*)* @f.destroy, void (%f.frame*)** %2

  %inc = add nsw i32 %n, 1
  %inc.spill.addr = getelementptr inbounds %f.Frame, %f.Frame* %FramePtr, i32 0, i32 2
  store i32 %inc, i32* %inc.spill.addr
  call void @print(i32 %n)

  ret i8* %frame
}
</pre></div>
</div>
<p>Outlined resume part of the coroutine will reside in function <cite>f.resume</cite>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">fastcc</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@f.resume</span><span class="p">(</span><span class="nv">%f.frame</span><span class="p">*</span><span class="w"> </span><span class="nv">%frame.ptr.resume</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%inc.spill.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="nv">%f.frame</span><span class="p">,</span><span class="w"> </span><span class="nv">%f.frame</span><span class="p">*</span><span class="w"> </span><span class="nv">%frame.ptr.resume</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="nv">%inc.spill</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%inc.spill.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.val</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%inc.spill.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Whereas function <cite>f.destroy</cite> will contain the cleanup code for the coroutine:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">fastcc</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@f.destroy</span><span class="p">(</span><span class="nv">%f.frame</span><span class="p">*</span><span class="w"> </span><span class="nv">%frame.ptr.destroy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">bitcast</span><span class="w"> </span><span class="nv">%f.frame</span><span class="p">*</span><span class="w"> </span><span class="nv">%frame.ptr.destroy</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@free</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="avoiding-heap-allocations">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">Avoiding Heap Allocations</a><a class="headerlink" href="#avoiding-heap-allocations" title="連結到這個標頭">¶</a></h3>
<p>A particular coroutine usage pattern, which is illustrated by the <cite>main</cite>
function in the overview section, where a coroutine is created, manipulated and
destroyed by the same calling function, is common for coroutines implementing
RAII idiom and is suitable for allocation elision optimization which avoid
dynamic allocation by storing the coroutine frame as a static <cite>alloca</cite> in its
caller.</p>
<p>In the entry block, we will call <a class="reference internal" href="#coro-alloc">coro.alloc</a> intrinsic that will return <cite>true</cite>
when dynamic allocation is required, and <cite>false</cite> if dynamic allocation is
elided.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>entry:
  %id = call token @llvm.coro.id(i32 0, i8* null, i8* null, i8* null)
  %need.dyn.alloc = call i1 @llvm.coro.alloc(token %id)
  br i1 %need.dyn.alloc, label %dyn.alloc, label %coro.begin
dyn.alloc:
  %size = call i32 @llvm.coro.size.i32()
  %alloc = call i8* @CustomAlloc(i32 %size)
  br label %coro.begin
coro.begin:
  %phi = phi i8* [ null, %entry ], [ %alloc, %dyn.alloc ]
  %hdl = call noalias i8* @llvm.coro.begin(token %id, i8* %phi)
</pre></div>
</div>
<p>In the cleanup block, we will make freeing the coroutine frame conditional on
<a class="reference internal" href="#coro-free">coro.free</a> intrinsic. If allocation is elided, <a class="reference internal" href="#coro-free">coro.free</a> returns <cite>null</cite>
thus skipping the deallocation code:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cleanup:
  %mem = call i8* @llvm.coro.free(token %id, i8* %hdl)
  %need.dyn.free = icmp ne i8* %mem, null
  br i1 %need.dyn.free, label %dyn.free, label %if.end
dyn.free:
  call void @CustomFree(i8* %mem)
  br label %if.end
if.end:
  ...
</pre></div>
</div>
<p>With allocations and deallocations represented as described as above, after
coroutine heap allocation elision optimization, the resulting main will be:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">5</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">6</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="multiple-suspend-points">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">Multiple Suspend Points</a><a class="headerlink" href="#multiple-suspend-points" title="連結到這個標頭">¶</a></h3>
<p>Let's consider the coroutine that has more than one suspend point:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">print</span><span class="p">(</span><span class="n">n</span><span class="o">++</span><span class="p">);</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">suspend</span><span class="o">&gt;</span>
<span class="w">     </span><span class="n">print</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">suspend</span><span class="o">&gt;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Matching LLVM code would look like (with the rest of the code remaining the same
as the code in the previous section):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>loop:
  %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]
  call void @print(i32 %n.addr) #4
  %2 = call i8 @llvm.coro.suspend(token none, i1 false)
  switch i8 %2, label %suspend [i8 0, label %loop.resume
                                i8 1, label %cleanup]
loop.resume:
  %inc = add nsw i32 %n.addr, 1
  %sub = xor i32 %n.addr, -1
  call void @print(i32 %sub)
  %3 = call i8 @llvm.coro.suspend(token none, i1 false)
  switch i8 %3, label %suspend [i8 0, label %loop
                                i8 1, label %cleanup]
</pre></div>
</div>
<p>In this case, the coroutine frame would include a suspend index that will
indicate at which suspend point the coroutine needs to resume. The resume
function will use an index to jump to an appropriate basic block and will look
as follows:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">fastcc</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@f.Resume</span><span class="p">(</span><span class="nv">%f.Frame</span><span class="p">*</span><span class="w"> </span><span class="nv">%FramePtr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry.Resume:</span>
<span class="w">  </span><span class="nv">%index.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="nv">%f.Frame</span><span class="p">,</span><span class="w"> </span><span class="nv">%f.Frame</span><span class="p">*</span><span class="w"> </span><span class="nv">%FramePtr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="nv">%index</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%index.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="nv">%switch</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%index</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%n.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="nv">%f.Frame</span><span class="p">,</span><span class="w"> </span><span class="nv">%f.Frame</span><span class="p">*</span><span class="w"> </span><span class="nv">%FramePtr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span>
<span class="w">  </span><span class="nv">%n</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%n.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%switch</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop.resume</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>

<span class="nl">loop.resume:</span>
<span class="w">  </span><span class="nv">%sub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="m">-1</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%sub</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span>
<span class="nl">loop:</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%n.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span>

<span class="nl">suspend:</span>
<span class="w">  </span><span class="nv">%storemerge</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop.resume</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%storemerge</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%index.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If different cleanup code needs to get executed for different suspend points,
a similar switch will be in the <cite>f.destroy</cite> function.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Using suspend index in a coroutine state and having a switch in <cite>f.resume</cite> and
<cite>f.destroy</cite> is one of the possible implementation strategies. We explored
another option where a distinct <cite>f.resume1</cite>, <cite>f.resume2</cite>, etc. are created for
every suspend point, and instead of storing an index, the resume and destroy
function pointers are updated at every suspend. Early testing showed that the
current approach is easier on the optimizer than the latter so it is a
lowering strategy implemented at the moment.</p>
</div>
</section>
<section id="distinct-save-and-suspend">
<h3><a class="toc-backref" href="#id52" role="doc-backlink">Distinct Save and Suspend</a><a class="headerlink" href="#distinct-save-and-suspend" title="連結到這個標頭">¶</a></h3>
<p>In the previous example, setting a resume index (or some other state change that
needs to happen to prepare a coroutine for resumption) happens at the same time as
a suspension of a coroutine. However, in certain cases, it is necessary to control
when coroutine is prepared for resumption and when it is suspended.</p>
<p>In the following example, a coroutine represents some activity that is driven
by completions of asynchronous operations <cite>async_op1</cite> and <cite>async_op2</cite> which get
a coroutine handle as a parameter and resume the coroutine once async
operation is finished.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>void g() {
   for (;;)
     if (cond()) {
        async_op1(&lt;coroutine-handle&gt;); // will resume once async_op1 completes
        &lt;suspend&gt;
        do_one();
     }
     else {
        async_op2(&lt;coroutine-handle&gt;); // will resume once async_op2 completes
        &lt;suspend&gt;
        do_two();
     }
   }
}
</pre></div>
</div>
<p>In this case, coroutine should be ready for resumption prior to a call to
<cite>async_op1</cite> and <cite>async_op2</cite>. The <a class="reference internal" href="#coro-save">coro.save</a> intrinsic is used to indicate a
point when coroutine should be ready for resumption (namely, when a resume index
should be stored in the coroutine frame, so that it can be resumed at the
correct resume point):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>if.true:
  %save1 = call token @llvm.coro.save(i8* %hdl)
  call void async_op1(i8* %hdl)
  %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false)
  switch i8 %suspend1, label %suspend [i8 0, label %resume1
                                       i8 1, label %cleanup]
if.false:
  %save2 = call token @llvm.coro.save(i8* %hdl)
  call void async_op2(i8* %hdl)
  %suspend2 = call i1 @llvm.coro.suspend(token %save2, i1 false)
  switch i8 %suspend1, label %suspend [i8 0, label %resume2
                                       i8 1, label %cleanup]
</pre></div>
</div>
</section>
<section id="coroutine-promise">
<span id="id2"></span><h3><a class="toc-backref" href="#id53" role="doc-backlink">Coroutine Promise</a><a class="headerlink" href="#coroutine-promise" title="連結到這個標頭">¶</a></h3>
<p>A coroutine author or a frontend may designate a distinguished <cite>alloca</cite> that can
be used to communicate with the coroutine. This distinguished alloca is called
<strong>coroutine promise</strong> and is provided as the second parameter to the
<a class="reference internal" href="#coro-id">coro.id</a> intrinsic.</p>
<p>The following coroutine designates a 32 bit integer <cite>promise</cite> and uses it to
store the current value produced by a coroutine.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>define i8* @f(i32 %n) {
entry:
  %promise = alloca i32
  %pv = bitcast i32* %promise to i8*
  %id = call token @llvm.coro.id(i32 0, i8* %pv, i8* null, i8* null)
  %need.dyn.alloc = call i1 @llvm.coro.alloc(token %id)
  br i1 %need.dyn.alloc, label %dyn.alloc, label %coro.begin
dyn.alloc:
  %size = call i32 @llvm.coro.size.i32()
  %alloc = call i8* @malloc(i32 %size)
  br label %coro.begin
coro.begin:
  %phi = phi i8* [ null, %entry ], [ %alloc, %dyn.alloc ]
  %hdl = call noalias i8* @llvm.coro.begin(token %id, i8* %phi)
  br label %loop
loop:
  %n.val = phi i32 [ %n, %coro.begin ], [ %inc, %loop ]
  %inc = add nsw i32 %n.val, 1
  store i32 %n.val, i32* %promise
  %0 = call i8 @llvm.coro.suspend(token none, i1 false)
  switch i8 %0, label %suspend [i8 0, label %loop
                                i8 1, label %cleanup]
cleanup:
  %mem = call i8* @llvm.coro.free(token %id, i8* %hdl)
  call void @free(i8* %mem)
  br label %suspend
suspend:
  call void @llvm.coro.end(i8* %hdl, i1 false)
  ret i8* %hdl
}
</pre></div>
</div>
<p>A coroutine consumer can rely on the <a class="reference internal" href="#coro-promise">coro.promise</a> intrinsic to access the
coroutine promise.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%promise.addr.raw</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="vg">@llvm.coro.promise</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%promise.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">bitcast</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%promise.addr.raw</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%promise.addr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%promise.addr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%val2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%promise.addr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val2</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.destroy</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After example in this section is compiled, result of the compilation will be:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">5</span><span class="p">)</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">6</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="final-suspend">
<span id="final"></span><span id="id3"></span><h3><a class="toc-backref" href="#id54" role="doc-backlink">Final Suspend</a><a class="headerlink" href="#final-suspend" title="連結到這個標頭">¶</a></h3>
<p>A coroutine author or a frontend may designate a particular suspend to be final,
by setting the second argument of the <a class="reference internal" href="#coro-suspend">coro.suspend</a> intrinsic to <cite>true</cite>.
Such a suspend point has two properties:</p>
<ul class="simple">
<li><p>it is possible to check whether a suspended coroutine is at the final suspend
point via <a class="reference internal" href="#coro-done">coro.done</a> intrinsic;</p></li>
<li><p>a resumption of a coroutine stopped at the final suspend point leads to
undefined behavior. The only possible action for a coroutine at a final
suspend point is destroying it via <a class="reference internal" href="#coro-destroy">coro.destroy</a> intrinsic.</p></li>
</ul>
<p>From the user perspective, the final suspend point represents an idea of a
coroutine reaching the end. From the compiler perspective, it is an optimization
opportunity for reducing number of resume points (and therefore switch cases) in
the resume function.</p>
<p>The following is an example of a function that keeps resuming the coroutine
until the final suspend point is reached after which point the coroutine is
destroyed:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while</span>
<span class="nl">while:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%done</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.done</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%done</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while</span>
<span class="nl">end:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.destroy</span><span class="p">(</span><span class="kt">i8</span><span class="p">*</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Usually, final suspend point is a frontend injected suspend point that does not
correspond to any explicitly authored suspend point of the high level language.
For example, for a Python generator that has only one suspend point:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">coroutine</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>Python frontend would inject two more suspend points, so that the actual code
looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">coroutine</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">current_value</span><span class="p">;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">designate</span><span class="w"> </span><span class="n">current_value</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">coroutine</span><span class="w"> </span><span class="n">promise</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">SUSPEND</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// injected suspend point, so that the coroutine starts suspended</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">current_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">SUSPEND</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// corresponds to &quot;yield i&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">SUSPEND</span><span class="w"> </span><span class="n">final</span><span class="o">=</span><span class="nb">true</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// injected final suspend point</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and python iterator <cite>__next__</cite> would look like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__next__</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">hdl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">coro</span><span class="p">.</span><span class="n">resume</span><span class="p">(</span><span class="n">hdl</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">coro</span><span class="p">.</span><span class="n">done</span><span class="p">(</span><span class="n">hdl</span><span class="p">))</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">StopIteration</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">coro</span><span class="p">.</span><span class="n">promise</span><span class="p">(</span><span class="n">hdl</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="intrinsics">
<h2><a class="toc-backref" href="#id55" role="doc-backlink">Intrinsics</a><a class="headerlink" href="#intrinsics" title="連結到這個標頭">¶</a></h2>
<section id="coroutine-manipulation-intrinsics">
<h3><a class="toc-backref" href="#id56" role="doc-backlink">Coroutine Manipulation Intrinsics</a><a class="headerlink" href="#coroutine-manipulation-intrinsics" title="連結到這個標頭">¶</a></h3>
<p>Intrinsics described in this section are used to manipulate an existing
coroutine. They can be used in any function which happen to have a pointer
to a <a class="reference internal" href="#coroutine-frame">coroutine frame</a> or a pointer to a <a class="reference internal" href="#coroutine-promise">coroutine promise</a>.</p>
<section id="llvm-coro-destroy-intrinsic">
<span id="coro-destroy"></span><h4><a class="toc-backref" href="#id57" role="doc-backlink">'llvm.coro.destroy' Intrinsic</a><a class="headerlink" href="#llvm-coro-destroy-intrinsic" title="連結到這個標頭">¶</a></h4>
<section id="syntax">
<h5>Syntax:<a class="headerlink" href="#syntax" title="連結到這個標頭">¶</a></h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="overview">
<h5>Overview:<a class="headerlink" href="#overview" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.destroy</span></code>' intrinsic destroys a suspended
coroutine.</p>
</section>
<section id="arguments">
<h5>Arguments:<a class="headerlink" href="#arguments" title="連結到這個標頭">¶</a></h5>
<p>The argument is a coroutine handle to a suspended coroutine.</p>
</section>
<section id="semantics">
<h5>Semantics:<a class="headerlink" href="#semantics" title="連結到這個標頭">¶</a></h5>
<p>When possible, the <cite>coro.destroy</cite> intrinsic is replaced with a direct call to
the coroutine destroy function. Otherwise it is replaced with an indirect call
based on the function pointer for the destroy function stored in the coroutine
frame. Destroying a coroutine that is not suspended leads to undefined behavior.</p>
</section>
</section>
<section id="llvm-coro-resume-intrinsic">
<span id="coro-resume"></span><h4><a class="toc-backref" href="#id58" role="doc-backlink">'llvm.coro.resume' Intrinsic</a><a class="headerlink" href="#llvm-coro-resume-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">resume</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id4">
<h5>Overview:<a class="headerlink" href="#id4" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.resume</span></code>' intrinsic resumes a suspended coroutine.</p>
</section>
<section id="id5">
<h5>Arguments:<a class="headerlink" href="#id5" title="連結到這個標頭">¶</a></h5>
<p>The argument is a handle to a suspended coroutine.</p>
</section>
<section id="id6">
<h5>Semantics:<a class="headerlink" href="#id6" title="連結到這個標頭">¶</a></h5>
<p>When possible, the <cite>coro.resume</cite> intrinsic is replaced with a direct call to the
coroutine resume function. Otherwise it is replaced with an indirect call based
on the function pointer for the resume function stored in the coroutine frame.
Resuming a coroutine that is not suspended leads to undefined behavior.</p>
</section>
</section>
<section id="llvm-coro-done-intrinsic">
<span id="coro-done"></span><h4><a class="toc-backref" href="#id59" role="doc-backlink">'llvm.coro.done' Intrinsic</a><a class="headerlink" href="#llvm-coro-done-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">done</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id7">
<h5>Overview:<a class="headerlink" href="#id7" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.done</span></code>' intrinsic checks whether a suspended coroutine is at
the final suspend point or not.</p>
</section>
<section id="id8">
<h5>Arguments:<a class="headerlink" href="#id8" title="連結到這個標頭">¶</a></h5>
<p>The argument is a handle to a suspended coroutine.</p>
</section>
<section id="id9">
<h5>Semantics:<a class="headerlink" href="#id9" title="連結到這個標頭">¶</a></h5>
<p>Using this intrinsic on a coroutine that does not have a <a class="reference internal" href="#final-suspend">final suspend</a> point
or on a coroutine that is not suspended leads to undefined behavior.</p>
</section>
</section>
<section id="llvm-coro-promise-intrinsic">
<span id="coro-promise"></span><h4><a class="toc-backref" href="#id60" role="doc-backlink">'llvm.coro.promise' Intrinsic</a><a class="headerlink" href="#llvm-coro-promise-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">promise</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">from</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id10">
<h5>Overview:<a class="headerlink" href="#id10" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.promise</span></code>' intrinsic obtains a pointer to a
<a class="reference internal" href="#coroutine-promise">coroutine promise</a> given a coroutine handle and vice versa.</p>
</section>
<section id="id11">
<h5>Arguments:<a class="headerlink" href="#id11" title="連結到這個標頭">¶</a></h5>
<p>The first argument is a handle to a coroutine if <cite>from</cite> is false. Otherwise,
it is a pointer to a coroutine promise.</p>
<p>The second argument is an alignment requirements of the promise.
If a frontend designated <cite>%promise = alloca i32</cite> as a promise, the alignment
argument to <cite>coro.promise</cite> should be the alignment of <cite>i32</cite> on the target
platform. If a frontend designated <cite>%promise = alloca i32, align 16</cite> as a
promise, the alignment argument should be 16.
This argument only accepts constants.</p>
<p>The third argument is a boolean indicating a direction of the transformation.
If <cite>from</cite> is true, the intrinsic returns a coroutine handle given a pointer
to a promise. If <cite>from</cite> is false, the intrinsics return a pointer to a promise
from a coroutine handle. This argument only accepts constants.</p>
</section>
<section id="id12">
<h5>Semantics:<a class="headerlink" href="#id12" title="連結到這個標頭">¶</a></h5>
<p>Using this intrinsic on a coroutine that does not have a coroutine promise
leads to undefined behavior. It is possible to read and modify coroutine
promise of the coroutine which is currently executing. The coroutine author and
a coroutine user are responsible to makes sure there is no data races.</p>
</section>
<section id="example">
<h5>Example:<a class="headerlink" href="#example" title="連結到這個標頭">¶</a></h5>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>define i8* @f(i32 %n) {
entry:
  %promise = alloca i32
  %pv = bitcast i32* %promise to i8*
  ; the second argument to coro.id points to the coroutine promise.
  %id = call token @llvm.coro.id(i32 0, i8* %pv, i8* null, i8* null)
  ...
  %hdl = call noalias i8* @llvm.coro.begin(token %id, i8* %alloc)
  ...
  store i32 42, i32* %promise ; store something into the promise
  ...
  ret i8* %hdl
}

define i32 @main() {
entry:
  %hdl = call i8* @f(i32 4) ; starts the coroutine and returns its handle
  %promise.addr.raw = call i8* @llvm.coro.promise(i8* %hdl, i32 4, i1 false)
  %promise.addr = bitcast i8* %promise.addr.raw to i32*
  %val = load i32, i32* %promise.addr ; load a value from the promise
  call void @print(i32 %val)
  call void @llvm.coro.destroy(i8* %hdl)
  ret i32 0
}
</pre></div>
</div>
</section>
</section>
</section>
<section id="coroutine-structure-intrinsics">
<span id="coroutine-intrinsics"></span><h3><a class="toc-backref" href="#id61" role="doc-backlink">Coroutine Structure Intrinsics</a><a class="headerlink" href="#coroutine-structure-intrinsics" title="連結到這個標頭">¶</a></h3>
<p>Intrinsics described in this section are used within a coroutine to describe
the coroutine structure. They should not be used outside of a coroutine.</p>
<section id="llvm-coro-size-intrinsic">
<span id="coro-size"></span><h4><a class="toc-backref" href="#id62" role="doc-backlink">'llvm.coro.size' Intrinsic</a><a class="headerlink" href="#llvm-coro-size-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">i32</span><span class="p">()</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">i64</span><span class="p">()</span>
</pre></div>
</div>
<section id="id13">
<h5>Overview:<a class="headerlink" href="#id13" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.size</span></code>' intrinsic returns the number of bytes
required to store a <a class="reference internal" href="#coroutine-frame">coroutine frame</a>.</p>
</section>
<section id="id14">
<h5>Arguments:<a class="headerlink" href="#id14" title="連結到這個標頭">¶</a></h5>
<p>None</p>
</section>
<section id="id15">
<h5>Semantics:<a class="headerlink" href="#id15" title="連結到這個標頭">¶</a></h5>
<p>The <cite>coro.size</cite> intrinsic is lowered to a constant representing the size of
the coroutine frame.</p>
</section>
</section>
<section id="llvm-coro-begin-intrinsic">
<span id="coro-begin"></span><h4><a class="toc-backref" href="#id63" role="doc-backlink">'llvm.coro.begin' Intrinsic</a><a class="headerlink" href="#llvm-coro-begin-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">token</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">mem</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id16">
<h5>Overview:<a class="headerlink" href="#id16" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.begin</span></code>' intrinsic returns an address of the coroutine frame.</p>
</section>
<section id="id17">
<h5>Arguments:<a class="headerlink" href="#id17" title="連結到這個標頭">¶</a></h5>
<p>The first argument is a token returned by a call to '<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>'
identifying the coroutine.</p>
<p>The second argument is a pointer to a block of memory where coroutine frame
will be stored if it is allocated dynamically.</p>
</section>
<section id="id18">
<h5>Semantics:<a class="headerlink" href="#id18" title="連結到這個標頭">¶</a></h5>
<p>Depending on the alignment requirements of the objects in the coroutine frame
and/or on the codegen compactness reasons the pointer returned from <cite>coro.begin</cite>
may be at offset to the <cite>%mem</cite> argument. (This could be beneficial if
instructions that express relative access to data can be more compactly encoded
with small positive and negative offsets).</p>
<p>A frontend should emit exactly one <cite>coro.begin</cite> intrinsic per coroutine.</p>
</section>
</section>
<section id="llvm-coro-free-intrinsic">
<span id="coro-free"></span><h4><a class="toc-backref" href="#id64" role="doc-backlink">'llvm.coro.free' Intrinsic</a><a class="headerlink" href="#llvm-coro-free-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">token</span> <span class="o">%</span><span class="nb">id</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">frame</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id19">
<h5>Overview:<a class="headerlink" href="#id19" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.free</span></code>' intrinsic returns a pointer to a block of memory where
coroutine frame is stored or <cite>null</cite> if this instance of a coroutine did not use
dynamically allocated memory for its coroutine frame.</p>
</section>
<section id="id20">
<h5>Arguments:<a class="headerlink" href="#id20" title="連結到這個標頭">¶</a></h5>
<p>The first argument is a token returned by a call to '<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>'
identifying the coroutine.</p>
<p>The second argument is a pointer to the coroutine frame. This should be the same
pointer that was returned by prior <cite>coro.begin</cite> call.</p>
</section>
<section id="example-custom-deallocation-function">
<h5>Example (custom deallocation function):<a class="headerlink" href="#example-custom-deallocation-function" title="連結到這個標頭">¶</a></h5>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cleanup:
  %mem = call i8* @llvm.coro.free(token %id, i8* %frame)
  %mem_not_null = icmp ne i8* %mem, null
  br i1 %mem_not_null, label %if.then, label %if.end
if.then:
  call void @CustomFree(i8* %mem)
  br label %if.end
if.end:
  ret void
</pre></div>
</div>
</section>
<section id="example-standard-deallocation-functions">
<h5>Example (standard deallocation functions):<a class="headerlink" href="#example-standard-deallocation-functions" title="連結到這個標頭">¶</a></h5>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cleanup:
  %mem = call i8* @llvm.coro.free(token %id, i8* %frame)
  call void @free(i8* %mem)
  ret void
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-alloc-intrinsic">
<span id="coro-alloc"></span><h4><a class="toc-backref" href="#id65" role="doc-backlink">'llvm.coro.alloc' Intrinsic</a><a class="headerlink" href="#llvm-coro-alloc-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">token</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id21">
<h5>Overview:<a class="headerlink" href="#id21" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.alloc</span></code>' intrinsic returns <cite>true</cite> if dynamic allocation is
required to obtain a memory for the corutine frame and <cite>false</cite> otherwise.</p>
</section>
<section id="id22">
<h5>Arguments:<a class="headerlink" href="#id22" title="連結到這個標頭">¶</a></h5>
<p>The first argument is a token returned by a call to '<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>'
identifying the coroutine.</p>
</section>
<section id="id23">
<h5>Semantics:<a class="headerlink" href="#id23" title="連結到這個標頭">¶</a></h5>
<p>A frontend should emit at most one <cite>coro.alloc</cite> intrinsic per coroutine.
The intrinsic is used to suppress dynamic allocation of the coroutine frame
when possible.</p>
</section>
<section id="id24">
<h5>Example:<a class="headerlink" href="#id24" title="連結到這個標頭">¶</a></h5>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>entry:
  %id = call token @llvm.coro.id(i32 0, i8* null, i8* null, i8* null)
  %dyn.alloc.required = call i1 @llvm.coro.alloc(token %id)
  br i1 %dyn.alloc.required, label %coro.alloc, label %coro.begin

coro.alloc:
  %frame.size = call i32 @llvm.coro.size()
  %alloc = call i8* @MyAlloc(i32 %frame.size)
  br label %coro.begin

coro.begin:
  %phi = phi i8* [ null, %entry ], [ %alloc, %coro.alloc ]
  %frame = call i8* @llvm.coro.begin(token %id, i8* %phi)
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-frame-intrinsic">
<span id="coro-frame"></span><h4><a class="toc-backref" href="#id66" role="doc-backlink">'llvm.coro.frame' Intrinsic</a><a class="headerlink" href="#llvm-coro-frame-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span><span class="o">*</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">frame</span><span class="p">()</span>
</pre></div>
</div>
<section id="id25">
<h5>Overview:<a class="headerlink" href="#id25" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.frame</span></code>' intrinsic returns an address of the coroutine frame of
the enclosing coroutine.</p>
</section>
<section id="id26">
<h5>Arguments:<a class="headerlink" href="#id26" title="連結到這個標頭">¶</a></h5>
<p>None</p>
</section>
<section id="id27">
<h5>Semantics:<a class="headerlink" href="#id27" title="連結到這個標頭">¶</a></h5>
<p>This intrinsic is lowered to refer to the <a class="reference internal" href="#coro-begin">coro.begin</a> instruction. This is
a frontend convenience intrinsic that makes it easier to refer to the
coroutine frame.</p>
</section>
</section>
<section id="llvm-coro-id-intrinsic">
<span id="coro-id"></span><h4><a class="toc-backref" href="#id67" role="doc-backlink">'llvm.coro.id' Intrinsic</a><a class="headerlink" href="#llvm-coro-id-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">promise</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">coroaddr</span><span class="o">&gt;</span><span class="p">,</span>
                                                        <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">fnaddrs</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id28">
<h5>Overview:<a class="headerlink" href="#id28" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>' intrinsic returns a token identifying a coroutine.</p>
</section>
<section id="id29">
<h5>Arguments:<a class="headerlink" href="#id29" title="連結到這個標頭">¶</a></h5>
<p>The first argument provides information on the alignment of the memory returned
by the allocation function and given to <cite>coro.begin</cite> by the first argument. If
this argument is 0, the memory is assumed to be aligned to 2 * sizeof(i8*).
This argument only accepts constants.</p>
<p>The second argument, if not <cite>null</cite>, designates a particular alloca instruction
to be a <a class="reference internal" href="#coroutine-promise">coroutine promise</a>.</p>
<p>The third argument is <cite>null</cite> coming out of the frontend. The CoroEarly pass sets
this argument to point to the function this coro.id belongs to.</p>
<p>The fourth argument is <cite>null</cite> before coroutine is split, and later is replaced
to point to a private global constant array containing function pointers to
outlined resume and destroy parts of the coroutine.</p>
</section>
<section id="id30">
<h5>Semantics:<a class="headerlink" href="#id30" title="連結到這個標頭">¶</a></h5>
<p>The purpose of this intrinsic is to tie together <cite>coro.id</cite>, <cite>coro.alloc</cite> and
<cite>coro.begin</cite> belonging to the same coroutine to prevent optimization passes from
duplicating any of these instructions unless entire body of the coroutine is
duplicated.</p>
<p>A frontend should emit exactly one <cite>coro.id</cite> intrinsic per coroutine.</p>
</section>
</section>
<section id="llvm-coro-end-intrinsic">
<span id="coro-end"></span><h4><a class="toc-backref" href="#id68" role="doc-backlink">'llvm.coro.end' Intrinsic</a><a class="headerlink" href="#llvm-coro-end-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">unwind</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id31">
<h5>Overview:<a class="headerlink" href="#id31" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.end</span></code>' marks the point where execution of the resume part of
the coroutine should end and control returns back to the caller.</p>
</section>
<section id="id32">
<h5>Arguments:<a class="headerlink" href="#id32" title="連結到這個標頭">¶</a></h5>
<p>The first argument should refer to the coroutine handle of the enclosing coroutine.</p>
<p>The second argument should be <cite>true</cite> if this coro.end is in the block that is
part of the unwind sequence leaving the coroutine body due to exception prior to
the first reaching any suspend points, and <cite>false</cite> otherwise.</p>
</section>
<section id="id33">
<h5>Semantics:<a class="headerlink" href="#id33" title="連結到這個標頭">¶</a></h5>
<p>The <a class="reference internal" href="#coro-end">coro.end</a> intrinsic is a no-op during an initial invocation of the
coroutine. When the coroutine resumes, the intrinsic marks the point when
coroutine need to return control back to the caller.</p>
<p>This intrinsic is removed by the CoroSplit pass when a coroutine is split into
the start, resume and destroy parts. In start part, the intrinsic is removed,
in resume and destroy parts, it is replaced with <cite>ret void</cite> instructions and
the rest of the block containing <cite>coro.end</cite> instruction is discarded.</p>
<p>In landing pads it is replaced with an appropriate instruction to unwind to
caller.</p>
<p>A frontend is allowed to supply null as the first parameter, in this case
<cite>coro-early</cite> pass will replace the null with an appropriate coroutine handle
value.</p>
</section>
</section>
<section id="llvm-coro-suspend-intrinsic">
<span id="suspend-points"></span><span id="coro-suspend"></span><h4><a class="toc-backref" href="#id69" role="doc-backlink">'llvm.coro.suspend' Intrinsic</a><a class="headerlink" href="#llvm-coro-suspend-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">suspend</span><span class="p">(</span><span class="n">token</span> <span class="o">&lt;</span><span class="n">save</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">final</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id34">
<h5>Overview:<a class="headerlink" href="#id34" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend</span></code>' marks the point where execution of the coroutine
need to get suspended and control returned back to the caller.
Conditional branches consuming the result of this intrinsic lead to basic blocks
where coroutine should proceed when suspended (-1), resumed (0) or destroyed
(1).</p>
</section>
<section id="id35">
<h5>Arguments:<a class="headerlink" href="#id35" title="連結到這個標頭">¶</a></h5>
<p>The first argument refers to a token of <cite>coro.save</cite> intrinsic that marks the
point when coroutine state is prepared for suspension. If <cite>none</cite> token is passed,
the intrinsic behaves as if there were a <cite>coro.save</cite> immediately preceding
the <cite>coro.suspend</cite> intrinsic.</p>
<p>The second argument indicates whether this suspension point is <a class="reference internal" href="#final">final</a>.
The second argument only accepts constants. If more than one suspend point is
designated as final, the resume and destroy branches should lead to the same
basic blocks.</p>
</section>
<section id="example-normal-suspend-point">
<h5>Example (normal suspend point):<a class="headerlink" href="#example-normal-suspend-point" title="連結到這個標頭">¶</a></h5>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%0 = call i8 @llvm.coro.suspend(token none, i1 false)
switch i8 %0, label %suspend [i8 0, label %resume
                              i8 1, label %cleanup]
</pre></div>
</div>
</section>
<section id="example-final-suspend-point">
<h5>Example (final suspend point):<a class="headerlink" href="#example-final-suspend-point" title="連結到這個標頭">¶</a></h5>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>while.end:
  %s.final = call i8 @llvm.coro.suspend(token none, i1 true)
  switch i8 %s.final, label %suspend [i8 0, label %trap
                                      i8 1, label %cleanup]
trap:
  call void @llvm.trap()
  unreachable
</pre></div>
</div>
</section>
<section id="id36">
<h5>Semantics:<a class="headerlink" href="#id36" title="連結到這個標頭">¶</a></h5>
<p>If a coroutine that was suspended at the suspend point marked by this intrinsic
is resumed via <a class="reference internal" href="#coro-resume">coro.resume</a> the control will transfer to the basic block
of the 0-case. If it is resumed via <a class="reference internal" href="#coro-destroy">coro.destroy</a>, it will proceed to the
basic block indicated by the 1-case. To suspend, coroutine proceed to the
default label.</p>
<p>If suspend intrinsic is marked as final, it can consider the <cite>true</cite> branch
unreachable and can perform optimizations that can take advantage of that fact.</p>
</section>
</section>
<section id="llvm-coro-save-intrinsic">
<span id="coro-save"></span><h4><a class="toc-backref" href="#id70" role="doc-backlink">'llvm.coro.save' Intrinsic</a><a class="headerlink" href="#llvm-coro-save-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id37">
<h5>Overview:<a class="headerlink" href="#id37" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.save</span></code>' marks the point where a coroutine need to update its
state to prepare for resumption to be considered suspended (and thus eligible
for resumption).</p>
</section>
<section id="id38">
<h5>Arguments:<a class="headerlink" href="#id38" title="連結到這個標頭">¶</a></h5>
<p>The first argument points to a coroutine handle of the enclosing coroutine.</p>
</section>
<section id="id39">
<h5>Semantics:<a class="headerlink" href="#id39" title="連結到這個標頭">¶</a></h5>
<p>Whatever coroutine state changes are required to enable resumption of
the coroutine from the corresponding suspend point should be done at the point
of <cite>coro.save</cite> intrinsic.</p>
</section>
<section id="id40">
<h5>Example:<a class="headerlink" href="#id40" title="連結到這個標頭">¶</a></h5>
<p>Separate save and suspend points are necessary when a coroutine is used to
represent an asynchronous control flow driven by callbacks representing
completions of asynchronous operations.</p>
<p>In such a case, a coroutine should be ready for resumption prior to a call to
<cite>async_op</cite> function that may trigger resumption of a coroutine from the same or
a different thread possibly prior to <cite>async_op</cite> call returning control back
to the coroutine:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%save1 = call token @llvm.coro.save(i8* %hdl)
call void async_op1(i8* %hdl)
%suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false)
switch i8 %suspend1, label %suspend [i8 0, label %resume1
                                     i8 1, label %cleanup]
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-param-intrinsic">
<span id="coro-param"></span><h4><a class="toc-backref" href="#id71" role="doc-backlink">'llvm.coro.param' Intrinsic</a><a class="headerlink" href="#llvm-coro-param-intrinsic" title="連結到這個標頭">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">original</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">copy</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id41">
<h5>Overview:<a class="headerlink" href="#id41" title="連結到這個標頭">¶</a></h5>
<p>The '<code class="docutils literal notranslate"><span class="pre">llvm.coro.param</span></code>' is used by a frontend to mark up the code used to
construct and destruct copies of the parameters. If the optimizer discovers that
a particular parameter copy is not used after any suspends, it can remove the
construction and destruction of the copy by replacing corresponding coro.param
with <cite>i1 false</cite> and replacing any use of the <cite>copy</cite> with the <cite>original</cite>.</p>
</section>
<section id="id42">
<h5>Arguments:<a class="headerlink" href="#id42" title="連結到這個標頭">¶</a></h5>
<p>The first argument points to an <cite>alloca</cite> storing the value of a parameter to a
coroutine.</p>
<p>The second argument points to an <cite>alloca</cite> storing the value of the copy of that
parameter.</p>
</section>
<section id="id43">
<h5>Semantics:<a class="headerlink" href="#id43" title="連結到這個標頭">¶</a></h5>
<p>The optimizer is free to always replace this intrinsic with <cite>i1 true</cite>.</p>
<p>The optimizer is also allowed to replace it with <cite>i1 false</cite> provided that the
parameter copy is only used prior to control flow reaching any of the suspend
points. The code that would be DCE'd if the <cite>coro.param</cite> is replaced with
<cite>i1 false</cite> is not considered to be a use of the parameter copy.</p>
<p>The frontend can emit this intrinsic if its language rules allow for this
optimization.</p>
</section>
<section id="id44">
<h5>Example:<a class="headerlink" href="#id44" title="連結到這個標頭">¶</a></h5>
<p>Consider the following example. A coroutine takes two parameters <cite>a</cite> and <cite>b</cite>
that has a destructor and a move constructor.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">~</span><span class="n">A</span><span class="p">();</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w"> </span><span class="p">};</span>

<span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">foo</span><span class="p">())</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>

<span class="w">  </span><span class="n">a</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span>
<span class="w">  </span><span class="k">co_await</span><span class="w"> </span><span class="n">read_async</span><span class="p">();</span><span class="w"> </span><span class="c1">// introduces suspend point</span>
<span class="w">  </span><span class="n">b</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that, uses of <cite>b</cite> is used after a suspend point and thus must be copied
into a coroutine frame, whereas <cite>a</cite> does not have to, since it never used
after suspend.</p>
<p>A frontend can create parameter copies for <cite>a</cite> and <cite>b</cite> as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>task&lt;int&gt; f(A a&#39;, A b&#39;) {
  a = alloca A;
  b = alloca A;
  // move parameters to its copies
  if (coro.param(a&#39;, a)) A::A(a, A&amp;&amp; a&#39;);
  if (coro.param(b&#39;, b)) A::A(b, A&amp;&amp; b&#39;);
  ...
  // destroy parameters copies
  if (coro.param(a&#39;, a)) A::~A(a);
  if (coro.param(b&#39;, b)) A::~A(b);
}
</pre></div>
</div>
<p>The optimizer can replace coro.param(a',a) with <cite>i1 false</cite> and replace all uses
of <cite>a</cite> with <cite>a'</cite>, since it is not used after suspend.</p>
<p>The optimizer must replace coro.param(b', b) with <cite>i1 true</cite>, since <cite>b</cite> is used
after suspend and therefore, it has to reside in the coroutine frame.</p>
</section>
</section>
</section>
</section>
<section id="coroutine-transformation-passes">
<h2><a class="toc-backref" href="#id72" role="doc-backlink">Coroutine Transformation Passes</a><a class="headerlink" href="#coroutine-transformation-passes" title="連結到這個標頭">¶</a></h2>
<section id="coroearly">
<h3><a class="toc-backref" href="#id73" role="doc-backlink">CoroEarly</a><a class="headerlink" href="#coroearly" title="連結到這個標頭">¶</a></h3>
<p>The pass CoroEarly lowers coroutine intrinsics that hide the details of the
structure of the coroutine frame, but, otherwise not needed to be preserved to
help later coroutine passes. This pass lowers <a class="reference internal" href="#coro-frame">coro.frame</a>, <a class="reference internal" href="#coro-done">coro.done</a>,
and <a class="reference internal" href="#coro-promise">coro.promise</a> intrinsics.</p>
</section>
<section id="corosplit">
<span id="id45"></span><h3><a class="toc-backref" href="#id74" role="doc-backlink">CoroSplit</a><a class="headerlink" href="#corosplit" title="連結到這個標頭">¶</a></h3>
<p>The pass CoroSplit buides coroutine frame and outlines resume and destroy parts
into separate functions.</p>
</section>
<section id="coroelide">
<h3><a class="toc-backref" href="#id75" role="doc-backlink">CoroElide</a><a class="headerlink" href="#coroelide" title="連結到這個標頭">¶</a></h3>
<p>The pass CoroElide examines if the inlined coroutine is eligible for heap
allocation elision optimization. If so, it replaces
<cite>coro.begin</cite> intrinsic with an address of a coroutine frame placed on its caller
and replaces <cite>coro.alloc</cite> and <cite>coro.free</cite> intrinsics with <cite>false</cite> and <cite>null</cite>
respectively to remove the deallocation code.
This pass also replaces <cite>coro.resume</cite> and <cite>coro.destroy</cite> intrinsics with direct
calls to resume and destroy functions for a particular coroutine where possible.</p>
</section>
<section id="corocleanup">
<h3><a class="toc-backref" href="#id76" role="doc-backlink">CoroCleanup</a><a class="headerlink" href="#corocleanup" title="連結到這個標頭">¶</a></h3>
<p>This pass runs late to lower all coroutine related intrinsics not replaced by
earlier passes.</p>
</section>
</section>
<section id="areas-requiring-attention">
<h2><a class="toc-backref" href="#id77" role="doc-backlink">Areas Requiring Attention</a><a class="headerlink" href="#areas-requiring-attention" title="連結到這個標頭">¶</a></h2>
<ol class="arabic simple">
<li><p>A coroutine frame is bigger than it could be. Adding stack packing and stack
coloring like optimization on the coroutine frame will result in tighter
coroutine frames.</p></li>
<li><p>Take advantage of the lifetime intrinsics for the data that goes into the
coroutine frame. Leave lifetime intrinsics as is for the data that stays in
allocas.</p></li>
<li><p>The CoroElide optimization pass relies on coroutine ramp function to be
inlined. It would be beneficial to split the ramp function further to
increase the chance that it will get inlined into its caller.</p></li>
<li><p>Design a convention that would make it possible to apply coroutine heap
elision optimization across ABI boundaries.</p></li>
<li><p>Cannot handle coroutines with <cite>inalloca</cite> parameters (used in x86 on Windows).</p></li>
<li><p>Alignment is ignored by coro.begin and coro.free intrinsics.</p></li>
<li><p>Make required changes to make sure that coroutine optimizations work with
LTO.</p></li>
<li><p>More tests, more tests, more tests</p></li>
</ol>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="GlobalISel.html" title="Global Instruction Selection"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="MIRLangRef.html" title="Machine IR (MIR) Format Reference Manual"
             >上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Coroutines in LLVM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; 版權所有 2003-2025, LLVM Project.
      最後更新於 2025-10-28。
      使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3 建立。
    </div>
  </body>
</html>