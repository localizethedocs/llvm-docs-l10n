
<!DOCTYPE html>

<html lang="zh-TW" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Global Instruction Selection &#8212; LLVM 9 說明文件</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=4c4af0c1" />
    <script src="_static/documentation_options.js?v=9e9749be"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/llvm-docs-l10n/GlobalISel.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜尋" href="search.html" />
    <link rel="next" title="XRay Instrumentation" href="XRay.html" />
    <link rel="prev" title="Coroutines in LLVM" href="Coroutines.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="XRay.html" title="XRay Instrumentation"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="Coroutines.html" title="Coroutines in LLVM"
             accesskey="P">上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Global Instruction Selection</a></li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="global-instruction-selection">
<h1>Global Instruction Selection<a class="headerlink" href="#global-instruction-selection" title="連結到這個標頭">¶</a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id14">簡介</a></p></li>
<li><p><a class="reference internal" href="#generic-machine-ir" id="id15">Generic Machine IR</a></p></li>
<li><p><a class="reference internal" href="#core-pipeline" id="id16">Core Pipeline</a></p></li>
<li><p><a class="reference internal" href="#maintainability" id="id17">Maintainability</a></p></li>
<li><p><a class="reference internal" href="#progress-and-future-work" id="id18">Progress and Future Work</a></p></li>
<li><p><a class="reference internal" href="#porting-globalisel-to-a-new-target" id="id19">Porting GlobalISel to A New Target</a></p></li>
<li><p><a class="reference internal" href="#resources" id="id20">Resources</a></p></li>
</ul>
</nav>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>This document is a work in progress.  It reflects the current state of the
implementation, as well as open design and implementation issues.</p>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">簡介</a><a class="headerlink" href="#introduction" title="連結到這個標頭">¶</a></h2>
<p>GlobalISel is a framework that provides a set of reusable passes and utilities
for instruction selection --- translation from LLVM IR to target-specific
Machine IR (MIR).</p>
<p>GlobalISel is intended to be a replacement for SelectionDAG and FastISel, to
solve three major problems:</p>
<ul>
<li><p><strong>Performance</strong> --- SelectionDAG introduces a dedicated intermediate
representation, which has a compile-time cost.</p>
<p>GlobalISel directly operates on the post-isel representation used by the
rest of the code generator, MIR.
It does require extensions to that representation to support arbitrary
incoming IR: <a class="reference internal" href="#gmir"><span class="std std-ref">Generic Machine IR</span></a>.</p>
</li>
<li><p><strong>Granularity</strong> --- SelectionDAG and FastISel operate on individual basic
blocks, losing some global optimization opportunities.</p>
<p>GlobalISel operates on the whole function.</p>
</li>
<li><p><strong>Modularity</strong> --- SelectionDAG and FastISel are radically different and share
very little code.</p>
<p>GlobalISel is built in a way that enables code reuse. For instance, both the
optimized and fast selectors share the <a class="reference internal" href="#pipeline"><span class="std std-ref">Core Pipeline</span></a>, and targets can
configure that pipeline to better suit their needs.</p>
</li>
</ul>
</section>
<section id="generic-machine-ir">
<span id="gmir"></span><h2><a class="toc-backref" href="#id15" role="doc-backlink">Generic Machine IR</a><a class="headerlink" href="#generic-machine-ir" title="連結到這個標頭">¶</a></h2>
<p>Machine IR operates on physical registers, register classes, and (mostly)
target-specific instructions.</p>
<p>To bridge the gap with LLVM IR, GlobalISel introduces &quot;generic&quot; extensions to
Machine IR:</p>
<nav class="contents local" id="id2">
<ul class="simple">
<li><p><a class="reference internal" href="#generic-instructions" id="id21">Generic Instructions</a></p></li>
<li><p><a class="reference internal" href="#generic-virtual-registers" id="id22">Generic Virtual Registers</a></p></li>
<li><p><a class="reference internal" href="#register-bank" id="id23">Register Bank</a></p></li>
<li><p><a class="reference internal" href="#low-level-type" id="id24">Low Level Type</a></p></li>
</ul>
</nav>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
The generic MIR (GMIR) representation still contains references to IR
constructs (such as <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code>).  Removing those should let us write more
accurate tests, or delete IR after building the initial MIR.  However, it is
not part of the GlobalISel effort.</p>
<section id="generic-instructions">
<span id="gmir-instructions"></span><h3><a class="toc-backref" href="#id21" role="doc-backlink">Generic Instructions</a><a class="headerlink" href="#generic-instructions" title="連結到這個標頭">¶</a></h3>
<p>The main addition is support for pre-isel generic machine instructions (e.g.,
<code class="docutils literal notranslate"><span class="pre">G_ADD</span></code>).  Like other target-independent instructions (e.g., <code class="docutils literal notranslate"><span class="pre">COPY</span></code> or
<code class="docutils literal notranslate"><span class="pre">PHI</span></code>), these are available on all targets.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
While we're progressively adding instructions, one kind in particular exposes
interesting problems: compares and how to represent condition codes.
Some targets (x86, ARM) have generic comparisons setting multiple flags,
which are then used by predicated variants.
Others (IR) specify the predicate in the comparison and users just get a single
bit.  SelectionDAG uses SETCC/CONDBR vs BR_CC (and similar for select) to
represent this.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MachineIRBuilder</span></code> class wraps the <code class="docutils literal notranslate"><span class="pre">MachineInstrBuilder</span></code> and provides
a convenient way to create these generic instructions.</p>
</section>
<section id="generic-virtual-registers">
<span id="gmir-gvregs"></span><h3><a class="toc-backref" href="#id22" role="doc-backlink">Generic Virtual Registers</a><a class="headerlink" href="#generic-virtual-registers" title="連結到這個標頭">¶</a></h3>
<p>Generic instructions operate on a new kind of register: &quot;generic&quot; virtual
registers.  As opposed to non-generic vregs, they are not assigned a Register
Class.  Instead, generic vregs have a <a class="reference internal" href="#gmir-llt"><span class="std std-ref">Low Level Type</span></a>, and can be assigned
a <a class="reference internal" href="#gmir-regbank"><span class="std std-ref">Register Bank</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MachineRegisterInfo</span></code> tracks the same information that it does for
non-generic vregs (e.g., use-def chains).  Additionally, it also tracks the
<a class="reference internal" href="#gmir-llt"><span class="std std-ref">Low Level Type</span></a> of the register, and, instead of the <code class="docutils literal notranslate"><span class="pre">TargetRegisterClass</span></code>,
its <a class="reference internal" href="#gmir-regbank"><span class="std std-ref">Register Bank</span></a>, if any.</p>
<p>For simplicity, most generic instructions only accept generic vregs:</p>
<ul class="simple">
<li><p>instead of immediates, they use a gvreg defined by an instruction
materializing the immediate value (see <a class="reference internal" href="#irtranslator-constants"><span class="std std-ref">Constant Lowering</span></a>).</p></li>
<li><p>instead of physical register, they use a gvreg defined by a <code class="docutils literal notranslate"><span class="pre">COPY</span></code>.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
We started with an alternative representation, where MRI tracks a size for
each gvreg, and instructions have lists of types.
That had two flaws: the type and size are redundant, and there was no generic
way of getting a given operand's type (as there was no 1:1 mapping between
instruction types and operands).
We considered putting the type in some variant of MCInstrDesc instead:
See <a class="reference external" href="http://llvm.org/PR26576">PR26576</a>: [GlobalISel] Generic MachineInstrs
need a type but this increases the memory footprint of the related objects</p>
</section>
<section id="register-bank">
<span id="gmir-regbank"></span><h3><a class="toc-backref" href="#id23" role="doc-backlink">Register Bank</a><a class="headerlink" href="#register-bank" title="連結到這個標頭">¶</a></h3>
<p>A Register Bank is a set of register classes defined by the target.
A bank has a size, which is the maximum store size of all covered classes.</p>
<p>In general, cross-class copies inside a bank are expected to be cheaper than
copies across banks.  They are also coalesceable by the register coalescer,
whereas cross-bank copies are not.</p>
<p>Also, equivalent operations can be performed on different banks using different
instructions.</p>
<p>For example, X86 can be seen as having 3 main banks: general-purpose, x87, and
vector (which could be further split into a bank per domain for single vs
double precision instructions).</p>
<p>Register banks are described by a target-provided API,
<a class="reference internal" href="#api-registerbankinfo"><span class="std std-ref">RegisterBankInfo</span></a>.</p>
</section>
<section id="low-level-type">
<span id="gmir-llt"></span><h3><a class="toc-backref" href="#id24" role="doc-backlink">Low Level Type</a><a class="headerlink" href="#low-level-type" title="連結到這個標頭">¶</a></h3>
<p>Additionally, every generic virtual register has a type, represented by an
instance of the <code class="docutils literal notranslate"><span class="pre">LLT</span></code> class.</p>
<p>Like <code class="docutils literal notranslate"><span class="pre">EVT</span></code>/<code class="docutils literal notranslate"><span class="pre">MVT</span></code>/<code class="docutils literal notranslate"><span class="pre">Type</span></code>, it has no distinction between unsigned and signed
integer types.  Furthermore, it also has no distinction between integer and
floating-point types: it mainly conveys absolutely necessary information, such
as size and number of vector lanes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sN</span></code> for scalars</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pN</span></code> for pointers</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;N</span> <span class="pre">x</span> <span class="pre">sM&gt;</span></code> for vectors</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsized</span></code> for labels, etc..</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">LLT</span></code> is intended to replace the usage of <code class="docutils literal notranslate"><span class="pre">EVT</span></code> in SelectionDAG.</p>
<p>Here are some LLT examples and their <code class="docutils literal notranslate"><span class="pre">EVT</span></code> and <code class="docutils literal notranslate"><span class="pre">Type</span></code> equivalents:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>LLT</p></th>
<th class="head"><p>EVT</p></th>
<th class="head"><p>IR Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i1</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s8</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i8</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i8</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s32</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s32</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f32</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s17</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i17</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i17</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s16</span></code></p></td>
<td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">{i8,</span> <span class="pre">i8}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s32</span></code></p></td>
<td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4</span> <span class="pre">x</span> <span class="pre">i8]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">p0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">iPTR</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i8*</span></code>, <code class="docutils literal notranslate"><span class="pre">i32*</span></code>, <code class="docutils literal notranslate"><span class="pre">%opaque*</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">p2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">iPTR</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i8</span> <span class="pre">addrspace(2)*</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">s32&gt;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v4f32</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">float&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s64</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v1f64</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;1</span> <span class="pre">x</span> <span class="pre">double&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;3</span> <span class="pre">x</span> <span class="pre">s32&gt;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v3i32</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;3</span> <span class="pre">x</span> <span class="pre">i32&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">unsized</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Other</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">label</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Rationale: instructions already encode a specific interpretation of types
(e.g., <code class="docutils literal notranslate"><span class="pre">add</span></code> vs. <code class="docutils literal notranslate"><span class="pre">fadd</span></code>, or <code class="docutils literal notranslate"><span class="pre">sdiv</span></code> vs. <code class="docutils literal notranslate"><span class="pre">udiv</span></code>).  Also encoding that
information in the type system requires introducing bitcast with no real
advantage for the selector.</p>
<p>Pointer types are distinguished by address space.  This matches IR, as opposed
to SelectionDAG where address space is an attribute on operations.
This representation better supports pointers having different sizes depending
on their addressspace.</p>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
Currently, LLT requires at least 2 elements in vectors, but some targets have
the concept of a '1-element vector'.  Representing them as their underlying
scalar type is a nice simplification.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
Currently, non-generic virtual registers, defined by non-pre-isel-generic
instructions, cannot have a type, and thus cannot be used by a pre-isel generic
instruction.  Instead, they are given a type using a COPY.  We could relax that
and allow types on all vregs: this would reduce the number of MI required when
emitting target-specific MIR early in the pipeline.  This should purely be
a compile-time optimization.</p>
</section>
</section>
<section id="core-pipeline">
<span id="pipeline"></span><h2><a class="toc-backref" href="#id16" role="doc-backlink">Core Pipeline</a><a class="headerlink" href="#core-pipeline" title="連結到這個標頭">¶</a></h2>
<p>There are four required passes, regardless of the optimization mode:</p>
<nav class="contents local" id="id3">
<ul class="simple">
<li><p><a class="reference internal" href="#irtranslator" id="id25">IRTranslator</a></p>
<ul>
<li><p><a class="reference internal" href="#api-calllowering" id="id26">API: CallLowering</a></p></li>
<li><p><a class="reference internal" href="#aggregates" id="id27">Aggregates</a></p></li>
<li><p><a class="reference internal" href="#constant-lowering" id="id28">Constant Lowering</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#legalizer" id="id29">Legalizer</a></p>
<ul>
<li><p><a class="reference internal" href="#api-legalizerinfo" id="id30">API: LegalizerInfo</a></p>
<ul>
<li><p><a class="reference internal" href="#rule-processing-and-declaring-rules" id="id31">Rule Processing and Declaring Rules</a></p></li>
<li><p><a class="reference internal" href="#rule-actions" id="id32">Rule Actions</a></p></li>
<li><p><a class="reference internal" href="#rule-predicates" id="id33">Rule Predicates</a></p></li>
<li><p><a class="reference internal" href="#composite-rules" id="id34">Composite Rules</a></p></li>
<li><p><a class="reference internal" href="#other-information" id="id35">Other Information</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#regbankselect" id="id36">RegBankSelect</a></p>
<ul>
<li><p><a class="reference internal" href="#api-registerbankinfo" id="id37">API: RegisterBankInfo</a></p></li>
<li><p><a class="reference internal" href="#regbankselect-modes" id="id38">RegBankSelect Modes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#instructionselect" id="id39">InstructionSelect</a></p>
<ul>
<li><p><a class="reference internal" href="#api-instructionselector" id="id40">API: InstructionSelector</a></p></li>
<li><p><a class="reference internal" href="#selectiondag-rule-imports" id="id41">SelectionDAG Rule Imports</a></p></li>
<li><p><a class="reference internal" href="#patleaf-predicates" id="id42">PatLeaf Predicates</a></p></li>
<li><p><a class="reference internal" href="#custom-sdnodes" id="id43">Custom SDNodes</a></p></li>
<li><p><a class="reference internal" href="#complexpatterns" id="id44">ComplexPatterns</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>Additional passes can then be inserted at higher optimization levels or for
specific targets. For example, to match the current SelectionDAG set of
transformations: MachineCSE and a better MachineCombiner between every pass.</p>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
In theory, not all passes are always necessary.
As an additional compile-time optimization, we could skip some of the passes by
setting the relevant MachineFunction properties.  For instance, if the
IRTranslator did not encounter any illegal instruction, it would set the
<code class="docutils literal notranslate"><span class="pre">legalized</span></code> property to avoid running the <a class="reference internal" href="#milegalizer"><span class="std std-ref">Legalizer</span></a>.
Similarly, we considered specializing the IRTranslator per-target to directly
emit target-specific MI.
However, we instead decided to keep the core pipeline simple, and focus on
minimizing the overhead of the passes in the no-op cases.</p>
<section id="irtranslator">
<span id="id4"></span><h3><a class="toc-backref" href="#id25" role="doc-backlink">IRTranslator</a><a class="headerlink" href="#irtranslator" title="連結到這個標頭">¶</a></h3>
<p>This pass translates the input LLVM IR <code class="docutils literal notranslate"><span class="pre">Function</span></code> to a GMIR
<code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
This currently doesn't support the more complex instructions, in particular
those involving control flow (<code class="docutils literal notranslate"><span class="pre">switch</span></code>, <code class="docutils literal notranslate"><span class="pre">invoke</span></code>, ...).
For <code class="docutils literal notranslate"><span class="pre">switch</span></code> in particular, we can initially use the <code class="docutils literal notranslate"><span class="pre">LowerSwitch</span></code> pass.</p>
<section id="api-calllowering">
<span id="id5"></span><h4><a class="toc-backref" href="#id26" role="doc-backlink">API: CallLowering</a><a class="headerlink" href="#api-calllowering" title="連結到這個標頭">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">IRTranslator</span></code> (using the <code class="docutils literal notranslate"><span class="pre">CallLowering</span></code> target-provided utility) also
implements the ABI's calling convention by lowering calls, returns, and
arguments to the appropriate physical register usage and instruction sequences.</p>
</section>
<section id="aggregates">
<span id="irtranslator-aggregates"></span><h4><a class="toc-backref" href="#id27" role="doc-backlink">Aggregates</a><a class="headerlink" href="#aggregates" title="連結到這個標頭">¶</a></h4>
<p>Aggregates are lowered to a single scalar vreg.
This differs from SelectionDAG's multiple vregs via <code class="docutils literal notranslate"><span class="pre">GetValueVTs</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
As some of the bits are undef (padding), we should consider augmenting the
representation with additional metadata (in effect, caching computeKnownBits
information on vregs).
See <a class="reference external" href="http://llvm.org/PR26161">PR26161</a>: [GlobalISel] Value to vreg during
IR to MachineInstr translation for aggregate type</p>
</section>
<section id="constant-lowering">
<span id="irtranslator-constants"></span><h4><a class="toc-backref" href="#id28" role="doc-backlink">Constant Lowering</a><a class="headerlink" href="#constant-lowering" title="連結到這個標頭">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">IRTranslator</span></code> lowers <code class="docutils literal notranslate"><span class="pre">Constant</span></code> operands into uses of gvregs defined
by <code class="docutils literal notranslate"><span class="pre">G_CONSTANT</span></code> or <code class="docutils literal notranslate"><span class="pre">G_FCONSTANT</span></code> instructions.
Currently, these instructions are always emitted in the entry basic block.
In a <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code>, each <code class="docutils literal notranslate"><span class="pre">Constant</span></code> is materialized by a single gvreg.</p>
<p>This is beneficial as it allows us to fold constants into immediate operands
during <a class="reference internal" href="#instructionselect"><span class="std std-ref">InstructionSelect</span></a>, while still avoiding redundant materializations
for expensive non-foldable constants.
However, this can lead to unnecessary spills and reloads in an -O0 pipeline, as
these vregs can have long live ranges.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
We're investigating better placement of these instructions, in fast and
optimized modes.</p>
</section>
</section>
<section id="legalizer">
<span id="milegalizer"></span><h3><a class="toc-backref" href="#id29" role="doc-backlink">Legalizer</a><a class="headerlink" href="#legalizer" title="連結到這個標頭">¶</a></h3>
<p>This pass transforms the generic machine instructions such that they are legal.</p>
<p>A legal instruction is defined as:</p>
<ul class="simple">
<li><p><strong>selectable</strong> --- the target will later be able to select it to a
target-specific (non-generic) instruction.</p></li>
<li><p>operating on <strong>vregs that can be loaded and stored</strong> -- if necessary, the
target can select a <code class="docutils literal notranslate"><span class="pre">G_LOAD</span></code>/<code class="docutils literal notranslate"><span class="pre">G_STORE</span></code> of each gvreg operand.</p></li>
</ul>
<p>As opposed to SelectionDAG, there are no legalization phases.  In particular,
'type' and 'operation' legalization are not separate.</p>
<p>Legalization is iterative, and all state is contained in GMIR.  To maintain the
validity of the intermediate code, instructions are introduced:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G_MERGE_VALUES</span></code> --- concatenate multiple registers of the same
size into a single wider register.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">G_UNMERGE_VALUES</span></code> --- extract multiple registers of the same size
from a single wider register.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">G_EXTRACT</span></code> --- extract a simple register (as contiguous sequences of bits)
from a single wider register.</p></li>
</ul>
<p>As they are expected to be temporary byproducts of the legalization process,
they are combined at the end of the <a class="reference internal" href="#milegalizer"><span class="std std-ref">Legalizer</span></a> pass.
If any remain, they are expected to always be selectable, using loads and stores
if necessary.</p>
<p>The legality of an instruction may only depend on the instruction itself and
must not depend on any context in which the instruction is used. However, after
deciding that an instruction is not legal, using the context of the instruction
to decide how to legalize the instruction is permitted. As an example, if we
have a <code class="docutils literal notranslate"><span class="pre">G_FOO</span></code> instruction of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">1</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_CONSTANT</span> <span class="n">i32</span> <span class="mi">1</span>
<span class="o">%</span><span class="mi">2</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_FOO</span> <span class="o">%</span><span class="mi">0</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">),</span> <span class="o">%</span><span class="mi">1</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span>
</pre></div>
</div>
<p>it's impossible to say that G_FOO is legal iff %1 is a <code class="docutils literal notranslate"><span class="pre">G_CONSTANT</span></code> with
value <code class="docutils literal notranslate"><span class="pre">1</span></code>. However, the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">2</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_FOO</span> <span class="o">%</span><span class="mi">0</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">),</span> <span class="n">i32</span> <span class="mi">1</span>
</pre></div>
</div>
<p>can say that it's legal iff operand 2 is an immediate with value <code class="docutils literal notranslate"><span class="pre">1</span></code> because
that information is entirely contained within the single instruction.</p>
<section id="api-legalizerinfo">
<span id="id6"></span><h4><a class="toc-backref" href="#id30" role="doc-backlink">API: LegalizerInfo</a><a class="headerlink" href="#api-legalizerinfo" title="連結到這個標頭">¶</a></h4>
<p>The recommended <a class="footnote-reference brackets" href="#legalizer-legacy-footnote" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> API looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">getActionDefinitionsBuilder</span><span class="p">({</span><span class="n">G_ADD</span><span class="p">,</span> <span class="n">G_SUB</span><span class="p">,</span> <span class="n">G_MUL</span><span class="p">,</span> <span class="n">G_AND</span><span class="p">,</span> <span class="n">G_OR</span><span class="p">,</span> <span class="n">G_XOR</span><span class="p">,</span> <span class="n">G_SHL</span><span class="p">})</span>
    <span class="o">.</span><span class="n">legalFor</span><span class="p">({</span><span class="n">s32</span><span class="p">,</span> <span class="n">s64</span><span class="p">,</span> <span class="n">v2s32</span><span class="p">,</span> <span class="n">v4s32</span><span class="p">,</span> <span class="n">v2s64</span><span class="p">})</span>
    <span class="o">.</span><span class="n">clampScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s32</span><span class="p">,</span> <span class="n">s64</span><span class="p">)</span>
    <span class="o">.</span><span class="n">widenScalarToNextPow2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="o">.</span><span class="n">clampNumElements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v2s32</span><span class="p">,</span> <span class="n">v4s32</span><span class="p">)</span>
    <span class="o">.</span><span class="n">clampNumElements</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v2s64</span><span class="p">,</span> <span class="n">v2s64</span><span class="p">)</span>
    <span class="o">.</span><span class="n">moreElementsToNextPow2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>and describes a set of rules by which we can either declare an instruction legal
or decide which action to take to make it more legal.</p>
<p>At the core of this ruleset is the <code class="docutils literal notranslate"><span class="pre">LegalityQuery</span></code> which describes the
instruction. We use a description rather than the instruction to both allow other
passes to determine legality without having to create an instruction and also to
limit the information available to the predicates to that which is safe to rely
on. Currently, the information available to the predicates that determine
legality contains:</p>
<ul class="simple">
<li><p>The opcode for the instruction</p></li>
<li><p>The type of each type index (see <code class="docutils literal notranslate"><span class="pre">type0</span></code>, <code class="docutils literal notranslate"><span class="pre">type1</span></code>, etc.)</p></li>
<li><p>The size in bytes and atomic ordering for each MachineMemOperand</p></li>
</ul>
<section id="rule-processing-and-declaring-rules">
<h5><a class="toc-backref" href="#id31" role="doc-backlink">Rule Processing and Declaring Rules</a><a class="headerlink" href="#rule-processing-and-declaring-rules" title="連結到這個標頭">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">getActionDefinitionsBuilder</span></code> function generates a ruleset for the given
opcode(s) that rules can be added to. If multiple opcodes are given, they are
all permanently bound to the same ruleset. The rules in a ruleset are executed
from top to bottom and will start again from the top if an instruction is
legalized as a result of the rules. If the ruleset is exhausted without
satisfying any rule, then it is considered unsupported.</p>
<p>When it doesn't declare the instruction legal, each pass over the rules may
request that one type changes to another type. Sometimes this can cause multiple
types to change but we avoid this as much as possible as making multiple changes
can make it difficult to avoid infinite loops where, for example, narrowing one
type causes another to be too small and widening that type causes the first one
to be too big.</p>
<p>In general, it's advisable to declare instructions legal as close to the top of
the rule as possible and to place any expensive rules as low as possible. This
helps with performance as testing for legality happens more often than
legalization and legalization can require multiple passes over the rules.</p>
<p>As a concrete example, consider the rule:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">getActionDefinitionsBuilder</span><span class="p">({</span><span class="n">G_ADD</span><span class="p">,</span> <span class="n">G_SUB</span><span class="p">,</span> <span class="n">G_MUL</span><span class="p">,</span> <span class="n">G_AND</span><span class="p">,</span> <span class="n">G_OR</span><span class="p">,</span> <span class="n">G_XOR</span><span class="p">,</span> <span class="n">G_SHL</span><span class="p">})</span>
    <span class="o">.</span><span class="n">legalFor</span><span class="p">({</span><span class="n">s32</span><span class="p">,</span> <span class="n">s64</span><span class="p">,</span> <span class="n">v2s32</span><span class="p">,</span> <span class="n">v4s32</span><span class="p">,</span> <span class="n">v2s64</span><span class="p">})</span>
    <span class="o">.</span><span class="n">clampScalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s32</span><span class="p">,</span> <span class="n">s64</span><span class="p">)</span>
    <span class="o">.</span><span class="n">widenScalarToNextPow2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>and the instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">2</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s7</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_ADD</span> <span class="o">%</span><span class="mi">0</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s7</span><span class="p">),</span> <span class="o">%</span><span class="mi">1</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s7</span><span class="p">)</span>
</pre></div>
</div>
<p>this doesn't meet the predicate for the <a class="reference internal" href="#legalfor"><span class="std std-ref">.legalFor()</span></a> as <code class="docutils literal notranslate"><span class="pre">s7</span></code>
is not one of the listed types so it falls through to the
<a class="reference internal" href="#clampscalar"><span class="std std-ref">.clampScalar()</span></a>. It does meet the predicate for this rule
as the type is smaller than the <code class="docutils literal notranslate"><span class="pre">s32</span></code> and this rule instructs the legalizer
to change type 0 to <code class="docutils literal notranslate"><span class="pre">s32</span></code>. It then restarts from the top. This time it does
satisfy <code class="docutils literal notranslate"><span class="pre">.legalFor()</span></code> and the resulting output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">3</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_ANYEXT</span> <span class="o">%</span><span class="mi">0</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s7</span><span class="p">)</span>
<span class="o">%</span><span class="mi">4</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_ANYEXT</span> <span class="o">%</span><span class="mi">1</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s7</span><span class="p">)</span>
<span class="o">%</span><span class="mi">5</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_ADD</span> <span class="o">%</span><span class="mi">3</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">),</span> <span class="o">%</span><span class="mi">4</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span>
<span class="o">%</span><span class="mi">2</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s7</span><span class="p">)</span> <span class="o">=</span> <span class="n">G_TRUNC</span> <span class="o">%</span><span class="mi">5</span><span class="p">:</span><span class="n">_</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">G_ADD</span></code> is legal and the other instructions are scheduled for
processing by the legalizer.</p>
</section>
<section id="rule-actions">
<h5><a class="toc-backref" href="#id32" role="doc-backlink">Rule Actions</a><a class="headerlink" href="#rule-actions" title="連結到這個標頭">¶</a></h5>
<p>There are various rule factories that append rules to a ruleset but they have a
few actions in common:</p>
<ul class="simple" id="legalfor">
<li><p><code class="docutils literal notranslate"><span class="pre">legalIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">legalFor()</span></code>, etc. declare an instruction to be legal if the
predicate is satisfied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">narrowScalarIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">narrowScalarFor()</span></code>, etc. declare an instruction to be illegal
if the predicate is satisfied and indicates that narrowing the scalars in one
of the types to a specific type would make it more legal. This action supports
both scalars and vectors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">widenScalarIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">widenScalarFor()</span></code>, etc. declare an instruction to be illegal
if the predicate is satisfied and indicates that widening the scalars in one
of the types to a specific type would make it more legal. This action supports
both scalars and vectors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fewerElementsIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">fewerElementsFor()</span></code>, etc. declare an instruction to be
illegal if the predicate is satisfied and indicates reducing the number of
vector elements in one of the types to a specific type would make it more
legal. This action supports vectors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">moreElementsIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">moreElementsFor()</span></code>, etc. declare an instruction to be illegal
if the predicate is satisfied and indicates increasing the number of vector
elements in one of the types to a specific type would make it more legal.
This action supports vectors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lowerIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">lowerFor()</span></code>, etc. declare an instruction to be illegal if the
predicate is satisfied and indicates that replacing it with equivalent
instruction(s) would make it more legal. Support for this action differs for
each opcode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">libcallIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">libcallFor()</span></code>, etc. declare an instruction to be illegal if the
predicate is satisfied and indicates that replacing it with a libcall would
make it more legal. Support for this action differs for
each opcode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">customIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">customFor()</span></code>, etc. declare an instruction to be illegal if the
predicate is satisfied and indicates that the backend developer will supply
a means of making it more legal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsupportedIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">unsupportedFor()</span></code>, etc. declare an instruction to be illegal
if the predicate is satisfied and indicates that there is no way to make it
legal and the compiler should fail.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fallback()</span></code> falls back on an older API and should only be used while porting
existing code from that API.</p></li>
</ul>
</section>
<section id="rule-predicates">
<h5><a class="toc-backref" href="#id33" role="doc-backlink">Rule Predicates</a><a class="headerlink" href="#rule-predicates" title="連結到這個標頭">¶</a></h5>
<p>The rule factories also have predicates in common:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">legal()</span></code>, <code class="docutils literal notranslate"><span class="pre">lower()</span></code>, etc. are always satisfied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">legalIf()</span></code>, <code class="docutils literal notranslate"><span class="pre">narrowScalarIf()</span></code>, etc. are satisfied if the user-supplied
<code class="docutils literal notranslate"><span class="pre">LegalityPredicate</span></code> function returns true. This predicate has access to the
information in the <code class="docutils literal notranslate"><span class="pre">LegalityQuery</span></code> to make its decision.
User-supplied predicates can also be combined using <code class="docutils literal notranslate"><span class="pre">all(P0,</span> <span class="pre">P1,</span> <span class="pre">...)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">legalFor()</span></code>, <code class="docutils literal notranslate"><span class="pre">narrowScalarFor()</span></code>, etc. are satisfied if the type matches one in
a given set of types. For example <code class="docutils literal notranslate"><span class="pre">.legalFor({s16,</span> <span class="pre">s32})</span></code> declares the
instruction legal if type 0 is either s16 or s32. Additional versions for two
and three type indices are generally available. For these, all the type
indices considered together must match all the types in one of the tuples. So
<code class="docutils literal notranslate"><span class="pre">.legalFor({{s16,</span> <span class="pre">s32},</span> <span class="pre">{s32,</span> <span class="pre">s64}})</span></code> will only accept <code class="docutils literal notranslate"><span class="pre">{s16,</span> <span class="pre">s32}</span></code>, or
<code class="docutils literal notranslate"><span class="pre">{s32,</span> <span class="pre">s64}</span></code> but will not accept <code class="docutils literal notranslate"><span class="pre">{s16,</span> <span class="pre">s64}</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">legalForTypesWithMemSize()</span></code>, <code class="docutils literal notranslate"><span class="pre">narrowScalarForTypesWithMemSize()</span></code>, etc. are
similar to <code class="docutils literal notranslate"><span class="pre">legalFor()</span></code>, <code class="docutils literal notranslate"><span class="pre">narrowScalarFor()</span></code>, etc. but additionally require a
MachineMemOperand to have a given size in each tuple.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">legalForCartesianProduct()</span></code>, <code class="docutils literal notranslate"><span class="pre">narrowScalarForCartesianProduct()</span></code>, etc. are
satisfied if each type index matches one element in each of the independent
sets. So <code class="docutils literal notranslate"><span class="pre">.legalForCartesianProduct({s16,</span> <span class="pre">s32},</span> <span class="pre">{s32,</span> <span class="pre">s64})</span></code> will accept
<code class="docutils literal notranslate"><span class="pre">{s16,</span> <span class="pre">s32}</span></code>, <code class="docutils literal notranslate"><span class="pre">{s16,</span> <span class="pre">s64}</span></code>, <code class="docutils literal notranslate"><span class="pre">{s32,</span> <span class="pre">s32}</span></code>, and <code class="docutils literal notranslate"><span class="pre">{s32,</span> <span class="pre">s64}</span></code>.</p></li>
</ul>
</section>
<section id="composite-rules">
<h5><a class="toc-backref" href="#id34" role="doc-backlink">Composite Rules</a><a class="headerlink" href="#composite-rules" title="連結到這個標頭">¶</a></h5>
<p>There are some composite rules for common situations built out of the above facilities:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">widenScalarToNextPow2()</span></code> is like <code class="docutils literal notranslate"><span class="pre">widenScalarIf()</span></code> but is satisfied iff the type
size in bits is not a power of 2 and selects a target type that is the next
largest power of 2.</p></li>
</ul>
<ul class="simple" id="clampscalar">
<li><p><code class="docutils literal notranslate"><span class="pre">minScalar()</span></code> is like <code class="docutils literal notranslate"><span class="pre">widenScalarIf()</span></code> but is satisfied iff the type
size in bits is smaller than the given minimum and selects the minimum as the
target type. Similarly, there is also a <code class="docutils literal notranslate"><span class="pre">maxScalar()</span></code> for the maximum and a
<code class="docutils literal notranslate"><span class="pre">clampScalar()</span></code> to do both at once.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">minScalarSameAs()</span></code> is like <code class="docutils literal notranslate"><span class="pre">minScalar()</span></code> but the minimum is taken from another
type index.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">moreElementsToNextMultiple()</span></code> is like <code class="docutils literal notranslate"><span class="pre">moreElementsToNextPow2()</span></code> but is based on
multiples of X rather than powers of 2.</p></li>
</ul>
</section>
<section id="other-information">
<h5><a class="toc-backref" href="#id35" role="doc-backlink">Other Information</a><a class="headerlink" href="#other-information" title="連結到這個標頭">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
An alternative worth investigating is to generalize the API to represent
actions using <code class="docutils literal notranslate"><span class="pre">std::function</span></code> that implements the action, instead of explicit
enum tokens (<code class="docutils literal notranslate"><span class="pre">Legal</span></code>, <code class="docutils literal notranslate"><span class="pre">WidenScalar</span></code>, ...).</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
Moreover, we could use TableGen to initially infer legality of operation from
existing patterns (as any pattern we can select is by definition legal).
Expanding that to describe legalization actions is a much larger but
potentially useful project.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="legalizer-legacy-footnote" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>An API is broadly similar to
SelectionDAG/TargetLowering is available but is not recommended as a more
powerful API is available.</p>
</aside>
</aside>
</section>
</section>
</section>
<section id="regbankselect">
<span id="id8"></span><h3><a class="toc-backref" href="#id36" role="doc-backlink">RegBankSelect</a><a class="headerlink" href="#regbankselect" title="連結到這個標頭">¶</a></h3>
<p>This pass constrains the <a class="reference internal" href="#gmir-gvregs"><span class="std std-ref">Generic Virtual Registers</span></a> operands of generic
instructions to some <a class="reference internal" href="#gmir-regbank"><span class="std std-ref">Register Bank</span></a>.</p>
<p>It iteratively maps instructions to a set of per-operand bank assignment.
The possible mappings are determined by the target-provided
<a class="reference internal" href="#api-registerbankinfo"><span class="std std-ref">RegisterBankInfo</span></a>.
The mapping is then applied, possibly introducing <code class="docutils literal notranslate"><span class="pre">COPY</span></code> instructions if
necessary.</p>
<p>It traverses the <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> top down so that all operands are already
mapped when analyzing an instruction.</p>
<p>This pass could also remap target-specific instructions when beneficial.
In the future, this could replace the ExeDepsFix pass, as we can directly
select the best variant for an instruction that's available on multiple banks.</p>
<section id="api-registerbankinfo">
<span id="id9"></span><h4><a class="toc-backref" href="#id37" role="doc-backlink">API: RegisterBankInfo</a><a class="headerlink" href="#api-registerbankinfo" title="連結到這個標頭">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">RegisterBankInfo</span></code> class describes multiple aspects of register banks.</p>
<ul class="simple">
<li><p><strong>Banks</strong>: <code class="docutils literal notranslate"><span class="pre">addRegBankCoverage</span></code> --- which register bank covers each
register class.</p></li>
<li><p><strong>Cross-Bank Copies</strong>: <code class="docutils literal notranslate"><span class="pre">copyCost</span></code> --- the cost of a <code class="docutils literal notranslate"><span class="pre">COPY</span></code> from one bank
to another.</p></li>
<li><p><strong>Default Mapping</strong>: <code class="docutils literal notranslate"><span class="pre">getInstrMapping</span></code> --- the default bank assignments for
a given instruction.</p></li>
<li><p><strong>Alternative Mapping</strong>: <code class="docutils literal notranslate"><span class="pre">getInstrAlternativeMapping</span></code> --- the other
possible bank assignments for a given instruction.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
All this information should eventually be static and generated by TableGen,
mostly using existing information augmented by bank descriptions.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
<code class="docutils literal notranslate"><span class="pre">getInstrMapping</span></code> is currently separate from <code class="docutils literal notranslate"><span class="pre">getInstrAlternativeMapping</span></code>
because the latter is more expensive: as we move to static mapping info,
both methods should be free, and we should merge them.</p>
</section>
<section id="regbankselect-modes">
<span id="id10"></span><h4><a class="toc-backref" href="#id38" role="doc-backlink">RegBankSelect Modes</a><a class="headerlink" href="#regbankselect-modes" title="連結到這個標頭">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">RegBankSelect</span></code> currently has two modes:</p>
<ul class="simple">
<li><p><strong>Fast</strong> --- For each instruction, pick a target-provided &quot;default&quot; bank
assignment.  This is the default at -O0.</p></li>
<li><p><strong>Greedy</strong> --- For each instruction, pick the cheapest of several
target-provided bank assignment alternatives.</p></li>
</ul>
<p>We intend to eventually introduce an additional optimizing mode:</p>
<ul class="simple">
<li><p><strong>Global</strong> --- Across multiple instructions, pick the cheapest combination of
bank assignments.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
On AArch64, we are considering using the Greedy mode even at -O0 (or perhaps at
backend -O1):  because <a class="reference internal" href="#gmir-llt"><span class="std std-ref">Low Level Type</span></a> doesn't distinguish floating point from
integer scalars, the default assignment for loads and stores is the integer
bank, introducing cross-bank copies on most floating point operations.</p>
</section>
</section>
<section id="instructionselect">
<span id="id11"></span><h3><a class="toc-backref" href="#id39" role="doc-backlink">InstructionSelect</a><a class="headerlink" href="#instructionselect" title="連結到這個標頭">¶</a></h3>
<p>This pass transforms generic machine instructions into equivalent
target-specific instructions.  It traverses the <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> bottom-up,
selecting uses before definitions, enabling trivial dead code elimination.</p>
<section id="api-instructionselector">
<span id="id12"></span><h4><a class="toc-backref" href="#id40" role="doc-backlink">API: InstructionSelector</a><a class="headerlink" href="#api-instructionselector" title="連結到這個標頭">¶</a></h4>
<p>The target implements the <code class="docutils literal notranslate"><span class="pre">InstructionSelector</span></code> class, containing the
target-specific selection logic proper.</p>
<p>The instance is provided by the subtarget, so that it can specialize the
selector by subtarget feature (with, e.g., a vector selector overriding parts
of a general-purpose common selector).
We might also want to parameterize it by MachineFunction, to enable selector
variants based on function attributes like optsize.</p>
<p>The simple API consists of:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">select</span><span class="p">(</span><span class="n">MachineInstr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MI</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>This target-provided method is responsible for mutating (or replacing) a
possibly-generic MI into a fully target-specific equivalent.
It is also responsible for doing the necessary constraining of gvregs into the
appropriate register classes as well as passing through COPY instructions to
the register allocator.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">InstructionSelector</span></code> can fold other instructions into the selected MI,
by walking the use-def chain of the vreg operands.
As GlobalISel is Global, this folding can occur across basic blocks.</p>
</section>
<section id="selectiondag-rule-imports">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">SelectionDAG Rule Imports</a><a class="headerlink" href="#selectiondag-rule-imports" title="連結到這個標頭">¶</a></h4>
<p>TableGen will import SelectionDAG rules and provide the following function to
execute them:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">selectImpl</span><span class="p">(</span><span class="n">MachineInstr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MI</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">--stats</span></code> option can be used to determine what proportion of rules were
successfully imported. The easiest way to use this is to copy the
<code class="docutils literal notranslate"><span class="pre">-gen-globalisel</span></code> tablegen command from <code class="docutils literal notranslate"><span class="pre">ninja</span> <span class="pre">-v</span></code> and modify it.</p>
<p>Similarly, the <code class="docutils literal notranslate"><span class="pre">--warn-on-skipped-patterns</span></code> option can be used to obtain the
reasons that rules weren't imported. This can be used to focus on the most
important rejection reasons.</p>
</section>
<section id="patleaf-predicates">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">PatLeaf Predicates</a><a class="headerlink" href="#patleaf-predicates" title="連結到這個標頭">¶</a></h4>
<p>PatLeafs cannot be imported because their C++ is implemented in terms of
<code class="docutils literal notranslate"><span class="pre">SDNode</span></code> objects. PatLeafs that handle immediate predicates should be
replaced by <code class="docutils literal notranslate"><span class="pre">ImmLeaf</span></code>, <code class="docutils literal notranslate"><span class="pre">IntImmLeaf</span></code>, or <code class="docutils literal notranslate"><span class="pre">FPImmLeaf</span></code> as appropriate.</p>
<p>There's no standard answer for other PatLeafs. Some standard predicates have
been baked into TableGen but this should not generally be done.</p>
</section>
<section id="custom-sdnodes">
<h4><a class="toc-backref" href="#id43" role="doc-backlink">Custom SDNodes</a><a class="headerlink" href="#custom-sdnodes" title="連結到這個標頭">¶</a></h4>
<p>Custom SDNodes should be mapped to Target Pseudos using <code class="docutils literal notranslate"><span class="pre">GINodeEquiv</span></code>. This
will cause the instruction selector to import them but you will also need to
ensure the target pseudo is introduced to the MIR before the instruction
selector. Any preceding pass is suitable but the legalizer will be a
particularly common choice.</p>
</section>
<section id="complexpatterns">
<h4><a class="toc-backref" href="#id44" role="doc-backlink">ComplexPatterns</a><a class="headerlink" href="#complexpatterns" title="連結到這個標頭">¶</a></h4>
<p>ComplexPatterns cannot be imported because their C++ is implemented in terms of
<code class="docutils literal notranslate"><span class="pre">SDNode</span></code> objects. GlobalISel versions should be defined with
<code class="docutils literal notranslate"><span class="pre">GIComplexOperandMatcher</span></code> and mapped to ComplexPattern with
<code class="docutils literal notranslate"><span class="pre">GIComplexPatternEquiv</span></code>.</p>
<p>The following predicates are useful for porting ComplexPattern:</p>
<ul class="simple">
<li><p>isBaseWithConstantOffset() - Check for base+offset structures</p></li>
<li><p>isOperandImmEqual() - Check for a particular constant</p></li>
<li><p>isObviouslySafeToFold() - Check for reasons an instruction can't be sunk and folded into another.</p></li>
</ul>
<p>There are some important points for the C++ implementation:</p>
<ul class="simple">
<li><p>Don't modify MIR in the predicate</p></li>
<li><p>Renderer lambdas should capture by value to avoid use-after-free. They will be used after the predicate returns.</p></li>
<li><p>Only create instructions in a renderer lambda. GlobalISel won't clean up things you create but don't use.</p></li>
</ul>
</section>
</section>
</section>
<section id="maintainability">
<span id="id13"></span><h2><a class="toc-backref" href="#id17" role="doc-backlink">Maintainability</a><a class="headerlink" href="#maintainability" title="連結到這個標頭">¶</a></h2>
<section id="iterative-transformations">
<span id="maintainability-iterative"></span><h3>Iterative Transformations<a class="headerlink" href="#iterative-transformations" title="連結到這個標頭">¶</a></h3>
<p>Passes are split into small, iterative transformations, with all state
represented in the MIR.</p>
<p>This differs from SelectionDAG (in particular, the legalizer) using various
in-memory side-tables.</p>
</section>
<section id="mir-serialization">
<span id="maintainability-mir"></span><h3>MIR Serialization<a class="headerlink" href="#mir-serialization" title="連結到這個標頭">¶</a></h3>
<p><a class="reference internal" href="#gmir"><span class="std std-ref">Generic Machine IR</span></a> is serializable (see <a class="reference internal" href="MIRLangRef.html"><span class="doc">Machine IR (MIR) Format Reference Manual</span></a>).
Combined with <a class="reference internal" href="#maintainability-iterative"><span class="std std-ref">Iterative Transformations</span></a>, this enables much finer-grained
testing, rather than requiring large and fragile IR-to-assembly tests.</p>
<p>The current &quot;stage&quot; in the <a class="reference internal" href="#pipeline"><span class="std std-ref">Core Pipeline</span></a> is represented by a set of
<code class="docutils literal notranslate"><span class="pre">MachineFunctionProperties</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">legalized</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">regBankSelected</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">selected</span></code></p></li>
</ul>
</section>
<section id="machineverifier">
<span id="maintainability-verifier"></span><h3>MachineVerifier<a class="headerlink" href="#machineverifier" title="連結到這個標頭">¶</a></h3>
<p>The pass approach lets us use the <code class="docutils literal notranslate"><span class="pre">MachineVerifier</span></code> to enforce invariants.
For instance, a <code class="docutils literal notranslate"><span class="pre">regBankSelected</span></code> function may not have gvregs without
a bank.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>:
The <code class="docutils literal notranslate"><span class="pre">MachineVerifier</span></code> being monolithic, some of the checks we want to do
can't be integrated to it:  GlobalISel is a separate library, so we can't
directly reference it from CodeGen.  For instance, legality checks are
currently done in RegBankSelect/InstructionSelect proper.  We could #ifdef out
the checks, or we could add some sort of verifier API.</p>
</section>
</section>
<section id="progress-and-future-work">
<span id="progress"></span><h2><a class="toc-backref" href="#id18" role="doc-backlink">Progress and Future Work</a><a class="headerlink" href="#progress-and-future-work" title="連結到這個標頭">¶</a></h2>
<p>The initial goal is to replace FastISel on AArch64.  The next step will be to
replace SelectionDAG as the optimized ISel.</p>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
While we iterate on GlobalISel, we strive to avoid affecting the performance of
SelectionDAG, FastISel, or the other MIR passes.  For instance, the types of
<a class="reference internal" href="#gmir-gvregs"><span class="std std-ref">Generic Virtual Registers</span></a> are stored in a separate table in <code class="docutils literal notranslate"><span class="pre">MachineRegisterInfo</span></code>,
that is destroyed after <a class="reference internal" href="#instructionselect"><span class="std std-ref">InstructionSelect</span></a>.</p>
<section id="fastisel-replacement">
<span id="progress-fastisel"></span><h3>FastISel Replacement<a class="headerlink" href="#fastisel-replacement" title="連結到這個標頭">¶</a></h3>
<p>For the initial FastISel replacement, we intend to fallback to SelectionDAG on
selection failures.</p>
<p>Currently, compile-time of the fast pipeline is within 1.5x of FastISel.
We're optimistic we can get to within 1.1/1.2x, but beating FastISel will be
challenging given the multi-pass approach.
Still, supporting all IR (via a complete legalizer) and avoiding the fallback
to SelectionDAG in the worst case should enable better amortized performance
than SelectionDAG+FastISel.</p>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
We considered never having a fallback to SelectionDAG, instead deciding early
whether a given function is supported by GlobalISel or not.  The decision would
be based on <a class="reference internal" href="#milegalizer"><span class="std std-ref">Legalizer</span></a> queries.
We abandoned that for two reasons:
a) on IR inputs, we'd need to basically simulate the <a class="reference internal" href="#irtranslator"><span class="std std-ref">IRTranslator</span></a>;
b) to be robust against unforeseen failures and to enable iterative
improvements.</p>
</section>
<section id="support-for-other-targets">
<span id="progress-targets"></span><h3>Support For Other Targets<a class="headerlink" href="#support-for-other-targets" title="連結到這個標頭">¶</a></h3>
<p>In parallel, we're investigating adding support for other - ideally quite
different - targets.  For instance, there is some initial AMDGPU support.</p>
</section>
</section>
<section id="porting-globalisel-to-a-new-target">
<span id="porting"></span><h2><a class="toc-backref" href="#id19" role="doc-backlink">Porting GlobalISel to A New Target</a><a class="headerlink" href="#porting-globalisel-to-a-new-target" title="連結到這個標頭">¶</a></h2>
<p>There are four major classes to implement by the target:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#api-calllowering"><span class="std std-ref">CallLowering</span></a> --- lower calls, returns, and arguments
according to the ABI.</p></li>
<li><p><a class="reference internal" href="#api-registerbankinfo"><span class="std std-ref">RegisterBankInfo</span></a> --- describe
<a class="reference internal" href="#gmir-regbank"><span class="std std-ref">Register Bank</span></a> coverage, cross-bank copy cost, and the mapping of
operands onto banks for each instruction.</p></li>
<li><p><a class="reference internal" href="#api-legalizerinfo"><span class="std std-ref">LegalizerInfo</span></a> --- describe what is legal, and how
to legalize what isn't.</p></li>
<li><p><a class="reference internal" href="#api-instructionselector"><span class="std std-ref">InstructionSelector</span></a> --- select generic MIR
to target-specific MIR.</p></li>
</ul>
<p>Additionally:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TargetPassConfig</span></code> --- create the passes constituting the pipeline,
including additional passes not included in the <a class="reference internal" href="#pipeline"><span class="std std-ref">Core Pipeline</span></a>.</p></li>
</ul>
</section>
<section id="resources">
<span id="other-resources"></span><h2><a class="toc-backref" href="#id20" role="doc-backlink">Resources</a><a class="headerlink" href="#resources" title="連結到這個標頭">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=F6GGbYtae3g">Global Instruction Selection - A Proposal by Quentin Colombet &#64;LLVMDevMeeting 2015</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=6tfb344A7w8">Global Instruction Selection - Status by Quentin Colombet, Ahmed Bougacha, and Tim Northover &#64;LLVMDevMeeting 2016</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=d6dF6E4BPeU">GlobalISel - LLVM's Latest Instruction Selection Framework by Diana Picus &#64;FOSDEM17</a></p></li>
<li><p>GlobalISel: Past, Present, and Future by Quentin Colombet and Ahmed Bougacha &#64;LLVMDevMeeting 2017</p></li>
<li><p>Head First into GlobalISel by Daniel Sanders, Aditya Nandakumar, and Justin Bogner &#64;LLVMDevMeeting 2017</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="XRay.html" title="XRay Instrumentation"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="Coroutines.html" title="Coroutines in LLVM"
             >上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Global Instruction Selection</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; 版權所有 2003-2025, LLVM Project.
      最後更新於 2025-10-28。
      使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3 建立。
    </div>
  </body>
</html>