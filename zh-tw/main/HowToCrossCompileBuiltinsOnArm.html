
<!DOCTYPE html>

<html lang="zh-TW" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>How to Cross Compile Compiler-rt Builtins For Arm &#8212; LLVM  說明文件</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=4c4af0c1" />
    <script src="_static/documentation_options.js?v=0d9984b1"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/llvm-docs-l10n/HowToCrossCompileBuiltinsOnArm.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜尋" href="search.html" />
    <link rel="next" title="How to cross-compile Clang/LLVM using Clang/LLVM" href="HowToCrossCompileLLVM.html" />
    <link rel="prev" title="How to build Windows Itanium applications." href="HowToBuildWindowsItaniumPrograms.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="HowToCrossCompileLLVM.html" title="How to cross-compile Clang/LLVM using Clang/LLVM"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="HowToBuildWindowsItaniumPrograms.html" title="How to build Windows Itanium applications."
             accesskey="P">上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">使用者指南</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to Cross Compile Compiler-rt Builtins For Arm</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="UserGuides.html">使用者指南</a></li>
    <li><a href="Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="Contributing.html">Contributing to LLVM</a></li>
    <li><a href="HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="GettingInvolved.html#discord">Discord</a></li>
    <li><a href="GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="FAQ.html">FAQ</a></li>
    <li><a href="Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/HowToCrossCompileBuiltinsOnArm.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="how-to-cross-compile-compiler-rt-builtins-for-arm">
<h1>How to Cross Compile Compiler-rt Builtins For Arm<a class="headerlink" href="#how-to-cross-compile-compiler-rt-builtins-for-arm" title="連結到這個標頭">¶</a></h1>
<section id="introduction">
<h2>簡介<a class="headerlink" href="#introduction" title="連結到這個標頭">¶</a></h2>
<p>This document contains information about building and testing the builtins part
of compiler-rt for an Arm target, from an x86_64 Linux machine.</p>
<p>While this document concentrates on Arm and Linux the general principles should
apply to other targets supported by compiler-rt. Further contributions for other
targets are welcome.</p>
<p>The instructions in this document depend on libraries and programs external to
LLVM, there are many ways to install and configure these dependencies so you
may need to adapt the instructions here to fit your own situation.</p>
</section>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="連結到這個標頭">¶</a></h2>
<p>In this use case we will be using cmake on a Debian-based Linux system,
cross-compiling from an x86_64 host to a hard-float Armv7-A target. We will be
using as many of the LLVM tools as we can, but it is possible to use GNU
equivalents.</p>
<dl class="simple">
<dt>You will need:</dt><dd><ul class="simple">
<li><p>A build of LLVM for the llvm-tools and LLVM CMake files.</p></li>
<li><p>A clang executable with support for the <code class="docutils literal notranslate"><span class="pre">ARM</span></code> target.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compiler-rt</span></code> sources.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">qemu-arm</span></code> user mode emulator.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabihf</span></code> sysroot.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>An existing sysroot is required because some of the builtins include C library
headers and a sysroot is the easiest way to get those.</p>
</div>
<p>In this example we will be using <code class="docutils literal notranslate"><span class="pre">ninja</span></code> as the build tool.</p>
<p>See <a class="reference external" href="https://compiler-rt.llvm.org/">https://compiler-rt.llvm.org/</a> for information about the dependencies
on clang and LLVM.</p>
<p>See <a class="reference external" href="https://llvm.org/docs/GettingStarted.html">https://llvm.org/docs/GettingStarted.html</a> for information about obtaining
the source for LLVM and compiler-rt.</p>
<p><code class="docutils literal notranslate"><span class="pre">qemu-arm</span></code> should be available as a package for your Linux distribution.</p>
<p>The most complicated of the prerequisites to satisfy is the <code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabihf</span></code>
sysroot. In theory it is possible to use the Linux distributions multiarch
support to fulfill the dependencies for building but unfortunately due to
<code class="docutils literal notranslate"><span class="pre">/usr/local/include</span></code> being added some host includes are selected.</p>
<p>The easiest way to supply a sysroot is to download an <code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabihf</span></code>
toolchain from <a class="reference external" href="https://developer.arm.com/open-source/gnu-toolchain/gnu-a/downloads">https://developer.arm.com/open-source/gnu-toolchain/gnu-a/downloads</a>.</p>
</section>
<section id="building-compiler-rt-builtins-for-arm">
<h2>Building compiler-rt builtins for Arm<a class="headerlink" href="#building-compiler-rt-builtins-for-arm" title="連結到這個標頭">¶</a></h2>
<p>We will be doing a standalone build of compiler-rt. The command is shown below.
Shell variables are used to simplify some of the options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>LLVM_TOOLCHAIN=&lt;path-to-llvm-install&gt;/
TARGET_TRIPLE=arm-none-linux-gnueabihf
GCC_TOOLCHAIN=&lt;path-to-gcc-toolchain&gt;
SYSROOT=${GCC_TOOLCHAIN}/${TARGET_TRIPLE}/libc
COMPILE_FLAGS=&quot;-march=armv7-a&quot;

cmake ../llvm-project/compiler-rt \
  -G Ninja \
  -DCMAKE_AR=${LLVM_TOOLCHAIN}/bin/llvm-ar \
  -DCMAKE_NM=${LLVM_TOOLCHAIN}/bin/llvm-nm \
  -DCMAKE_RANLIB=${LLVM_TOOLCHAIN}/bin/llvm-ranlib \
  -DLLVM_CMAKE_DIR=&quot;${LLVM_TOOLCHAIN}/lib/cmake/llvm&quot; \
  -DCMAKE_SYSROOT=&quot;${SYSROOT}&quot; \
  -DCMAKE_ASM_COMPILER_TARGET=&quot;${TARGET_TRIPLE}&quot; \
  -DCMAKE_ASM_FLAGS=&quot;${COMPILE_FLAGS}&quot; \
  -DCMAKE_C_COMPILER_TARGET=&quot;${TARGET_TRIPLE}&quot; \
  -DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN=${GCC_TOOLCHAIN} \
  -DCMAKE_C_COMPILER=${LLVM_TOOLCHAIN}/bin/clang \
  -DCMAKE_C_FLAGS=&quot;${COMPILE_FLAGS}&quot; \
  -DCMAKE_CXX_COMPILER_TARGET=&quot;${TARGET_TRIPLE}&quot; \
  -DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN=${GCC_TOOLCHAIN} \
  -DCMAKE_CXX_COMPILER=${LLVM_TOOLCHAIN}/bin/clang \
  -DCMAKE_CXX_FLAGS=&quot;${COMPILE_FLAGS}&quot; \
  -DCMAKE_EXE_LINKER_FLAGS=&quot;-fuse-ld=lld&quot; \
  -DCOMPILER_RT_BUILD_BUILTINS=ON \
  -DCOMPILER_RT_BUILD_LIBFUZZER=OFF \
  -DCOMPILER_RT_BUILD_MEMPROF=OFF \
  -DCOMPILER_RT_BUILD_PROFILE=OFF \
  -DCOMPILER_RT_BUILD_CTX_PROFILE=OFF \
  -DCOMPILER_RT_BUILD_SANITIZERS=OFF \
  -DCOMPILER_RT_BUILD_XRAY=OFF \
  -DCOMPILER_RT_BUILD_ORC=OFF \
  -DCOMPILER_RT_BUILD_CRT=OFF \
  -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON \
  -DCOMPILER_RT_EMULATOR=&quot;qemu-arm -L ${SYSROOT}&quot; \
  -DCOMPILER_RT_INCLUDE_TESTS=ON \
  -DCOMPILER_RT_TEST_COMPILER=${LLVM_TOOLCHAIN}/bin/clang \
  -DCOMPILER_RT_TEST_COMPILER_CFLAGS=&quot;--target=${TARGET_TRIPLE} ${COMPILE_FLAGS} --gcc-toolchain=${GCC_TOOLCHAIN} --sysroot=${SYSROOT} -fuse-ld=lld&quot;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>The command above also enables tests. Enabling tests is not required, more details
in the testing section.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CMAKE_&lt;LANGUAGE&gt;_&lt;OPTION&gt;</span></code> options are set so that the correct <code class="docutils literal notranslate"><span class="pre">--target</span></code>,
<code class="docutils literal notranslate"><span class="pre">--sysroot</span></code>, <code class="docutils literal notranslate"><span class="pre">--gcc-toolchain</span></code> and <code class="docutils literal notranslate"><span class="pre">-march</span></code> options will be given to the
compilers.</p>
<p>The combination of these settings needs to be enough to pass CMake's compiler
checks, compile compiler-rt and build the test cases.</p>
<dl class="simple">
<dt>The flags need to select:</dt><dd><ul class="simple">
<li><p>The Arm target (<code class="docutils literal notranslate"><span class="pre">--target</span> <span class="pre">arm-none-linux-gnueabihf</span></code>)</p></li>
<li><p>The Arm architecture level (<code class="docutils literal notranslate"><span class="pre">-march=armv7-a</span></code>)</p></li>
<li><p>Whether to generate Arm (<code class="docutils literal notranslate"><span class="pre">-marm</span></code>, the default) or Thumb (<code class="docutils literal notranslate"><span class="pre">-mthumb</span></code>) instructions.</p></li>
</ul>
</dd>
</dl>
<p>It is possible to pass all these flags to CMake using <code class="docutils literal notranslate"><span class="pre">CMAKE_&lt;LANGUAGE&gt;_FLAGS</span></code>,
but the command above uses standard CMake options instead. If you need to
add flags that CMake cannot generate automatically, add them to
<code class="docutils literal notranslate"><span class="pre">CMAKE_&lt;LANGUAGE&gt;_FLAGS</span></code>.</p>
<p>When CMake has finished, build with Ninja:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ninja</span> <span class="n">builtins</span>
</pre></div>
</div>
</section>
<section id="testing-compiler-rt-builtins-using-qemu-arm">
<h2>Testing compiler-rt builtins using qemu-arm<a class="headerlink" href="#testing-compiler-rt-builtins-using-qemu-arm" title="連結到這個標頭">¶</a></h2>
<p>The following options are required to enable tests:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>-DCOMPILER_RT_EMULATOR=&quot;qemu-arm -L ${SYSROOT}&quot; \
-DCOMPILER_RT_INCLUDE_TESTS=ON \
-DCOMPILER_RT_TEST_COMPILER=${LLVM_TOOLCHAIN}/bin/clang \
-DCOMPILER_RT_TEST_COMPILER_CFLAGS=&quot;--target=${TARGET_TRIPLE} -march=armv7-a --gcc-toolchain=${GCC_TOOLCHAIN} --sysroot=${SYSROOT} -fuse-ld=lld&quot;
</pre></div>
</div>
<p>This tells compiler-rt that we want to run tests on <code class="docutils literal notranslate"><span class="pre">qemu-arm</span></code>. If you do not
want to run tests, remove these options from the CMake command.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">COMPILER_RT_TEST_COMPILER_CFLAGS</span></code> contains the equivalent of the
options CMake generated for us with the first command. We must pass them
manually here because standard options like <code class="docutils literal notranslate"><span class="pre">CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN</span></code>
do not apply here.</p>
<p>When CMake has finished, run the tests:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ninja</span> <span class="n">check</span><span class="o">-</span><span class="n">builtins</span>
</pre></div>
</div>
</section>
<section id="troubleshooting">
<h2>Troubleshooting<a class="headerlink" href="#troubleshooting" title="連結到這個標頭">¶</a></h2>
<section id="the-cmake-try-compile-stage-fails">
<h3>The cmake try compile stage fails<a class="headerlink" href="#the-cmake-try-compile-stage-fails" title="連結到這個標頭">¶</a></h3>
<p>At an early stage cmake will attempt to compile and link a simple C program to
test if the toolchain is working.</p>
<p>This stage can often fail at link time if the <code class="docutils literal notranslate"><span class="pre">--sysroot=</span></code>, <code class="docutils literal notranslate"><span class="pre">--target</span></code> or
<code class="docutils literal notranslate"><span class="pre">--gcc-toolchain=</span></code> options are not passed to the compiler. Check the
<code class="docutils literal notranslate"><span class="pre">CMAKE_&lt;LANGUAGE&gt;_FLAGS</span></code> and <code class="docutils literal notranslate"><span class="pre">CMAKE_&lt;LANGAUGE&gt;_COMPILER_TARGET</span></code> flags along
with any of the specific CMake sysroot and toolchain options.</p>
<p>It can be useful to build a simple example outside of cmake with your toolchain
to make sure it is working. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clang</span> <span class="o">--</span><span class="n">target</span><span class="o">=</span><span class="n">arm</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnueabi</span> <span class="o">-</span><span class="n">march</span><span class="o">=</span><span class="n">armv7a</span> <span class="o">--</span><span class="n">gcc</span><span class="o">-</span><span class="n">toolchain</span><span class="o">=/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">gcc</span><span class="o">-</span><span class="n">toolchain</span> <span class="o">--</span><span class="n">sysroot</span><span class="o">=/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">gcc</span><span class="o">-</span><span class="n">toolchain</span><span class="o">/</span><span class="n">arm</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnueabihf</span><span class="o">/</span><span class="n">libc</span> <span class="n">helloworld</span><span class="o">.</span><span class="n">c</span>
</pre></div>
</div>
</section>
<section id="clang-uses-the-host-header-files">
<h3>Clang uses the host header files<a class="headerlink" href="#clang-uses-the-host-header-files" title="連結到這個標頭">¶</a></h3>
<p>On debian based systems it is possible to install multiarch support for
<code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabi</span></code> and <code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabihf</span></code>. In many cases clang can successfully
use this multiarch support when <code class="docutils literal notranslate"><span class="pre">--gcc-toolchain=</span></code> and <code class="docutils literal notranslate"><span class="pre">--sysroot=</span></code> are not supplied.
Unfortunately clang adds <code class="docutils literal notranslate"><span class="pre">/usr/local/include</span></code> before
<code class="docutils literal notranslate"><span class="pre">/usr/include/arm-linux-gnueabihf</span></code> leading to errors when compiling the hosts
header files.</p>
<p>The multiarch support is not sufficient to build the builtins you will need to
use a separate <code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabihf</span></code> toolchain.</p>
</section>
<section id="no-target-passed-to-clang">
<h3>No target passed to clang<a class="headerlink" href="#no-target-passed-to-clang" title="連結到這個標頭">¶</a></h3>
<p>If clang is not given a target it will typically use the host target, this will
not understand the Arm assembly language files resulting in error messages such
as <code class="docutils literal notranslate"><span class="pre">error:</span> <span class="pre">unknown</span> <span class="pre">directive</span> <span class="pre">.syntax</span> <span class="pre">unified</span></code>.</p>
<p>You can check the clang invocation in the error message to see if there is no
<code class="docutils literal notranslate"><span class="pre">--target</span></code> or if it is set incorrectly. The cause is usually
<code class="docutils literal notranslate"><span class="pre">CMAKE_ASM_FLAGS</span></code> not containing <code class="docutils literal notranslate"><span class="pre">--target</span></code> or <code class="docutils literal notranslate"><span class="pre">CMAKE_ASM_COMPILER_TARGET</span></code>
not being present.</p>
</section>
<section id="arm-architecture-not-given">
<h3>Arm architecture not given<a class="headerlink" href="#arm-architecture-not-given" title="連結到這個標頭">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">--target=arm-linux-gnueabihf</span></code> will default to Arm architecture v4t which
cannot assemble the barrier instructions used in the <code class="docutils literal notranslate"><span class="pre">synch_and_fetch</span></code> source
files.</p>
<p>The cause is usually a missing <code class="docutils literal notranslate"><span class="pre">-march=armv7a</span></code> from the <code class="docutils literal notranslate"><span class="pre">CMAKE_ASM_FLAGS</span></code>.</p>
</section>
<section id="compiler-rt-builds-but-the-tests-fail-to-build">
<h3>Compiler-rt builds but the tests fail to build<a class="headerlink" href="#compiler-rt-builds-but-the-tests-fail-to-build" title="連結到這個標頭">¶</a></h3>
<p>The flags used to build the tests are not the same as those used to build the
builtins. The c flags are provided by <code class="docutils literal notranslate"><span class="pre">COMPILER_RT_TEST_COMPILE_CFLAGS</span></code> and
the <code class="docutils literal notranslate"><span class="pre">CMAKE_C_COMPILER_TARGET</span></code>, <code class="docutils literal notranslate"><span class="pre">CMAKE_ASM_COMPILER_TARGET</span></code>,
<code class="docutils literal notranslate"><span class="pre">CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN</span></code> and <code class="docutils literal notranslate"><span class="pre">CMAKE_SYSROOT</span></code> flags are not
applied to tests.</p>
<p>Make sure that <code class="docutils literal notranslate"><span class="pre">COMPILER_RT_TEST_COMPILE_CFLAGS</span></code> contains all the necessary
flags.</p>
</section>
</section>
<section id="modifications-for-other-targets">
<h2>Modifications for other Targets<a class="headerlink" href="#modifications-for-other-targets" title="連結到這個標頭">¶</a></h2>
<section id="arm-soft-float-target">
<h3>Arm Soft-Float Target<a class="headerlink" href="#arm-soft-float-target" title="連結到這個標頭">¶</a></h3>
<p>The instructions for the Arm hard-float target can be used for the soft-float
target by substituting soft-float equivalents for the sysroot and target. The
target to use is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-DCMAKE_C_COMPILER_TARGET=arm-linux-gnueabi</span></code></p></li>
</ul>
<p>Depending on whether you want to use floating point instructions or not you
may need extra c-flags such as <code class="docutils literal notranslate"><span class="pre">-mfloat-abi=softfp</span></code> for use of floating-point
instructions, and <code class="docutils literal notranslate"><span class="pre">-mfloat-abi=soft</span> <span class="pre">-mfpu=none</span></code> for software floating-point
emulation.</p>
<p>You will need to use an <code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabi</span></code> GNU toolchain for soft-float.</p>
</section>
<section id="aarch64-target">
<h3>AArch64 Target<a class="headerlink" href="#aarch64-target" title="連結到這個標頭">¶</a></h3>
<p>The instructions for Arm can be used for AArch64 by substituting AArch64
equivalents for the sysroot, emulator and target:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">DCMAKE_C_COMPILER_TARGET</span><span class="o">=</span><span class="n">aarch64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span>
<span class="o">-</span><span class="n">DCOMPILER_RT_EMULATOR</span><span class="o">=</span><span class="s2">&quot;qemu-aarch64 -L /path/to/aarch64/sysroot</span>
</pre></div>
</div>
<p>You will also have to update any use of the target triple in compiler flags.
For instance in <code class="docutils literal notranslate"><span class="pre">CMAKE_C_FLAGS</span></code> and <code class="docutils literal notranslate"><span class="pre">COMPILER_RT_TEST_COMPILER_CFLAGS</span></code>.</p>
</section>
<section id="armv6-m-armv7-m-and-armv7e-m-targets">
<h3>Armv6-m, Armv7-m and Armv7E-M targets<a class="headerlink" href="#armv6-m-armv7-m-and-armv7e-m-targets" title="連結到這個標頭">¶</a></h3>
<p>To build and test the libraries using a similar method to Armv7-A is possible
but more difficult. The main problems are:</p>
<ul class="simple">
<li><p>There is not a <code class="docutils literal notranslate"><span class="pre">qemu-arm</span></code> user-mode emulator for bare-metal systems.
<code class="docutils literal notranslate"><span class="pre">qemu-system-arm</span></code> can be used but this is significantly more difficult
to setup. This document does not explain how to do this.</p></li>
<li><p>The targets to compile compiler-rt have the suffix <code class="docutils literal notranslate"><span class="pre">-none-eabi</span></code>. This uses
the BareMetal driver in clang and by default will not find the libraries
needed to pass the cmake compiler check.</p></li>
</ul>
<p>As the Armv6-M, Armv7-M and Armv7E-M builds of compiler-rt only use instructions
that are supported on Armv7-A we can still get most of the value of running the
tests using the same <code class="docutils literal notranslate"><span class="pre">qemu-arm</span></code> that we used for Armv7-A by building and
running the test cases for Armv7-A but using the builtins compiled for
Armv6-M, Armv7-M or Armv7E-M. This will test that the builtins can be linked
into a binary and execute the tests correctly but it will not catch if the
builtins use instructions that are supported on Armv7-A but not Armv6-M,
Armv7-M and Armv7E-M.</p>
<p>This requires a second <code class="docutils literal notranslate"><span class="pre">arm-none-eabi</span></code> toolchain for building the builtins.
Using a bare-metal toolchain ensures that the target and C library details are
specific to bare-metal instead of using Linux settings. This means that some
tests may behave differently compared to real hardware, but at least the content
of the builtins library is correct.</p>
<p>Below is an example that builds the builtins for Armv7-M, but runs the tests
as Armv7-A. It is presented in full, but is very similar to the earlier
command for Armv7-A build and test:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>LLVM_TOOLCHAIN=&lt;path to llvm install&gt;/

# For the builtins.
TARGET_TRIPLE=arm-none-eabi
GCC_TOOLCHAIN=&lt;path to arm-none-eabi toolchain&gt;/
SYSROOT=${GCC_TOOLCHAIN}/${TARGET_TRIPLE}/libc
COMPILE_FLAGS=&quot;-march=armv7-m -mfpu=vfpv2&quot;

# For the test cases.
A_PROFILE_TARGET_TRIPLE=arm-none-linux-gnueabihf
A_PROFILE_GCC_TOOLCHAIN=&lt;path to arm-none-linux-gnueabihf toolchain&gt;/
A_PROFILE_SYSROOT=${A_PROFILE_GCC_TOOLCHAIN}/${A_PROFILE_TARGET_TRIPLE}/libc

cmake ../llvm-project/compiler-rt \
  -G Ninja \
  -DCMAKE_AR=${LLVM_TOOLCHAIN}/bin/llvm-ar \
  -DCMAKE_NM=${LLVM_TOOLCHAIN}/bin/llvm-nm \
  -DCMAKE_RANLIB=${LLVM_TOOLCHAIN}/bin/llvm-ranlib \
  -DLLVM_CMAKE_DIR=&quot;${LLVM_TOOLCHAIN}/lib/cmake/llvm&quot; \
  -DCMAKE_SYSROOT=&quot;${SYSROOT}&quot; \
  -DCMAKE_ASM_COMPILER_TARGET=&quot;${TARGET_TRIPLE}&quot; \
  -DCMAKE_ASM_FLAGS=&quot;${COMPILE_FLAGS}&quot; \
  -DCMAKE_C_COMPILER_TARGET=&quot;${TARGET_TRIPLE}&quot; \
  -DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN=${GCC_TOOLCHAIN} \
  -DCMAKE_C_COMPILER=${LLVM_TOOLCHAIN}/bin/clang \
  -DCMAKE_C_FLAGS=&quot;${COMPILE_FLAGS}&quot; \
  -DCMAKE_CXX_COMPILER_TARGET=&quot;${TARGET_TRIPLE}&quot; \
  -DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN=${GCC_TOOLCHAIN} \
  -DCMAKE_CXX_COMPILER=${LLVM_TOOLCHAIN}/bin/clang \
  -DCMAKE_CXX_FLAGS=&quot;${COMPILE_FLAGS}&quot; \
  -DCMAKE_EXE_LINKER_FLAGS=&quot;-fuse-ld=lld&quot; \
  -DCOMPILER_RT_BUILD_BUILTINS=ON \
  -DCOMPILER_RT_BUILD_LIBFUZZER=OFF \
  -DCOMPILER_RT_BUILD_MEMPROF=OFF \
  -DCOMPILER_RT_BUILD_PROFILE=OFF \
  -DCOMPILER_RT_BUILD_CTX_PROFILE=OFF \
  -DCOMPILER_RT_BUILD_SANITIZERS=OFF \
  -DCOMPILER_RT_BUILD_XRAY=OFF \
  -DCOMPILER_RT_BUILD_ORC=OFF \
  -DCOMPILER_RT_BUILD_CRT=OFF \
  -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON \
  -DCOMPILER_RT_EMULATOR=&quot;qemu-arm -L ${A_PROFILE_SYSROOT}&quot; \
  -DCOMPILER_RT_INCLUDE_TESTS=ON \
  -DCOMPILER_RT_TEST_COMPILER=${LLVM_TOOLCHAIN}/bin/clang \
  -DCOMPILER_RT_TEST_COMPILER_CFLAGS=&quot;--target=${A_PROFILE_TARGET_TRIPLE} -march=armv7-a --gcc-toolchain=${A_PROFILE_GCC_TOOLCHAIN} --sysroot=${A_PROFILE_SYSROOT} -fuse-ld=lld&quot; \
  -DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY \
  -DCOMPILER_RT_OS_DIR=&quot;baremetal&quot; \
  -DCOMPILER_RT_BAREMETAL_BUILD=ON
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>The sysroot used for compiling the tests is <code class="docutils literal notranslate"><span class="pre">arm-linux-gnueabihf</span></code>, not
<code class="docutils literal notranslate"><span class="pre">arm-none-eabi</span></code> which is used when compiling the builtins.</p>
</div>
<p>The Armv6-M builtins will use the soft-float ABI. When compiling the tests for
Armv7-A we must include <code class="docutils literal notranslate"><span class="pre">&quot;-mthumb</span> <span class="pre">-mfloat-abi=soft</span> <span class="pre">-mfpu=none&quot;</span></code> in the
test-c-flags. We must use an Armv7-A soft-float abi sysroot for <code class="docutils literal notranslate"><span class="pre">qemu-arm</span></code>.</p>
<p>Depending on the linker used for the test cases you may encounter BuildAttribute
mismatches between the M-profile objects from compiler-rt and the A-profile
objects from the test. The lld linker does not check the profile
BuildAttribute so it can be used to link the tests by adding <code class="docutils literal notranslate"><span class="pre">-fuse-ld=lld</span></code> to the
<code class="docutils literal notranslate"><span class="pre">COMPILER_RT_TEST_COMPILER_CFLAGS</span></code>.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="HowToCrossCompileLLVM.html" title="How to cross-compile Clang/LLVM using Clang/LLVM"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="HowToBuildWindowsItaniumPrograms.html" title="How to build Windows Itanium applications."
             >上一頁</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >使用者指南</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to Cross Compile Compiler-rt Builtins For Arm</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; 版權所有 2003-2025, LLVM Project.
      最後更新於 2025-10-27。
      使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3 建立。
    </div>
  </body>
</html>