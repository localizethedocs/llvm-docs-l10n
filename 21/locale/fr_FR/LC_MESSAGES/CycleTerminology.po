# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 21\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 09:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CycleTerminology.rst:5
msgid "LLVM Cycle Terminology"
msgstr ""

#: ../../../CycleTerminology.rst:13
msgid "Cycles"
msgstr ""

#: ../../../CycleTerminology.rst:15
msgid ""
"Cycles are a generalization of LLVM :ref:`loops <loop-terminology>`, defined "
"recursively as follows [HavlakCycles]_:"
msgstr ""

#: ../../../CycleTerminology.rst:18
msgid ""
"In a directed graph G that is a function CFG or a subgraph of it, a *cycle* "
"is a maximal strongly connected region with at least one internal edge. "
"(Informational note --- The requirement for at least one internal edge "
"ensures that a single basic block is a cycle only if there is an edge that "
"goes back to the same basic block.)"
msgstr ""

#: ../../../CycleTerminology.rst:23
msgid ""
"A basic block in a cycle that can be reached from the entry of the function "
"along a path that does not visit any other basic block in the cycle is "
"called an *entry* of the cycle. A cycle can have multiple entries."
msgstr ""

#: ../../../CycleTerminology.rst:27
msgid ""
"For a given depth-first search starting from the entry of the function, the "
"first node of a cycle to be visited is called the *header* of this cycle "
"with respect to this particular DFS. The header is always an entry node."
msgstr ""

#: ../../../CycleTerminology.rst:30
msgid ""
"In any depth-first search starting from the entry, the set of cycles found "
"in the CFG is the same. These are the *top-level cycles* that do not "
"themselves have a parent."
msgstr ""

#: ../../../CycleTerminology.rst:33
msgid ""
"The *child cycles* (or simply cycles) nested inside a cycle C with header H "
"are the cycles in the subgraph induced on the set of nodes (C - H). C is "
"said to be the *parent* of these cycles."
msgstr ""

#: ../../../CycleTerminology.rst:37
msgid ""
"Thus, cycles form an implementation-defined forest where each cycle C is the "
"parent of any child cycles nested inside C. The tree closely follows the "
"nesting of loops in the same function. The unique entry of a reducible cycle "
"(an LLVM loop) L dominates all its other nodes, and is always chosen as the "
"header of some cycle C regardless of the DFS tree used. This cycle C is a "
"superset of the loop L. For an irreducible cycle, no one entry dominates the "
"nodes of the cycle. One of the entries is chosen as header of the cycle, in "
"an implementation-defined way."
msgstr ""

#: ../../../CycleTerminology.rst:49
msgid ""
"A cycle is *irreducible* if it has multiple entries and it is *reducible* "
"otherwise."
msgstr ""

#: ../../../CycleTerminology.rst:54
msgid ""
"A cycle C is said to be the *parent* of a basic block B if B occurs in C but "
"not in any child cycle of C. Then B is also said to be a *child* of cycle C."
msgstr ""

#: ../../../CycleTerminology.rst:60
msgid ""
"A block B is said to be a *top-level block* if it is not the child of any "
"cycle."
msgstr ""

#: ../../../CycleTerminology.rst:65
msgid ""
"A basic block or cycle X is a *sibling* of another basic block or cycle Y if "
"they both have no parent or both have the same parent."
msgstr ""

#: ../../../CycleTerminology.rst:68
msgid "Informational notes:"
msgstr ""

#: ../../../CycleTerminology.rst:70
msgid "Non-header entry blocks of a cycle can be contained in child cycles."
msgstr ""

#: ../../../CycleTerminology.rst:71
msgid ""
"If the CFG is reducible, the cycles are exactly the natural loops and every "
"cycle has exactly one entry block."
msgstr ""

#: ../../../CycleTerminology.rst:73
msgid "Cycles are well-nested (by definition)."
msgstr ""

#: ../../../CycleTerminology.rst:74
msgid "The entry blocks of a cycle are siblings in the dominator tree."
msgstr ""

#: ../../../CycleTerminology.rst:76
msgid ""
"Paul Havlak, \"Nesting of reducible and irreducible loops.\" ACM "
"Transactions on Programming Languages and Systems (TOPLAS) 19.4 (1997): "
"557-567."
msgstr ""

#: ../../../CycleTerminology.rst:83
msgid "Examples of Cycles"
msgstr ""

#: ../../../CycleTerminology.rst:86
msgid "Irreducible cycle enclosing natural loops"
msgstr ""

#: ../../../CycleTerminology.rst:111
msgid ""
"The self-loops of ``A`` and ``B`` give rise to two single-block natural "
"loops. A possible hierarchy of cycles is::"
msgstr ""

#: ../../../CycleTerminology.rst:118
msgid ""
"This hierarchy arises when DFS visits the blocks in the order ``A``, ``C``, "
"``B`` (in preorder)."
msgstr ""

#: ../../../CycleTerminology.rst:122
msgid "Irreducible union of two natural loops"
msgstr ""

#: ../../../CycleTerminology.rst:151
msgid ""
"There are two natural loops: ``{A, C}`` and ``{B, D}``. A possible hierarchy "
"of cycles is::"
msgstr ""

#: ../../../CycleTerminology.rst:158
msgid "Irreducible cycle without natural loops"
msgstr ""

#: ../../../CycleTerminology.rst:188
msgid ""
"This graph does not contain any natural loops --- the nodes ``A``, ``B``, "
"``C`` and ``D`` are siblings in the dominator tree. A possible hierarchy of "
"cycles is::"
msgstr ""

#: ../../../CycleTerminology.rst:198
msgid "Closed Paths and Cycles"
msgstr ""

#: ../../../CycleTerminology.rst:200
msgid ""
"A *closed path* in a CFG is a connected sequence of nodes and edges in the "
"CFG whose start and end nodes are the same, and whose remaining (inner) "
"nodes are distinct."
msgstr ""

#: ../../../CycleTerminology.rst:204
msgid ""
"An *entry* to a closed path ``P`` is a node on ``P`` that is reachable from "
"the function entry without passing through any other node on ``P``."
msgstr ""

#: ../../../CycleTerminology.rst:207
msgid ""
"If a node D dominates one or more nodes in a closed path P and P does not "
"contain D, then D dominates every node in P."
msgstr ""

#: ../../../CycleTerminology.rst:210
msgid ""
"**Proof:** Let U be a node in P that is dominated by D. If there was a node "
"V in P not dominated by D, then U would be reachable from the function entry "
"node via V without passing through D, which contradicts the fact that D "
"dominates U."
msgstr ""

#: ../../../CycleTerminology.rst:215
msgid ""
"If a node D dominates one or more nodes in a closed path P and P does not "
"contain D, then there exists a cycle C that contains P but not D."
msgstr ""

#: ../../../CycleTerminology.rst:219
msgid ""
"**Proof:** From the above property, D dominates all the nodes in P. For any "
"nesting of cycles discovered by the implementation-defined DFS, consider the "
"smallest cycle C which contains P. For the sake of contradiction, assume "
"that D is in C. Then the header H of C cannot be in P, since the header of a "
"cycle cannot be dominated by any other node in the cycle. Thus, P is in the "
"set (C-H), and there must be a smaller cycle C' in C which also contains P, "
"but that contradicts how we chose C."
msgstr ""

#: ../../../CycleTerminology.rst:228
msgid ""
"If a closed path P contains nodes U1 and U2 but not their dominators D1 and "
"D2 respectively, then there exists a cycle C that contains U1 and U2 but "
"neither of D1 and D2."
msgstr ""

#: ../../../CycleTerminology.rst:232
msgid ""
"**Proof:** From the above properties, each D1 and D2 separately dominate "
"every node in P. There exists a cycle C1 (respectively, C2) that contains P "
"but not D1 (respectively, D2). Either C1 and C2 are the same cycle, or one "
"of them is nested inside the other. Hence there is always a cycle that "
"contains U1 and U2 but neither of D1 and D2."
msgstr ""

#: ../../../CycleTerminology.rst:241
msgid ""
"In any cycle hierarchy, the header ``H`` of the smallest cycle ``C`` "
"containing a closed path ``P`` itself lies on ``P``."
msgstr ""

#: ../../../CycleTerminology.rst:244
msgid ""
"**Proof:** If ``H`` is not in ``P``, then there is a smaller cycle ``C'`` in "
"the set ``C - H`` containing ``P``, thus contradicting the claim that ``C`` "
"is the smallest such cycle."
msgstr ""

#: ../../../CycleTerminology.rst:251
msgid "Reducible Cycle Headers"
msgstr ""

#: ../../../CycleTerminology.rst:253
msgid ""
"Although the cycle hierarchy depends on the DFS chosen, reducible cycles "
"satisfy the following invariant:"
msgstr ""

#: ../../../CycleTerminology.rst:256
msgid ""
"If a reducible cycle ``C`` with header ``H`` is discovered in any DFS, then "
"there exists a cycle ``C'`` in every DFS with header ``H``, that contains "
"``C``."
msgstr ""

#: ../../../CycleTerminology.rst:260
msgid ""
"**Proof:** For a closed path ``P`` in ``C`` that passes through ``H``, every "
"cycle hierarchy has a smallest cycle ``C'`` containing ``P`` and whose "
"header is in ``P``. Since ``H`` is the only entry to ``P``, ``H`` must be "
"the header of ``C'``. Since headers uniquely define cycles, ``C'`` contains "
"every such closed path ``P``, and hence ``C'`` contains ``C``."
msgstr ""
