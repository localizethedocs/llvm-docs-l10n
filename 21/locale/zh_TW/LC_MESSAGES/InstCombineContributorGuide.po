# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 21\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../InstCombineContributorGuide.md:1
msgid "InstCombine contributor guide"
msgstr ""

#: ../../../InstCombineContributorGuide.md:2
msgid "Contents"
msgstr ""

#: ../../../InstCombineContributorGuide.md:7
msgid ""
"This guide lays out a series of rules that contributions to InstCombine "
"should follow. **Following these rules will results in much faster PR "
"approvals.**"
msgstr ""

#: ../../../InstCombineContributorGuide.md:10
msgid "Tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:12
msgid "Precommit tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:14
msgid ""
"Tests for new optimizations or miscompilation fixes should be pre-committed. "
"This means that you first commit the test with CHECK lines showing the "
"behavior *without* your change. Your actual change will then only contain "
"CHECK line diffs relative to that baseline."
msgstr ""

#: ../../../InstCombineContributorGuide.md:19
msgid ""
"This means that pull requests should generally contain two commits: First, "
"one commit adding new tests with baseline check lines. Second, a commit with "
"functional changes and test diffs."
msgstr ""

#: ../../../InstCombineContributorGuide.md:23
msgid ""
"If the second commit in your PR does not contain test diffs, you did "
"something wrong. Either you made a mistake when generating CHECK lines, or "
"your tests are not actually affected by your patch."
msgstr ""

#: ../../../InstCombineContributorGuide.md:27
msgid ""
"Exceptions: When fixing assertion failures or infinite loops, do not pre-"
"commit tests."
msgstr ""

#: ../../../InstCombineContributorGuide.md:30
msgid "Use `update_test_checks.py`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:32
msgid ""
"CHECK lines should be generated using the `update_test_checks.py` script. Do "
"**not** manually edit check lines after using it."
msgstr ""

#: ../../../InstCombineContributorGuide.md:35
msgid ""
"Be sure to use the correct opt binary when using the script. For example, if "
"your build directory is `build`, then you'll want to run:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:43
msgid "Exceptions: Hand-written CHECK lines are allowed for debuginfo tests."
msgstr ""

#: ../../../InstCombineContributorGuide.md:45
msgid "General testing considerations"
msgstr ""

#: ../../../InstCombineContributorGuide.md:47
msgid ""
"Place all tests relating to a transform into a single file. If you are "
"adding a regression test for a crash/miscompile in an existing transform, "
"find the file where the existing tests are located. A good way to do that is "
"to comment out the transform and see which tests fail."
msgstr ""

#: ../../../InstCombineContributorGuide.md:52
msgid ""
"Make tests minimal. Only test exactly the pattern being transformed. If your "
"original motivating case is a larger pattern that your fold enables to "
"optimize in some non-trivial way, you may add it as well -- however, the "
"bulk of the test coverage should be minimal."
msgstr ""

#: ../../../InstCombineContributorGuide.md:57
msgid ""
"Give tests short, but meaningful names. Don't call them `@test1`, `@test2` "
"etc.  For example, a test checking multi-use behavior of a fold involving "
"the addition of two selects might be called `@add_of_selects_multi_use`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:61
msgid ""
"Add representative tests for each test category (discussed below), but don't "
"test all combinations of everything. If you have multi-use tests, and you "
"have commuted tests, you shouldn't also add commuted multi-use tests."
msgstr ""

#: ../../../InstCombineContributorGuide.md:65
msgid ""
"Prefer to keep bit-widths for tests low to improve performance of proof "
"checking using alive2. Using `i8` is better than `i128` where possible."
msgstr ""

#: ../../../InstCombineContributorGuide.md:67
msgid "Add negative tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:69
msgid ""
"Make sure to add tests for which your transform does **not** apply. Start "
"with one of the test cases that succeeds and then create a sequence of "
"negative tests, such that **exactly one** different pre-condition of your "
"transform is not satisfied in each test."
msgstr ""

#: ../../../InstCombineContributorGuide.md:74
msgid "Add multi-use tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:76
msgid ""
"Add multi-use tests that ensures your transform does not increase "
"instruction count if some instructions have additional uses. The standard "
"pattern is to introduce extra uses with function calls:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:91
msgid ""
"Exceptions: For transform that only produce one instruction, multi-use tests "
"may be omitted."
msgstr ""

#: ../../../InstCombineContributorGuide.md:94
msgid "Add commuted tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:96
msgid ""
"If the transform involves commutative operations, add tests with commuted "
"(swapped) operands."
msgstr ""

#: ../../../InstCombineContributorGuide.md:99
msgid ""
"Make sure that the operand order stays intact in the CHECK lines of your pre-"
"commited tests. You should not see something like this:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:108
msgid ""
"If this happens, you may need to change one of the operands to have higher "
"complexity (include the \"thwart\" comment in that case):"
msgstr ""

#: ../../../InstCombineContributorGuide.md:116
msgid "Add vector tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:118
msgid ""
"When possible, it is recommended to add at least one test that uses vectors "
"instead of scalars."
msgstr ""

#: ../../../InstCombineContributorGuide.md:121
msgid ""
"For patterns that include constants, we distinguish three kinds of tests. "
"The first are \"splat\" vectors, where all the vector elements are the same. "
"These tests *should* usually fold without additional effort."
msgstr ""

#: ../../../InstCombineContributorGuide.md:133
msgid ""
"A minor variant is to replace some of the splat elements with poison. These "
"will often also fold without additional effort."
msgstr ""

#: ../../../InstCombineContributorGuide.md:144
msgid ""
"Finally, you can have non-splat vectors, where the vector elements are not "
"the same:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:155
msgid ""
"Non-splat vectors will often not fold by default. You should **not** try to "
"make them fold, unless doing so does not add **any** additional complexity. "
"You should still add the test though, even if it does not fold."
msgstr ""

#: ../../../InstCombineContributorGuide.md:159
msgid "Flag tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:161
msgid ""
"If your transform involves instructions that can have poison-generating "
"flags, such as `nuw` and `nsw` on `add`, you should test how these interact "
"with the transform."
msgstr ""

#: ../../../InstCombineContributorGuide.md:165
msgid ""
"If your transform *requires* a certain flag for correctness, make sure to "
"add negative tests missing the required flag."
msgstr ""

#: ../../../InstCombineContributorGuide.md:168
msgid ""
"If your transform doesn't require flags for correctness, you should have "
"tests for preservation behavior. If the input instructions have certain "
"flags, are they preserved in the output instructions, if it is valid to "
"preserve them? (This depends on the transform. Check with alive2.)"
msgstr ""

#: ../../../InstCombineContributorGuide.md:173
msgid ""
"The same also applies to fast-math-flags (FMF). In that case, please always "
"test specific flags like `nnan`, `nsz` or `reassoc`, rather than the "
"umbrella `fast` flag."
msgstr ""

#: ../../../InstCombineContributorGuide.md:177
msgid "Other tests"
msgstr ""

#: ../../../InstCombineContributorGuide.md:179
msgid ""
"The test categories mentioned above are non-exhaustive. There may be more "
"tests to be added, depending on the instructions involved in the transform. "
"Some examples:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:183
msgid ""
"For folds involving memory accesses like load/store, check that scalable "
"vectors and non-byte-size types (like i3) are handled correctly. Also check "
"that volatile/atomic are handled."
msgstr ""

#: ../../../InstCombineContributorGuide.md:184
msgid ""
"For folds that interact with the bitwidth in some non-trivial way, check an "
"illegal type like i13. Also confirm that the transform is correct for i1."
msgstr ""

#: ../../../InstCombineContributorGuide.md:185
msgid ""
"For folds that involve phis, you may want to check that the case of multiple "
"incoming values from one block is handled correctly."
msgstr ""

#: ../../../InstCombineContributorGuide.md:187
msgid "Proofs"
msgstr ""

#: ../../../InstCombineContributorGuide.md:189
msgid ""
"Your pull request description should contain one or more [alive2 proofs]"
"(https://alive2.llvm.org/ce/) for the correctness of the proposed transform."
msgstr ""

#: ../../../InstCombineContributorGuide.md:193
msgid "Basics"
msgstr ""

#: ../../../InstCombineContributorGuide.md:195
msgid ""
"Proofs are written using LLVM IR, by specifying a `@src` and `@tgt` "
"function. It is possible to include multiple proofs in a single file by "
"giving the src and tgt functions matching suffixes."
msgstr ""

#: ../../../InstCombineContributorGuide.md:199
msgid ""
"For example, here is a pair of proofs that both `(x-y)+y` and `(x+y)-y` can "
"be simplified to `x` ([online](https://alive2.llvm.org/ce/z/MsPPGz)):"
msgstr ""

#: ../../../InstCombineContributorGuide.md:225
msgid "Use generic values in proofs"
msgstr ""

#: ../../../InstCombineContributorGuide.md:227
msgid ""
"Proofs should operate on generic values, rather than specific constants, to "
"the degree that this is possible."
msgstr ""

#: ../../../InstCombineContributorGuide.md:229
msgid ""
"For example, if we want to fold `X s/ C s< X` to `X s> 0`, the following "
"would be a *bad* proof:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:246
msgid ""
"This is because it only proves that the transform is correct for the "
"specific constant 123. Maybe there are some constants for which the "
"transform is incorrect?"
msgstr ""

#: ../../../InstCombineContributorGuide.md:250
msgid ""
"The correct way to write this proof is as follows ([online](https://alive2."
"llvm.org/ce/z/acjwb6)):"
msgstr ""

#: ../../../InstCombineContributorGuide.md:268
msgid ""
"Note that the `@llvm.assume` intrinsic is used to specify pre-conditions for "
"the transform. In this case, the proof will fail unless we specify `C != 1` "
"as a pre-condition."
msgstr ""

#: ../../../InstCombineContributorGuide.md:272
msgid ""
"It should be emphasized that there is, in general, no expectation that the "
"IR in the proofs will be transformed by the implemented fold. In the above "
"example, the transform would only apply if `%C` is actually a constant, but "
"we need to use non-constants in the proof."
msgstr ""

#: ../../../InstCombineContributorGuide.md:277
msgid "Common pre-conditions"
msgstr ""

#: ../../../InstCombineContributorGuide.md:279
msgid "Here are some examples of common preconditions."
msgstr ""

#: ../../../InstCombineContributorGuide.md:303
msgid "Timeouts"
msgstr ""

#: ../../../InstCombineContributorGuide.md:305
msgid ""
"Alive2 proofs will sometimes produce a timeout with the following message:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:321
msgid "This is good advice, follow it!"
msgstr ""

#: ../../../InstCombineContributorGuide.md:323
msgid ""
"Reducing the bitwidth usually helps. For floating point numbers, you can use "
"the `half` type for bitwidth reduction purposes. For pointers, you can "
"reduce the bitwidth by specifying a custom data layout:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:332
msgid ""
"If reducing the bitwidth does not help, try `-disable-undef-input`. This "
"will often significantly improve performance, but also implies that the "
"correctness of the transform with `undef` values is no longer verified. This "
"is usually fine if the transform does not increase the number of uses of any "
"value."
msgstr ""

#: ../../../InstCombineContributorGuide.md:337
msgid ""
"Finally, it's possible to build alive2 locally and use `-smt-to=<m>` to "
"verify the proof with a larger timeout. If you don't want to do this (or it "
"still does not work), please submit the proof you have despite the timeout."
msgstr ""

#: ../../../InstCombineContributorGuide.md:341
msgid "Implementation"
msgstr ""

#: ../../../InstCombineContributorGuide.md:343
msgid "Real-world usefulness"
msgstr ""

#: ../../../InstCombineContributorGuide.md:345
msgid ""
"There is a very large number of transforms that *could* be implemented, but "
"only a tiny fraction of them are useful for real-world code."
msgstr ""

#: ../../../InstCombineContributorGuide.md:348
msgid ""
"Transforms that do not have real-world usefulness provide *negative* value "
"to the LLVM project, by taking up valuable reviewer time, increasing code "
"complexity and increasing compile-time overhead."
msgstr ""

#: ../../../InstCombineContributorGuide.md:352
msgid ""
"We do not require explicit proof of real-world usefulness for every "
"transform -- in most cases the usefulness is fairly \"obvious\". However, "
"the question may come up for complex or unusual folds. Keep this in mind "
"when chosing what you work on."
msgstr ""

#: ../../../InstCombineContributorGuide.md:357
msgid ""
"In particular, fixes for fuzzer-generated missed optimization reports will "
"likely be rejected if there is no evidence of real-world usefulness."
msgstr ""

#: ../../../InstCombineContributorGuide.md:360
msgid "Pick the correct optimization pass"
msgstr ""

#: ../../../InstCombineContributorGuide.md:362
msgid ""
"There are a number of passes and utilities in the InstCombine family, and it "
"is important to pick the right place when implementing a fold."
msgstr ""

#: ../../../InstCombineContributorGuide.md:365
msgid ""
"`ConstantFolding`: For folding instructions with constant arguments to a "
"constant. (Mainly relevant for intrinsics.)"
msgstr ""

#: ../../../InstCombineContributorGuide.md:366
msgid ""
"`ValueTracking`: For analyzing instructions, e.g. for known bits, non-zero, "
"etc. Tests should usually use `-passes=instsimplify`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:367
msgid ""
"`InstructionSimplify`: For folds that do not create new instructions (either "
"fold to existing value or constant)."
msgstr ""

#: ../../../InstCombineContributorGuide.md:368
msgid "`InstCombine`: For folds that create or modify instructions."
msgstr ""

#: ../../../InstCombineContributorGuide.md:369
msgid ""
"`AggressiveInstCombine`: For folds that are expensive, or violate "
"InstCombine requirements."
msgstr ""

#: ../../../InstCombineContributorGuide.md:370
msgid ""
"`VectorCombine`: For folds of vector operations that require target-"
"dependent cost-modelling."
msgstr ""

#: ../../../InstCombineContributorGuide.md:372
msgid ""
"Sometimes, folds that logically belong in InstSimplify are placed in "
"InstCombine instead, for example because they are too expensive, or because "
"they are structurally simpler to implement in InstCombine."
msgstr ""

#: ../../../InstCombineContributorGuide.md:374
msgid ""
"For example, if a fold produces new instructions in some cases but returns "
"an existing value in others, it may be preferable to keep all cases in "
"InstCombine, rather than trying to split them among InstCombine and "
"InstSimplify."
msgstr ""

#: ../../../InstCombineContributorGuide.md:376
msgid "Canonicalization and target-independence"
msgstr ""

#: ../../../InstCombineContributorGuide.md:378
msgid ""
"InstCombine is a target-independent canonicalization pass. This means that "
"it tries to bring IR into a \"canonical form\" that other optimizations "
"(both inside and outside of InstCombine) can rely on. For this reason, the "
"chosen canonical form needs to be the same for all targets, and not depend "
"on target-specific cost modelling."
msgstr ""

#: ../../../InstCombineContributorGuide.md:384
msgid ""
"In many cases, \"canonicalization\" and \"optimization\" coincide. For "
"example, if we convert `x * 2` into `x << 1`, this both makes the IR more "
"canonical (because there is now only one way to express the same operation, "
"rather than two) and faster (because shifts will usually have lower latency "
"than multiplies)."
msgstr ""

#: ../../../InstCombineContributorGuide.md:390
msgid ""
"However, there are also canonicalizations that don't serve any direct "
"optimization purpose. For example, InstCombine will canonicalize non-strict "
"predicates like `ule` to strict predicates like `ult`. `icmp ule i8 %x, 7` "
"becomes `icmp ult i8 %x, 8`. This is not an optimization in any meaningful "
"sense, but it does reduce the number of cases that other transforms need to "
"handle."
msgstr ""

#: ../../../InstCombineContributorGuide.md:397
msgid ""
"If some canonicalization is not profitable for a specific target, then a "
"reverse transform needs to be added in the backend. Patches to disable "
"specific InstCombine transforms on certain targets, or to drive them using "
"target-specific cost-modelling, **will not be accepted**. The only permitted "
"target-dependence is on DataLayout and TargetLibraryInfo."
msgstr ""

#: ../../../InstCombineContributorGuide.md:403
msgid ""
"The use of TargetTransformInfo is only allowed for hooks for target-specific "
"intrinsics, such as `TargetTransformInfo::instCombineIntrinsic()`. These are "
"already inherently target-dependent anyway."
msgstr ""

#: ../../../InstCombineContributorGuide.md:407
msgid ""
"If some canonicalization narrow/widen the integer width of expressions, "
"please check `shouldChangeType()` first. Otherwise, we may evaluate the "
"expression  in illegal/inefficient types."
msgstr ""

#: ../../../InstCombineContributorGuide.md:411
msgid ""
"For vector-specific transforms that require cost-modelling, the "
"VectorCombine pass can be used instead. In very rare circumstances, if there "
"are no other alternatives, target-dependent transforms may be accepted into "
"AggressiveInstCombine."
msgstr ""

#: ../../../InstCombineContributorGuide.md:416
msgid ""
"Generally, we prefer unsigned operations over signed operations in the "
"middle-end, even if signed operations are more efficient on some targets. "
"The following is an incomplete list of canonicalizations that are "
"implemented in InstCombine:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "Original Pattern"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "Canonical Form"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "Condition"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`icmp spred X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`icmp samesign upred X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`sign(X) == sign(Y)`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`smin/smax X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`umin/umax X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`sext X`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`zext nneg X`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`X >=s 0`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`sitofp X`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`uitofp nneg X`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`ashr X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`lshr X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`sdiv/srem X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`udiv/urem X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`X >=s 0 && Y >=s 0`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`add X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`or disjoint X, Y`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`(X & Y) != 0`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`mul X, C`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`shl X, Log2(C)`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`isPowerOf2(C)`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`select Cond1, Cond2, false`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`and Cond1, Cond2`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`impliesPoison(Cond2, Cond1)`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`select Cond1, true, Cond2`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:3
msgid "`or Cond1, Cond2`"
msgstr ""

#: ../../../InstCombineContributorGuide.md:433
msgid "PatternMatch"
msgstr ""

#: ../../../InstCombineContributorGuide.md:435
msgid ""
"Many transforms make use of the matching infrastructure defined in "
"[PatternMatch.h](https://github.com/llvm/llvm-project/blame/main/llvm/"
"include/llvm/IR/PatternMatch.h)."
msgstr ""

#: ../../../InstCombineContributorGuide.md:438
msgid "Here is a typical usage example:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:447
msgid "And another:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:458
msgid "Some common matchers are:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:460
msgid "`m_Value(A)`: Match any value and write it into `Value *A`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:461
msgid ""
"`m_Specific(A)`: Check that the operand equals A. Use this if A is assigned "
"**outside** the pattern."
msgstr ""

#: ../../../InstCombineContributorGuide.md:463
msgid ""
"`m_Deferred(A)`: Check that the operand equals A. Use this if A is assigned "
"**inside** the pattern, for example via `m_Value(A)`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:465
msgid ""
"`m_APInt(C)`: Match a scalar integer constant or splat vector constant into "
"`const APInt *C`. Does not permit undef/poison values."
msgstr ""

#: ../../../InstCombineContributorGuide.md:467
msgid ""
"`m_ImmConstant(C)`: Match any non-constant-expression constant into "
"`Constant *C`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:469
msgid ""
"`m_Constant(C)`: Match any constant into `Constant *C`. Don't use this "
"unless you know what you're doing."
msgstr ""

#: ../../../InstCombineContributorGuide.md:471
msgid ""
"`m_Add(M1, M2)`, `m_Sub(M1, M2)`, etc: Match an add/sub/etc where the first "
"operand matches M1 and the second M2."
msgstr ""

#: ../../../InstCombineContributorGuide.md:473
msgid ""
"`m_c_Add(M1, M2)`, etc: Match an add commutatively. The operands must match "
"either M1 and M2 or M2 and M1. Most instruction matchers have a commutative "
"variant."
msgstr ""

#: ../../../InstCombineContributorGuide.md:476
msgid ""
"`m_ICmp(Pred, M1, M2)` and `m_c_ICmp(Pred, M1, M2)`: Match an icmp, writing "
"the predicate into `IcmpInst::Predicate Pred`. If the commutative version is "
"used, and the operands match in order M2, M1, then `Pred` will be the "
"swapped predicate."
msgstr ""

#: ../../../InstCombineContributorGuide.md:480
msgid ""
"`m_OneUse(M)`: Check that the value only has one use, and also matches M. "
"For example `m_OneUse(m_Add(...))`. See the next section for more "
"information."
msgstr ""

#: ../../../InstCombineContributorGuide.md:484
msgid "See the header for the full list of available matchers."
msgstr ""

#: ../../../InstCombineContributorGuide.md:486
msgid "InstCombine APIs"
msgstr ""

#: ../../../InstCombineContributorGuide.md:488
msgid ""
"InstCombine transforms are handled by `visitXYZ()` methods, where XYZ "
"corresponds to the root instruction of your transform. If the outermost "
"instruction of the pattern you are matching is an icmp, the fold will be "
"located somewhere inside `visitICmpInst()`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:493
msgid ""
"The return value of the visit method is an instruction. You can either "
"return a new instruction, in which case it will be inserted before the old "
"one, and uses of the old one will be replaced by it. Or you can return the "
"original instruction to indicate that *some* kind of change has been made. "
"Finally, a nullptr return value indicates that no change occurred."
msgstr ""

#: ../../../InstCombineContributorGuide.md:499
msgid ""
"For example, if your transform produces a single new icmp instruction, you "
"could write the following:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:507
msgid ""
"In this case the main InstCombine loop takes care of inserting the "
"instruction and replacing uses of the old instruction."
msgstr ""

#: ../../../InstCombineContributorGuide.md:510
msgid "Alternatively, you can also write it like this:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:517
msgid ""
"In this case `IRBuilder` will insert the instruction and "
"`replaceInstUsesWith()` will replace the uses of the old instruction, and "
"return it to indicate that a change occurred."
msgstr ""

#: ../../../InstCombineContributorGuide.md:521
msgid ""
"Both forms are equivalent, and you can use whichever is more convenient in "
"context. For example, it's common that folds are inside helper functions "
"that return `Value *` and then `replaceInstUsesWith()` is invoked on the "
"result of that helper."
msgstr ""

#: ../../../InstCombineContributorGuide.md:526
msgid ""
"InstCombine makes use of a worklist, which needs to be correctly updated "
"during transforms. This usually happens automatically, but there are some "
"things to keep in mind:"
msgstr ""

#: ../../../InstCombineContributorGuide.md:530
msgid ""
"Don't use the `Value::replaceAllUsesWith()` API. Use InstCombine's "
"`replaceInstUsesWith()` helper instead."
msgstr ""

#: ../../../InstCombineContributorGuide.md:532
msgid ""
"Don't use the `Instruction::eraseFromParent()` API. Use InstCombine's "
"`eraseInstFromFunction()` helper instead. (Explicitly erasing instruction is "
"usually not necessary, as side-effect free instructions without users are "
"automatically removed.)"
msgstr ""

#: ../../../InstCombineContributorGuide.md:536
msgid ""
"Apart from the \"directly return an instruction\" pattern above, use "
"IRBUilder to create all instruction. Do not manually create and insert them."
msgstr ""

#: ../../../InstCombineContributorGuide.md:538
msgid ""
"When replacing operands or uses of instructions, use `replaceOperand()` and "
"`replaceUse()` instead of `setOperand()`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:541
msgid "Multi-use handling"
msgstr ""

#: ../../../InstCombineContributorGuide.md:543
msgid ""
"Transforms should usually not increase the total number of instructions. "
"This is not a hard requirement: For example, it is usually worthwhile to "
"replace a single division instruction with multiple other instructions."
msgstr ""

#: ../../../InstCombineContributorGuide.md:547
msgid ""
"For example, if you have a transform that replaces two instructions, with "
"two other instructions, this is (usually) only profitable if *both* the "
"original instructions can be removed. To ensure that both instructions are "
"removed, you need to add a one-use check for the inner instruction."
msgstr ""

#: ../../../InstCombineContributorGuide.md:552
msgid ""
"One-use checks can be performed using the `m_OneUse()` matcher, or the `V-"
">hasOneUse()` method."
msgstr ""

#: ../../../InstCombineContributorGuide.md:555
msgid "Flag handling"
msgstr ""

#: ../../../InstCombineContributorGuide.md:557
msgid ""
"When possible, favour propagation of poison-generating flags like `nuw` and "
"`nsw` since they may be hard to salvage later. Avoid doing so if it "
"introduces additional complexity (e.g. requires querying `willNotOverflow` "
"or KnownBits)."
msgstr ""

#: ../../../InstCombineContributorGuide.md:561
msgid ""
"Be careful with in-place operand/predicate changes, as poison-generating "
"flags may not be valid for new operands. It is recommended to create a new "
"instruction with careful handling of flags. If not applicable, call "
"`Instruction::dropPoisonGeneratingFlags()` to clear flags in a conservative "
"manner."
msgstr ""

#: ../../../InstCombineContributorGuide.md:565
msgid ""
"Do not rely on fcmp's `nsz` flag to perform optimizations. It is meaningless "
"for fcmp so it should not affect the optimization."
msgstr ""

#: ../../../InstCombineContributorGuide.md:568
msgid "Generalization"
msgstr ""

#: ../../../InstCombineContributorGuide.md:570
msgid ""
"Transforms can both be too specific (only handling some odd subset of "
"patterns, leading to unexpected optimization cliffs) and too general "
"(introducing complexity to handle cases with no real-world relevance). The "
"right level of generality is quite subjective, so this section only provides "
"some broad guidelines."
msgstr ""

#: ../../../InstCombineContributorGuide.md:576
msgid ""
"Avoid transforms that are hardcoded to specific constants. Try to figure out "
"what the general rule for arbitrary constants is."
msgstr ""

#: ../../../InstCombineContributorGuide.md:578
msgid ""
"Add handling for conjugate patterns. For example, if you implement a fold "
"for `icmp eq`, you almost certainly also want to support `icmp ne`, with the "
"inverse result. Similarly, if you implement a pattern for `and` of `icmp`s, "
"you should also handle the de-Morgan conjugate using `or`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:582
msgid ""
"Handle non-splat vector constants if doing so is free, but do not add "
"handling for them if it adds any additional complexity to the code."
msgstr ""

#: ../../../InstCombineContributorGuide.md:584
msgid ""
"Do not handle non-canonical patterns, unless there is a specific motivation "
"to do so. For example, it may sometimes be worthwhile to handle a pattern "
"that would normally be converted into a different canonical form, but can "
"still occur in multi-use scenarios. This is fine to do if there is specific "
"real-world motivation, but you should not go out of your way to do this "
"otherwise."
msgstr ""

#: ../../../InstCombineContributorGuide.md:590
msgid ""
"Sometimes the motivating pattern uses a constant value with certain "
"properties, but the fold can be generalized to non-constant values by making "
"use of ValueTracking queries. Whether this makes sense depends on the case, "
"but it's usually a good idea to only handle the constant pattern first, and "
"then generalize later if it seems useful."
msgstr ""

#: ../../../InstCombineContributorGuide.md:595
msgid ""
"When possible, handle more canonical patterns as well. It is encouraged to "
"avoid potential phase-ordering issues. For example, if the motivating "
"transform holds for `add`, it also holds for `or disjoint`. See the "
"canonicalization list above for details. In most cases, it can be easily "
"implemented with matchers like `m_AddLike/m_SExtLike/m_LogicalAnd/"
"m_LogicalOr`."
msgstr ""

#: ../../../InstCombineContributorGuide.md:601
msgid "Guidelines for reviewers"
msgstr ""

#: ../../../InstCombineContributorGuide.md:603
msgid ""
"Do not ask new contributors to implement non-splat vector support in code "
"reviews. If you think non-splat vector support for a fold is both worthwhile "
"and policy-compliant (that is, the handling would not result in any "
"appreciable increase in code complexity), implement it yourself in a follow-"
"up patch."
msgstr ""
