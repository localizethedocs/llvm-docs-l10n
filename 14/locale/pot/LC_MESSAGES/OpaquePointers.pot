# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../OpaquePointers.rst:3
msgid "Opaque Pointers"
msgstr ""

#: ../../../OpaquePointers.rst:6
msgid "The Opaque Pointer Type"
msgstr ""

#: ../../../OpaquePointers.rst:8
msgid ""
"Traditionally, LLVM IR pointer types have contained a pointee type. For "
"example, ``i32*`` is a pointer that points to an ``i32`` somewhere in "
"memory. However, due to a lack of pointee type semantics and various issues "
"with having pointee types, there is a desire to remove pointee types from "
"pointers."
msgstr ""

#: ../../../OpaquePointers.rst:13
msgid ""
"The opaque pointer type project aims to replace all pointer types containing "
"pointee types in LLVM with an opaque pointer type. The new pointer type is "
"tentatively represented textually as ``ptr``."
msgstr ""

#: ../../../OpaquePointers.rst:17
msgid ""
"Address spaces are still used to distinguish between different kinds of "
"pointers where the distinction is relevant for lowering (e.g. data vs "
"function pointers have different sizes on some architectures). Opaque "
"pointers are not changing anything related to address spaces and lowering. "
"For more information, see `DataLayout <LangRef.html#langref-datalayout>`_."
msgstr ""

#: ../../../OpaquePointers.rst:24
msgid "Issues with explicit pointee types"
msgstr ""

#: ../../../OpaquePointers.rst:26
msgid ""
"LLVM IR pointers can be cast back and forth between pointers with different "
"pointee types. The pointee type does not necessarily actually represent the "
"actual underlying type in memory. In other words, the pointee type contains "
"no real semantics."
msgstr ""

#: ../../../OpaquePointers.rst:31
msgid ""
"Lots of operations do not actually care about the underlying type. These "
"operations, typically intrinsics, usually end up taking an ``i8*``. This "
"causes lots of redundant no-op bitcasts in the IR to and from a pointer with "
"a different pointee type. The extra bitcasts take up space and require extra "
"work to look through in optimizations. And more bitcasts increases the "
"chances of incorrect bitcasts, especially in regards to address spaces."
msgstr ""

#: ../../../OpaquePointers.rst:38
msgid ""
"Some instructions still need to know what type to treat the memory pointed "
"to by the pointer as. For example, a load needs to know how many bytes to "
"load from memory. In these cases, instructions themselves contain a type "
"argument. For example the load instruction from older versions of LLVM"
msgstr ""

#: ../../../OpaquePointers.rst:47
msgid "becomes"
msgstr ""

#: ../../../OpaquePointers.rst:53
msgid ""
"A nice analogous transition that happened earlier in LLVM is integer "
"signedness. There is no distinction between signed and unsigned integer "
"types, rather the integer operations themselves contain what to treat the "
"integer as. Initially, LLVM IR distinguished between unsigned and signed "
"integer types. The transition from manifesting signedness in types to "
"instructions happened early on in LLVM's life to the betterment of LLVM IR."
msgstr ""

#: ../../../OpaquePointers.rst:61
msgid "Opaque Pointers Mode"
msgstr ""

#: ../../../OpaquePointers.rst:63
msgid ""
"During the transition phase, LLVM can be used in two modes: In typed pointer "
"mode (currently still the default) all pointer types have a pointee type and "
"opaque pointers cannot be used. In opaque pointers mode, all pointers are "
"opaque. The opaque pointer mode can be enabled using ``-opaque-pointers`` in "
"LLVM tools like ``opt``, or ``-mllvm -opaque-pointers`` in clang."
msgstr ""

#: ../../../OpaquePointers.rst:69
msgid ""
"In opaque pointer mode, all typed pointers used in IR, bitcode, or created "
"using ``PointerType::get()`` and similar APIs are automatically converted "
"into opaque pointers. This simplifies migration and allows testing existing "
"IR with opaque pointers."
msgstr ""

#: ../../../OpaquePointers.rst:90
msgid "I Still Need Pointee Types!"
msgstr ""

#: ../../../OpaquePointers.rst:92
msgid ""
"The frontend should already know what type each operation operates on based "
"on the input source code. However, some frontends like Clang may end up "
"relying on LLVM pointer pointee types to keep track of pointee types. The "
"frontend needs to keep track of frontend pointee types on its own."
msgstr ""

#: ../../../OpaquePointers.rst:97
msgid ""
"For optimizations around frontend types, pointee types are not useful due "
"their lack of semantics. Rather, since LLVM IR works on untyped memory, for "
"a frontend to tell LLVM about frontend types for the purposes of alias "
"analysis, extra metadata is added to the IR. For more information, see `TBAA "
"<LangRef.html#tbaa-metadata>`_."
msgstr ""

#: ../../../OpaquePointers.rst:103
msgid ""
"Some specific operations still need to know what type a pointer types to. "
"For the most part, this is codegen and ABI specific. For example, `byval "
"<LangRef.html#parameter-attributes>`_ arguments are pointers, but backends "
"need to know the underlying type of the argument to properly lower it. In "
"cases like these, the attributes contain a type argument. For example,"
msgstr ""

#: ../../../OpaquePointers.rst:113
msgid ""
"signifies that ``%p`` as an argument should be lowered as an ``i32`` passed "
"indirectly."
msgstr ""

#: ../../../OpaquePointers.rst:116
msgid ""
"If you have use cases that this sort of fix doesn't cover, please email llvm-"
"dev."
msgstr ""

#: ../../../OpaquePointers.rst:120
msgid "Migration Instructions"
msgstr ""

#: ../../../OpaquePointers.rst:122
msgid ""
"In order to support opaque pointers, two types of changes tend to be "
"necessary. The first is the removal of all calls to ``PointerType::"
"getElementType()`` and ``Type::getPointerElementType()``."
msgstr ""

#: ../../../OpaquePointers.rst:126
msgid ""
"In the LLVM middle-end and backend, this is usually accomplished by "
"inspecting the type of relevant operations instead. For example, memory "
"access related analyses and optimizations should use the types encoded in "
"the load and store instructions instead of querying the pointer type."
msgstr ""

#: ../../../OpaquePointers.rst:131
msgid ""
"Frontends need to be adjusted to track pointee types independently of LLVM, "
"insofar as they are necessary for lowering. For example, clang now tracks "
"the pointee type in the ``Address`` structure."
msgstr ""

#: ../../../OpaquePointers.rst:135
msgid ""
"While direct usage of pointer element types is immediately apparent in code, "
"there is a more subtle issue that opaque pointers need to contend with: A "
"lot of code assumes that pointer equality also implies that the used load/"
"store type is the same. Consider the following examples with typed an opaque "
"pointers:"
msgstr ""

#: ../../../OpaquePointers.rst:155
msgid ""
"Without opaque pointers, a check that the pointer operand of the load and "
"store are the same also ensures that the accessed type is the same. Using a "
"different type requires a bitcast, which will result in distinct pointer "
"operands."
msgstr ""

#: ../../../OpaquePointers.rst:160
msgid ""
"With opaque pointers, the bitcast is not present, and this check is no "
"longer sufficient. In the above example, it could result in store to load "
"forwarding of an incorrect type. Code making such assumptions needs to be "
"adjusted to check the accessed type explicitly: ``LI->getType() == SI-"
">getValueOperand()->getType()``."
msgstr ""

#: ../../../OpaquePointers.rst:166
msgid ""
"Frontends using the C API through an FFI interface should be aware that a "
"number of C API functions are deprecated and will be removed as part of the "
"opaque pointer transition::"
msgstr ""

#: ../../../OpaquePointers.rst:180
msgid ""
"Additionally, it will no longer be possible to call ``LLVMGetElementType()`` "
"on a pointer type."
msgstr ""

#: ../../../OpaquePointers.rst:184
msgid "Transition State"
msgstr ""

#: ../../../OpaquePointers.rst:186
msgid ""
"As of January 2022 large parts of LLVM support opaque pointers, but there "
"are still some major open problems:"
msgstr ""

#: ../../../OpaquePointers.rst:189
msgid ""
"Bitcode already fully supports opaque pointers, and reading up-to-date typed "
"pointer bitcode in opaque pointers mode also works. However, we currently do "
"not support pointee type based auto-upgrade of old bitcode in opaque pointer "
"mode."
msgstr ""

#: ../../../OpaquePointers.rst:194
msgid ""
"While clang has limited support for opaque pointers (sufficient to compile "
"CTMark on Linux), a major effort will be needed to systematically remove all "
"uses of ``getPointerElementType()`` and the deprecated ``Address()`` "
"constructor."
msgstr ""

#: ../../../OpaquePointers.rst:199
msgid ""
"We do not yet have a testing strategy for how we can test both typed and "
"opaque pointers during the migration. Currently, individual tests for opaque "
"pointers are being added, but the bulk of tests still uses typed pointers."
msgstr ""

#: ../../../OpaquePointers.rst:204
msgid ""
"Loop access analysis does not support opaque pointers yet, and is currently "
"the main source of assertion failures in optimized builds."
msgstr ""

#: ../../../OpaquePointers.rst:207
msgid "Miscellanous uses of pointer element types remain everywhere."
msgstr ""
