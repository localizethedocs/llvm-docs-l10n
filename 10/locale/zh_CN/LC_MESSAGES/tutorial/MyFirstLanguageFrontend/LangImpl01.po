# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:3
msgid "Kaleidoscope: Kaleidoscope Introduction and the Lexer"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:9
msgid "The Kaleidoscope Language"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:11
msgid ""
"This tutorial is illustrated with a toy language called \"`Kaleidoscope "
"<http://en.wikipedia.org/wiki/Kaleidoscope>`_\" (derived from \"meaning "
"beautiful, form, and view\"). Kaleidoscope is a procedural language that "
"allows you to define functions, use conditionals, math, etc. Over the course "
"of the tutorial, we'll extend Kaleidoscope to support the if/then/else "
"construct, a for loop, user defined operators, JIT compilation with a simple "
"command line interface, debug info, etc."
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:19
msgid ""
"We want to keep things simple, so the only datatype in Kaleidoscope is a 64-"
"bit floating point type (aka 'double' in C parlance). As such, all values "
"are implicitly double precision and the language doesn't require type "
"declarations. This gives the language a very nice and simple syntax. For "
"example, the following simple example computes `Fibonacci numbers: <http://"
"en.wikipedia.org/wiki/Fibonacci_number>`_"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:38
msgid ""
"We also allow Kaleidoscope to call into standard library functions - the "
"LLVM JIT makes this really easy. This means that you can use the 'extern' "
"keyword to define a function before you use it (this is also useful for "
"mutually recursive functions).  For example:"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:51
msgid ""
"A more interesting example is included in Chapter 6 where we write a little "
"Kaleidoscope application that `displays a Mandelbrot Set <LangImpl06."
"html#kicking-the-tires>`_ at various levels of magnification."
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:55
msgid "Let's dive into the implementation of this language!"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:58
msgid "The Lexer"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:60
msgid ""
"When it comes to implementing a language, the first thing needed is the "
"ability to process a text file and recognize what it says. The traditional "
"way to do this is to use a \"`lexer <http://en.wikipedia.org/wiki/"
"Lexical_analysis>`_\" (aka 'scanner') to break the input up into \"tokens\". "
"Each token returned by the lexer includes a token code and potentially some "
"metadata (e.g. the numeric value of a number). First, we define the "
"possibilities:"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:87
msgid ""
"Each token returned by our lexer will either be one of the Token enum values "
"or it will be an 'unknown' character like '+', which is returned as its "
"ASCII value. If the current token is an identifier, the ``IdentifierStr`` "
"global variable holds the name of the identifier. If the current token is a "
"numeric literal (like 1.0), ``NumVal`` holds its value. We use global "
"variables for simplicity, but this is not the best choice for a real "
"language implementation :)."
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:95
msgid ""
"The actual implementation of the lexer is a single function named "
"``gettok``. The ``gettok`` function is called to return the next token from "
"standard input. Its definition starts as:"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:109
msgid ""
"``gettok`` works by calling the C ``getchar()`` function to read characters "
"one at a time from standard input. It eats them as it recognizes them and "
"stores the last character read, but not processed, in LastChar. The first "
"thing that it has to do is ignore whitespace between tokens. This is "
"accomplished with the loop above."
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:115
msgid ""
"The next thing ``gettok`` needs to do is recognize identifiers and specific "
"keywords like \"def\". Kaleidoscope does this with this simple loop:"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:133
msgid ""
"Note that this code sets the '``IdentifierStr``' global whenever it lexes an "
"identifier. Also, since language keywords are matched by the same loop, we "
"handle them here inline. Numeric values are similar:"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:150
msgid ""
"This is all pretty straightforward code for processing input. When reading a "
"numeric value from input, we use the C ``strtod`` function to convert it to "
"a numeric value that we store in ``NumVal``. Note that this isn't doing "
"sufficient error checking: it will incorrectly read \"1.23.45.67\" and "
"handle it as if you typed in \"1.23\". Feel free to extend it!  Next we "
"handle comments:"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:169
msgid ""
"We handle comments by skipping to the end of the line and then return the "
"next token. Finally, if the input doesn't match one of the above cases, it "
"is either an operator character like '+' or the end of the file. These are "
"handled with this code:"
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:186
msgid ""
"With this, we have the complete lexer for the basic Kaleidoscope language "
"(the `full code listing <LangImpl02.html#full-code-listing>`_ for the Lexer "
"is available in the `next chapter <LangImpl02.html>`_ of the tutorial). Next "
"we'll `build a simple parser that uses this to build an Abstract Syntax Tree "
"<LangImpl02.html>`_. When we have that, we'll include a driver so that you "
"can use the lexer and parser together."
msgstr ""

#: ../../../tutorial/MyFirstLanguageFrontend/LangImpl01.rst:193
msgid "`Next: Implementing a Parser and AST <LangImpl02.html>`_"
msgstr ""
