# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CMakePrimer.rst:3
msgid "CMake Primer"
msgstr ""

#: ../../../CMakePrimer.rst:9
msgid ""
"Disclaimer: This documentation is written by LLVM project contributors `not` "
"anyone affiliated with the CMake project. This document may contain "
"inaccurate terminology, phrasing, or technical details. It is provided with "
"the best intentions."
msgstr ""

#: ../../../CMakePrimer.rst:16
msgid "Introduction"
msgstr ""

#: ../../../CMakePrimer.rst:18
msgid ""
"The LLVM project and many of the core projects built on LLVM build using "
"CMake. This document aims to provide a brief overview of CMake for "
"developers modifying LLVM projects or building their own projects on top of "
"LLVM."
msgstr ""

#: ../../../CMakePrimer.rst:22
msgid ""
"The official CMake language references is available in the cmake-language "
"manpage and `cmake-language online documentation <https://cmake.org/cmake/"
"help/v3.4/manual/cmake-language.7.html>`_."
msgstr ""

#: ../../../CMakePrimer.rst:27
msgid "10,000 ft View"
msgstr ""

#: ../../../CMakePrimer.rst:29
msgid ""
"CMake is a tool that reads script files in its own language that describe "
"how a software project builds. As CMake evaluates the scripts it constructs "
"an internal representation of the software project. Once the scripts have "
"been fully processed, if there are no errors, CMake will generate build "
"files to actually build the project. CMake supports generating build files "
"for a variety of command line build tools as well as for popular IDEs."
msgstr ""

#: ../../../CMakePrimer.rst:36
msgid ""
"When a user runs CMake it performs a variety of checks similar to how "
"autoconf worked historically. During the checks and the evaluation of the "
"build description scripts CMake caches values into the CMakeCache. This is "
"useful because it allows the build system to skip long-running checks during "
"incremental development. CMake caching also has some drawbacks, but that "
"will be discussed later."
msgstr ""

#: ../../../CMakePrimer.rst:44
msgid "Scripting Overview"
msgstr ""

#: ../../../CMakePrimer.rst:46
msgid ""
"CMake's scripting language has a very simple grammar. Every language "
"construct is a command that matches the pattern _name_(_args_). Commands "
"come in three primary types: language-defined (commands implemented in C++ "
"in CMake), defined functions, and defined macros. The CMake distribution "
"also contains a suite of CMake modules that contain definitions for useful "
"functionality."
msgstr ""

#: ../../../CMakePrimer.rst:52
msgid ""
"The example below is the full CMake build for building a C++ \"Hello World\" "
"program. The example uses only CMake language-defined functions."
msgstr ""

#: ../../../CMakePrimer.rst:61
msgid ""
"The CMake language provides control flow constructs in the form of foreach "
"loops and if blocks. To make the example above more complicated you could "
"add an if block to define \"APPLE\" when targeting Apple platforms:"
msgstr ""

#: ../../../CMakePrimer.rst:75
msgid "Variables, Types, and Scope"
msgstr ""

#: ../../../CMakePrimer.rst:78
msgid "Dereferencing"
msgstr ""

#: ../../../CMakePrimer.rst:80
msgid ""
"In CMake variables are \"stringly\" typed. All variables are represented as "
"strings throughout evaluation. Wrapping a variable in ``${}`` dereferences "
"it and results in a literal substitution of the name for the value. CMake "
"refers to this as \"variable evaluation\" in their documentation. "
"Dereferences are performed *before* the command being called receives the "
"arguments. This means dereferencing a list results in multiple separate "
"arguments being passed to the command."
msgstr ""

#: ../../../CMakePrimer.rst:88
msgid ""
"Variable dereferences can be nested and be used to model complex data. For "
"example:"
msgstr ""

#: ../../../CMakePrimer.rst:97
msgid ""
"Dereferencing an unset variable results in an empty expansion. It is a "
"common pattern in CMake to conditionally set variables knowing that it will "
"be used in code paths that the variable isn't set. There are examples of "
"this throughout the LLVM CMake build system."
msgstr ""

#: ../../../CMakePrimer.rst:102
msgid "An example of variable empty expansion is:"
msgstr ""

#: ../../../CMakePrimer.rst:111
msgid ""
"In this example the ``extra_sources`` variable is only defined if you're "
"targeting an Apple platform. For all other targets the ``extra_sources`` "
"will be evaluated as empty before add_executable is given its arguments."
msgstr ""

#: ../../../CMakePrimer.rst:116
msgid "Lists"
msgstr ""

#: ../../../CMakePrimer.rst:118
msgid ""
"In CMake lists are semi-colon delimited strings, and it is strongly advised "
"that you avoid using semi-colons in lists; it doesn't go smoothly. A few "
"examples of defining lists:"
msgstr ""

#: ../../../CMakePrimer.rst:132
msgid "Lists of Lists"
msgstr ""

#: ../../../CMakePrimer.rst:134
msgid ""
"One of the more complicated patterns in CMake is lists of lists. Because a "
"list cannot contain an element with a semi-colon to construct a list of "
"lists you make a list of variable names that refer to other lists. For "
"example:"
msgstr ""

#: ../../../CMakePrimer.rst:145
msgid ""
"With this layout you can iterate through the list of lists printing each "
"value with the following code:"
msgstr ""

#: ../../../CMakePrimer.rst:156
msgid ""
"You'll notice that the inner foreach loop's list is doubly dereferenced. "
"This is because the first dereference turns ``list_name`` into the name of "
"the sub-list (a, b, or c in the example), then the second dereference is to "
"get the value of the list."
msgstr ""

#: ../../../CMakePrimer.rst:161
msgid ""
"This pattern is used throughout CMake, the most common example is the "
"compiler flags options, which CMake refers to using the following variable "
"expansions: CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}"
"_FLAGS_${CMAKE_BUILD_TYPE}."
msgstr ""

#: ../../../CMakePrimer.rst:166
msgid "Other Types"
msgstr ""

#: ../../../CMakePrimer.rst:168
msgid ""
"Variables that are cached or specified on the command line can have types "
"associated with them. The variable's type is used by CMake's UI tool to "
"display the right input field. A variable's type generally doesn't impact "
"evaluation, however CMake does have special handling for some variables such "
"as PATH. You can read more about the special handling in `CMake's set "
"documentation <https://cmake.org/cmake/help/v3.5/command/set.html#set-cache-"
"entry>`_."
msgstr ""

#: ../../../CMakePrimer.rst:176
msgid "Scope"
msgstr ""

#: ../../../CMakePrimer.rst:178
msgid ""
"CMake inherently has a directory-based scoping. Setting a variable in a "
"CMakeLists file, will set the variable for that file, and all "
"subdirectories. Variables set in a CMake module that is included in a "
"CMakeLists file will be set in the scope they are included from, and all "
"subdirectories."
msgstr ""

#: ../../../CMakePrimer.rst:183
msgid ""
"When a variable that is already set is set again in a subdirectory it "
"overrides the value in that scope and any deeper subdirectories."
msgstr ""

#: ../../../CMakePrimer.rst:186
msgid ""
"The CMake set command provides two scope-related options. PARENT_SCOPE sets "
"a variable into the parent scope, and not the current scope. The CACHE "
"option sets the variable in the CMakeCache, which results in it being set in "
"all scopes. The CACHE option will not set a variable that already exists in "
"the CACHE unless the FORCE option is specified."
msgstr ""

#: ../../../CMakePrimer.rst:192
msgid ""
"In addition to directory-based scope, CMake functions also have their own "
"scope. This means variables set inside functions do not bleed into the "
"parent scope. This is not true of macros, and it is for this reason LLVM "
"prefers functions over macros whenever reasonable."
msgstr ""

#: ../../../CMakePrimer.rst:198
msgid ""
"Unlike C-based languages, CMake's loop and control flow blocks do not have "
"their own scopes."
msgstr ""

#: ../../../CMakePrimer.rst:202
msgid "Control Flow"
msgstr ""

#: ../../../CMakePrimer.rst:204
msgid ""
"CMake features the same basic control flow constructs you would expect in "
"any scripting language, but there are a few quirks because, as with "
"everything in CMake, control flow constructs are commands."
msgstr ""

#: ../../../CMakePrimer.rst:209
msgid "If, ElseIf, Else"
msgstr ""

#: ../../../CMakePrimer.rst:212
msgid ""
"For the full documentation on the CMake if command go `here <https://cmake."
"org/cmake/help/v3.4/command/if.html>`_. That resource is far more complete."
msgstr ""

#: ../../../CMakePrimer.rst:216
msgid "In general CMake if blocks work the way you'd expect:"
msgstr ""

#: ../../../CMakePrimer.rst:228
msgid ""
"The single most important thing to know about CMake's if blocks coming from "
"a C background is that they do not have their own scope. Variables set "
"inside conditional blocks persist after the ``endif()``."
msgstr ""

#: ../../../CMakePrimer.rst:233
msgid "Loops"
msgstr ""

#: ../../../CMakePrimer.rst:235
msgid "The most common form of the CMake ``foreach`` block is:"
msgstr ""

#: ../../../CMakePrimer.rst:243
msgid ""
"The variable argument portion of the ``foreach`` block can contain "
"dereferenced lists, values to iterate, or a mix of both:"
msgstr ""

#: ../../../CMakePrimer.rst:274
msgid ""
"There is also a more modern CMake foreach syntax. The code below is "
"equivalent to the code above:"
msgstr ""

#: ../../../CMakePrimer.rst:305
msgid ""
"Similar to the conditional statements, these generally behave how you would "
"expect, and they do not have their own scope."
msgstr ""

#: ../../../CMakePrimer.rst:308
msgid ""
"CMake also supports ``while`` loops, although they are not widely used in "
"LLVM."
msgstr ""

#: ../../../CMakePrimer.rst:311
msgid "Modules, Functions and Macros"
msgstr ""

#: ../../../CMakePrimer.rst:314
msgid "Modules"
msgstr ""

#: ../../../CMakePrimer.rst:316
msgid ""
"Modules are CMake's vehicle for enabling code reuse. CMake modules are just "
"CMake script files. They can contain code to execute on include as well as "
"definitions for commands."
msgstr ""

#: ../../../CMakePrimer.rst:320
msgid ""
"In CMake macros and functions are universally referred to as commands, and "
"they are the primary method of defining code that can be called multiple "
"times."
msgstr ""

#: ../../../CMakePrimer.rst:323
msgid ""
"In LLVM we have several CMake modules that are included as part of our "
"distribution for developers who don't build our project from source. Those "
"modules are the fundamental pieces needed to build LLVM-based projects with "
"CMake. We also rely on modules as a way of organizing the build system's "
"functionality for maintainability and re-use within LLVM projects."
msgstr ""

#: ../../../CMakePrimer.rst:330
msgid "Argument Handling"
msgstr ""

#: ../../../CMakePrimer.rst:332
msgid ""
"When defining a CMake command handling arguments is very useful. The "
"examples in this section will all use the CMake ``function`` block, but this "
"all applies to the ``macro`` block as well."
msgstr ""

#: ../../../CMakePrimer.rst:336
msgid ""
"CMake commands can have named arguments that are requried at every call "
"site. In addition, all commands will implicitly accept a variable number of "
"extra arguments (In C parlance, all commands are varargs functions). When a "
"command is invoked with extra arguments (beyond the named ones) CMake will "
"store the full list of arguments (both named and unnamed) in a list named "
"``ARGV``, and the sublist of unnamed arguments in ``ARGN``. Below is a "
"trivial example of providing a wrapper function for CMake's built in "
"function ``add_dependencies``."
msgstr ""

#: ../../../CMakePrimer.rst:350
msgid ""
"This example defines a new macro named ``add_deps`` which takes a required "
"first argument, and just calls another function passing through the first "
"argument and all trailing arguments."
msgstr ""

#: ../../../CMakePrimer.rst:354
msgid ""
"CMake provides a module ``CMakeParseArguments`` which provides an "
"implementation of advanced argument parsing. We use this all over LLVM, and "
"it is recommended for any function that has complex argument-based behaviors "
"or optional arguments. CMake's official documentation for the module is in "
"the ``cmake-modules`` manpage, and is also available at the `cmake-modules "
"online documentation <https://cmake.org/cmake/help/v3.4/module/"
"CMakeParseArguments.html>`_."
msgstr ""

#: ../../../CMakePrimer.rst:363
msgid ""
"As of CMake 3.5 the cmake_parse_arguments command has become a native "
"command and the CMakeParseArguments module is empty and only left around for "
"compatibility."
msgstr ""

#: ../../../CMakePrimer.rst:368
msgid "Functions Vs Macros"
msgstr ""

#: ../../../CMakePrimer.rst:370
msgid ""
"Functions and Macros look very similar in how they are used, but there is "
"one fundamental difference between the two. Functions have their own scope, "
"and macros don't. This means variables set in macros will bleed out into the "
"calling scope. That makes macros suitable for defining very small bits of "
"functionality only."
msgstr ""

#: ../../../CMakePrimer.rst:376
msgid ""
"The other difference between CMake functions and macros is how arguments are "
"passed. Arguments to macros are not set as variables, instead dereferences "
"to the parameters are resolved across the macro before executing it. This "
"can result in some unexpected behavior if using unreferenced variables. For "
"example:"
msgstr ""

#: ../../../CMakePrimer.rst:398
msgid ""
"Generally speaking this issue is uncommon because it requires using non-"
"dereferenced variables with names that overlap in the parent scope, but it "
"is important to be aware of because it can lead to subtle bugs."
msgstr ""

#: ../../../CMakePrimer.rst:403
msgid "LLVM Project Wrappers"
msgstr ""

#: ../../../CMakePrimer.rst:405
msgid ""
"LLVM projects provide lots of wrappers around critical CMake built-in "
"commands. We use these wrappers to provide consistent behaviors across LLVM "
"components and to reduce code duplication."
msgstr ""

#: ../../../CMakePrimer.rst:409
msgid ""
"We generally (but not always) follow the convention that commands prefaced "
"with ``llvm_`` are intended to be used only as building blocks for other "
"commands. Wrapper commands that are intended for direct use are generally "
"named following with the project in the middle of the command name (i.e. "
"``add_llvm_executable`` is the wrapper for ``add_executable``). The LLVM "
"``add_*`` wrapper functions are all defined in ``AddLLVM.cmake`` which is "
"installed as part of the LLVM distribution. It can be included and used by "
"any LLVM sub-project that requires LLVM."
msgstr ""

#: ../../../CMakePrimer.rst:420
msgid ""
"Not all LLVM projects require LLVM for all use cases. For example compiler-"
"rt can be built without LLVM, and the compiler-rt sanitizer libraries are "
"used with GCC."
msgstr ""

#: ../../../CMakePrimer.rst:425
msgid "Useful Built-in Commands"
msgstr ""

#: ../../../CMakePrimer.rst:427
msgid ""
"CMake has a bunch of useful built-in commands. This document isn't going to "
"go into details about them because The CMake project has excellent "
"documentation. To highlight a few useful functions see:"
msgstr ""

#: ../../../CMakePrimer.rst:431
msgid ""
"`add_custom_command <https://cmake.org/cmake/help/v3.4/command/"
"add_custom_command.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:432
msgid ""
"`add_custom_target <https://cmake.org/cmake/help/v3.4/command/"
"add_custom_target.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:433
msgid "`file <https://cmake.org/cmake/help/v3.4/command/file.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:434
msgid "`list <https://cmake.org/cmake/help/v3.4/command/list.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:435
msgid "`math <https://cmake.org/cmake/help/v3.4/command/math.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:436
msgid "`string <https://cmake.org/cmake/help/v3.4/command/string.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:438
msgid ""
"The full documentation for CMake commands is in the ``cmake-commands`` "
"manpage and available on `CMake's website <https://cmake.org/cmake/help/v3.4/"
"manual/cmake-commands.7.html>`_"
msgstr ""
