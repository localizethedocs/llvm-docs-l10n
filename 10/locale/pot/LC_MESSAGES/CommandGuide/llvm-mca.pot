# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CommandGuide/llvm-mca.rst:2
msgid "llvm-mca - LLVM Machine Code Analyzer"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:7
msgid "SYNOPSIS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:9
msgid ":program:`llvm-mca` [*options*] [input]"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:12
msgid "DESCRIPTION"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:14
msgid ""
":program:`llvm-mca` is a performance analysis tool that uses information "
"available in LLVM (e.g. scheduling models) to statically measure the "
"performance of machine code in a specific CPU."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:18
msgid ""
"Performance is measured in terms of throughput as well as processor resource "
"consumption. The tool currently works for processors with an out-of-order "
"backend, for which there is a scheduling model available in LLVM."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:22
msgid ""
"The main goal of this tool is not just to predict the performance of the "
"code when run on the target, but also help with diagnosing potential "
"performance issues."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:26
msgid ""
"Given an assembly code sequence, :program:`llvm-mca` estimates the "
"Instructions Per Cycle (IPC), as well as hardware resource pressure. The "
"analysis and reporting style were inspired by the IACA tool from Intel."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:30
msgid ""
"For example, you can compile code with clang, output assembly, and pipe it "
"directly into :program:`llvm-mca` for analysis:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:37
msgid "Or for Intel syntax:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:43
msgid ""
"Scheduling models are not just used to compute instruction latencies and "
"throughput, but also to understand what processor resources are available "
"and how to simulate them."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:47
msgid ""
"By design, the quality of the analysis conducted by :program:`llvm-mca` is "
"inevitably affected by the quality of the scheduling models in LLVM."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:50
msgid ""
"If you see that the performance report is not accurate for a processor, "
"please `file a bug <https://bugs.llvm.org/enter_bug.cgi?product=libraries>`_ "
"against the appropriate backend."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:55
msgid "OPTIONS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:57
msgid ""
"If ``input`` is \"``-``\" or omitted, :program:`llvm-mca` reads from "
"standard input. Otherwise, it will read from the specified filename."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:60
msgid ""
"If the :option:`-o` option is omitted, then :program:`llvm-mca` will send "
"its output to standard output if the input is from standard input.  If the :"
"option:`-o` option specifies \"``-``\", then the output will also be sent to "
"standard output."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:67
msgid "Print a summary of command line options."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:71
msgid ""
"Use ``<filename>`` as the output filename. See the summary above for more "
"details."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:76
msgid "Specify a target triple string."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:80
msgid ""
"Specify the architecture for which to analyze the code. It defaults to the "
"host default target."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:85
msgid ""
"Specify the processor for which to analyze the code.  By default, the cpu "
"name is autodetected from the host."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:90
msgid ""
"Specify the output assembly variant for the report generated by the tool. On "
"x86, possible values are [0, 1]. A value of 0 (vic. 1) for this flag enables "
"the AT&T (vic. Intel) assembly format for the code printed out by the tool "
"in the analysis report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:97
msgid ""
"Prefer hex format for numeric literals in the output assembly printed as "
"part of the report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:102
msgid ""
"Specify a different dispatch width for the processor. The dispatch width "
"defaults to field 'IssueWidth' in the processor scheduling model.  If width "
"is zero, then the default dispatch width is used."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:108
msgid ""
"Specify the size of the register file. When specified, this flag limits how "
"many physical registers are available for register renaming purposes. A "
"value of zero for this flag means \"unlimited number of physical registers\"."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:114
msgid ""
"Specify the number of iterations to run. If this flag is set to 0, then the "
"tool sets the number of iterations to a default value (i.e. 100)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:119
msgid ""
"If set, the tool assumes that loads and stores don't alias. This is the "
"default behavior."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:124
msgid ""
"Specify the size of the load queue in the load/store unit emulated by the "
"tool. By default, the tool assumes an unbound number of entries in the load "
"queue. A value of zero for this flag is ignored, and the default load queue "
"size is used instead."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:131
msgid ""
"Specify the size of the store queue in the load/store unit emulated by the "
"tool. By default, the tool assumes an unbound number of entries in the store "
"queue. A value of zero for this flag is ignored, and the default store queue "
"size is used instead."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:138
msgid "Enable the timeline view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:142
msgid ""
"Limit the number of iterations to print in the timeline view. By default, "
"the timeline view prints information for up to 10 iterations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:147
msgid ""
"Limit the number of cycles in the timeline view. By default, the number of "
"cycles is set to 80."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:152
msgid "Enable the resource pressure view. This is enabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:156
msgid "Enable register file usage statistics."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:160
msgid ""
"Enable extra dispatch statistics. This view collects and analyzes "
"instruction dispatch events, as well as static/dynamic dispatch stall "
"events. This view is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:166
msgid ""
"Enable extra scheduler statistics. This view collects and analyzes "
"instruction issue events. This view is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:171
msgid ""
"Enable extra retire control unit statistics. This view is disabled by "
"default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:175
msgid "Enable the instruction info view. This is enabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:179
msgid ""
"Enable the printing of instruction encodings within the instruction info "
"view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:183
msgid ""
"Print all hardware statistics. This enables extra statistics related to the "
"dispatch logic, the hardware schedulers, the register file(s), and the "
"retire control unit. This option is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:189
msgid "Enable all the view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:193
msgid ""
"Prints resource pressure information based on the static information "
"available from the processor model. This differs from the resource pressure "
"view because it doesn't require that the code is simulated. It instead "
"prints the theoretical uniform distribution of resource pressure for every "
"instruction in sequence."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:201
msgid ""
"Print information about bottlenecks that affect the throughput. This "
"analysis can be expensive, and it is disabled by default.  Bottlenecks are "
"highlighted in the summary view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:207
msgid "EXIT STATUS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:209
msgid ""
":program:`llvm-mca` returns 0 on success. Otherwise, an error message is "
"printed to standard error, and the tool returns 1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:213
msgid "USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:214
msgid ""
":program:`llvm-mca` allows for the optional usage of special code comments "
"to mark regions of the assembly code to be analyzed.  A comment starting "
"with substring ``LLVM-MCA-BEGIN`` marks the beginning of a code region. A "
"comment starting with substring ``LLVM-MCA-END`` marks the end of a code "
"region.  For example:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:226
msgid ""
"If no user-defined region is specified, then :program:`llvm-mca` assumes a "
"default region which contains every instruction in the input file.  Every "
"region is analyzed in isolation, and the final performance report is the "
"union of all the reports generated for every code region."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:231
msgid "Code regions can have names. For example:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:239
msgid ""
"The code from the example above defines a region named \"A simple example\" "
"with a single instruction in it. Note how the region name doesn't have to be "
"repeated in the ``LLVM-MCA-END`` directive. In the absence of overlapping "
"regions, an anonymous ``LLVM-MCA-END`` directive always ends the currently "
"active user defined region."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:245
msgid "Example of nesting regions:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:256
msgid "Example of overlapping regions:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:268
msgid ""
"Note that multiple anonymous regions cannot overlap. Also, overlapping "
"regions cannot have the same name."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:271
msgid ""
"There is no support for marking regions from high-level source code, like C "
"or C++. As a workaround, inline assembly directives may be used:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:284
msgid ""
"However, this interferes with optimizations like loop vectorization and may "
"have an impact on the code generated. This is because the ``__asm`` "
"statements are seen as real code having important side effects, which limits "
"how the code around them can be transformed. If users want to make use of "
"inline assembly to emit markers, then the recommendation is to always verify "
"that the output assembly is equivalent to the assembly generated in the "
"absence of markers. The `Clang options to emit optimization reports <https://"
"clang.llvm.org/docs/UsersManual.html#options-to-emit-optimization-reports>`_ "
"can also help in detecting missed optimizations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:294
msgid "HOW LLVM-MCA WORKS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:296
msgid ""
":program:`llvm-mca` takes assembly code as input. The assembly code is "
"parsed into a sequence of MCInst with the help of the existing LLVM target "
"assembly parsers. The parsed sequence of MCInst is then analyzed by a "
"``Pipeline`` module to generate a performance report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:301
msgid ""
"The Pipeline module simulates the execution of the machine code sequence in "
"a loop of iterations (default is 100). During this process, the pipeline "
"collects a number of execution related statistics. At the end of this "
"process, the pipeline generates and prints a report from the collected "
"statistics."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:306
msgid ""
"Here is an example of a performance report generated by the tool for a dot-"
"product of two packed float vectors of four elements. The analysis is "
"conducted for target x86, cpu btver2.  The following result can be produced "
"via the following command using the example located at ``test/tools/llvm-mca/"
"X86/BtVer2/dot-product.s``:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:370
msgid ""
"According to this report, the dot-product kernel has been executed 300 "
"times, for a total of 900 simulated instructions. The total number of "
"simulated micro opcodes (uOps) is also 900."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:374
msgid ""
"The report is structured in three main sections.  The first section collects "
"a few performance numbers; the goal of this section is to give a very quick "
"overview of the performance throughput. Important performance indicators are "
"**IPC**, **uOps Per Cycle**, and  **Block RThroughput** (Block Reciprocal "
"Throughput)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:380
msgid ""
"Field *DispatchWidth* is the maximum number of micro opcodes that are "
"dispatched to the out-of-order backend every simulated cycle."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:383
msgid ""
"IPC is computed dividing the total number of simulated instructions by the "
"total number of cycles."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:386
msgid ""
"Field *Block RThroughput* is the reciprocal of the block throughput. Block "
"throuhgput is a theoretical quantity computed as the maximum number of "
"blocks (i.e. iterations) that can be executed per simulated clock cycle in "
"the absence of loop carried dependencies. Block throughput is is superiorly "
"limited by the dispatch rate, and the availability of hardware resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:392
msgid ""
"In the absence of loop-carried data dependencies, the observed IPC tends to "
"a theoretical maximum which can be computed by dividing the number of "
"instructions of a single iteration by the `Block RThroughput`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:396
msgid ""
"Field 'uOps Per Cycle' is computed dividing the total number of simulated "
"micro opcodes by the total number of cycles. A delta between Dispatch Width "
"and this field is an indicator of a performance issue. In the absence of "
"loop-carried data dependencies, the observed 'uOps Per Cycle' should tend to "
"a theoretical maximum throughput which can be computed by dividing the "
"number of uOps of a single iteration by the `Block RThroughput`."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:403
msgid ""
"Field *uOps Per Cycle* is bounded from above by the dispatch width. That is "
"because the dispatch width limits the maximum size of a dispatch group. Both "
"IPC and 'uOps Per Cycle' are limited by the amount of hardware parallelism. "
"The availability of hardware resources affects the resource pressure "
"distribution, and it limits the number of instructions that can be executed "
"in parallel every cycle.  A delta between Dispatch Width and the theoretical "
"maximum uOps per Cycle (computed by dividing the number of uOps of a single "
"iteration by the `Block RThroughput`) is an indicator of a performance "
"bottleneck caused by the lack of hardware resources. In general, the lower "
"the Block RThroughput, the better."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:414
msgid ""
"In this example, ``uOps per iteration/Block RThroughput`` is 1.50. Since "
"there are no loop-carried dependencies, the observed `uOps Per Cycle` is "
"expected to approach 1.50 when the number of iterations tends to infinity. "
"The delta between the Dispatch Width (2.00), and the theoretical maximum uOp "
"throughput (1.50) is an indicator of a performance bottleneck caused by the "
"lack of hardware resources, and the *Resource pressure view* can help to "
"identify the problematic resource usage."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:422
msgid ""
"The second section of the report is the `instruction info view`. It shows "
"the latency and reciprocal throughput of every instruction in the sequence. "
"It also reports extra information related to the number of micro opcodes, "
"and opcode properties (i.e., 'MayLoad', 'MayStore', and 'HasSideEffects')."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:427
msgid ""
"Field *RThroughput* is the reciprocal of the instruction throughput. "
"Throughput is computed as the maximum number of instructions of a same type "
"that can be executed per clock cycle in the absence of operand dependencies. "
"In this example, the reciprocal throughput of a vector float multiply is 1 "
"cycles/instruction.  That is because the FP multiplier JFPM is only "
"available from pipeline JFPU1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:434
msgid ""
"Instruction encodings are displayed within the instruction info view when "
"flag `-show-encoding` is specified."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:437
msgid ""
"Below is an example of `-show-encoding` output for the dot-product kernel:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:455
msgid ""
"The `Encoding Size` column shows the size in bytes of instructions.  The "
"`Encodings` column shows the actual instruction encodings (byte sequences in "
"hex)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:459
msgid ""
"The third section is the *Resource pressure view*.  This view reports the "
"average number of resource cycles consumed every iteration by instructions "
"for every processor resource unit available on the target.  Information is "
"structured in two tables. The first table reports the number of resource "
"cycles spent on average every iteration. The second table correlates the "
"resource cycles to the machine instruction in the sequence. For example, "
"every iteration of the instruction vmulps always executes on resource unit "
"[6] (JFPU1 - floating point pipeline #1), consuming an average of 1 resource "
"cycle per iteration.  Note that on AMD Jaguar, vector floating-point "
"multiply can only be issued to pipeline JFPU1, while horizontal floating-"
"point additions can only be issued to pipeline JFPU0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:471
msgid ""
"The resource pressure view helps with identifying bottlenecks caused by high "
"usage of specific hardware resources.  Situations with resource pressure "
"mainly concentrated on a few resources should, in general, be avoided.  "
"Ideally, pressure should be uniformly distributed between multiple resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:477
msgid "Timeline View"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:478
msgid ""
"The timeline view produces a detailed report of each instruction's state "
"transitions through an instruction pipeline.  This view is enabled by the "
"command line option ``-timeline``.  As instructions transition through the "
"various stages of the pipeline, their states are depicted in the view "
"report. These states are represented by the following characters:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:484
msgid "D : Instruction dispatched."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:485
msgid "e : Instruction executing."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:486
msgid "E : Instruction executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:487
msgid "R : Instruction retired."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:488
msgid "= : Instruction already dispatched, waiting to be executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:489
msgid "\\- : Instruction executed, waiting to be retired."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:491
msgid ""
"Below is the timeline view for a subset of the dot-product example located "
"in ``test/tools/llvm-mca/X86/BtVer2/dot-product.s`` and processed by :"
"program:`llvm-mca` using the following command:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:528
msgid ""
"The timeline view is interesting because it shows instruction state changes "
"during execution.  It also gives an idea of how the tool processes "
"instructions executed on the target, and how their timing information might "
"be calculated."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:532
msgid ""
"The timeline view is structured in two tables.  The first table shows "
"instructions changing state over time (measured in cycles); the second table "
"(named *Average Wait times*) reports useful timing statistics, which should "
"help diagnose performance bottlenecks caused by long data dependencies and "
"sub-optimal usage of hardware resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:538
msgid ""
"An instruction in the timeline view is identified by a pair of indices, "
"where the first index identifies an iteration, and the second index is the "
"instruction index (i.e., where it appears in the code sequence).  Since this "
"example was generated using 3 iterations: ``-iterations=3``, the iteration "
"indices range from 0-2 inclusively."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:544
msgid ""
"Excluding the first and last column, the remaining columns are in cycles. "
"Cycles are numbered sequentially starting from 0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:547
msgid "From the example output above, we know the following:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:549
msgid "Instruction [1,0] was dispatched at cycle 1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:550
msgid "Instruction [1,0] started executing at cycle 2."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:551
msgid "Instruction [1,0] reached the write back stage at cycle 4."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:552
msgid "Instruction [1,0] was retired at cycle 10."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:554
msgid ""
"Instruction [1,0] (i.e., vmulps from iteration #1) does not have to wait in "
"the scheduler's queue for the operands to become available. By the time "
"vmulps is dispatched, operands are already available, and pipeline JFPU1 is "
"ready to serve another instruction.  So the instruction can be immediately "
"issued on the JFPU1 pipeline. That is demonstrated by the fact that the "
"instruction only spent 1cy in the scheduler's queue."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:561
msgid ""
"There is a gap of 5 cycles between the write-back stage and the retire "
"event. That is because instructions must retire in program order, so [1,0] "
"has to wait for [0,2] to be retired first (i.e., it has to wait until cycle "
"10)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:565
msgid ""
"In the example, all instructions are in a RAW (Read After Write) dependency "
"chain.  Register %xmm2 written by vmulps is immediately used by the first "
"vhaddps, and register %xmm3 written by the first vhaddps is used by the "
"second vhaddps.  Long data dependencies negatively impact the ILP "
"(Instruction Level Parallelism)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:571
msgid ""
"In the dot-product example, there are anti-dependencies introduced by "
"instructions from different iterations.  However, those dependencies can be "
"removed at register renaming stage (at the cost of allocating register "
"aliases, and therefore consuming physical registers)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:576
msgid ""
"Table *Average Wait times* helps diagnose performance issues that are caused "
"by the presence of long latency instructions and potentially long data "
"dependencies which may limit the ILP. Last row, ``<total>``, shows a global "
"average over all instructions measured. Note that :program:`llvm-mca`, by "
"default, assumes at least 1cy between the dispatch event and the issue event."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:582
msgid ""
"When the performance is limited by data dependencies and/or long latency "
"instructions, the number of cycles spent while in the *ready* state is "
"expected to be very small when compared with the total number of cycles "
"spent in the scheduler's queue.  The difference between the two counters is "
"a good indicator of how large of an impact data dependencies had on the "
"execution of the instructions.  When performance is mostly limited by the "
"lack of hardware resources, the delta between the two counters is small.  "
"However, the number of cycles spent in the queue tends to be larger (i.e., "
"more than 1-3cy), especially when compared to other low latency instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:593
msgid "Bottleneck Analysis"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:594
msgid ""
"The ``-bottleneck-analysis`` command line option enables the analysis of "
"performance bottlenecks."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:597
msgid ""
"This analysis is potentially expensive. It attempts to correlate increases "
"in backend pressure (caused by pipeline resource pressure and data "
"dependencies) to dynamic dispatch stalls."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:601
msgid ""
"Below is an example of ``-bottleneck-analysis`` output generated by :program:"
"`llvm-mca` for 500 iterations of the dot-product example on btver2."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:632
msgid ""
"According to the analysis, throughput is limited by resource pressure and "
"not by data dependencies.  The analysis observed increases in backend "
"pressure during 48.07% of the simulated run. Almost all those pressure "
"increase events were caused by contention on processor resources JFPA/JFPU0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:637
msgid ""
"The `critical sequence` is the most expensive sequence of instructions "
"according to the simulation. It is annotated to provide extra information "
"about critical register dependencies and resource interferences between "
"instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:641
msgid ""
"Instructions from the critical sequence are expected to significantly impact "
"performance. By construction, the accuracy of this analysis is strongly "
"dependent on the simulation and (as always) by the quality of the processor "
"model in llvm."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:648
msgid "Extra Statistics to Further Diagnose Performance Issues"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:649
msgid ""
"The ``-all-stats`` command line option enables extra statistics and "
"performance counters for the dispatch logic, the reorder buffer, the retire "
"control unit, and the register file."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:653
msgid ""
"Below is an example of ``-all-stats`` output generated by  :program:`llvm-"
"mca` for 300 iterations of the dot-product example discussed in the previous "
"sections."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:718
msgid ""
"If we look at the *Dynamic Dispatch Stall Cycles* table, we see the counter "
"for SCHEDQ reports 272 cycles.  This counter is incremented every time the "
"dispatch logic is unable to dispatch a full group because the scheduler's "
"queue is full."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:722
msgid ""
"Looking at the *Dispatch Logic* table, we see that the pipeline was only "
"able to dispatch two micro opcodes 51.5% of the time.  The dispatch group "
"was limited to one micro opcode 44.6% of the cycles, which corresponds to "
"272 cycles.  The dispatch statistics are displayed by either using the "
"command option ``-all-stats`` or ``-dispatch-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:728
msgid ""
"The next table, *Schedulers*, presents a histogram displaying a count, "
"representing the number of micro opcodes issued on some number of cycles. In "
"this case, of the 610 simulated cycles, single opcodes were issued 306 times "
"(50.2%) and there were 7 cycles where no opcodes were issued."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:733
msgid ""
"The *Scheduler's queue usage* table shows that the average and maximum "
"number of buffer entries (i.e., scheduler queue entries) used at runtime.  "
"Resource JFPU01 reached its maximum (18 of 18 queue entries). Note that AMD "
"Jaguar implements three schedulers:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:738
msgid "JALU01 - A scheduler for ALU instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:739
msgid "JFPU01 - A scheduler floating point operations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:740
msgid "JLSAGU - A scheduler for address generation."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:742
msgid ""
"The dot-product is a kernel of three floating point instructions (a vector "
"multiply followed by two horizontal adds).  That explains why only the "
"floating point scheduler appears to be used."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:746
msgid ""
"A full scheduler queue is either caused by data dependency chains or by a "
"sub-optimal usage of hardware resources.  Sometimes, resource pressure can "
"be mitigated by rewriting the kernel using different instructions that "
"consume different scheduler resources.  Schedulers with a small queue are "
"less resilient to bottlenecks caused by the presence of long data "
"dependencies.  The scheduler statistics are displayed by using the command "
"option ``-all-stats`` or ``-scheduler-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:754
msgid ""
"The next table, *Retire Control Unit*, presents a histogram displaying a "
"count, representing the number of instructions retired on some number of "
"cycles.  In this case, of the 610 simulated cycles, two instructions were "
"retired during the same cycle 399 times (65.4%) and there were 109 cycles "
"where no instructions were retired.  The retire statistics are displayed by "
"using the command option ``-all-stats`` or ``-retire-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:761
msgid ""
"The last table presented is *Register File statistics*.  Each physical "
"register file (PRF) used by the pipeline is presented in this table.  In the "
"case of AMD Jaguar, there are two register files, one for floating-point "
"registers (JFpuPRF) and one for integer registers (JIntegerPRF).  The table "
"shows that of the 900 instructions processed, there were 900 mappings "
"created.  Since this dot-product example utilized only floating point "
"registers, the JFPuPRF was responsible for creating the 900 mappings.  "
"However, we see that the pipeline only used a maximum of 35 of 72 available "
"register slots at any given time. We can conclude that the floating point "
"PRF was the only register file used for the example, and that it was never "
"resource constrained.  The register file statistics are displayed by using "
"the command option ``-all-stats`` or ``-register-file-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:774
msgid ""
"In this example, we can conclude that the IPC is mostly limited by data "
"dependencies, and not by resource pressure."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:778
msgid "Instruction Flow"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:779
msgid ""
"This section describes the instruction flow through the default pipeline of :"
"program:`llvm-mca`, as well as the functional units involved in the process."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:782
msgid ""
"The default pipeline implements the following sequence of stages used to "
"process instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:785
msgid "Dispatch (Instruction is dispatched to the schedulers)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:786
msgid "Issue (Instruction is issued to the processor pipelines)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:787
msgid "Write Back (Instruction is executed, and results are written back)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:788
msgid "Retire (Instruction is retired; writes are architecturally committed)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:790
msgid ""
"The default pipeline only models the out-of-order portion of a processor. "
"Therefore, the instruction fetch and decode stages are not modeled. "
"Performance bottlenecks in the frontend are not diagnosed. :program:`llvm-"
"mca` assumes that instructions have all been decoded and placed into a queue "
"before the simulation start.  Also, :program:`llvm-mca` does not model "
"branch prediction."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:797
msgid "Instruction Dispatch"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:798
msgid ""
"During the dispatch stage, instructions are picked in program order from a "
"queue of already decoded instructions, and dispatched in groups to the "
"simulated hardware schedulers."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:802
msgid ""
"The size of a dispatch group depends on the availability of the simulated "
"hardware resources.  The processor dispatch width defaults to the value of "
"the ``IssueWidth`` in LLVM's scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:806
msgid "An instruction can be dispatched if:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:808
msgid ""
"The size of the dispatch group is smaller than processor's dispatch width."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:809
msgid "There are enough entries in the reorder buffer."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:810
msgid "There are enough physical registers to do register renaming."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:811
msgid "The schedulers are not full."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:813
msgid ""
"Scheduling models can optionally specify which register files are available "
"on the processor. :program:`llvm-mca` uses that information to initialize "
"register file descriptors.  Users can limit the number of physical registers "
"that are globally available for register renaming by using the command "
"option ``-register-file-size``.  A value of zero for this option means "
"*unbounded*. By knowing how many registers are available for renaming, the "
"tool can predict dispatch stalls caused by the lack of physical registers."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:821
msgid ""
"The number of reorder buffer entries consumed by an instruction depends on "
"the number of micro-opcodes specified for that instruction by the target "
"scheduling model.  The reorder buffer is responsible for tracking the "
"progress of instructions that are \"in-flight\", and retiring them in "
"program order.  The number of entries in the reorder buffer defaults to the "
"value specified by field `MicroOpBufferSize` in the target scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:828
msgid ""
"Instructions that are dispatched to the schedulers consume scheduler buffer "
"entries. :program:`llvm-mca` queries the scheduling model to determine the "
"set of buffered resources consumed by an instruction.  Buffered resources "
"are treated like scheduler resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:834
msgid "Instruction Issue"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:835
msgid ""
"Each processor scheduler implements a buffer of instructions.  An "
"instruction has to wait in the scheduler's buffer until input register "
"operands become available.  Only at that point, does the instruction becomes "
"eligible for execution and may be issued (potentially out-of-order) for "
"execution. Instruction latencies are computed by :program:`llvm-mca` with "
"the help of the scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:842
msgid ""
":program:`llvm-mca`'s scheduler is designed to simulate multiple processor "
"schedulers.  The scheduler is responsible for tracking data dependencies, "
"and dynamically selecting which processor resources are consumed by "
"instructions. It delegates the management of processor resource units and "
"resource groups to a resource manager.  The resource manager is responsible "
"for selecting resource units that are consumed by instructions.  For "
"example, if an instruction consumes 1cy of a resource group, the resource "
"manager selects one of the available units from the group; by default, the "
"resource manager uses a round-robin selector to guarantee that resource "
"usage is uniformly distributed between all units of a group."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:853
msgid ""
":program:`llvm-mca`'s scheduler internally groups instructions into three "
"sets:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:855
msgid "WaitSet: a set of instructions whose operands are not ready."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:856
msgid "ReadySet: a set of instructions ready to execute."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:857
msgid "IssuedSet: a set of instructions executing."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:859
msgid ""
"Depending on the operands availability, instructions that are dispatched to "
"the scheduler are either placed into the WaitSet or into the ReadySet."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:862
msgid ""
"Every cycle, the scheduler checks if instructions can be moved from the "
"WaitSet to the ReadySet, and if instructions from the ReadySet can be issued "
"to the underlying pipelines. The algorithm prioritizes older instructions "
"over younger instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:868
msgid "Write-Back and Retire Stage"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:869
msgid ""
"Issued instructions are moved from the ReadySet to the IssuedSet.  There, "
"instructions wait until they reach the write-back stage.  At that point, "
"they get removed from the queue and the retire control unit is notified."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:873
msgid ""
"When instructions are executed, the retire control unit flags the "
"instruction as \"ready to retire.\""
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:876
msgid ""
"Instructions are retired in program order.  The register file is notified of "
"the retirement so that it can free the physical registers that were "
"allocated for the instruction during the register renaming stage."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:881
msgid "Load/Store Unit and Memory Consistency Model"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:882
msgid ""
"To simulate an out-of-order execution of memory operations, :program:`llvm-"
"mca` utilizes a simulated load/store unit (LSUnit) to simulate the "
"speculative execution of loads and stores."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:886
msgid ""
"Each load (or store) consumes an entry in the load (or store) queue. Users "
"can specify flags ``-lqueue`` and ``-squeue`` to limit the number of entries "
"in the load and store queues respectively. The queues are unbounded by "
"default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:890
msgid ""
"The LSUnit implements a relaxed consistency model for memory loads and "
"stores. The rules are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:893
msgid ""
"A younger load is allowed to pass an older load only if there are no "
"intervening stores or barriers between the two loads."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:895
msgid ""
"A younger load is allowed to pass an older store provided that the load does "
"not alias with the store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:897
msgid "A younger store is not allowed to pass an older store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:898
msgid "A younger store is not allowed to pass an older load."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:900
msgid ""
"By default, the LSUnit optimistically assumes that loads do not alias (`-"
"noalias=true`) store operations.  Under this assumption, younger loads are "
"always allowed to pass older stores.  Essentially, the LSUnit does not "
"attempt to run any alias analysis to predict when loads and stores do not "
"alias with each other."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:906
msgid ""
"Note that, in the case of write-combining memory, rule 3 could be relaxed to "
"allow reordering of non-aliasing store operations.  That being said, at the "
"moment, there is no way to further relax the memory model (``-noalias`` is "
"the only option).  Essentially, there is no option to specify a different "
"memory type (e.g., write-back, write-combining, write-through; etc.) and "
"consequently to weaken, or strengthen, the memory model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:913
msgid "Other limitations are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:915
msgid "The LSUnit does not know when store-to-load forwarding may occur."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:916
msgid ""
"The LSUnit does not know anything about cache hierarchy and memory types."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:917
msgid ""
"The LSUnit does not know how to identify serializing operations and memory "
"fences."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:920
msgid ""
"The LSUnit does not attempt to predict if a load or store hits or misses the "
"L1 cache.  It only knows if an instruction \"MayLoad\" and/or \"MayStore.\"  "
"For loads, the scheduling model provides an \"optimistic\" load-to-use "
"latency (which usually matches the load-to-use latency for when there is a "
"hit in the L1D)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:925
msgid ""
":program:`llvm-mca` does not know about serializing operations or memory-"
"barrier like instructions.  The LSUnit conservatively assumes that an "
"instruction which has both \"MayLoad\" and unmodeled side effects behaves "
"like a \"soft\" load-barrier.  That means, it serializes loads without "
"forcing a flush of the load queue.  Similarly, instructions that "
"\"MayStore\" and have unmodeled side effects are treated like store "
"barriers.  A full memory barrier is a \"MayLoad\" and \"MayStore\" "
"instruction with unmodeled side effects.  This is inaccurate, but it is the "
"best that we can do at the moment with the current information available in "
"LLVM."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:935
msgid ""
"A load/store barrier consumes one entry of the load/store queue.  A load/"
"store barrier enforces ordering of loads/stores.  A younger load cannot pass "
"a load barrier.  Also, a younger store cannot pass a store barrier.  A "
"younger load has to wait for the memory/load barrier to execute.  A load/"
"store barrier is \"executed\" when it becomes the oldest entry in the load/"
"store queue(s). That also means, by construction, all of the older loads/"
"stores have been executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:942
msgid "In conclusion, the full set of load/store consistency rules are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:944
msgid "A store may not pass a previous store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:945
msgid "A store may not pass a previous load (regardless of ``-noalias``)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:946
msgid "A store has to wait until an older store barrier is fully executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:947
msgid "A load may pass a previous load."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:948
msgid "A load may not pass a previous store unless ``-noalias`` is set."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:949
msgid "A load has to wait until an older load barrier is fully executed."
msgstr ""
