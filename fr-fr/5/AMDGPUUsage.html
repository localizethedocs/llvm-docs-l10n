
<!DOCTYPE html>

<html lang="fr-FR" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>User Guide for AMDGPU Backend &#8212; Documentation LLVM 5</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=4c4af0c1" />
    <script src="_static/documentation_options.js?v=3f3de610"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=aa914e54"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/llvm-docs-l10n/AMDGPUUsage.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="Stack maps and patch points in LLVM" href="StackMaps.html" />
    <link rel="prev" title="User Guide for NVPTX Back-end" href="NVPTXUsage.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="StackMaps.html" title="Stack maps and patch points in LLVM"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="NVPTXUsage.html" title="User Guide for NVPTX Back-end"
             accesskey="P">précédent</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">User Guide for AMDGPU Backend</a></li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="user-guide-for-amdgpu-backend">
<h1>User Guide for AMDGPU Backend<a class="headerlink" href="#user-guide-for-amdgpu-backend" title="Lien vers cette rubrique">¶</a></h1>
<nav class="contents local" id="sommaire">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id37">Introduction</a></p></li>
<li><p><a class="reference internal" href="#llvm" id="id38">LLVM</a></p>
<ul>
<li><p><a class="reference internal" href="#target-triples" id="id39">Target Triples</a></p></li>
<li><p><a class="reference internal" href="#processors" id="id40">Processors</a></p></li>
<li><p><a class="reference internal" href="#address-spaces" id="id41">Address Spaces</a></p></li>
<li><p><a class="reference internal" href="#memory-scopes" id="id42">Memory Scopes</a></p></li>
<li><p><a class="reference internal" href="#amdgpu-intrinsics" id="id43">AMDGPU Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-object" id="id44">Code Object</a></p>
<ul>
<li><p><a class="reference internal" href="#header" id="id45">Header</a></p></li>
<li><p><a class="reference internal" href="#sections" id="id46">Sections</a></p></li>
<li><p><a class="reference internal" href="#note-records" id="id47">Note Records</a></p></li>
<li><p><a class="reference internal" href="#code-object-metadata" id="id48">Code Object Metadata</a></p></li>
<li><p><a class="reference internal" href="#symbols" id="id49">Symbols</a></p></li>
<li><p><a class="reference internal" href="#relocation-records" id="id50">Relocation Records</a></p></li>
<li><p><a class="reference internal" href="#dwarf" id="id51">DWARF</a></p>
<ul>
<li><p><a class="reference internal" href="#address-space-mapping" id="id52">Address Space Mapping</a></p></li>
<li><p><a class="reference internal" href="#register-mapping" id="id53">Register Mapping</a></p></li>
<li><p><a class="reference internal" href="#source-text" id="id54">Source Text</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-conventions" id="id55">Code Conventions</a></p>
<ul>
<li><p><a class="reference internal" href="#amdhsa" id="id56">AMDHSA</a></p>
<ul>
<li><p><a class="reference internal" href="#kernel-dispatch" id="id57">Kernel Dispatch</a></p></li>
<li><p><a class="reference internal" href="#memory-spaces" id="id58">Memory Spaces</a></p></li>
<li><p><a class="reference internal" href="#hsa-image-and-samplers" id="id59">HSA Image and Samplers</a></p></li>
<li><p><a class="reference internal" href="#hsa-signals" id="id60">HSA Signals</a></p></li>
<li><p><a class="reference internal" href="#hsa-aql-queue" id="id61">HSA AQL Queue</a></p></li>
<li><p><a class="reference internal" href="#kernel-descriptor" id="id62">Kernel Descriptor</a></p>
<ul>
<li><p><a class="reference internal" href="#kernel-descriptor-for-gfx6-gfx9" id="id63">Kernel Descriptor for GFX6-GFX9</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#initial-kernel-execution-state" id="id64">Initial Kernel Execution State</a></p></li>
<li><p><a class="reference internal" href="#kernel-prolog" id="id65">Kernel Prolog</a></p>
<ul>
<li><p><a class="reference internal" href="#m0" id="id66">M0</a></p></li>
<li><p><a class="reference internal" href="#flat-scratch" id="id67">Flat Scratch</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#memory-model" id="id68">Memory Model</a></p></li>
<li><p><a class="reference internal" href="#trap-handler-abi" id="id69">Trap Handler ABI</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#non-amdhsa" id="id70">Non-AMDHSA</a></p>
<ul>
<li><p><a class="reference internal" href="#id31" id="id71">Trap Handler ABI</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#source-languages" id="id72">Source Languages</a></p>
<ul>
<li><p><a class="reference internal" href="#opencl" id="id73">OpenCL</a></p></li>
<li><p><a class="reference internal" href="#hcc" id="id74">HCC</a></p></li>
<li><p><a class="reference internal" href="#assembler" id="id75">Assembler</a></p>
<ul>
<li><p><a class="reference internal" href="#operands" id="id76">Operands</a></p></li>
<li><p><a class="reference internal" href="#instruction-examples" id="id77">Instruction Examples</a></p></li>
<li><p><a class="reference internal" href="#ds" id="id78">DS</a></p>
<ul>
<li><p><a class="reference internal" href="#flat" id="id79">FLAT</a></p></li>
<li><p><a class="reference internal" href="#mubuf" id="id80">MUBUF</a></p></li>
<li><p><a class="reference internal" href="#smrd-smem" id="id81">SMRD/SMEM</a></p></li>
<li><p><a class="reference internal" href="#sop1" id="id82">SOP1</a></p></li>
<li><p><a class="reference internal" href="#sop2" id="id83">SOP2</a></p></li>
<li><p><a class="reference internal" href="#sopc" id="id84">SOPC</a></p></li>
<li><p><a class="reference internal" href="#sopp" id="id85">SOPP</a></p></li>
<li><p><a class="reference internal" href="#valu" id="id86">VALU</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#hsa-code-object-directives" id="id87">HSA Code Object Directives</a></p>
<ul>
<li><p><a class="reference internal" href="#hsa-code-object-version-major-minor" id="id88">.hsa_code_object_version major, minor</a></p></li>
<li><p><a class="reference internal" href="#hsa-code-object-isa-major-minor-stepping-vendor-arch" id="id89">.hsa_code_object_isa [major, minor, stepping, vendor, arch]</a></p></li>
<li><p><a class="reference internal" href="#amdgpu-hsa-kernel-name" id="id90">.amdgpu_hsa_kernel (name)</a></p></li>
<li><p><a class="reference internal" href="#amd-kernel-code-t" id="id91">.amd_kernel_code_t</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#additional-documentation" id="id92">Additional Documentation</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Lien vers cette rubrique">¶</a></h2>
<p>The AMDGPU backend provides ISA code generation for AMD GPUs, starting with the
R600 family up until the current GCN families. It lives in the
<code class="docutils literal notranslate"><span class="pre">lib/Target/AMDGPU</span></code> directory.</p>
</section>
<section id="llvm">
<h2><a class="toc-backref" href="#id38" role="doc-backlink">LLVM</a><a class="headerlink" href="#llvm" title="Lien vers cette rubrique">¶</a></h2>
<section id="target-triples">
<span id="amdgpu-target-triples"></span><h3><a class="toc-backref" href="#id39" role="doc-backlink">Target Triples</a><a class="headerlink" href="#target-triples" title="Lien vers cette rubrique">¶</a></h3>
<p>Use the <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-target</span> <span class="pre">&lt;Architecture&gt;-&lt;Vendor&gt;-&lt;OS&gt;-&lt;Environment&gt;</span></code> option to
specify the target triple:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-target-triples-table">
<caption><span class="caption-text">AMDGPU Target Triples</span><a class="headerlink" href="#amdgpu-target-triples-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Architecture</p></th>
<th class="head"><p>Vendor</p></th>
<th class="head"><p>OS</p></th>
<th class="head"><p>Environment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>r600</p></td>
<td><p>amd</p></td>
<td><p>&lt;empty&gt;</p></td>
<td><p>&lt;empty&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>amdgcn</p></td>
<td><p>amd</p></td>
<td><p>&lt;empty&gt;</p></td>
<td><p>&lt;empty&gt;</p></td>
</tr>
<tr class="row-even"><td><p>amdgcn</p></td>
<td><p>amd</p></td>
<td><p>amdhsa</p></td>
<td><p>&lt;empty&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>amdgcn</p></td>
<td><p>amd</p></td>
<td><p>amdhsa</p></td>
<td><p>opencl</p></td>
</tr>
<tr class="row-even"><td><p>amdgcn</p></td>
<td><p>amd</p></td>
<td><p>amdhsa</p></td>
<td><p>amdgizcl</p></td>
</tr>
<tr class="row-odd"><td><p>amdgcn</p></td>
<td><p>amd</p></td>
<td><p>amdhsa</p></td>
<td><p>amdgiz</p></td>
</tr>
<tr class="row-even"><td><p>amdgcn</p></td>
<td><p>amd</p></td>
<td><p>amdhsa</p></td>
<td><p>hcc</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">r600-amd--</span></code></dt><dd><p>Supports AMD GPUs HD2XXX-HD6XXX for graphics and compute shaders executed on
the MESA runtime.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">amdgcn-amd--</span></code></dt><dd><p>Supports AMD GPUs GCN 6 onwards for graphics and compute shaders executed on
the MESA runtime.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa-</span></code></dt><dd><p>Supports AMD GCN GPUs GFX6 onwards for compute kernels executed on HSA <a class="reference internal" href="#hsa" id="id1"><span>[HSA]</span></a>
compatible runtimes such as AMD’s ROCm <a class="reference internal" href="#amd-rocm" id="id2"><span>[AMD-ROCm]</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa-opencl</span></code></dt><dd><p>Supports AMD GCN GPUs GFX6 onwards for OpenCL compute kernels executed on HSA
<a class="reference internal" href="#hsa" id="id3"><span>[HSA]</span></a> compatible runtimes such as AMD’s ROCm <a class="reference internal" href="#amd-rocm" id="id4"><span>[AMD-ROCm]</span></a>. See
<a class="reference internal" href="#amdgpu-opencl"><span class="std std-ref">OpenCL</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa-amdgizcl</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa-opencl</span></code> except a different address space mapping
is used (see <a class="reference internal" href="#amdgpu-address-spaces"><span class="std std-ref">Address Spaces</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa-amdgiz</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa-</span></code> except a different address space mapping is
used (see <a class="reference internal" href="#amdgpu-address-spaces"><span class="std std-ref">Address Spaces</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa-hcc</span></code></dt><dd><p>Supports AMD GCN GPUs GFX6 onwards for AMD HC language compute kernels
executed on HSA <a class="reference internal" href="#hsa" id="id5"><span>[HSA]</span></a> compatible runtimes such as AMD’s ROCm <a class="reference internal" href="#amd-rocm" id="id6"><span>[AMD-ROCm]</span></a>. See
<a class="reference internal" href="#amdgpu-hcc"><span class="std std-ref">HCC</span></a>.</p>
</dd>
</dl>
</section>
<section id="processors">
<span id="amdgpu-processors"></span><h3><a class="toc-backref" href="#id40" role="doc-backlink">Processors</a><a class="headerlink" href="#processors" title="Lien vers cette rubrique">¶</a></h3>
<p>Use the <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-mcpu</span> <span class="pre">&lt;Processor&gt;</span></code> option to specify the AMD GPU processor. The
names from both the <em>Processor</em> and <em>Alternative Processor</em> can be used.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-processors-table">
<caption><span class="caption-text">AMDGPU Processors</span><a class="headerlink" href="#amdgpu-processors-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Processor</p></th>
<th class="head"><p>Alternative
Processor</p></th>
<th class="head"><p>Target
Triple
Architecture</p></th>
<th class="head"><p>dGPU/
APU</p></th>
<th class="head"><p>Runtime
Support</p></th>
<th class="head"><p>Example
Products</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="6"><p><strong>R600</strong> <a class="reference internal" href="#amd-r6xx" id="id7"><span>[AMD-R6xx]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>r600</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>r630</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>rs880</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>rv670</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="6"><p><strong>R700</strong> <a class="reference internal" href="#amd-r7xx" id="id8"><span>[AMD-R7xx]</span></a></p></td>
</tr>
<tr class="row-even"><td><p>rv710</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>rv730</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>rv770</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="6"><p><strong>Evergreen</strong> <a class="reference internal" href="#amd-evergreen" id="id9"><span>[AMD-Evergreen]</span></a></p></td>
</tr>
<tr class="row-even"><td><p>cedar</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>redwood</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>sumo</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>juniper</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>cypress</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="6"><p><strong>Northern Islands</strong> <a class="reference internal" href="#amd-cayman-trinity" id="id10"><span>[AMD-Cayman-Trinity]</span></a></p></td>
</tr>
<tr class="row-even"><td><p>barts</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>turks</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>caicos</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>cayman</p></td>
<td></td>
<td><p>r600</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td colspan="6"><p><strong>GCN GFX6 (Southern Islands (SI))</strong> <a class="reference internal" href="#amd-souther-islands" id="id11"><span>[AMD-Souther-Islands]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>gfx600</p></td>
<td><ul class="simple">
<li><p>SI</p></li>
<li><p>tahiti</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>gfx601</p></td>
<td><ul class="simple">
<li><p>pitcairn</p></li>
<li><p>verde</p></li>
<li><p>oland</p></li>
<li><p>hainan</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="6"><p><strong>GCN GFX7 (Sea Islands (CI))</strong> <a class="reference internal" href="#amd-sea-islands" id="id12"><span>[AMD-Sea-Islands]</span></a></p></td>
</tr>
<tr class="row-even"><td><p>gfx700</p></td>
<td><ul class="simple">
<li><p>bonaire</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Radeon HD 7790</p></li>
<li><p>Radeon HD 8770</p></li>
<li><p>R7 260</p></li>
<li><p>R7 260X</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><ul class="simple">
<li><p>kaveri</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>A6-7000</p></li>
<li><p>A6 Pro-7050B</p></li>
<li><p>A8-7100</p></li>
<li><p>A8 Pro-7150B</p></li>
<li><p>A10-7300</p></li>
<li><p>A10 Pro-7350B</p></li>
<li><p>FX-7500</p></li>
<li><p>A8-7200P</p></li>
<li><p>A10-7400P</p></li>
<li><p>FX-7600P</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>gfx701</p></td>
<td><ul class="simple">
<li><p>hawaii</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td><p>ROCm</p></td>
<td><ul class="simple">
<li><p>FirePro W8100</p></li>
<li><p>FirePro W9100</p></li>
<li><p>FirePro S9150</p></li>
<li><p>FirePro S9170</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>gfx702</p></td>
<td></td>
<td></td>
<td><p>dGPU</p></td>
<td><p>ROCm</p></td>
<td><ul class="simple">
<li><p>Radeon R9 290</p></li>
<li><p>Radeon R9 290x</p></li>
<li><p>Radeon R390</p></li>
<li><p>Radeon R390x</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>gfx703</p></td>
<td><ul class="simple">
<li><p>kabini</p></li>
<li><p>mullins</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>E1-2100</p></li>
<li><p>E1-2200</p></li>
<li><p>E1-2500</p></li>
<li><p>E2-3000</p></li>
<li><p>E2-3800</p></li>
<li><p>A4-5000</p></li>
<li><p>A4-5100</p></li>
<li><p>A6-5200</p></li>
<li><p>A4 Pro-3340B</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td colspan="6"><p><strong>GCN GFX8 (Volcanic Islands (VI))</strong> <a class="reference internal" href="#amd-volcanic-islands" id="id13"><span>[AMD-Volcanic-Islands]</span></a></p></td>
</tr>
<tr class="row-even"><td><p>gfx800</p></td>
<td><ul class="simple">
<li><p>iceland</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>FirePro S7150</p></li>
<li><p>FirePro S7100</p></li>
<li><p>FirePro W7100</p></li>
<li><p>Radeon R285</p></li>
<li><p>Radeon R9 380</p></li>
<li><p>Radeon R9 385</p></li>
<li><p>Mobile FirePro
M7170</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>gfx801</p></td>
<td><ul class="simple">
<li><p>carrizo</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>A6-8500P</p></li>
<li><p>Pro A6-8500B</p></li>
<li><p>A8-8600P</p></li>
<li><p>Pro A8-8600B</p></li>
<li><p>FX-8800P</p></li>
<li><p>Pro A12-8800B</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p></p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td><p>ROCm</p></td>
<td><ul class="simple">
<li><p>A10-8700P</p></li>
<li><p>Pro A10-8700B</p></li>
<li><p>A10-8780P</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>A10-9600P</p></li>
<li><p>A10-9630P</p></li>
<li><p>A12-9700P</p></li>
<li><p>A12-9730P</p></li>
<li><p>FX-9800P</p></li>
<li><p>FX-9830P</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p></p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>E2-9010</p></li>
<li><p>A6-9210</p></li>
<li><p>A9-9410</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>gfx802</p></td>
<td><ul class="simple">
<li><p>tonga</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td><p>ROCm</p></td>
<td><p>Same as gfx800</p></td>
</tr>
<tr class="row-even"><td><p>gfx803</p></td>
<td><ul class="simple">
<li><p>fiji</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td><p>ROCm</p></td>
<td><ul class="simple">
<li><p>Radeon R9 Nano</p></li>
<li><p>Radeon R9 Fury</p></li>
<li><p>Radeon R9 FuryX</p></li>
<li><p>Radeon Pro Duo</p></li>
<li><p>FirePro S9300x2</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><ul class="simple">
<li><p>polaris10</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td><p>ROCm</p></td>
<td><ul class="simple">
<li><p>Radeon RX 470</p></li>
<li><p>Radeon RX 480</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><ul class="simple">
<li><p>polaris11</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td><p>ROCm</p></td>
<td><ul class="simple">
<li><p>Radeon RX 460</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>gfx804</p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td></td>
<td><p>Same as gfx803</p></td>
</tr>
<tr class="row-even"><td><p>gfx810</p></td>
<td><ul class="simple">
<li><p>stoney</p></li>
</ul>
</td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="6"><p><strong>GCN GFX9</strong></p></td>
</tr>
<tr class="row-even"><td><p>gfx900</p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Radeon Vega Frontier Edition</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>gfx901</p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>dGPU</p></td>
<td><p>ROCm</p></td>
<td><p>Same as gfx900
except XNACK is
enabled</p></td>
</tr>
<tr class="row-even"><td><p>gfx902</p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td><p>gfx903</p></td>
<td></td>
<td><p>amdgcn</p></td>
<td><p>APU</p></td>
<td></td>
<td><p>Same as gfx902
except XNACK is
enabled</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="address-spaces">
<span id="amdgpu-address-spaces"></span><h3><a class="toc-backref" href="#id41" role="doc-backlink">Address Spaces</a><a class="headerlink" href="#address-spaces" title="Lien vers cette rubrique">¶</a></h3>
<p>The AMDGPU backend uses the following address space mappings.</p>
<p>The memory space names used in the table, aside from the region memory space, is
from the OpenCL standard.</p>
<p>LLVM Address Space number is used throughout LLVM (for example, in LLVM IR).</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-address-space-mapping-table">
<caption><span class="caption-text">Address Space Mapping</span><a class="headerlink" href="#amdgpu-address-space-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Address Space</p></th>
<th class="head" colspan="4"><p>Memory Space</p></th>
</tr>
<tr class="row-even"><th class="head"><p></p></th>
<th class="head"><p>Current Default</p></th>
<th class="head"><p>amdgiz/amdgizcl</p></th>
<th class="head"><p>hcc</p></th>
<th class="head"><p>Future Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>Private (Scratch)</p></td>
<td><p>Generic (Flat)</p></td>
<td><p>Generic (Flat)</p></td>
<td><p>Generic (Flat)</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>Global</p></td>
<td><p>Global</p></td>
<td><p>Global</p></td>
<td><p>Global</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Constant</p></td>
<td><p>Constant</p></td>
<td><p>Constant</p></td>
<td><p>Region (GDS)</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Local (group/LDS)</p></td>
<td><p>Local (group/LDS)</p></td>
<td><p>Local (group/LDS)</p></td>
<td><p>Local (group/LDS)</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Generic (Flat)</p></td>
<td><p>Region (GDS)</p></td>
<td><p>Region (GDS)</p></td>
<td><p>Constant</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Region (GDS)</p></td>
<td><p>Private (Scratch)</p></td>
<td><p>Private (Scratch)</p></td>
<td><p>Private (Scratch)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="simple">
<dt>Current Default</dt><dd><p>This is the current default address space mapping used for all languages
except hcc. This will shortly be deprecated.</p>
</dd>
<dt>amdgiz/amdgizcl</dt><dd><p>This is the current address space mapping used when <code class="docutils literal notranslate"><span class="pre">amdgiz</span></code> or <code class="docutils literal notranslate"><span class="pre">amdgizcl</span></code>
is specified as the target triple environment value.</p>
</dd>
<dt>hcc</dt><dd><p>This is the current address space mapping used when <code class="docutils literal notranslate"><span class="pre">hcc</span></code> is specified as
the target triple environment value.This will shortly be deprecated.</p>
</dd>
<dt>Future Default</dt><dd><p>This will shortly be the only address space mapping for all languages using
AMDGPU backend.</p>
</dd>
</dl>
</section>
<section id="memory-scopes">
<span id="amdgpu-memory-scopes"></span><h3><a class="toc-backref" href="#id42" role="doc-backlink">Memory Scopes</a><a class="headerlink" href="#memory-scopes" title="Lien vers cette rubrique">¶</a></h3>
<p>This section provides LLVM memory synchronization scopes supported by the AMDGPU
backend memory model when the target triple OS is <code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see
<a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a> and <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<p>The memory model supported is based on the HSA memory model <a class="reference internal" href="#hsa" id="id14"><span>[HSA]</span></a> which is
based in turn on HRF-indirect with scope inclusion <a class="reference internal" href="#hrf" id="id15"><span>[HRF]</span></a>. The happens-before
relation is transitive over the synchonizes-with relation independent of scope,
and synchonizes-with allows the memory scope instances to be inclusive (see
table <a class="reference internal" href="#amdgpu-amdhsa-llvm-sync-scopes-amdhsa-table"><span class="std std-ref">AMDHSA LLVM Sync Scopes for AMDHSA</span></a>).</p>
<p>This is different to the OpenCL <a class="reference internal" href="#id36" id="id16"><span>[OpenCL]</span></a> memory model which does not have scope
inclusion and requires the memory scopes to exactly match. However, this
is conservatively correct for OpenCL.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-llvm-sync-scopes-amdhsa-table">
<caption><span class="caption-text">AMDHSA LLVM Sync Scopes for AMDHSA</span><a class="headerlink" href="#amdgpu-amdhsa-llvm-sync-scopes-amdhsa-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Sync Scope</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>none</em></p></td>
<td><p>The default: <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
<p>Synchronizes with, and participates in modification and
seq_cst total orderings with, other operations (except
image operations) for all address spaces (except private,
or generic that accesses private) provided the other
operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">agent</span></code> and executed by a thread on the same agent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code> and executed by a thread in the same
workgroup.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code> and executed by a thread in the same
wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">agent</span></code></p></td>
<td><p>Synchronizes with, and participates in modification and
seq_cst total orderings with, other operations (except
image operations) for all address spaces (except private,
or generic that accesses private) provided the other
operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code> or <code class="docutils literal notranslate"><span class="pre">agent</span></code> and executed by a thread on the
same agent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code> and executed by a thread in the same
workgroup.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code> and executed by a thread in the same
wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code></p></td>
<td><p>Synchronizes with, and participates in modification and
seq_cst total orderings with, other operations (except
image operations) for all address spaces (except private,
or generic that accesses private) provided the other
operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code>, <code class="docutils literal notranslate"><span class="pre">agent</span></code> or <code class="docutils literal notranslate"><span class="pre">workgroup</span></code> and executed by a
thread in the same workgroup.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code> and executed by a thread in the same
wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code></p></td>
<td><p>Synchronizes with, and participates in modification and
seq_cst total orderings with, other operations (except
image operations) for all address spaces (except private,
or generic that accesses private) provided the other
operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code>, <code class="docutils literal notranslate"><span class="pre">agent</span></code>, <code class="docutils literal notranslate"><span class="pre">workgroup</span></code> or <code class="docutils literal notranslate"><span class="pre">wavefront</span></code>
and executed by a thread in the same wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">singlethread</span></code></p></td>
<td><p>Only synchronizes with, and participates in modification
and seq_cst total orderings with, other operations (except
image operations) running in the same thread for all
address spaces (for example, in signal handlers).</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="amdgpu-intrinsics">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">AMDGPU Intrinsics</a><a class="headerlink" href="#amdgpu-intrinsics" title="Lien vers cette rubrique">¶</a></h3>
<p>The AMDGPU backend implements the following intrinsics.</p>
<p><em>This section is WIP.</em></p>
</section>
</section>
<section id="code-object">
<h2><a class="toc-backref" href="#id44" role="doc-backlink">Code Object</a><a class="headerlink" href="#code-object" title="Lien vers cette rubrique">¶</a></h2>
<p>The AMDGPU backend generates a standard ELF <a class="reference internal" href="#elf" id="id17"><span>[ELF]</span></a> relocatable code object that
can be linked by <code class="docutils literal notranslate"><span class="pre">lld</span></code> to produce a standard ELF shared code object which can
be loaded and executed on an AMDGPU target.</p>
<section id="header">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">Header</a><a class="headerlink" href="#header" title="Lien vers cette rubrique">¶</a></h3>
<p>The AMDGPU backend uses the following ELF header:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-header-table">
<caption><span class="caption-text">AMDGPU ELF Header</span><a class="headerlink" href="#amdgpu-elf-header-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_CLASS]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ELFCLASS64</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_DATA]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ELFDATA2LSB</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_OSABI]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_HSA</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_ABIVERSION]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_type</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ET_REL</span></code> or <code class="docutils literal notranslate"><span class="pre">ET_DYN</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_machine</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EM_AMDGPU</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_entry</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_flags</span></code></p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-header-enumeration-values-table">
<caption><span class="caption-text">AMDGPU ELF Header Enumeration Values</span><a class="headerlink" href="#amdgpu-elf-header-enumeration-values-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Nom</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EM_AMDGPU</span></code></p></td>
<td><p>224</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_HSA</span></code></p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA</span></code></p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_CLASS]</span></code></dt><dd><p>The ELF class is always <code class="docutils literal notranslate"><span class="pre">ELFCLASS64</span></code>. The AMDGPU backend only supports 64 bit
applications.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_DATA]</span></code></dt><dd><p>All AMDGPU targets use ELFDATA2LSB for little-endian byte ordering.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_OSABI]</span></code></dt><dd><p>The AMD GPU architecture specific OS ABI of <code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_HSA</span></code> is used to
specify that the code object conforms to the AMD HSA runtime ABI <a class="reference internal" href="#hsa" id="id18"><span>[HSA]</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_ABIVERSION]</span></code></dt><dd><p>The AMD GPU architecture specific OS ABI version of
<code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA</span></code> is used to specify the version of AMD HSA runtime
ABI to which the code object conforms.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_type</span></code></dt><dd><p>Can be one of the following values:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ET_REL</span></code></dt><dd><p>The type produced by the AMD GPU backend compiler as it is relocatable code
object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ET_DYN</span></code></dt><dd><p>The type produced by the linker as it is a shared code object.</p>
</dd>
</dl>
<p>The AMD HSA runtime loader requires a <code class="docutils literal notranslate"><span class="pre">ET_DYN</span></code> code object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_machine</span></code></dt><dd><p>The value <code class="docutils literal notranslate"><span class="pre">EM_AMDGPU</span></code> is used for the machine for all members of the AMD GPU
architecture family. The specific member is specified in the
<code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDGPU_ISA</span></code> entry in the <code class="docutils literal notranslate"><span class="pre">.note</span></code> section (see
<a class="reference internal" href="#amdgpu-note-records"><span class="std std-ref">Note Records</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_entry</span></code></dt><dd><p>The entry point is 0 as the entry points for individual kernels must be
selected in order to invoke them through AQL packets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_flags</span></code></dt><dd><p>The value is 0 as no flags are used.</p>
</dd>
</dl>
</section>
<section id="sections">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">Sections</a><a class="headerlink" href="#sections" title="Lien vers cette rubrique">¶</a></h3>
<p>An AMDGPU target ELF code object has the standard ELF sections which include:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-sections-table">
<caption><span class="caption-text">AMDGPU ELF Sections</span><a class="headerlink" href="#amdgpu-elf-sections-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Nom</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Attributes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.bss</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_NOBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_WRITE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.data</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_WRITE</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.debug_</span></code><em>*</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.dynamic</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_DYNAMIC</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.dynstr</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.dynsym</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.got</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_WRITE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.hash</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_HASH</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.note</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_NOTE</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.rela</span></code><em>name</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_RELA</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.rela.dyn</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_RELA</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.rodata</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.shstrtab</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_STRTAB</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.strtab</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_STRTAB</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.symtab</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_SYMTAB</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.text</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_EXECINSTR</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>These sections have their standard meanings (see <a class="reference internal" href="#elf" id="id19"><span>[ELF]</span></a>) and are only generated
if needed.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">.debug</span></code><em>*</em></dt><dd><p>The standard DWARF sections. See <a class="reference internal" href="#amdgpu-dwarf"><span class="std std-ref">DWARF</span></a> for information on the
DWARF produced by the AMDGPU backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.dynamic</span></code>, <code class="docutils literal notranslate"><span class="pre">.dynstr</span></code>, <code class="docutils literal notranslate"><span class="pre">.dynstr</span></code>, <code class="docutils literal notranslate"><span class="pre">.hash</span></code></dt><dd><p>The standard sections used by a dynamic loader.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.note</span></code></dt><dd><p>See <a class="reference internal" href="#amdgpu-note-records"><span class="std std-ref">Note Records</span></a> for the note records supported by the AMDGPU
backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.rela</span></code><em>name</em>, <code class="docutils literal notranslate"><span class="pre">.rela.dyn</span></code></dt><dd><p>For relocatable code objects, <em>name</em> is the name of the section that the
relocation records apply. For example, <code class="docutils literal notranslate"><span class="pre">.rela.text</span></code> is the section name for
relocation records associated with the <code class="docutils literal notranslate"><span class="pre">.text</span></code> section.</p>
<p>For linked shared code objects, <code class="docutils literal notranslate"><span class="pre">.rela.dyn</span></code> contains all the relocation
records from each of the relocatable code object’s <code class="docutils literal notranslate"><span class="pre">.rela</span></code><em>name</em> sections.</p>
<p>See <a class="reference internal" href="#amdgpu-relocation-records"><span class="std std-ref">Relocation Records</span></a> for the relocation records supported by
the AMDGPU backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.text</span></code></dt><dd><p>The executable machine code for the kernels and functions they call. Generated
as position independent code. See <a class="reference internal" href="#amdgpu-code-conventions"><span class="std std-ref">Code Conventions</span></a> for
information on conventions used in the isa generation.</p>
</dd>
</dl>
</section>
<section id="note-records">
<span id="amdgpu-note-records"></span><h3><a class="toc-backref" href="#id47" role="doc-backlink">Note Records</a><a class="headerlink" href="#note-records" title="Lien vers cette rubrique">¶</a></h3>
<p>As required by <code class="docutils literal notranslate"><span class="pre">ELFCLASS64</span></code>, minimal zero byte padding must be generated after
the <code class="docutils literal notranslate"><span class="pre">name</span></code> field to ensure the <code class="docutils literal notranslate"><span class="pre">desc</span></code> field is 4 byte aligned. In addition,
minimal zero byte padding must be generated to ensure the <code class="docutils literal notranslate"><span class="pre">desc</span></code> field size is
a multiple of 4 bytes. The <code class="docutils literal notranslate"><span class="pre">sh_addralign</span></code> field of the <code class="docutils literal notranslate"><span class="pre">.note</span></code> section must
be at least 4 to indicate at least 8 byte alignment.</p>
<p>The AMDGPU backend code object uses the following ELF note records in the
<code class="docutils literal notranslate"><span class="pre">.note</span></code> section. The <em>Description</em> column specifies the layout of the note
record’s <code class="docutils literal notranslate"><span class="pre">desc</span></code> field. All fields are consecutive bytes. Note records with
variable size strings have a corresponding <code class="docutils literal notranslate"><span class="pre">*_size</span></code> field that specifies the
number of bytes, including the terminating null character, in the string. The
string(s) come immediately after the preceding fields.</p>
<p>Additional note records can be present.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-note-records-table">
<caption><span class="caption-text">AMDGPU ELF Note Records</span><a class="headerlink" href="#amdgpu-elf-note-records-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Nom</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>« AMD »</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDGPU_METADATA</span></code></p></td>
<td><p>&lt;metadata null terminated string&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>« AMD »</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDGPU_ISA</span></code></p></td>
<td><p>&lt;isa name null terminated string&gt;</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-note-record-enumeration-values-table">
<caption><span class="caption-text">AMDGPU ELF Note Record Enumeration Values</span><a class="headerlink" href="#amdgpu-elf-note-record-enumeration-values-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Nom</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>reserved</em></p></td>
<td><p>0-9</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDGPU_METADATA</span></code></p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDGPU_ISA</span></code></p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDGPU_ISA</span></code></dt><dd><p>Specifies the instruction set architecture used by the machine code contained
in the code object.</p>
<p>This note record is required for code objects containing machine code for
processors matching the <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> architecture in table
<a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
<p>The null terminated string has the following syntax:</p>
<blockquote>
<div><p><em>architecture</em><code class="docutils literal notranslate"><span class="pre">-</span></code><em>vendor</em><code class="docutils literal notranslate"><span class="pre">-</span></code><em>os</em><code class="docutils literal notranslate"><span class="pre">-</span></code><em>environment</em><code class="docutils literal notranslate"><span class="pre">-</span></code><em>processor</em></p>
</div></blockquote>
<p>where:</p>
<blockquote>
<div><dl>
<dt><em>architecture</em></dt><dd><p>The architecture from table <a class="reference internal" href="#amdgpu-target-triples-table"><span class="std std-ref">AMDGPU Target Triples</span></a>.</p>
<p>This is always <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> when the target triple OS is <code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see
<a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
</dd>
<dt><em>vendor</em></dt><dd><p>The vendor from table <a class="reference internal" href="#amdgpu-target-triples-table"><span class="std std-ref">AMDGPU Target Triples</span></a>.</p>
<p>For the AMDGPU backend this is always <code class="docutils literal notranslate"><span class="pre">amd</span></code>.</p>
</dd>
<dt><em>os</em></dt><dd><p>The OS from table <a class="reference internal" href="#amdgpu-target-triples-table"><span class="std std-ref">AMDGPU Target Triples</span></a>.</p>
</dd>
<dt><em>environment</em></dt><dd><p>An environment from table <a class="reference internal" href="#amdgpu-target-triples-table"><span class="std std-ref">AMDGPU Target Triples</span></a>, or blank if
the environment has no affect on the execution of the code object.</p>
<p>For the AMDGPU backend this is currently always blank.</p>
</dd>
<dt><em>processor</em></dt><dd><p>The processor from table <a class="reference internal" href="#amdgpu-processors-table"><span class="std std-ref">AMDGPU Processors</span></a>.</p>
</dd>
</dl>
</div></blockquote>
<p>For example:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">amdgcn-amd-amdhsa--gfx901</span></code></p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDGPU_METADATA</span></code></dt><dd><p>Specifies extensible metadata associated with the code object. See
<a class="reference internal" href="#amdgpu-code-object-metadata"><span class="std std-ref">Code Object Metadata</span></a> for the syntax of the code object metadata
string.</p>
<p>This note record is required and must contain the minimum information
necessary to support the ROCM kernel queries. For example, the segment sizes
needed in a dispatch packet. In addition, a high level language runtime may
require other information to be included. For example, the AMD OpenCL runtime
records kernel argument information.</p>
</dd>
</dl>
</section>
<section id="code-object-metadata">
<span id="amdgpu-code-object-metadata"></span><h3><a class="toc-backref" href="#id48" role="doc-backlink">Code Object Metadata</a><a class="headerlink" href="#code-object-metadata" title="Lien vers cette rubrique">¶</a></h3>
<p>The code object metadata is specified by the <code class="docutils literal notranslate"><span class="pre">NT_AMD_AMDHSA_METADATA</span></code> note
record (see <a class="reference internal" href="#amdgpu-note-records"><span class="std std-ref">Note Records</span></a>).</p>
<p>The metadata is specified as a YAML formatted string (see <a class="reference internal" href="#yaml" id="id20"><span>[YAML]</span></a> and
<a class="reference internal" href="YamlIO.html"><span class="doc">YAML I/O</span></a>).</p>
<p>The metadata is represented as a single YAML document comprised of the mapping
defined in table <a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-mapping-table"><span class="std std-ref">AMDHSA Code Object Metadata Mapping</span></a> and
referenced tables.</p>
<p>For boolean values, the string values of <code class="docutils literal notranslate"><span class="pre">false</span></code> and <code class="docutils literal notranslate"><span class="pre">true</span></code> are used for
false and true respectively.</p>
<p>Additional information can be added to the mappings. To avoid conflicts, any
non-AMD key names should be prefixed by « <em>vendor-name</em>. ».</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-metadata-mapping-table">
<caption><span class="caption-text">AMDHSA Code Object Metadata Mapping</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-metadata-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>« Version »</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Required</p></td>
<td><ul class="simple">
<li><p>The first integer is the major
version. Currently 1.</p></li>
<li><p>The second integer is the minor
version. Currently 0.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>« Printf »</p></td>
<td><p>sequence of
strings</p></td>
<td></td>
<td><p>Each string is encoded information
about a printf function call. The
encoded information is organized as
fields separated by colon (“:”):</p>
<p><code class="docutils literal notranslate"><span class="pre">ID:N:S[0]:S[1]:...:S[N-1]:FormatString</span></code></p>
<p>where:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ID</span></code></dt><dd><p>A 32 bit integer as a unique id for
each printf function call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt><dd><p>A 32 bit integer equal to the number
of arguments of printf function call
minus 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S[i]</span></code> (where i = 0, 1, … , N-1)</dt><dd><p>32 bit integers for the size in bytes
of the i-th FormatString argument of
the printf function call</p>
</dd>
<dt>FormatString</dt><dd><p>The format string passed to the
printf function call.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>« Kernels »</p></td>
<td><p>sequence of
mapping</p></td>
<td><p>Required</p></td>
<td><p>Sequence of the mappings for each
kernel in the code object. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-metadata-mapping-table"><span class="std std-ref">AMDHSA Code Object Kernel Metadata Mapping</span></a>
for the definition of the mapping.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-metadata-mapping-table">
<caption><span class="caption-text">AMDHSA Code Object Kernel Metadata Mapping</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-metadata-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>« Name »</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Source name of the kernel.</p></td>
</tr>
<tr class="row-odd"><td><p>« SymbolName »</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Name of the kernel
descriptor ELF symbol.</p></td>
</tr>
<tr class="row-even"><td><p>« Language »</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Source language of the kernel.
Values include:</p>
<ul class="simple">
<li><p>« OpenCL C »</p></li>
<li><p>« OpenCL C++ »</p></li>
<li><p>« HCC »</p></li>
<li><p>« OpenMP »</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>« LanguageVersion »</p></td>
<td><p>sequence of
2 integers</p></td>
<td></td>
<td><ul class="simple">
<li><p>The first integer is the major
version.</p></li>
<li><p>The second integer is the
minor version.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>« Attrs »</p></td>
<td><p>mapping</p></td>
<td></td>
<td><p>Mapping of kernel attributes.
See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-attribute-metadata-mapping-table"><span class="std std-ref">AMDHSA Code Object Kernel Attribute Metadata Mapping</span></a>
for the mapping definition.</p></td>
</tr>
<tr class="row-odd"><td><p>« Arguments »</p></td>
<td><p>sequence of
mapping</p></td>
<td></td>
<td><p>Sequence of mappings of the
kernel arguments. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-argument-metadata-mapping-table"><span class="std std-ref">AMDHSA Code Object Kernel Argument Metadata Mapping</span></a>
for the definition of the mapping.</p></td>
</tr>
<tr class="row-even"><td><p>« CodeProps »</p></td>
<td><p>mapping</p></td>
<td></td>
<td><p>Mapping of properties related to
the kernel code. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-code-properties-metadata-mapping-table"><span class="std std-ref">AMDHSA Code Object Kernel Code Properties Metadata Mapping</span></a>
for the mapping definition.</p></td>
</tr>
<tr class="row-odd"><td><p>« DebugProps »</p></td>
<td><p>mapping</p></td>
<td></td>
<td><p>Mapping of properties related to
the kernel debugging. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-debug-properties-metadata-mapping-table"><span class="std std-ref">AMDHSA Code Object Kernel Debug Properties Metadata Mapping</span></a>
for the mapping definition.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-attribute-metadata-mapping-table">
<caption><span class="caption-text">AMDHSA Code Object Kernel Attribute Metadata Mapping</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-attribute-metadata-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>« ReqdWorkGroupSize »</p></td>
<td><p>sequence of
3 integers</p></td>
<td></td>
<td><p>The dispatch work-group size
X, Y, Z must correspond to the
specified values.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">reqd_work_group_size</span></code>
attribute.</p>
</td>
</tr>
<tr class="row-odd"><td><p>« WorkGroupSizeHint »</p></td>
<td><p>sequence of
3 integers</p></td>
<td></td>
<td><p>The dispatch work-group size
X, Y, Z is likely to be the
specified values.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">work_group_size_hint</span></code>
attribute.</p>
</td>
</tr>
<tr class="row-even"><td><p>« VecTypeHint »</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The name of a scalar or vector
type.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">vec_type_hint</span></code> attribute.</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-argument-metadata-mapping-table">
<caption><span class="caption-text">AMDHSA Code Object Kernel Argument Metadata Mapping</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-argument-metadata-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>« Name »</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument name.</p></td>
</tr>
<tr class="row-odd"><td><p>« TypeName »</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument type name.</p></td>
</tr>
<tr class="row-even"><td><p>« Size »</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument size in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>« Align »</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument alignment in
bytes. Must be a power of two.</p></td>
</tr>
<tr class="row-even"><td><p>« ValueKind »</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument kind that
specifies how to set up the
corresponding argument.
Values include:</p>
<dl class="simple">
<dt>« ByValue »</dt><dd><p>The argument is copied
directly into the kernarg.</p>
</dd>
<dt>« GlobalBuffer »</dt><dd><p>A global address space pointer
to the buffer data is passed
in the kernarg.</p>
</dd>
<dt>« DynamicSharedPointer »</dt><dd><p>A group address space pointer
to dynamically allocated LDS
is passed in the kernarg.</p>
</dd>
<dt>« Sampler »</dt><dd><p>A global address space
pointer to a S# is passed in
the kernarg.</p>
</dd>
<dt>« Image »</dt><dd><p>A global address space
pointer to a T# is passed in
the kernarg.</p>
</dd>
<dt>« Pipe »</dt><dd><p>A global address space pointer
to an OpenCL pipe is passed in
the kernarg.</p>
</dd>
<dt>« Queue »</dt><dd><p>A global address space pointer
to an OpenCL device enqueue
queue is passed in the
kernarg.</p>
</dd>
<dt>« HiddenGlobalOffsetX »</dt><dd><p>The OpenCL grid dispatch
global offset for the X
dimension is passed in the
kernarg.</p>
</dd>
<dt>« HiddenGlobalOffsetY »</dt><dd><p>The OpenCL grid dispatch
global offset for the Y
dimension is passed in the
kernarg.</p>
</dd>
<dt>« HiddenGlobalOffsetZ »</dt><dd><p>The OpenCL grid dispatch
global offset for the Z
dimension is passed in the
kernarg.</p>
</dd>
<dt>« HiddenNone »</dt><dd><p>An argument that is not used
by the kernel. Space needs to
be left for it, but it does
not need to be set up.</p>
</dd>
<dt>« HiddenPrintfBuffer »</dt><dd><p>A global address space pointer
to the runtime printf buffer
is passed in kernarg.</p>
</dd>
<dt>« HiddenDefaultQueue »</dt><dd><p>A global address space pointer
to the OpenCL device enqueue
queue that should be used by
the kernel by default is
passed in the kernarg.</p>
</dd>
<dt>« HiddenCompletionAction »</dt><dd><p><em>TBD</em></p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>« ValueType »</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument value type. Only
present if « ValueKind » is
« ByValue ». For vector data
types, the value is for the
element type. Values include:</p>
<ul class="simple">
<li><p>« Struct »</p></li>
<li><p>« I8 »</p></li>
<li><p>« U8 »</p></li>
<li><p>« I16 »</p></li>
<li><p>« U16 »</p></li>
<li><p>« F16 »</p></li>
<li><p>« I32 »</p></li>
<li><p>« U32 »</p></li>
<li><p>« F32 »</p></li>
<li><p>« I64 »</p></li>
<li><p>« U64 »</p></li>
<li><p>« F64 »</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>« PointeeAlign »</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Alignment in bytes of pointee
type for pointer type kernel
argument. Must be a power
of 2. Only present if
« ValueKind » is
« DynamicSharedPointer ».</p></td>
</tr>
<tr class="row-odd"><td><p>« AddrSpaceQual »</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument address space
qualifier. Only present if
« ValueKind » is « GlobalBuffer » or
« DynamicSharedPointer ». Values
are:</p>
<ul class="simple">
<li><p>« Private »</p></li>
<li><p>« Global »</p></li>
<li><p>« Constant »</p></li>
<li><p>« Local »</p></li>
<li><p>« Generic »</p></li>
<li><p>« Region »</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>« AccQual »</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument access
qualifier. Only present if
« ValueKind » is « Image » or
« Pipe ». Values
are:</p>
<ul class="simple">
<li><p>« ReadOnly »</p></li>
<li><p>« WriteOnly »</p></li>
<li><p>« ReadWrite »</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>« ActualAcc »</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The actual memory accesses
performed by the kernel on the
kernel argument. Only present if
« ValueKind » is « GlobalBuffer »,
« Image », or « Pipe ». This may be
more restrictive than indicated
by « AccQual » to reflect what the
kernel actual does. If not
present then the runtime must
assume what is implied by
« AccQual » and « IsConst ». Values
are:</p>
<ul class="simple">
<li><p>« ReadOnly »</p></li>
<li><p>« WriteOnly »</p></li>
<li><p>« ReadWrite »</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>« IsConst »</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is const qualified. Only present
if « ValueKind » is
« GlobalBuffer ».</p></td>
</tr>
<tr class="row-odd"><td><p>« IsRestrict »</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is restrict qualified. Only
present if « ValueKind » is
« GlobalBuffer ».</p></td>
</tr>
<tr class="row-even"><td><p>« IsVolatile »</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is volatile qualified. Only
present if « ValueKind » is
« GlobalBuffer ».</p></td>
</tr>
<tr class="row-odd"><td><p>« IsPipe »</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is pipe qualified. Only present
if « ValueKind » is « Pipe ».</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-code-properties-metadata-mapping-table">
<caption><span class="caption-text">AMDHSA Code Object Kernel Code Properties Metadata Mapping</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-code-properties-metadata-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>« KernargSegmentSize »</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The size in bytes of
the kernarg segment
that holds the values
of the arguments to
the kernel.</p></td>
</tr>
<tr class="row-odd"><td><p>« GroupSegmentFixedSize »</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The amount of group
segment memory
required by a
work-group in
bytes. This does not
include any
dynamically allocated
group segment memory
that may be added
when the kernel is
dispatched.</p></td>
</tr>
<tr class="row-even"><td><p>« PrivateSegmentFixedSize »</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The amount of fixed
private address space
memory required for a
work-item in
bytes. If
IsDynamicCallstack
is 1 then additional
space must be added
to this value for the
call stack.</p></td>
</tr>
<tr class="row-odd"><td><p>« KernargSegmentAlign »</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The maximum byte
alignment of
arguments in the
kernarg segment. Must
be a power of 2.</p></td>
</tr>
<tr class="row-even"><td><p>« WavefrontSize »</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Wavefront size. Must
be a power of 2.</p></td>
</tr>
<tr class="row-odd"><td><p>« NumSGPRs »</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of scalar
registers used by a
wavefront for
GFX6-GFX9. This
includes the special
SGPRs for VCC, Flat
Scratch (GFX7-GFX9)
and XNACK (for
GFX8-GFX9). It does
not include the 16
SGPR added if a trap
handler is
enabled. It is not
rounded up to the
allocation
granularity.</p></td>
</tr>
<tr class="row-even"><td><p>« NumVGPRs »</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of vector
registers used by
each work-item for
GFX6-GFX9</p></td>
</tr>
<tr class="row-odd"><td><p>« MaxFlatWorkgroupSize »</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Maximum flat
work-group size
supported by the
kernel in work-items.</p></td>
</tr>
<tr class="row-even"><td><p>« IsDynamicCallStack »</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the
generated machine
code is using a
dynamically sized
call stack.</p></td>
</tr>
<tr class="row-odd"><td><p>« IsXNACKEnabled »</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the
generated machine
code is capable of
supporting XNACK.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-debug-properties-metadata-mapping-table">
<caption><span class="caption-text">AMDHSA Code Object Kernel Debug Properties Metadata Mapping</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-debug-properties-metadata-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>« DebuggerABIVersion »</p></td>
<td><p>string</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>« ReservedNumVGPRs »</p></td>
<td><p>integer</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>« ReservedFirstVGPR »</p></td>
<td><p>integer</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>« PrivateSegmentBufferSGPR »</p></td>
<td><p>integer</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>« WavefrontPrivateSegmentOffsetSGPR »</p></td>
<td><p>integer</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="symbols">
<span id="amdgpu-symbols"></span><h3><a class="toc-backref" href="#id49" role="doc-backlink">Symbols</a><a class="headerlink" href="#symbols" title="Lien vers cette rubrique">¶</a></h3>
<p>Symbols include the following:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-symbols-table">
<caption><span class="caption-text">AMDGPU ELF Symbols</span><a class="headerlink" href="#amdgpu-elf-symbols-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Nom</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Section</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>link-name</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">STT_OBJECT</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.data</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.rodata</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.bss</span></code></p></li>
</ul>
</td>
<td><p>Global variable</p></td>
</tr>
<tr class="row-odd"><td><p><em>link-name</em><code class="docutils literal notranslate"><span class="pre">&#64;kd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">STT_OBJECT</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.rodata</span></code></p></li>
</ul>
</td>
<td><p>Kernel descriptor</p></td>
</tr>
<tr class="row-even"><td><p><em>link-name</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">STT_FUNC</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.text</span></code></p></li>
</ul>
</td>
<td><p>Kernel entry point</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt>Global variable</dt><dd><p>Global variables both used and defined by the compilation unit.</p>
<p>If the symbol is defined in the compilation unit then it is allocated in the
appropriate section according to if it has initialized data or is readonly.</p>
<p>If the symbol is external then its section is <code class="docutils literal notranslate"><span class="pre">STN_UNDEF</span></code> and the loader
will resolve relocations using the definition provided by another code object
or explicitly defined by the runtime.</p>
<p>All global symbols, whether defined in the compilation unit or external, are
accessed by the machine code indirectly through a GOT table entry. This
allows them to be preemptable. The GOT table is only supported when the target
triple OS is <code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
</dd>
<dt>Kernel descriptor</dt><dd><p>Every HSA kernel has an associated kernel descriptor. It is the address of the
kernel descriptor that is used in the AQL dispatch packet used to invoke the
kernel, not the kernel entry point. The layout of the HSA kernel descriptor is
defined in <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>.</p>
</dd>
<dt>Kernel entry point</dt><dd><p>Every HSA kernel also has a symbol for its machine code entry point.</p>
</dd>
</dl>
</section>
<section id="relocation-records">
<span id="amdgpu-relocation-records"></span><h3><a class="toc-backref" href="#id50" role="doc-backlink">Relocation Records</a><a class="headerlink" href="#relocation-records" title="Lien vers cette rubrique">¶</a></h3>
<p>AMDGPU backend generates <code class="docutils literal notranslate"><span class="pre">Elf64_Rela</span></code> relocation records. Supported
relocatable fields are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">word32</span></code></dt><dd><p>This specifies a 32-bit field occupying 4 bytes with arbitrary byte
alignment. These values use the same byte order as other word values in the
AMD GPU architecture.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">word64</span></code></dt><dd><p>This specifies a 64-bit field occupying 8 bytes with arbitrary byte
alignment. These values use the same byte order as other word values in the
AMD GPU architecture.</p>
</dd>
</dl>
<p>Following notations are used for specifying relocation calculations:</p>
<dl class="simple">
<dt><strong>A</strong></dt><dd><p>Represents the addend used to compute the value of the relocatable field.</p>
</dd>
<dt><strong>G</strong></dt><dd><p>Represents the offset into the global offset table at which the relocation
entry’s symbol will reside during execution.</p>
</dd>
<dt><strong>GOT</strong></dt><dd><p>Represents the address of the global offset table.</p>
</dd>
<dt><strong>P</strong></dt><dd><p>Represents the place (section offset for <code class="docutils literal notranslate"><span class="pre">et_rel</span></code> or address for <code class="docutils literal notranslate"><span class="pre">et_dyn</span></code>)
of the storage unit being relocated (computed using <code class="docutils literal notranslate"><span class="pre">r_offset</span></code>).</p>
</dd>
<dt><strong>S</strong></dt><dd><p>Represents the value of the symbol whose index resides in the relocation
entry.</p>
</dd>
</dl>
<p>The following relocation types are supported:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-relocation-records-table">
<caption><span class="caption-text">AMDGPU ELF Relocation Records</span><a class="headerlink" href="#amdgpu-elf-relocation-records-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Relocation Type</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Field</p></th>
<th class="head"><p>Calculation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_NONE</span></code></p></td>
<td><p>0</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32_LO</span></code></p></td>
<td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A) &amp; 0xFFFFFFFF</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32_HI</span></code></p></td>
<td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A) &gt;&gt; 32</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS64</span></code></p></td>
<td><p>3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word64</span></code></p></td>
<td><p>S + A</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL32</span></code></p></td>
<td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>S + A - P</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL64</span></code></p></td>
<td><p>5</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word64</span></code></p></td>
<td><p>S + A - P</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32</span></code></p></td>
<td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>S + A</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_GOTPCREL</span></code></p></td>
<td><p>7</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>G + GOT + A - P</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_GOTPCREL32_LO</span></code></p></td>
<td><p>8</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(G + GOT + A - P) &amp; 0xFFFFFFFF</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_GOTPCREL32_HI</span></code></p></td>
<td><p>9</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(G + GOT + A - P) &gt;&gt; 32</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL32_LO</span></code></p></td>
<td><p>10</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A - P) &amp; 0xFFFFFFFF</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL32_HI</span></code></p></td>
<td><p>11</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A - P) &gt;&gt; 32</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="dwarf">
<span id="amdgpu-dwarf"></span><h3><a class="toc-backref" href="#id51" role="doc-backlink">DWARF</a><a class="headerlink" href="#dwarf" title="Lien vers cette rubrique">¶</a></h3>
<p>Standard DWARF <a class="reference internal" href="#id35" id="id21"><span>[DWARF]</span></a> Version 2 sections can be generated. These contain
information that maps the code object executable code and data to the source
language constructs. It can be used by tools such as debuggers and profilers.</p>
<section id="address-space-mapping">
<h4><a class="toc-backref" href="#id52" role="doc-backlink">Address Space Mapping</a><a class="headerlink" href="#address-space-mapping" title="Lien vers cette rubrique">¶</a></h4>
<p>The following address space mapping is used:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-dwarf-address-space-mapping-table">
<caption><span class="caption-text">AMDGPU DWARF Address Space Mapping</span><a class="headerlink" href="#amdgpu-dwarf-address-space-mapping-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>DWARF Address Space</p></th>
<th class="head"><p>Memory Space</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Private (Scratch)</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Local (group/LDS)</p></td>
</tr>
<tr class="row-even"><td><p><em>omitted</em></p></td>
<td><p>Global</p></td>
</tr>
<tr class="row-odd"><td><p><em>omitted</em></p></td>
<td><p>Constant</p></td>
</tr>
<tr class="row-even"><td><p><em>omitted</em></p></td>
<td><p>Generic (Flat)</p></td>
</tr>
<tr class="row-odd"><td><p><em>not supported</em></p></td>
<td><p>Region (GDS)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>See <a class="reference internal" href="#amdgpu-address-spaces"><span class="std std-ref">Address Spaces</span></a> for infomration on the memory space terminology
used in the table.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">address_class</span></code> attribute is generated on pointer type DIEs to specify the
DWARF address space of the value of the pointer when it is in the <em>private</em> or
<em>local</em> address space. Otherwise the attribute is omitted.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">XDEREF</span></code> operation is generated in location list expressions for variables
that are allocated in the <em>private</em> and <em>local</em> address space. Otherwise no
<code class="docutils literal notranslate"><span class="pre">XDREF</span></code> is omitted.</p>
</section>
<section id="register-mapping">
<h4><a class="toc-backref" href="#id53" role="doc-backlink">Register Mapping</a><a class="headerlink" href="#register-mapping" title="Lien vers cette rubrique">¶</a></h4>
<p><em>This section is WIP.</em></p>
</section>
<section id="source-text">
<h4><a class="toc-backref" href="#id54" role="doc-backlink">Source Text</a><a class="headerlink" href="#source-text" title="Lien vers cette rubrique">¶</a></h4>
<p><em>This section is WIP.</em></p>
</section>
</section>
</section>
<section id="code-conventions">
<span id="amdgpu-code-conventions"></span><h2><a class="toc-backref" href="#id55" role="doc-backlink">Code Conventions</a><a class="headerlink" href="#code-conventions" title="Lien vers cette rubrique">¶</a></h2>
<section id="amdhsa">
<h3><a class="toc-backref" href="#id56" role="doc-backlink">AMDHSA</a><a class="headerlink" href="#amdhsa" title="Lien vers cette rubrique">¶</a></h3>
<p>This section provides code conventions used when the target triple OS is
<code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<section id="kernel-dispatch">
<h4><a class="toc-backref" href="#id57" role="doc-backlink">Kernel Dispatch</a><a class="headerlink" href="#kernel-dispatch" title="Lien vers cette rubrique">¶</a></h4>
<p>The HSA architected queuing language (AQL) defines a user space memory interface
that can be used to control the dispatch of kernels, in an agent independent
way. An agent can have zero or more AQL queues created for it using the ROCm
runtime, in which AQL packets (all of which are 64 bytes) can be placed. See the
<em>HSA Platform System Architecture Specification</em> <a class="reference internal" href="#hsa" id="id22"><span>[HSA]</span></a> for the AQL queue
mechanics and packet layouts.</p>
<p>The packet processor of a kernel agent is responsible for detecting and
dispatching HSA kernels from the AQL queues associated with it. For AMD GPUs the
packet processor is implemented by the hardware command processor (CP),
asynchronous dispatch controller (ADC) and shader processor input controller
(SPI).</p>
<p>The ROCm runtime can be used to allocate an AQL queue object. It uses the kernel
mode driver to initialize and register the AQL queue with CP.</p>
<p>To dispatch a kernel the following actions are performed. This can occur in the
CPU host program, or from an HSA kernel executing on a GPU.</p>
<ol class="arabic simple">
<li><p>A pointer to an AQL queue for the kernel agent on which the kernel is to be
executed is obtained.</p></li>
<li><p>A pointer to the kernel descriptor (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>) of the kernel to execute is
obtained. It must be for a kernel that is contained in a code object that that
was loaded by the ROCm runtime on the kernel agent with which the AQL queue is
associated.</p></li>
<li><p>Space is allocated for the kernel arguments using the ROCm runtime allocator
for a memory region with the kernarg property for the kernel agent that will
execute the kernel. It must be at least 16 byte aligned.</p></li>
<li><p>Kernel argument values are assigned to the kernel argument memory
allocation. The layout is defined in the <em>HSA Programmer’s Language Reference</em>
<a class="reference internal" href="#hsa" id="id23"><span>[HSA]</span></a>. For AMDGPU the kernel execution directly accesses the kernel argument
memory in the same way constant memory is accessed. (Note that the HSA
specification allows an implementation to copy the kernel argument contents to
another location that is accessed by the kernel.)</p></li>
<li><p>An AQL kernel dispatch packet is created on the AQL queue. The ROCm runtime
api uses 64 bit atomic operations to reserve space in the AQL queue for the
packet. The packet must be set up, and the final write must use an atomic
store release to set the packet kind to ensure the packet contents are
visible to the kernel agent. AQL defines a doorbell signal mechanism to
notify the kernel agent that the AQL queue has been updated. These rules, and
the layout of the AQL queue and kernel dispatch packet is defined in the <em>HSA
System Architecture Specification</em> <a class="reference internal" href="#hsa" id="id24"><span>[HSA]</span></a>.</p></li>
<li><p>A kernel dispatch packet includes information about the actual dispatch,
such as grid and work-group size, together with information from the code
object about the kernel, such as segment sizes. The ROCm runtime queries on
the kernel symbol can be used to obtain the code object values which are
recorded in the <a class="reference internal" href="#amdgpu-code-object-metadata"><span class="std std-ref">Code Object Metadata</span></a>.</p></li>
<li><p>CP executes micro-code and is responsible for detecting and setting up the
GPU to execute the wavefronts of a kernel dispatch.</p></li>
<li><p>CP ensures that when the a wavefront starts executing the kernel machine
code, the scalar general purpose registers (SGPR) and vector general purpose
registers (VGPR) are set up as required by the machine code. The required
setup is defined in the <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>. The initial
register state is defined in
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>.</p></li>
<li><p>The prolog of the kernel machine code (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog"><span class="std std-ref">Kernel Prolog</span></a>) sets up the machine state as necessary
before continuing executing the machine code that corresponds to the kernel.</p></li>
<li><p>When the kernel dispatch has completed execution, CP signals the completion
signal specified in the kernel dispatch packet if not 0.</p></li>
</ol>
</section>
<section id="memory-spaces">
<span id="amdgpu-amdhsa-memory-spaces"></span><h4><a class="toc-backref" href="#id58" role="doc-backlink">Memory Spaces</a><a class="headerlink" href="#memory-spaces" title="Lien vers cette rubrique">¶</a></h4>
<p>The memory space properties are:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-spaces-table">
<caption><span class="caption-text">AMDHSA Memory Spaces</span><a class="headerlink" href="#amdgpu-amdhsa-memory-spaces-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Memory Space Name</p></th>
<th class="head"><p>HSA Segment
Name</p></th>
<th class="head"><p>Hardware
Name</p></th>
<th class="head"><p>Address
Size</p></th>
<th class="head"><p>NULL Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Private</p></td>
<td><p>private</p></td>
<td><p>scratch</p></td>
<td><p>32</p></td>
<td><p>0x00000000</p></td>
</tr>
<tr class="row-odd"><td><p>Local</p></td>
<td><p>group</p></td>
<td><p>LDS</p></td>
<td><p>32</p></td>
<td><p>0xFFFFFFFF</p></td>
</tr>
<tr class="row-even"><td><p>Global</p></td>
<td><p>global</p></td>
<td><p>global</p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-odd"><td><p>Constant</p></td>
<td><p>constant</p></td>
<td><p><em>same as
global</em></p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-even"><td><p>Generic</p></td>
<td><p>flat</p></td>
<td><p>flat</p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-odd"><td><p>Region</p></td>
<td><p>N/A</p></td>
<td><p>GDS</p></td>
<td><p>32</p></td>
<td><p><em>not implemented
for AMDHSA</em></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The global and constant memory spaces both use global virtual addresses, which
are the same virtual address space used by the CPU. However, some virtual
addresses may only be accessible to the CPU, some only accessible by the GPU,
and some by both.</p>
<p>Using the constant memory space indicates that the data will not change during
the execution of the kernel. This allows scalar read instructions to be
used. The vector and scalar L1 caches are invalidated of volatile data before
each kernel dispatch execution to allow constant memory to change values between
kernel dispatches.</p>
<p>The local memory space uses the hardware Local Data Store (LDS) which is
automatically allocated when the hardware creates work-groups of wavefronts, and
freed when all the wavefronts of a work-group have terminated. The data store
(DS) instructions can be used to access it.</p>
<p>The private memory space uses the hardware scratch memory support. If the kernel
uses scratch, then the hardware allocates memory that is accessed using
wavefront lane dword (4 byte) interleaving. The mapping used from private
address to physical address is:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">wavefront-scratch-base</span> <span class="pre">+</span>
<span class="pre">(private-address</span> <span class="pre">*</span> <span class="pre">wavefront-size</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">+</span>
<span class="pre">(wavefront-lane-id</span> <span class="pre">*</span> <span class="pre">4)</span></code></p>
</div></blockquote>
<p>There are different ways that the wavefront scratch base address is determined
by a wavefront (see <a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>). This
memory can be accessed in an interleaved manner using buffer instruction with
the scratch buffer descriptor and per wave scratch offset, by the scratch
instructions, or by flat instructions. If each lane of a wavefront accesses the
same private address, the interleaving results in adjacent dwords being accessed
and hence requires fewer cache lines to be fetched. Multi-dword access is not
supported except by flat and scratch instructions in GFX9.</p>
<p>The generic address space uses the hardware flat address support available in
GFX7-GFX9. This uses two fixed ranges of virtual addresses (the private and
local appertures), that are outside the range of addressible global memory, to
map from a flat address to a private or local address.</p>
<p>FLAT instructions can take a flat address and access global, private (scratch)
and group (LDS) memory depending in if the address is within one of the
apperture ranges. Flat access to scratch requires hardware aperture setup and
setup in the kernel prologue (see <a class="reference internal" href="#amdgpu-amdhsa-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>). Flat
access to LDS requires hardware aperture setup and M0 (GFX7-GFX8) register setup
(see <a class="reference internal" href="#amdgpu-amdhsa-m0"><span class="std std-ref">M0</span></a>).</p>
<p>To convert between a segment address and a flat address the base address of the
appertures address can be used. For GFX7-GFX8 these are available in the
<a class="reference internal" href="#amdgpu-amdhsa-hsa-aql-queue"><span class="std std-ref">HSA AQL Queue</span></a> the address of which can be obtained with
Queue Ptr SGPR (see <a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>). For
GFX9 the appature base addresses are directly available as inline constant
registers <code class="docutils literal notranslate"><span class="pre">SRC_SHARED_BASE/LIMIT</span></code> and <code class="docutils literal notranslate"><span class="pre">SRC_PRIVATE_BASE/LIMIT</span></code>. In 64 bit
address mode the apperture sizes are 2^32 bytes and the base is aligned to 2^32
which makes it easier to convert from flat to segment or segment to flat.</p>
</section>
<section id="hsa-image-and-samplers">
<h4><a class="toc-backref" href="#id59" role="doc-backlink">HSA Image and Samplers</a><a class="headerlink" href="#hsa-image-and-samplers" title="Lien vers cette rubrique">¶</a></h4>
<p>Image and sample handles created by the ROCm runtime are 64 bit addresses of a
hardware 32 byte V# and 48 byte S# object respectively. In order to support the
HSA <code class="docutils literal notranslate"><span class="pre">query_sampler</span></code> operations two extra dwords are used to store the HSA BRIG
enumeration values for the queries that are not trivially deducible from the S#
representation.</p>
</section>
<section id="hsa-signals">
<h4><a class="toc-backref" href="#id60" role="doc-backlink">HSA Signals</a><a class="headerlink" href="#hsa-signals" title="Lien vers cette rubrique">¶</a></h4>
<p>Signal handles created by the ROCm runtime are 64 bit addresses of a structure
allocated in memory accessible from both the CPU and GPU. The structure is
defined by the ROCm runtime and subject to change between releases (see
<a class="reference internal" href="#amd-rocm-github" id="id25"><span>[AMD-ROCm-github]</span></a>).</p>
</section>
<section id="hsa-aql-queue">
<span id="amdgpu-amdhsa-hsa-aql-queue"></span><h4><a class="toc-backref" href="#id61" role="doc-backlink">HSA AQL Queue</a><a class="headerlink" href="#hsa-aql-queue" title="Lien vers cette rubrique">¶</a></h4>
<p>The AQL queue structure is defined by the ROCm runtime and subject to change
between releases (see <a class="reference internal" href="#amd-rocm-github" id="id26"><span>[AMD-ROCm-github]</span></a>). For some processors it contains
fields needed to implement certain language features such as the flat address
aperture bases. It also contains fields used by CP such as managing the
allocation of scratch memory.</p>
</section>
<section id="kernel-descriptor">
<span id="amdgpu-amdhsa-kernel-descriptor"></span><h4><a class="toc-backref" href="#id62" role="doc-backlink">Kernel Descriptor</a><a class="headerlink" href="#kernel-descriptor" title="Lien vers cette rubrique">¶</a></h4>
<p>A kernel descriptor consists of the information needed by CP to initiate the
execution of a kernel, including the entry point address of the machine code
that implements the kernel.</p>
<section id="kernel-descriptor-for-gfx6-gfx9">
<h5><a class="toc-backref" href="#id63" role="doc-backlink">Kernel Descriptor for GFX6-GFX9</a><a class="headerlink" href="#kernel-descriptor-for-gfx6-gfx9" title="Lien vers cette rubrique">¶</a></h5>
<p>CP microcode requires the Kernel descritor to be allocated on 64 byte alignment.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-kernel-descriptor-gfx6-gfx9-table">
<caption><span class="caption-text">Kernel Descriptor for GFX6-GFX9</span><a class="headerlink" href="#amdgpu-amdhsa-kernel-descriptor-gfx6-gfx9-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>31:0</p></td>
<td><p>4 bytes</p></td>
<td><p>group_segment_fixed_size</p></td>
<td><p>The amount of fixed local
address space memory
required for a work-group
in bytes. This does not
include any dynamically
allocated local address
space memory that may be
added when the kernel is
dispatched.</p></td>
</tr>
<tr class="row-odd"><td><p>63:32</p></td>
<td><p>4 bytes</p></td>
<td><p>private_segment_fixed_size</p></td>
<td><p>The amount of fixed
private address space
memory required for a
work-item in bytes. If
is_dynamic_callstack is 1
then additional space must
be added to this value for
the call stack.</p></td>
</tr>
<tr class="row-even"><td><p>95:64</p></td>
<td><p>4 bytes</p></td>
<td><p>max_flat_workgroup_size</p></td>
<td><p>Maximum flat work-group
size supported by the
kernel in work-items.</p></td>
</tr>
<tr class="row-odd"><td><p>96</p></td>
<td><p>1 bit</p></td>
<td><p>is_dynamic_call_stack</p></td>
<td><p>Indicates if the generated
machine code is using a
dynamically sized call
stack.</p></td>
</tr>
<tr class="row-even"><td><p>97</p></td>
<td><p>1 bit</p></td>
<td><p>is_xnack_enabled</p></td>
<td><p>Indicates if the generated
machine code is capable of
suppoting XNACK.</p></td>
</tr>
<tr class="row-odd"><td><p>127:98</p></td>
<td><p>30 bits</p></td>
<td></td>
<td><p>Reserved. Must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>191:128</p></td>
<td><p>8 bytes</p></td>
<td><p>kernel_code_entry_byte_offset</p></td>
<td><p>Byte offset (possibly
negative) from base
address of kernel
descriptor to kernel’s
entry point instruction
which must be 256 byte
aligned.</p></td>
</tr>
<tr class="row-odd"><td><p>383:192</p></td>
<td><p>24
bytes</p></td>
<td></td>
<td><p>Reserved. Must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>415:384</p></td>
<td><p>4 bytes</p></td>
<td><p>compute_pgm_rsrc1</p></td>
<td><p>Compute Shader (CS)
program settings used by
CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1</span></code>
configuration
register. See
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-t-gfx6-gfx9-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX9</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>447:416</p></td>
<td><p>4 bytes</p></td>
<td><p>compute_pgm_rsrc2</p></td>
<td><p>Compute Shader (CS)
program settings used by
CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2</span></code>
configuration
register. See
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx9-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX9</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>448</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_private_segment
_buffer</p></td>
<td><p>Enable the setup of the
SGPR user data registers
(see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>The total number of SGPR
user data registers
requested must not exceed
16 and match value in
<code class="docutils literal notranslate"><span class="pre">compute_pgm_rsrc2.user_sgpr.user_sgpr_count</span></code>.
Any requests beyond 16
will be ignored.</p>
</td>
</tr>
<tr class="row-odd"><td><p>449</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_dispatch_ptr</p></td>
<td><p><em>see above</em></p></td>
</tr>
<tr class="row-even"><td><p>450</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_queue_ptr</p></td>
<td><p><em>see above</em></p></td>
</tr>
<tr class="row-odd"><td><p>451</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_kernarg_segment_ptr</p></td>
<td><p><em>see above</em></p></td>
</tr>
<tr class="row-even"><td><p>452</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_dispatch_id</p></td>
<td><p><em>see above</em></p></td>
</tr>
<tr class="row-odd"><td><p>453</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_flat_scratch_init</p></td>
<td><p><em>see above</em></p></td>
</tr>
<tr class="row-even"><td><p>454</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_private_segment
_size</p></td>
<td><p><em>see above</em></p></td>
</tr>
<tr class="row-odd"><td><p>455</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_grid_workgroup
_count_X</p></td>
<td><p>Not implemented in CP and
should always be 0.</p></td>
</tr>
<tr class="row-even"><td><p>456</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_grid_workgroup
_count_Y</p></td>
<td><p>Not implemented in CP and
should always be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>457</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_grid_workgroup
_count_Z</p></td>
<td><p>Not implemented in CP and
should always be 0.</p></td>
</tr>
<tr class="row-even"><td><p>463:458</p></td>
<td><p>6 bits</p></td>
<td></td>
<td><p>Reserved. Must be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>511:464</p></td>
<td><p>4
bytes</p></td>
<td></td>
<td><p>Reserved. Must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>512</p></td>
<td colspan="3"><p><strong>Total size 64 bytes.</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-compute-pgm-rsrc1-t-gfx6-gfx9-table">
<caption><span class="caption-text">compute_pgm_rsrc1 for GFX6-GFX9</span><a class="headerlink" href="#amdgpu-amdhsa-compute-pgm-rsrc1-t-gfx6-gfx9-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>5:0</p></td>
<td><p>6 bits</p></td>
<td><p>granulated_workitem_vgpr_count</p></td>
<td><p>Number of vector registers
used by each work-item,
granularity is device
specific:</p>
<dl class="simple">
<dt>GFX6-9</dt><dd><p>roundup((max-vgpg + 1)
/ 4) - 1</p>
</dd>
</dl>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.VGPRS</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>9:6</p></td>
<td><p>4 bits</p></td>
<td><p>granulated_wavefront_sgpr_count</p></td>
<td><p>Number of scalar registers
used by a wavefront,
granularity is device
specific:</p>
<dl class="simple">
<dt>GFX6-8</dt><dd><p>roundup((max-sgpg + 1)
/ 8) - 1</p>
</dd>
<dt>GFX9</dt><dd><p>roundup((max-sgpg + 1)
/ 16) - 1</p>
</dd>
</dl>
<p>Includes the special SGPRs
for VCC, Flat Scratch (for
GFX7 onwards) and XNACK
(for GFX8 onwards). It does
not include the 16 SGPR
added if a trap handler is
enabled.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.SGPRS</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>11:10</p></td>
<td><p>2 bits</p></td>
<td><p>priority</p></td>
<td><p>Must be 0.</p>
<p>Start executing wavefront
at the specified priority.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.PRIORITY</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>13:12</p></td>
<td><p>2 bits</p></td>
<td><p>float_mode_round_32</p></td>
<td><p>Wavefront starts execution
with specified rounding
mode for single (32
bit) floating point
precision floating point
operations.</p>
<p>Floating point rounding
mode values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table"><span class="std std-ref">Floating Point Rounding Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>15:14</p></td>
<td><p>2 bits</p></td>
<td><p>float_mode_round_16_64</p></td>
<td><p>Wavefront starts execution
with specified rounding
denorm mode for half/double (16
and 64 bit) floating point
precision floating point
operations.</p>
<p>Floating point rounding
mode values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table"><span class="std std-ref">Floating Point Rounding Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>17:16</p></td>
<td><p>2 bits</p></td>
<td><p>float_mode_denorm_32</p></td>
<td><p>Wavefront starts execution
with specified denorm mode
for single (32
bit)  floating point
precision floating point
operations.</p>
<p>Floating point denorm mode
values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table"><span class="std std-ref">Floating Point Denorm Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>19:18</p></td>
<td><p>2 bits</p></td>
<td><p>float_mode_denorm_16_64</p></td>
<td><p>Wavefront starts execution
with specified denorm mode
for half/double (16
and 64 bit) floating point
precision floating point
operations.</p>
<p>Floating point denorm mode
values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table"><span class="std std-ref">Floating Point Denorm Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>20</p></td>
<td><p>1 bit</p></td>
<td><p>priv</p></td>
<td><p>Must be 0.</p>
<p>Start executing wavefront
in privilege trap handler
mode.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.PRIV</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>21</p></td>
<td><p>1 bit</p></td>
<td><p>enable_dx10_clamp</p></td>
<td><p>Wavefront starts execution
with DX10 clamp mode
enabled. Used by the vector
ALU to force DX-10 style
treatment of NaN’s (when
set, clamp NaN to zero,
otherwise pass NaN
through).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.DX10_CLAMP</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>22</p></td>
<td><p>1 bit</p></td>
<td><p>debug_mode</p></td>
<td><p>Must be 0.</p>
<p>Start executing wavefront
in single step mode.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.DEBUG_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>23</p></td>
<td><p>1 bit</p></td>
<td><p>enable_ieee_mode</p></td>
<td><p>Wavefront starts execution
with IEEE mode
enabled. Floating point
opcodes that support
exception flag gathering
will quiet and propagate
signaling-NaN inputs per
IEEE 754-2008. Min_dx10 and
max_dx10 become IEEE
754-2008 compliant due to
signaling-NaN propagation
and quieting.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.IEEE_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>24</p></td>
<td><p>1 bit</p></td>
<td><p>bulky</p></td>
<td><p>Must be 0.</p>
<p>Only one work-group allowed
to execute on a compute
unit.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.BULKY</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>25</p></td>
<td><p>1 bit</p></td>
<td><p>cdbg_user</p></td>
<td><p>Must be 0.</p>
<p>Flag that can be used to
control debugging code.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.CDBG_USER</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>31:26</p></td>
<td><p>6 bits</p></td>
<td></td>
<td><p>Reserved. Must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td colspan="3"><p><strong>Total size 4 bytes</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx9-table">
<caption><span class="caption-text">compute_pgm_rsrc2 for GFX6-GFX9</span><a class="headerlink" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx9-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_private_segment
_wave_offset</p></td>
<td><p>Enable the setup of the
SGPR wave scratch offset
system register (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.SCRATCH_EN</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>5:1</p></td>
<td><p>5 bits</p></td>
<td><p>user_sgpr_count</p></td>
<td><p>The total number of SGPR
user data registers
requested. This number must
match the number of user
data registers enabled.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.USER_SGPR</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>1 bit</p></td>
<td><p>enable_trap_handler</p></td>
<td><p>Set to 1 if code contains a
TRAP instruction which
requires a trap handler to
be enabled.</p>
<p>CP sets
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TRAP_PRESENT</span></code>
if the runtime has
installed a trap handler
regardless of the setting
of this field.</p>
</td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_workgroup_id_x</p></td>
<td><p>Enable the setup of the
system SGPR register for
the work-group id in the X
dimension (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_X_EN</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_workgroup_id_y</p></td>
<td><p>Enable the setup of the
system SGPR register for
the work-group id in the Y
dimension (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_Y_EN</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_workgroup_id_z</p></td>
<td><p>Enable the setup of the
system SGPR register for
the work-group id in the Z
dimension (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_Z_EN</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>1 bit</p></td>
<td><p>enable_sgpr_workgroup_info</p></td>
<td><p>Enable the setup of the
system SGPR register for
work-group information (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_SIZE_EN</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>12:11</p></td>
<td><p>2 bits</p></td>
<td><p>enable_vgpr_workitem_id</p></td>
<td><p>Enable the setup of the
VGPR system registers used
for the work-item ID.
<a class="reference internal" href="#amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table"><span class="std std-ref">System VGPR Work-Item ID Enumeration Values</span></a>
defines the values.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TIDIG_CMP_CNT</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_address_watch</p></td>
<td><p>Must be 0.</p>
<p>Wavefront starts execution
with address watch
exceptions enabled which
are generated when L1 has
witnessed a thread access
an <em>address of
interest</em>.</p>
<p>CP is responsible for
filling in the address
watch bit in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.EXCP_EN_MSB</span></code>
according to what the
runtime requests.</p>
</td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_memory</p></td>
<td><p>Must be 0.</p>
<p>Wavefront starts execution
with memory violation
exceptions exceptions
enabled which are generated
when a memory violation has
occurred for this wave from
L1 or LDS
(write-to-read-only-memory,
mis-aligned atomic, LDS
address out of range,
illegal address, etc.).</p>
<p>CP sets the memory
violation bit in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.EXCP_EN_MSB</span></code>
according to what the
runtime requests.</p>
</td>
</tr>
<tr class="row-even"><td><p>23:15</p></td>
<td><p>9 bits</p></td>
<td><p>granulated_lds_size</p></td>
<td><p>Must be 0.</p>
<p>CP uses the rounded value
from the dispatch packet,
not this value, as the
dispatch may contain
dynamically allocated group
segment memory. CP writes
directly to
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.LDS_SIZE</span></code>.</p>
<p>Amount of group segment
(LDS) to allocate for each
work-group. Granularity is
device specific:</p>
<dl class="simple">
<dt>GFX6:</dt><dd><p>roundup(lds-size / (64 * 4))</p>
</dd>
<dt>GFX7-GFX9:</dt><dd><p>roundup(lds-size / (128 * 4))</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>24</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_ieee_754_fp
_invalid_operation</p></td>
<td><p>Wavefront starts execution
with specified exceptions
enabled.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.EXCP_EN</span></code>
(set from bits 0..6).</p>
<p>IEEE 754 FP Invalid
Operation</p>
</td>
</tr>
<tr class="row-even"><td><p>25</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_fp_denormal
_source</p></td>
<td><p>FP Denormal one or more
input operands is a
denormal number</p></td>
</tr>
<tr class="row-odd"><td><p>26</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_ieee_754_fp
_division_by_zero</p></td>
<td><p>IEEE 754 FP Division by
Zero</p></td>
</tr>
<tr class="row-even"><td><p>27</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_ieee_754_fp
_overflow</p></td>
<td><p>IEEE 754 FP FP Overflow</p></td>
</tr>
<tr class="row-odd"><td><p>28</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_ieee_754_fp
_underflow</p></td>
<td><p>IEEE 754 FP Underflow</p></td>
</tr>
<tr class="row-even"><td><p>29</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_ieee_754_fp
_inexact</p></td>
<td><p>IEEE 754 FP Inexact</p></td>
</tr>
<tr class="row-odd"><td><p>30</p></td>
<td><p>1 bit</p></td>
<td><p>enable_exception_int_divide_by
_zero</p></td>
<td><p>Integer Division by Zero
(rcp_iflag_f32 instruction
only)</p></td>
</tr>
<tr class="row-even"><td><p>31</p></td>
<td><p>1 bit</p></td>
<td></td>
<td><p>Reserved. Must be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>32</p></td>
<td colspan="3"><p><strong>Total size 4 bytes.</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table">
<caption><span class="caption-text">Floating Point Rounding Mode Enumeration Values</span><a class="headerlink" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Enumeration Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AMD_FLOAT_ROUND_MODE_NEAR_EVEN</p></td>
<td><p>0</p></td>
<td><p>Round Ties To Even</p></td>
</tr>
<tr class="row-odd"><td><p>AMD_FLOAT_ROUND_MODE_PLUS_INFINITY</p></td>
<td><p>1</p></td>
<td><p>Round Toward +infinity</p></td>
</tr>
<tr class="row-even"><td><p>AMD_FLOAT_ROUND_MODE_MINUS_INFINITY</p></td>
<td><p>2</p></td>
<td><p>Round Toward -infinity</p></td>
</tr>
<tr class="row-odd"><td><p>AMD_FLOAT_ROUND_MODE_ZERO</p></td>
<td><p>3</p></td>
<td><p>Round Toward 0</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table">
<caption><span class="caption-text">Floating Point Denorm Mode Enumeration Values</span><a class="headerlink" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Enumeration Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AMD_FLOAT_DENORM_MODE_FLUSH_SRC_DST</p></td>
<td><p>0</p></td>
<td><p>Flush Source and Destination
Denorms</p></td>
</tr>
<tr class="row-odd"><td><p>AMD_FLOAT_DENORM_MODE_FLUSH_DST</p></td>
<td><p>1</p></td>
<td><p>Flush Output Denorms</p></td>
</tr>
<tr class="row-even"><td><p>AMD_FLOAT_DENORM_MODE_FLUSH_SRC</p></td>
<td><p>2</p></td>
<td><p>Flush Source Denorms</p></td>
</tr>
<tr class="row-odd"><td><p>AMD_FLOAT_DENORM_MODE_FLUSH_NONE</p></td>
<td><p>3</p></td>
<td><p>No Flush</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table">
<caption><span class="caption-text">System VGPR Work-Item ID Enumeration Values</span><a class="headerlink" href="#amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Enumeration Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AMD_SYSTEM_VGPR_WORKITEM_ID_X</p></td>
<td><p>0</p></td>
<td><p>Set work-item X dimension ID.</p></td>
</tr>
<tr class="row-odd"><td><p>AMD_SYSTEM_VGPR_WORKITEM_ID_X_Y</p></td>
<td><p>1</p></td>
<td><p>Set work-item X and Y
dimensions ID.</p></td>
</tr>
<tr class="row-even"><td><p>AMD_SYSTEM_VGPR_WORKITEM_ID_X_Y_Z</p></td>
<td><p>2</p></td>
<td><p>Set work-item X, Y and Z
dimensions ID.</p></td>
</tr>
<tr class="row-odd"><td><p>AMD_SYSTEM_VGPR_WORKITEM_ID_UNDEFINED</p></td>
<td><p>3</p></td>
<td><p>Undefined.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
</section>
<section id="initial-kernel-execution-state">
<span id="amdgpu-amdhsa-initial-kernel-execution-state"></span><h4><a class="toc-backref" href="#id64" role="doc-backlink">Initial Kernel Execution State</a><a class="headerlink" href="#initial-kernel-execution-state" title="Lien vers cette rubrique">¶</a></h4>
<p>This section defines the register state that will be set up by the packet
processor prior to the start of execution of every wavefront. This is limited by
the constraints of the hardware controllers of CP/ADC/SPI.</p>
<p>The order of the SGPR registers is defined, but the compiler can specify which
ones are actually setup in the kernel descriptor using the <code class="docutils literal notranslate"><span class="pre">enable_sgpr_*</span></code> bit
fields (see <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>). The register numbers used
for enabled registers are dense starting at SGPR0: the first enabled register is
SGPR0, the next enabled register is SGPR1 etc.; disabled registers do not have
an SGPR number.</p>
<p>The initial SGPRs comprise up to 16 User SRGPs that are set by CP and apply to
all waves of the grid. It is possible to specify more than 16 User SGPRs using
the <code class="docutils literal notranslate"><span class="pre">enable_sgpr_*</span></code> bit fields, in which case only the first 16 are actually
initialized. These are then immediately followed by the System SGPRs that are
set up by ADC/SPI and can have different values for each wave of the grid
dispatch.</p>
<p>SGPR register initial state is defined in
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-sgpr-register-set-up-order-table">
<caption><span class="caption-text">SGPR Register Set Up Order</span><a class="headerlink" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>SGPR Order</p></th>
<th class="head"><p>Name
(kernel descriptor enable
field)</p></th>
<th class="head"><p>Number
of
SGPRs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>First</p></td>
<td><p>Private Segment Buffer
(enable_sgpr_private
_segment_buffer)</p></td>
<td><p>4</p></td>
<td><p>V# that can be used, together
with Scratch Wave Offset as an
offset, to access the private
memory space using a segment
address.</p>
<p>CP uses the value provided by
the runtime.</p>
</td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Dispatch Ptr
(enable_sgpr_dispatch_ptr)</p></td>
<td><p>2</p></td>
<td><p>64 bit address of AQL dispatch
packet for kernel dispatch
actually executing.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Queue Ptr
(enable_sgpr_queue_ptr)</p></td>
<td><p>2</p></td>
<td><p>64 bit address of amd_queue_t
object for AQL queue on which
the dispatch packet was
queued.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Kernarg Segment Ptr
(enable_sgpr_kernarg
_segment_ptr)</p></td>
<td><p>2</p></td>
<td><p>64 bit address of Kernarg
segment. This is directly
copied from the
kernarg_address in the kernel
dispatch packet.</p>
<p>Having CP load it once avoids
loading it at the beginning of
every wavefront.</p>
</td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Dispatch Id
(enable_sgpr_dispatch_id)</p></td>
<td><p>2</p></td>
<td><p>64 bit Dispatch ID of the
dispatch packet being
executed.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Flat Scratch Init
(enable_sgpr_flat_scratch
_init)</p></td>
<td><p>2</p></td>
<td><p>This is 2 SGPRs:</p>
<dl>
<dt>GFX6</dt><dd><p>Not supported.</p>
</dd>
<dt>GFX7-GFX8</dt><dd><p>The first SGPR is a 32 bit
byte offset from
<code class="docutils literal notranslate"><span class="pre">SH_HIDDEN_PRIVATE_BASE_VIMID</span></code>
to per SPI base of memory
for scratch for the queue
executing the kernel
dispatch. CP obtains this
from the runtime.</p>
<p>This is the same offset used
in computing the Scratch
Segment Buffer base
address. The value of
Scratch Wave Offset must be
added by the kernel machine
code and moved to SGPRn-4
for use as the FLAT SCRATCH
BASE in flat memory
instructions.</p>
<p>The second SGPR is 32 bit
byte size of a single
work-item’s scratch memory
usage. This is directly
loaded from the kernel
dispatch packet Private
Segment Byte Size and
rounded up to a multiple of
DWORD.</p>
<p>The kernel code must move to
SGPRn-3 for use as the FLAT
SCRATCH SIZE in flat memory
instructions. Having CP load
it once avoids loading it at
the beginning of every
wavefront.</p>
</dd>
<dt>GFX9</dt><dd><p>This is the 64 bit base
address of the per SPI
scratch backing memory
managed by SPI for the queue
executing the kernel
dispatch. CP obtains this
from the runtime (and
divides it if there are
multiple Shader Arrays each
with its own SPI). The value
of Scratch Wave Offset must
be added by the kernel
machine code and moved to
SGPRn-4 and SGPRn-3 for use
as the FLAT SCRATCH BASE in
flat memory instructions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Private Segment Size
(enable_sgpr_private
_segment_size)</p></td>
<td><p>1</p></td>
<td><p>The 32 bit byte size of a
single work-item’s scratch
memory allocation. This is the
value from the kernel dispatch
packet Private Segment Byte
Size rounded up by CP to a
multiple of DWORD.</p>
<p>Having CP load it once avoids
loading it at the beginning of
every wavefront.</p>
<p>This is not used for
GFX7-GFX8 since it is the same
value as the second SGPR of
Flat Scratch Init. However, it
may be needed for GFX9 which
changes the meaning of the
Flat Scratch Init value.</p>
</td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Grid Work-Group Count X
(enable_sgpr_grid
_workgroup_count_X)</p></td>
<td><p>1</p></td>
<td><p>32 bit count of the number of
work-groups in the X dimension
for the grid being
executed. Computed from the
fields in the kernel dispatch
packet as ((grid_size.x +
workgroup_size.x - 1) /
workgroup_size.x).</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Grid Work-Group Count Y
(enable_sgpr_grid
_workgroup_count_Y &amp;&amp;
less than 16 previous
SGPRs)</p></td>
<td><p>1</p></td>
<td><p>32 bit count of the number of
work-groups in the Y dimension
for the grid being
executed. Computed from the
fields in the kernel dispatch
packet as ((grid_size.y +
workgroup_size.y - 1) /
workgroupSize.y).</p>
<p>Only initialized if &lt;16
previous SGPRs initialized.</p>
</td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Grid Work-Group Count Z
(enable_sgpr_grid
_workgroup_count_Z &amp;&amp;
less than 16 previous
SGPRs)</p></td>
<td><p>1</p></td>
<td><p>32 bit count of the number of
work-groups in the Z dimension
for the grid being
executed. Computed from the
fields in the kernel dispatch
packet as ((grid_size.z +
workgroup_size.z - 1) /
workgroupSize.z).</p>
<p>Only initialized if &lt;16
previous SGPRs initialized.</p>
</td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Work-Group Id X
(enable_sgpr_workgroup_id
_X)</p></td>
<td><p>1</p></td>
<td><p>32 bit work-group id in X
dimension of grid for
wavefront.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Work-Group Id Y
(enable_sgpr_workgroup_id
_Y)</p></td>
<td><p>1</p></td>
<td><p>32 bit work-group id in Y
dimension of grid for
wavefront.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Work-Group Id Z
(enable_sgpr_workgroup_id
_Z)</p></td>
<td><p>1</p></td>
<td><p>32 bit work-group id in Z
dimension of grid for
wavefront.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Work-Group Info
(enable_sgpr_workgroup
_info)</p></td>
<td><p>1</p></td>
<td><p>{first_wave, 14’b0000,
ordered_append_term[10:0],
threadgroup_size_in_waves[5:0]}</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Scratch Wave Offset
(enable_sgpr_private
_segment_wave_offset)</p></td>
<td><p>1</p></td>
<td><p>32 bit byte offset from base
of scratch base of queue
executing the kernel
dispatch. Must be used as an
offset with Private
segment address when using
Scratch Segment Buffer. It
must be used to set up FLAT
SCRATCH for flat addressing
(see
<a class="reference internal" href="#amdgpu-amdhsa-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>).</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The order of the VGPR registers is defined, but the compiler can specify which
ones are actually setup in the kernel descriptor using the <code class="docutils literal notranslate"><span class="pre">enable_vgpr*</span></code> bit
fields (see <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>). The register numbers used
for enabled registers are dense starting at VGPR0: the first enabled register is
VGPR0, the next enabled register is VGPR1 etc.; disabled registers do not have a
VGPR number.</p>
<p>VGPR register initial state is defined in
<a class="reference internal" href="#amdgpu-amdhsa-vgpr-register-set-up-order-table"><span class="std std-ref">VGPR Register Set Up Order</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-vgpr-register-set-up-order-table">
<caption><span class="caption-text">VGPR Register Set Up Order</span><a class="headerlink" href="#amdgpu-amdhsa-vgpr-register-set-up-order-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>VGPR Order</p></th>
<th class="head"><p>Name
(kernel descriptor enable
field)</p></th>
<th class="head"><p>Number
of
VGPRs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>First</p></td>
<td><p>Work-Item Id X
(Always initialized)</p></td>
<td><p>1</p></td>
<td><p>32 bit work item id in X
dimension of work-group for
wavefront lane.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Work-Item Id Y
(enable_vgpr_workitem_id
&gt; 0)</p></td>
<td><p>1</p></td>
<td><p>32 bit work item id in Y
dimension of work-group for
wavefront lane.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Work-Item Id Z
(enable_vgpr_workitem_id
&gt; 1)</p></td>
<td><p>1</p></td>
<td><p>32 bit work item id in Z
dimension of work-group for
wavefront lane.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The setting of registers is is done by GPU CP/ADC/SPI hardware as follows:</p>
<ol class="arabic simple">
<li><p>SGPRs before the Work-Group Ids are set by CP using the 16 User Data
registers.</p></li>
<li><p>Work-group Id registers X, Y, Z are set by ADC which supports any
combination including none.</p></li>
<li><p>Scratch Wave Offset is set by SPI in a per wave basis which is why its value
cannot included with the flat scratch init value which is per queue.</p></li>
<li><p>The VGPRs are set by SPI which only supports specifying either (X), (X, Y)
or (X, Y, Z).</p></li>
</ol>
<p>Flat Scratch register pair are adjacent SGRRs so they can be moved as a 64 bit
value to the hardware required SGPRn-3 and SGPRn-4 respectively.</p>
<p>The global segment can be accessed either using buffer instructions (GFX6 which
has V# 64 bit address support), flat instructions (GFX7-9), or global
instructions (GFX9).</p>
<p>If buffer operations are used then the compiler can generate a V# with the
following properties:</p>
<ul class="simple">
<li><p>base address of 0</p></li>
<li><p>no swizzle</p></li>
<li><p>ATC: 1 if IOMMU present (such as APU)</p></li>
<li><p>ptr64: 1</p></li>
<li><p>MTYPE set to support memory coherence that matches the runtime (such as CC for
APU and NC for dGPU).</p></li>
</ul>
</section>
<section id="kernel-prolog">
<span id="amdgpu-amdhsa-kernel-prolog"></span><h4><a class="toc-backref" href="#id65" role="doc-backlink">Kernel Prolog</a><a class="headerlink" href="#kernel-prolog" title="Lien vers cette rubrique">¶</a></h4>
<section id="m0">
<span id="amdgpu-amdhsa-m0"></span><h5><a class="toc-backref" href="#id66" role="doc-backlink">M0</a><a class="headerlink" href="#m0" title="Lien vers cette rubrique">¶</a></h5>
<dl class="simple">
<dt>GFX6-GFX8</dt><dd><p>The M0 register must be initialized with a value at least the total LDS size
if the kernel may access LDS via DS or flat operations. Total LDS size is
available in dispatch packet. For M0, it is also possible to use maximum
possible value of LDS for given target (0x7FFF for GFX6 and 0xFFFF for
GFX7-GFX8).</p>
</dd>
<dt>GFX9</dt><dd><p>The M0 register is not used for range checking LDS accesses and so does not
need to be initialized in the prolog.</p>
</dd>
</dl>
</section>
<section id="flat-scratch">
<span id="amdgpu-amdhsa-flat-scratch"></span><h5><a class="toc-backref" href="#id67" role="doc-backlink">Flat Scratch</a><a class="headerlink" href="#flat-scratch" title="Lien vers cette rubrique">¶</a></h5>
<p>If the kernel may use flat operations to access scratch memory, the prolog code
must set up FLAT_SCRATCH register pair (FLAT_SCRATCH_LO/FLAT_SCRATCH_HI which
are in SGPRn-4/SGPRn-3). Initialization uses Flat Scratch Init and Scratch Wave
Offset SGPR registers (see <a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>):</p>
<dl class="simple">
<dt>GFX6</dt><dd><p>Flat scratch is not supported.</p>
</dd>
<dt>GFX7-8</dt><dd><ol class="arabic simple">
<li><p>The low word of Flat Scratch Init is 32 bit byte offset from
<code class="docutils literal notranslate"><span class="pre">SH_HIDDEN_PRIVATE_BASE_VIMID</span></code> to the base of scratch backing memory
being managed by SPI for the queue executing the kernel dispatch. This is
the same value used in the Scratch Segment Buffer V# base address. The
prolog must add the value of Scratch Wave Offset to get the wave’s byte
scratch backing memory offset from <code class="docutils literal notranslate"><span class="pre">SH_HIDDEN_PRIVATE_BASE_VIMID</span></code>. Since
FLAT_SCRATCH_LO is in units of 256 bytes, the offset must be right shifted
by 8 before moving into FLAT_SCRATCH_LO.</p></li>
<li><p>The second word of Flat Scratch Init is 32 bit byte size of a single
work-items scratch memory usage. This is directly loaded from the kernel
dispatch packet Private Segment Byte Size and rounded up to a multiple of
DWORD. Having CP load it once avoids loading it at the beginning of every
wavefront. The prolog must move it to FLAT_SCRATCH_LO for use as FLAT SCRATCH
SIZE.</p></li>
</ol>
</dd>
<dt>GFX9</dt><dd><p>The Flat Scratch Init is the 64 bit address of the base of scratch backing
memory being managed by SPI for the queue executing the kernel dispatch. The
prolog must add the value of Scratch Wave Offset and moved to the FLAT_SCRATCH
pair for use as the flat scratch base in flat memory instructions.</p>
</dd>
</dl>
</section>
</section>
<section id="memory-model">
<span id="amdgpu-amdhsa-memory-model"></span><h4><a class="toc-backref" href="#id68" role="doc-backlink">Memory Model</a><a class="headerlink" href="#memory-model" title="Lien vers cette rubrique">¶</a></h4>
<p>This section describes the mapping of LLVM memory model onto AMDGPU machine code
(see <a class="reference internal" href="LangRef.html#memmodel"><span class="std std-ref">Memory Model for Concurrent Operations</span></a>). <em>The implementation is WIP.</em></p>
<p>The AMDGPU backend supports the memory synchronization scopes specified in
<a class="reference internal" href="#amdgpu-memory-scopes"><span class="std std-ref">Memory Scopes</span></a>.</p>
<p>The code sequences used to implement the memory model are defined in table
<a class="reference internal" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table"><span class="std std-ref">AMDHSA Memory Model Code Sequences GFX6-GFX9</span></a>.</p>
<p>The sequences specify the order of instructions that a single thread must
execute. The <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> and <code class="docutils literal notranslate"><span class="pre">buffer_wbinvl1_vol</span></code> are defined with respect
to other memory instructions executed by the same thread. This allows them to be
moved earlier or later which can allow them to be combined with other instances
of the same instruction, or hoisted/sunk out of loops to improve
performance. Only the instructions related to the memory model are given;
additional <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> instructions are required to ensure registers are
defined before being used. These may be able to be combined with the memory
model <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> instructions as described above.</p>
<p>The AMDGPU memory model supports both the HSA <a class="reference internal" href="#hsa" id="id27"><span>[HSA]</span></a> memory model, and the
OpenCL <a class="reference internal" href="#id36" id="id28"><span>[OpenCL]</span></a> memory model. The HSA memory model uses a single happens-before
relation for all address spaces (see <a class="reference internal" href="#amdgpu-address-spaces"><span class="std std-ref">Address Spaces</span></a>). The OpenCL
memory model which has separate happens-before relations for the global and
local address spaces, and only a fence specifying both global and local address
space joins the relationships. Since the LLVM <code class="docutils literal notranslate"><span class="pre">memfence</span></code> instruction does not
allow an address space to be specified the OpenCL fence has to convervatively
assume both local and global address space was specified. However, optimizations
can often be done to eliminate the additional <code class="docutils literal notranslate"><span class="pre">s_waitcnt``instructions</span> <span class="pre">when</span>
<span class="pre">there</span> <span class="pre">are</span> <span class="pre">no</span> <span class="pre">intervening</span> <span class="pre">corresponding</span> <span class="pre">``ds/flat_load/store/atomic</span></code> memory
instructions. The code sequences in the table indicate what can be omitted for
the OpenCL memory. The target triple environment is used to determine if the
source language is OpenCL (see <a class="reference internal" href="#amdgpu-opencl"><span class="std std-ref">OpenCL</span></a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">ds/flat_load/store/atomic</span></code> instructions to local memory are termed LDS
operations.</p>
<p><code class="docutils literal notranslate"><span class="pre">buffer/global/flat_load/store/atomic</span></code> instructions to global memory are
termed vector memory operations.</p>
<p>For GFX6-GFX9:</p>
<ul class="simple">
<li><p>Each agent has multiple compute units (CU).</p></li>
<li><p>Each CU has multiple SIMDs that execute wavefronts.</p></li>
<li><p>The wavefronts for a single work-group are executed in the same CU but may be
executed by different SIMDs.</p></li>
<li><p>Each CU has a single LDS memory shared by the wavefronts of the work-groups
executing on it.</p></li>
<li><p>All LDS operations of a CU are performed as wavefront wide operations in a
global order and involve no caching. Completion is reported to a wavefront in
execution order.</p></li>
<li><p>The LDS memory has multiple request queues shared by the SIMDs of a
CU. Therefore, the LDS operations performed by different waves of a work-group
can be reordered relative to each other, which can result in reordering the
visibility of vector memory operations with respect to LDS operations of other
wavefronts in the same work-group. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span> <span class="pre">lgkmcnt(0)</span></code> is required to
ensure synchronization between LDS operations and vector memory operations
between waves of a work-group, but not between operations performed by the
same wavefront.</p></li>
<li><p>The vector memory operations are performed as wavefront wide operations and
completion is reported to a wavefront in execution order. The exception is
that for GFX7-9 <code class="docutils literal notranslate"><span class="pre">flat_load/store/atomic</span></code> instructions can report out of
vector memory order if they access LDS memory, and out of LDS operation order
if they access global memory.</p></li>
<li><p>The vector memory operations access a vector L1 cache shared by all wavefronts
on a CU. Therefore, no special action is required for coherence between
wavefronts in the same work-group. A <code class="docutils literal notranslate"><span class="pre">buffer_wbinvl1_vol</span></code> is required for
coherence between waves executing in different work-groups as they may be
executing on different CUs.</p></li>
<li><p>The scalar memory operations access a scalar L1 cache shared by all wavefronts
on a group of CUs. The scalar and vector L1 caches are not coherent. However,
scalar operations are used in a restricted way so do not impact the memory
model. See <a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p></li>
<li><p>The vector and scalar memory operations use an L2 cache shared by all CUs on
the same agent.</p></li>
<li><p>The L2 cache has independent channels to service disjoint ranges of virtual
addresses.</p></li>
<li><p>Each CU has a separate request queue per channel. Therefore, the vector and
scalar memory operations performed by waves executing in different work-groups
(which may be executing on different CUs) of an agent can be reordered
relative to each other. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span> <span class="pre">vmcnt(0)</span></code> is required to ensure
synchronization between vector memory operations of different CUs. It ensures a
previous vector memory operation has completed before executing a subsequent
vector memory or LDS operation and so can be used to meet the requirements of
acquire and release.</p></li>
<li><p>The L2 cache can be kept coherent with other agents on some targets, or ranges
of virtual addresses can be set up to bypass it to ensure system coherence.</p></li>
</ul>
<p>Private address space uses <code class="docutils literal notranslate"><span class="pre">buffer_load/store</span></code> using the scratch V# (GFX6-8),
or <code class="docutils literal notranslate"><span class="pre">scratch_load/store</span></code> (GFX9). Since only a single thread is accessing the
memory, atomic memory orderings are not meaningful and all accesses are treated
as non-atomic.</p>
<p>Constant address space uses <code class="docutils literal notranslate"><span class="pre">buffer/global_load</span></code> instructions (or equivalent
scalar memory instructions). Since the constant address space contents do not
change during the execution of a kernel dispatch it is not legal to perform
stores, and atomic memory orderings are not meaningful and all access are
treated as non-atomic.</p>
<p>A memory synchronization scope wider than work-group is not meaningful for the
group (LDS) address space and is treated as work-group.</p>
<p>The memory model does not support the region address space which is treated as
non-atomic.</p>
<p>Acquire memory ordering is not meaningful on store atomic instructions and is
treated as non-atomic.</p>
<p>Release memory ordering is not meaningful on load atomic instructions and is
treated a non-atomic.</p>
<p>Acquire-release memory ordering is not meaningful on load or store atomic
instructions and is treated as acquire and release respectively.</p>
<p>AMDGPU backend only uses scalar memory operations to access memory that is
proven to not change during the execution of the kernel dispatch. This includes
constant address space and global address space for program scope const
variables. Therefore the kernel machine code does not have to maintain the
scalar L1 cache to ensure it is coherent with the vector L1 cache. The scalar
and vector L1 caches are invalidated between kernel dispatches by CP since
constant address space data may change between kernel dispatch executions. See
<a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p>
<p>The one execption is if scalar writes are used to spill SGPR registers. In this
case the AMDGPU backend ensures the memory location used to spill is never
accessed by vector memory operations at the same time. If scalar writes are used
then a <code class="docutils literal notranslate"><span class="pre">s_dcache_wb</span></code> is inserted before the <code class="docutils literal notranslate"><span class="pre">s_endpgm</span></code> and before a function
return since the locations may be used for vector memory instructions by a
future wave that uses the same scratch area, or a function call that creates a
frame at the same address, respectively. There is no need for a <code class="docutils literal notranslate"><span class="pre">s_dcache_inv</span></code>
as all scalar writes are write-before-read in the same thread.</p>
<p>Scratch backing memory (which is used for the private address space) is accessed
with MTYPE NC_NV (non-coherenent non-volatile). Since the private address space
is only accessed by a single thread, and is always write-before-read,
there is never a need to invalidate these entries from the L1 cache. Hence all
cache invalidates are done as <code class="docutils literal notranslate"><span class="pre">*_vol</span></code> to only invalidate the volatile cache
lines.</p>
<p>On dGPU the kernarg backing memory is accessed as UC (uncached) to avoid needing
to invalidate the L2 cache. This also causes it to be treated as non-volatile
and so is not invalidated by <code class="docutils literal notranslate"><span class="pre">*_vol</span></code>. On APU it is accessed as CC (cache
coherent) and so the L2 cache will coherent with the CPU and other agents.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table">
<caption><span class="caption-text">AMDHSA Memory Model Code Sequences GFX6-GFX9</span><a class="headerlink" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Instr</p></th>
<th class="head"><p>LLVM Memory
Ordering</p></th>
<th class="head"><p>LLVM Memory
Sync Scope</p></th>
<th class="head"><p>AMDGPU
Address
Space</p></th>
<th class="head"><p>AMDGPU Machine Code</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="5"><p><strong>Non-Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><dl class="simple">
<dt>non-volatile</dt><dd><ol class="arabic simple">
<li><p>buffer/global/flat_load</p></li>
</ol>
</dd>
<dt>volatile</dt><dd><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
</ol>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Unordered Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as monotonic
atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Monotonic Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_load</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Acquire Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds/flat_load</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load
glc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the load
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_load glc=1</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the flat_load
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds/flat_atomic</p></li>
<li><p>waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
waitcnt. However,
since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the
value read by the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).
However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
group/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
fence-paired atomic
has completed
before invalidating
the
cache. Therefore
any following
locations read must
be no older than
the value read by
the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Release Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/ds/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global and local
have completed
before performing
the atomicrmw that
is being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/ds/flat_atomic*</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
waitcnt. However,
since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Must happen after
any preceding
local/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).
However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Acquire-Release Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
waitcnt.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
waitcnt. However,
since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Must happen after
any preceding
local/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing any
following global
memory operations.</p></li>
<li><p>Ensures that the
preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic)
has completed
before following
global memory
operations. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
local/generic store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).
However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
preceding
global/local/generic
load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic)
has completed
before invalidating
the cache. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
global/local/generic
store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data. This
satisfies the
requirements of
acquire.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Sequential Consistent Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
load atomic acquire</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen after
preceding
global/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent global
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
waitcnt vmcnt(0) of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
competing out of
order.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire</em>.</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
store atomic release</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
store atomic release</em>.</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
atomicrmw acq_rel</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
atomicrmw acq_rel</em>.</p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>Same as corresponding
fence acq_rel</em>.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The memory order also adds the single thread optimization constrains defined in
table
<a class="reference internal" href="#amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-gfx6-gfx9-table"><span class="std std-ref">AMDHSA Memory Model Single Thread Optimization Constraints GFX6-GFX9</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-gfx6-gfx9-table">
<caption><span class="caption-text">AMDHSA Memory Model Single Thread Optimization Constraints GFX6-GFX9</span><a class="headerlink" href="#amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-gfx6-gfx9-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Memory</p></th>
<th class="head"><p>Optimization Constraints</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Ordering</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>unordered</p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>monotonic</p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p>acquire</p></td>
<td><ul class="simple">
<li><p>If a load atomic/atomicrmw then no following load/load
atomic/store/ store atomic/atomicrmw/fence instruction can
be moved before the acquire.</p></li>
<li><p>If a fence then same as load atomic, plus no preceding
associated fence-paired-atomic can be moved after the fence.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>release</p></td>
<td><ul class="simple">
<li><p>If a store atomic/atomicrmw then no preceding load/load
atomic/store/ store atomic/atomicrmw/fence instruction can
be moved after the release.</p></li>
<li><p>If a fence then same as store atomic, plus no following
associated fence-paired-atomic can be moved before the
fence.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>acq_rel</p></td>
<td><p>Same constraints as both acquire and release.</p></td>
</tr>
<tr class="row-even"><td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>If a load atomic then same constraints as acquire, plus no
preceding sequentially consistent load atomic/store
atomic/atomicrmw/fence instruction can be moved after the
seq_cst.</p></li>
<li><p>If a store atomic then the same constraints as release, plus
no following sequentially consistent load atomic/store
atomic/atomicrmw/fence instruction can be moved before the
seq_cst.</p></li>
<li><p>If an atomicrmw/fence then same constraints as acq_rel.</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="trap-handler-abi">
<h4><a class="toc-backref" href="#id69" role="doc-backlink">Trap Handler ABI</a><a class="headerlink" href="#trap-handler-abi" title="Lien vers cette rubrique">¶</a></h4>
<p>For code objects generated by AMDGPU backend for HSA <a class="reference internal" href="#hsa" id="id29"><span>[HSA]</span></a> compatible runtimes
(such as ROCm <a class="reference internal" href="#amd-rocm" id="id30"><span>[AMD-ROCm]</span></a>), the runtime installs a trap handler that supports
the <code class="docutils literal notranslate"><span class="pre">s_trap</span></code> instruction with the following usage:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-trap-handler-for-amdhsa-os-table">
<caption><span class="caption-text">AMDGPU Trap Handler for AMDHSA OS</span><a class="headerlink" href="#amdgpu-trap-handler-for-amdhsa-os-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Usage</p></th>
<th class="head"><p>Code Sequence</p></th>
<th class="head"><p>Trap Handler
Inputs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x00</span></code></p></td>
<td></td>
<td><p>Reserved by hardware.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">debugtrap(arg)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x01</span></code></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SGPR0-1</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">queue_ptr</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VGPR0</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">arg</span></code></p>
</dd>
</dl>
</td>
<td><p>Reserved for HSA
<code class="docutils literal notranslate"><span class="pre">debugtrap</span></code>
intrinsic (not
implemented).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x02</span></code></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SGPR0-1</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">queue_ptr</span></code></p>
</dd>
</dl>
</td>
<td><p>Causes dispatch to be
terminated and its
associated queue put
into the error state.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x03</span></code></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SGPR0-1</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">queue_ptr</span></code></p>
</dd>
</dl>
</td>
<td><p>If debugger not
installed handled
same as <code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>debugger breakpoint</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x07</span></code></p></td>
<td></td>
<td><p>Reserved for  debugger
breakpoints.</p></td>
</tr>
<tr class="row-odd"><td><p>debugger</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x08</span></code></p></td>
<td></td>
<td><p>Reserved for debugger.</p></td>
</tr>
<tr class="row-even"><td><p>debugger</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xfe</span></code></p></td>
<td></td>
<td><p>Reserved for debugger.</p></td>
</tr>
<tr class="row-odd"><td><p>debugger</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xff</span></code></p></td>
<td></td>
<td><p>Reserved for debugger.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
</section>
<section id="non-amdhsa">
<h3><a class="toc-backref" href="#id70" role="doc-backlink">Non-AMDHSA</a><a class="headerlink" href="#non-amdhsa" title="Lien vers cette rubrique">¶</a></h3>
<section id="id31">
<h4><a class="toc-backref" href="#id71" role="doc-backlink">Trap Handler ABI</a><a class="headerlink" href="#id31" title="Lien vers cette rubrique">¶</a></h4>
<p>For code objects generated by AMDGPU backend for non-amdhsa OS, the runtime does
not install a trap handler. The <code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code>
instructions are handled as follows:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-trap-handler-for-non-amdhsa-os-table">
<caption><span class="caption-text">AMDGPU Trap Handler for Non-AMDHSA OS</span><a class="headerlink" href="#amdgpu-trap-handler-for-non-amdhsa-os-table" title="Lien vers ce tableau">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Usage</p></th>
<th class="head"><p>Code Sequence</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>llvm.trap</p></td>
<td><p>s_endpgm</p></td>
<td><p>Causes wavefront to be terminated.</p></td>
</tr>
<tr class="row-odd"><td><p>llvm.debugtrap</p></td>
<td><p><em>none</em></p></td>
<td><p>Compiler warning given that there is no
trap handler installed.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
</section>
</section>
<section id="source-languages">
<h2><a class="toc-backref" href="#id72" role="doc-backlink">Source Languages</a><a class="headerlink" href="#source-languages" title="Lien vers cette rubrique">¶</a></h2>
<section id="opencl">
<span id="amdgpu-opencl"></span><h3><a class="toc-backref" href="#id73" role="doc-backlink">OpenCL</a><a class="headerlink" href="#opencl" title="Lien vers cette rubrique">¶</a></h3>
<p>When generating code for the OpenCL language the target triple environment
should be <code class="docutils literal notranslate"><span class="pre">opencl</span></code> or <code class="docutils literal notranslate"><span class="pre">amdgizcl</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<p>When the language is OpenCL the following differences occur:</p>
<ol class="arabic simple">
<li><p>The OpenCL memory model is used (see <a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a>).</p></li>
<li><p>The AMDGPU backend adds additional arguments to the kernel.</p></li>
<li><p>Additional metadata is generated (<a class="reference internal" href="#amdgpu-code-object-metadata"><span class="std std-ref">Code Object Metadata</span></a>).</p></li>
</ol>
</section>
<section id="hcc">
<span id="amdgpu-hcc"></span><h3><a class="toc-backref" href="#id74" role="doc-backlink">HCC</a><a class="headerlink" href="#hcc" title="Lien vers cette rubrique">¶</a></h3>
<p>When generating code for the OpenCL language the target triple environment
should be <code class="docutils literal notranslate"><span class="pre">hcc</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<p>When the language is OpenCL the following differences occur:</p>
<ol class="arabic simple">
<li><p>The HSA memory model is used (see <a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a>).</p></li>
</ol>
</section>
<section id="assembler">
<h3><a class="toc-backref" href="#id75" role="doc-backlink">Assembler</a><a class="headerlink" href="#assembler" title="Lien vers cette rubrique">¶</a></h3>
<p>AMDGPU backend has LLVM-MC based assembler which is currently in development.
It supports AMDGCN GFX6-GFX8.</p>
<p>This section describes general syntax for instructions and operands. For more
information about instructions, their semantics and supported combinations of
operands, refer to one of instruction set architecture manuals
<a class="reference internal" href="#amd-souther-islands" id="id32"><span>[AMD-Souther-Islands]</span></a> <a class="reference internal" href="#amd-sea-islands" id="id33"><span>[AMD-Sea-Islands]</span></a> <a class="reference internal" href="#amd-volcanic-islands" id="id34"><span>[AMD-Volcanic-Islands]</span></a>.</p>
<p>An instruction has the following syntax (register operands are normally
comma-separated while extra operands are space-separated):</p>
<p><em>&lt;opcode&gt; &lt;register_operand0&gt;, … &lt;extra_operand0&gt; …</em></p>
<section id="operands">
<h4><a class="toc-backref" href="#id76" role="doc-backlink">Operands</a><a class="headerlink" href="#operands" title="Lien vers cette rubrique">¶</a></h4>
<p>The following syntax for register operands is supported:</p>
<ul class="simple">
<li><p>SGPR registers: s0, … or s[0], …</p></li>
<li><p>VGPR registers: v0, … or v[0], …</p></li>
<li><p>TTMP registers: ttmp0, … or ttmp[0], …</p></li>
<li><p>Special registers: exec (exec_lo, exec_hi), vcc (vcc_lo, vcc_hi), flat_scratch (flat_scratch_lo, flat_scratch_hi)</p></li>
<li><p>Special trap registers: tba (tba_lo, tba_hi), tma (tma_lo, tma_hi)</p></li>
<li><p>Register pairs, quads, etc: s[2:3], v[10:11], ttmp[5:6], s[4:7], v[12:15], ttmp[4:7], s[8:15], …</p></li>
<li><p>Register lists: [s0, s1], [ttmp0, ttmp1, ttmp2, ttmp3]</p></li>
<li><p>Register index expressions: v[2*2], s[1-1:2-1]</p></li>
<li><p>“off” indicates that an operand is not enabled</p></li>
</ul>
<p>The following extra operands are supported:</p>
<ul class="simple">
<li><p>offset, offset0, offset1</p></li>
<li><p>idxen, offen bits</p></li>
<li><p>glc, slc, tfe bits</p></li>
<li><p>waitcnt: integer or combination of counter values</p></li>
<li><p>VOP3 modifiers:</p>
<ul>
<li><p>abs (| |), neg (-)</p></li>
</ul>
</li>
<li><p>DPP modifiers:</p>
<ul>
<li><p>row_shl, row_shr, row_ror, row_rol</p></li>
<li><p>row_mirror, row_half_mirror, row_bcast</p></li>
<li><p>wave_shl, wave_shr, wave_ror, wave_rol, quad_perm</p></li>
<li><p>row_mask, bank_mask, bound_ctrl</p></li>
</ul>
</li>
<li><p>SDWA modifiers:</p>
<ul>
<li><p>dst_sel, src0_sel, src1_sel (BYTE_N, WORD_M, DWORD)</p></li>
<li><p>dst_unused (UNUSED_PAD, UNUSED_SEXT, UNUSED_PRESERVE)</p></li>
<li><p>abs, neg, sext</p></li>
</ul>
</li>
</ul>
</section>
<section id="instruction-examples">
<h4><a class="toc-backref" href="#id77" role="doc-backlink">Instruction Examples</a><a class="headerlink" href="#instruction-examples" title="Lien vers cette rubrique">¶</a></h4>
</section>
<section id="ds">
<h4><a class="toc-backref" href="#id78" role="doc-backlink">DS</a><a class="headerlink" href="#ds" title="Lien vers cette rubrique">¶</a></h4>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">ds_add_u32</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">v4</span><span class="w"> </span><span class="nv">offset</span><span class="p">:</span><span class="mi">16</span>
<span class="nf">ds_write_src2_b64</span><span class="w"> </span><span class="nv">v2</span><span class="w"> </span><span class="nv">offset0</span><span class="p">:</span><span class="mi">4</span><span class="w"> </span><span class="nv">offset1</span><span class="p">:</span><span class="mi">8</span>
<span class="nf">ds_cmpst_f32</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">v4</span><span class="p">,</span><span class="w"> </span><span class="nv">v6</span>
<span class="nf">ds_min_rtn_f64</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « LDS/GDS instructions » in ISA Manual.</p>
<section id="flat">
<h5><a class="toc-backref" href="#id79" role="doc-backlink">FLAT</a><a class="headerlink" href="#flat" title="Lien vers cette rubrique">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">flat_load_dword</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">flat_store_dwordx3</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">flat_atomic_swap</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="nv">v5</span><span class="w"> </span><span class="nv">glc</span>
<span class="nf">flat_atomic_cmpswap</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="nv">glc</span><span class="w"> </span><span class="nv">slc</span>
<span class="nf">flat_atomic_fmax_x2</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="nv">glc</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « FLAT instructions » in ISA Manual.</p>
</section>
<section id="mubuf">
<h5><a class="toc-backref" href="#id80" role="doc-backlink">MUBUF</a><a class="headerlink" href="#mubuf" title="Lien vers cette rubrique">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">buffer_load_dword</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">off</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="nv">s1</span>
<span class="nf">buffer_store_dwordx4</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">ttmp</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="nv">s1</span><span class="w"> </span><span class="nv">offen</span><span class="w"> </span><span class="nv">offset</span><span class="p">:</span><span class="mi">4</span><span class="w"> </span><span class="nv">glc</span><span class="w"> </span><span class="nv">tfe</span>
<span class="nf">buffer_store_format_xy</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="nv">off</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span><span class="w"> </span><span class="nv">s1</span>
<span class="nf">buffer_wbinvl1</span>
<span class="nf">buffer_atomic_inc</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="nv">s4</span><span class="w"> </span><span class="nv">idxen</span><span class="w"> </span><span class="nv">offset</span><span class="p">:</span><span class="mi">4</span><span class="w"> </span><span class="nv">slc</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « MUBUF Instructions » in ISA Manual.</p>
</section>
<section id="smrd-smem">
<h5><a class="toc-backref" href="#id81" role="doc-backlink">SMRD/SMEM</a><a class="headerlink" href="#smrd-smem" title="Lien vers cette rubrique">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_load_dword</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="mh">0xfc</span>
<span class="nf">s_load_dwordx8</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">15</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s4</span>
<span class="nf">s_load_dwordx16</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">88</span><span class="p">:</span><span class="mi">103</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s4</span>
<span class="nf">s_dcache_inv_vol</span>
<span class="nf">s_memtime</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « Scalar Memory Operations » in ISA Manual.</p>
</section>
<section id="sop1">
<h5><a class="toc-backref" href="#id82" role="doc-backlink">SOP1</a><a class="headerlink" href="#sop1" title="Lien vers cette rubrique">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_mov_b32</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="nv">s2</span>
<span class="nf">s_mov_b64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mh">0x80000000</span>
<span class="nf">s_cmov_b32</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span>
<span class="nf">s_wqm_b64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">s_bcnt0_i32_b64</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">s_swappc_b64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">s_cbranch_join</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « SOP1 Instructions » in ISA Manual.</p>
</section>
<section id="sop2">
<h5><a class="toc-backref" href="#id83" role="doc-backlink">SOP2</a><a class="headerlink" href="#sop2" title="Lien vers cette rubrique">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_add_u32</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="nv">s2</span><span class="p">,</span><span class="w"> </span><span class="nv">s3</span>
<span class="nf">s_and_b64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">s_cselect_b32</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="nv">s2</span><span class="p">,</span><span class="w"> </span><span class="nv">s3</span>
<span class="nf">s_andn2_b32</span><span class="w"> </span><span class="nv">s2</span><span class="p">,</span><span class="w"> </span><span class="nv">s4</span><span class="p">,</span><span class="w"> </span><span class="nv">s6</span>
<span class="nf">s_lshr_b64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="nv">s6</span>
<span class="nf">s_ashr_i32</span><span class="w"> </span><span class="nv">s2</span><span class="p">,</span><span class="w"> </span><span class="nv">s4</span><span class="p">,</span><span class="w"> </span><span class="nv">s6</span>
<span class="nf">s_bfm_b64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s4</span><span class="p">,</span><span class="w"> </span><span class="nv">s6</span>
<span class="nf">s_bfe_i64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="nv">s6</span>
<span class="nf">s_cbranch_g_fork</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « SOP2 Instructions » in ISA Manual.</p>
</section>
<section id="sopc">
<h5><a class="toc-backref" href="#id84" role="doc-backlink">SOPC</a><a class="headerlink" href="#sopc" title="Lien vers cette rubrique">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_cmp_eq_i32</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="nv">s2</span>
<span class="nf">s_bitcmp1_b32</span><span class="w"> </span><span class="nv">s1</span><span class="p">,</span><span class="w"> </span><span class="nv">s2</span>
<span class="nf">s_bitcmp0_b64</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="nv">s4</span>
<span class="nf">s_setvskip</span><span class="w"> </span><span class="nv">s3</span><span class="p">,</span><span class="w"> </span><span class="nv">s5</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « SOPC Instructions » in ISA Manual.</p>
</section>
<section id="sopp">
<h5><a class="toc-backref" href="#id85" role="doc-backlink">SOPP</a><a class="headerlink" href="#sopp" title="Lien vers cette rubrique">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_barrier</span>
<span class="nf">s_nop</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">s_endpgm</span>
<span class="nf">s_waitcnt</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">; Wait for all counters to be 0</span>
<span class="nf">s_waitcnt</span><span class="w"> </span><span class="nv">vmcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">expcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">lgkmcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">; Equivalent to above</span>
<span class="nf">s_waitcnt</span><span class="w"> </span><span class="nv">vmcnt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; Wait for vmcnt counter to be 1.</span>
<span class="nf">s_sethalt</span><span class="w"> </span><span class="mi">9</span>
<span class="nf">s_sleep</span><span class="w"> </span><span class="mi">10</span>
<span class="nf">s_sendmsg</span><span class="w"> </span><span class="mh">0x1</span>
<span class="nf">s_sendmsg</span><span class="w"> </span><span class="nv">sendmsg</span><span class="p">(</span><span class="nv">MSG_INTERRUPT</span><span class="p">)</span>
<span class="nf">s_trap</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « SOPP Instructions » in ISA Manual.</p>
<p>Unless otherwise mentioned, little verification is performed on the operands
of SOPP Instructions, so it is up to the programmer to be familiar with the
range or acceptable values.</p>
</section>
<section id="valu">
<h5><a class="toc-backref" href="#id86" role="doc-backlink">VALU</a><a class="headerlink" href="#valu" title="Lien vers cette rubrique">¶</a></h5>
<p>For vector ALU instruction opcodes (VOP1, VOP2, VOP3, VOPC, VOP_DPP, VOP_SDWA),
the assembler will automatically use optimal encoding based on its operands.
To force specific encoding, one can add a suffix to the opcode of the instruction:</p>
<ul class="simple">
<li><p>_e32 for 32-bit VOP1/VOP2/VOPC</p></li>
<li><p>_e64 for 64-bit VOP3</p></li>
<li><p>_dpp for VOP_DPP</p></li>
<li><p>_sdwa for VOP_SDWA</p></li>
</ul>
<p>VOP1/VOP2/VOP3/VOPC examples:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">v_mov_b32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span>
<span class="nf">v_mov_b32_e32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span>
<span class="nf">v_nop</span>
<span class="nf">v_cvt_f64_i32_e32</span><span class="w"> </span><span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="nv">v2</span>
<span class="nf">v_floor_f32_e32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span>
<span class="nf">v_bfrev_b32_e32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span>
<span class="nf">v_add_f32_e32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">v3</span>
<span class="nf">v_mul_i32_i24_e64</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="nf">v_mul_i32_i24_e32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="nv">v3</span>
<span class="nf">v_mul_i32_i24_e32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="nv">v3</span>
<span class="nf">v_addc_u32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">v3</span><span class="p">,</span><span class="w"> </span><span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">v_max_f16_e32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">v3</span>
</pre></div>
</div>
<p>VOP_DPP examples:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">v_mov_b32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="w"> </span><span class="nv">quad_perm</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">v_sin_f32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="w"> </span><span class="nv">row_shl</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span><span class="w"> </span><span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span><span class="w"> </span><span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
<span class="nf">v_mov_b32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="w"> </span><span class="nv">wave_shl</span><span class="p">:</span><span class="mi">1</span>
<span class="nf">v_mov_b32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="w"> </span><span class="nv">row_mirror</span>
<span class="nf">v_mov_b32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="w"> </span><span class="nv">row_bcast</span><span class="p">:</span><span class="mi">31</span>
<span class="nf">v_mov_b32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="w"> </span><span class="nv">quad_perm</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span><span class="w"> </span><span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span><span class="w"> </span><span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
<span class="nf">v_add_f32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="nv">v0</span><span class="o">|</span><span class="w"> </span><span class="nv">row_shl</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span><span class="w"> </span><span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span><span class="w"> </span><span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
<span class="nf">v_max_f16</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span><span class="p">,</span><span class="w"> </span><span class="nv">v3</span><span class="w"> </span><span class="nv">row_shl</span><span class="p">:</span><span class="mi">1</span><span class="w"> </span><span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span><span class="w"> </span><span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span><span class="w"> </span><span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
</pre></div>
</div>
<p>VOP_SDWA examples:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">v_mov_b32</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span><span class="w"> </span><span class="nv">dst_sel</span><span class="p">:</span><span class="kt">BYTE</span><span class="nv">_0</span><span class="w"> </span><span class="nv">dst_unused</span><span class="p">:</span><span class="nv">UNUSED_PRESERVE</span><span class="w"> </span><span class="nv">src0_sel</span><span class="p">:</span><span class="kt">DWORD</span>
<span class="nf">v_min_u32</span><span class="w"> </span><span class="nv">v200</span><span class="p">,</span><span class="w"> </span><span class="nv">v200</span><span class="p">,</span><span class="w"> </span><span class="nv">v1</span><span class="w"> </span><span class="nv">dst_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_1</span><span class="w"> </span><span class="nv">dst_unused</span><span class="p">:</span><span class="nv">UNUSED_PAD</span><span class="w"> </span><span class="nv">src0_sel</span><span class="p">:</span><span class="kt">BYTE</span><span class="nv">_1</span><span class="w"> </span><span class="nv">src1_sel</span><span class="p">:</span><span class="kt">DWORD</span>
<span class="nf">v_sin_f32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="nv">v0</span><span class="w"> </span><span class="nv">dst_unused</span><span class="p">:</span><span class="nv">UNUSED_PAD</span><span class="w"> </span><span class="nv">src0_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_1</span>
<span class="nf">v_fract_f32</span><span class="w"> </span><span class="nv">v0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="nv">v0</span><span class="o">|</span><span class="w"> </span><span class="nv">dst_sel</span><span class="p">:</span><span class="kt">DWORD</span><span class="w"> </span><span class="nv">dst_unused</span><span class="p">:</span><span class="nv">UNUSED_PAD</span><span class="w"> </span><span class="nv">src0_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_1</span>
<span class="nf">v_cmpx_le_u32</span><span class="w"> </span><span class="nv">vcc</span><span class="p">,</span><span class="w"> </span><span class="nv">v1</span><span class="p">,</span><span class="w"> </span><span class="nv">v2</span><span class="w"> </span><span class="nv">src0_sel</span><span class="p">:</span><span class="kt">BYTE</span><span class="nv">_2</span><span class="w"> </span><span class="nv">src1_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_0</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to « Vector ALU instructions ».</p>
</section>
</section>
<section id="hsa-code-object-directives">
<h4><a class="toc-backref" href="#id87" role="doc-backlink">HSA Code Object Directives</a><a class="headerlink" href="#hsa-code-object-directives" title="Lien vers cette rubrique">¶</a></h4>
<p>AMDGPU ABI defines auxiliary data in output code object. In assembly source,
one can specify them with assembler directives.</p>
<section id="hsa-code-object-version-major-minor">
<h5><a class="toc-backref" href="#id88" role="doc-backlink">.hsa_code_object_version major, minor</a><a class="headerlink" href="#hsa-code-object-version-major-minor" title="Lien vers cette rubrique">¶</a></h5>
<p><em>major</em> and <em>minor</em> are integers that specify the version of the HSA code
object that will be generated by the assembler.</p>
</section>
<section id="hsa-code-object-isa-major-minor-stepping-vendor-arch">
<h5><a class="toc-backref" href="#id89" role="doc-backlink">.hsa_code_object_isa [major, minor, stepping, vendor, arch]</a><a class="headerlink" href="#hsa-code-object-isa-major-minor-stepping-vendor-arch" title="Lien vers cette rubrique">¶</a></h5>
<p><em>major</em>, <em>minor</em>, and <em>stepping</em> are all integers that describe the instruction
set architecture (ISA) version of the assembly program.</p>
<p><em>vendor</em> and <em>arch</em> are quoted strings.  <em>vendor</em> should always be equal to
« AMD » and <em>arch</em> should always be equal to « AMDGPU ».</p>
<p>By default, the assembler will derive the ISA version, <em>vendor</em>, and <em>arch</em>
from the value of the -mcpu option that is passed to the assembler.</p>
</section>
<section id="amdgpu-hsa-kernel-name">
<h5><a class="toc-backref" href="#id90" role="doc-backlink">.amdgpu_hsa_kernel (name)</a><a class="headerlink" href="#amdgpu-hsa-kernel-name" title="Lien vers cette rubrique">¶</a></h5>
<p>This directives specifies that the symbol with given name is a kernel entry point
(label) and the object should contain corresponding symbol of type STT_AMDGPU_HSA_KERNEL.</p>
</section>
<section id="amd-kernel-code-t">
<h5><a class="toc-backref" href="#id91" role="doc-backlink">.amd_kernel_code_t</a><a class="headerlink" href="#amd-kernel-code-t" title="Lien vers cette rubrique">¶</a></h5>
<p>This directive marks the beginning of a list of key / value pairs that are used
to specify the amd_kernel_code_t object that will be emitted by the assembler.
The list must be terminated by the <em>.end_amd_kernel_code_t</em> directive.  For
any amd_kernel_code_t values that are unspecified a default value will be
used.  The default value for all keys is 0, with the following exceptions:</p>
<ul class="simple">
<li><p><em>kernel_code_version_major</em> defaults to 1.</p></li>
<li><p><em>machine_kind</em> defaults to 1.</p></li>
<li><p><em>machine_version_major</em>, <em>machine_version_minor</em>, and
<em>machine_version_stepping</em> are derived from the value of the -mcpu option
that is passed to the assembler.</p></li>
<li><p><em>kernel_code_entry_byte_offset</em> defaults to 256.</p></li>
<li><p><em>wavefront_size</em> defaults to 6.</p></li>
<li><p><em>kernarg_segment_alignment</em>, <em>group_segment_alignment</em>, and
<em>private_segment_alignment</em> default to 4.  Note that alignments are specified
as a power of two, so a value of <strong>n</strong> means an alignment of 2^ <strong>n</strong>.</p></li>
</ul>
<p>The <em>.amd_kernel_code_t</em> directive must be placed immediately after the
function label and before any instructions.</p>
<p>For a full list of amd_kernel_code_t keys, refer to AMDGPU ABI document,
comments in lib/Target/AMDGPU/AmdKernelCodeT.h and test/CodeGen/AMDGPU/hsa.s.</p>
<p>Here is an example of a minimal amd_kernel_code_t specification:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.hsa_code_object_version 1,0
.hsa_code_object_isa

.hsatext
.globl  hello_world
.p2align 8
.amdgpu_hsa_kernel hello_world

hello_world:

   .amd_kernel_code_t
      enable_sgpr_kernarg_segment_ptr = 1
      is_ptr64 = 1
      compute_pgm_rsrc1_vgprs = 0
      compute_pgm_rsrc1_sgprs = 0
      compute_pgm_rsrc2_user_sgpr = 2
      kernarg_segment_byte_size = 8
      wavefront_sgpr_count = 2
      workitem_vgpr_count = 3
  .end_amd_kernel_code_t

  s_load_dwordx2 s[0:1], s[0:1] 0x0
  v_mov_b32 v0, 3.14159
  s_waitcnt lgkmcnt(0)
  v_mov_b32 v1, s0
  v_mov_b32 v2, s1
  flat_store_dword v[1:2], v0
  s_endpgm
.Lfunc_end0:
     .size   hello_world, .Lfunc_end0-hello_world
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="additional-documentation">
<h2><a class="toc-backref" href="#id92" role="doc-backlink">Additional Documentation</a><a class="headerlink" href="#additional-documentation" title="Lien vers cette rubrique">¶</a></h2>
<div role="list" class="citation-list">
<div class="citation" id="amd-r6xx" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">AMD-R6xx</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/R600_Instruction_Set_Architecture.pdf">AMD R6xx shader ISA</a></p>
</div>
<div class="citation" id="amd-r7xx" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">AMD-R7xx</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/R700-Family_Instruction_Set_Architecture.pdf">AMD R7xx shader ISA</a></p>
</div>
<div class="citation" id="amd-evergreen" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">AMD-Evergreen</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/AMD_Evergreen-Family_Instruction_Set_Architecture.pdf">AMD Evergreen shader ISA</a></p>
</div>
<div class="citation" id="amd-cayman-trinity" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">AMD-Cayman-Trinity</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/AMD_HD_6900_Series_Instruction_Set_Architecture.pdf">AMD Cayman/Trinity shader ISA</a></p>
</div>
<div class="citation" id="amd-souther-islands" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-Souther-Islands<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id11">1</a>,<a role="doc-backlink" href="#id32">2</a>)</span>
<p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/12/AMD_Southern_Islands_Instruction_Set_Architecture.pdf">AMD Southern Islands Series ISA</a></p>
</div>
<div class="citation" id="amd-sea-islands" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-Sea-Islands<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id12">1</a>,<a role="doc-backlink" href="#id33">2</a>)</span>
<p><a class="reference external" href="http://developer.amd.com/wordpress/media/2013/07/AMD_Sea_Islands_Instruction_Set_Architecture.pdf">AMD Sea Islands Series ISA</a></p>
</div>
<div class="citation" id="amd-volcanic-islands" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-Volcanic-Islands<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id34">2</a>)</span>
<p><a class="reference external" href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/12/AMD_GCN3_Instruction_Set_Architecture_rev1.1.pdf">AMD GCN3 Instruction Set Architecture</a></p>
</div>
<div class="citation" id="amd-opencl-programming-guide" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-OpenCL_Programming-Guide<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://developer.amd.com/download/AMD_Accelerated_Parallel_Processing_OpenCL_Programming_Guide.pdf">AMD Accelerated Parallel Processing OpenCL Programming Guide</a></p>
</div>
<div class="citation" id="amd-app-sdk" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-APP-SDK<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://developer.amd.com/tools/heterogeneous-computing/amd-accelerated-parallel-processing-app-sdk/documentation/">AMD Accelerated Parallel Processing APP SDK Documentation</a></p>
</div>
<div class="citation" id="amd-rocm" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-ROCm<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id4">2</a>,<a role="doc-backlink" href="#id6">3</a>,<a role="doc-backlink" href="#id30">4</a>)</span>
<p><a class="reference external" href="http://gpuopen.com/compute-product/rocm/">ROCm: Open Platform for Development, Discovery and Education Around GPU Computing</a></p>
</div>
<div class="citation" id="amd-rocm-github" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-ROCm-github<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id25">1</a>,<a role="doc-backlink" href="#id26">2</a>)</span>
<p><a class="reference external" href="http://github.com/RadeonOpenCompute">ROCm github</a></p>
</div>
<div class="citation" id="hsa" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HSA<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id3">2</a>,<a role="doc-backlink" href="#id5">3</a>,<a role="doc-backlink" href="#id14">4</a>,<a role="doc-backlink" href="#id18">5</a>,<a role="doc-backlink" href="#id22">6</a>,<a role="doc-backlink" href="#id23">7</a>,<a role="doc-backlink" href="#id24">8</a>,<a role="doc-backlink" href="#id27">9</a>,<a role="doc-backlink" href="#id29">10</a>)</span>
<p><a class="reference external" href="http://www.hsafoundation.com/">Heterogeneous System Architecture (HSA) Foundation</a></p>
</div>
<div class="citation" id="elf" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ELF<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id17">1</a>,<a role="doc-backlink" href="#id19">2</a>)</span>
<p><a class="reference external" href="http://www.sco.com/developers/gabi/">Executable and Linkable Format (ELF)</a></p>
</div>
<div class="citation" id="id35" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">DWARF</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://dwarfstd.org/">DWARF Debugging Information Format</a></p>
</div>
<div class="citation" id="yaml" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">YAML</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html">YAML Ain’t Markup Language (YAML™) Version 1.2</a></p>
</div>
<div class="citation" id="id36" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>OpenCL<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id16">1</a>,<a role="doc-backlink" href="#id28">2</a>)</span>
<p><a class="reference external" href="http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf">The OpenCL Specification Version 2.0</a></p>
</div>
<div class="citation" id="hrf" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">HRF</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://benedictgaster.org/wp-content/uploads/2014/01/asplos269-FINAL.pdf">Heterogeneous-race-free Memory Models</a></p>
</div>
<div class="citation" id="amd-amdgpu-compute-application-binary-interface" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AMD-AMDGPU-Compute-Application-Binary-Interface<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/RadeonOpenCompute/ROCm-ComputeABI-Doc/blob/master/AMDGPU-ABI.md">AMDGPU Compute Application Binary Interface</a></p>
</div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="StackMaps.html" title="Stack maps and patch points in LLVM"
             >suivant</a> |</li>
        <li class="right" >
          <a href="NVPTXUsage.html" title="User Guide for NVPTX Back-end"
             >précédent</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">User Guide for AMDGPU Backend</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Mis à jour le 2025-10-28.
      Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>