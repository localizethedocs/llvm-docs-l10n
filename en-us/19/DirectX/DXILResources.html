
<!DOCTYPE html>

<html lang="en-US" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>DXIL Resource Handling &#8212; LLVM  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../_static/llvm-theme.css?v=4c4af0c1" />
    <script src="../_static/documentation_options.js?v=ccd1e645"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/llvm-docs-l10n/DirectX/DXILResources.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A guide to Dockerfiles for building LLVM" href="../Docker.html" />
    <link rel="prev" title="Specification of DXIL Operations using TableGen Representation" href="DXILOpTableGenDesign.html" />
<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../Docker.html" title="A guide to Dockerfiles for building LLVM"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="DXILOpTableGenDesign.html" title="Specification of DXIL Operations using TableGen Representation"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../DirectXUsage.html" accesskey="U">User Guide for the DirectX Target</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DXIL Resource Handling</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="../GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="../UserGuides.html">User Guides</a></li>
    <li><a href="../Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="../Contributing.html">Contributing to LLVM</a></li>
    <li><a href="../HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="../GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="../GettingInvolved.html#discord">Discord</a></li>
    <li><a href="../GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="../FAQ.html">FAQ</a></li>
    <li><a href="../Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/DirectX/DXILResources.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="dxil-resource-handling">
<h1>DXIL Resource Handling<a class="headerlink" href="#dxil-resource-handling" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id7">Introduction</a></p></li>
<li><p><a class="reference internal" href="#resource-type-information-and-properties" id="id8">Resource Type Information and Properties</a></p></li>
<li><p><a class="reference internal" href="#types-of-resource" id="id9">Types of Resource</a></p>
<ul>
<li><p><a class="reference internal" href="#buffers" id="id10">Buffers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#resource-operations" id="id11">Resource Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#resource-handles" id="id12">Resource Handles</a></p></li>
<li><p><a class="reference internal" href="#buffer-loads-and-stores" id="id13">Buffer Loads and Stores</a></p></li>
</ul>
</li>
</ul>
</nav>
<div class="toctree-wrapper compound">
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Resources in DXIL are represented via <code class="docutils literal notranslate"><span class="pre">TargetExtType</span></code> in LLVM IR and
eventually lowered by the DirectX backend into metadata in DXIL.</p>
<p>In DXC and DXIL, static resources are represented as lists of SRVs (Shader
Resource Views), UAVs (Uniform Access Views), CBVs (Constant Bffer Views), and
Samplers. This metadata consists of a “resource record ID” which uniquely
identifies a resource and type information. As of shader model 6.6, there are
also dynamic resources, which forgo the metadata and are described via
<code class="docutils literal notranslate"><span class="pre">annotateHandle</span></code> operations in the instruction stream instead.</p>
<p>In LLVM we attempt to unify some of the alternative representations that are
present in DXC, with the aim of making handling of resources in the middle end
of the compiler simpler and more consistent.</p>
</section>
<section id="resource-type-information-and-properties">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Resource Type Information and Properties</a><a class="headerlink" href="#resource-type-information-and-properties" title="Link to this heading">¶</a></h2>
<p>There are a number of properties associated with a resource in DXIL.</p>
<dl>
<dt><cite>Resource ID</cite></dt><dd><p>An arbitrary ID that must be unique per resource type (SRV, UAV, etc).</p>
<p>In LLVM we don’t bother representing this, instead opting to generate it at
DXIL lowering time.</p>
</dd>
<dt><cite>Binding information</cite></dt><dd><p>Information about where the resource comes from. This is either (a) a
register space, lower bound in that space, and size of the binding, or (b)
an index into a dynamic resource heap.</p>
<p>In LLVM we represent binding information in the arguments of the
<a class="reference internal" href="#dxil-resources-handles"><span class="std std-ref">handle creation intrinsics</span></a>. When generating
DXIL we transform these calls to metadata, <code class="docutils literal notranslate"><span class="pre">dx.op.createHandle</span></code>,
<code class="docutils literal notranslate"><span class="pre">dx.op.createHandleFromBinding</span></code>, <code class="docutils literal notranslate"><span class="pre">dx.op.createHandleFromHeap</span></code>, and
<code class="docutils literal notranslate"><span class="pre">dx.op.createHandleForLib</span></code> as needed.</p>
</dd>
<dt><cite>Type information</cite></dt><dd><p>The type of data that’s accessible via the resource. For buffers and
textures this can be a simple type like <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">float4</span></code>, a struct,
or raw bytes. For constant buffers this is just a size. For samplers this is
the kind of sampler.</p>
<p>In LLVM we embed this information as a parameter on the <code class="docutils literal notranslate"><span class="pre">target()</span></code> type of
the resource. See <a class="reference internal" href="#dxil-resources-types-of-resource"><span class="std std-ref">Types of Resource</span></a>.</p>
</dd>
<dt><cite>Resource kind information</cite></dt><dd><p>The kind of resource. In HLSL we have things like <code class="docutils literal notranslate"><span class="pre">ByteAddressBuffer</span></code>,
<code class="docutils literal notranslate"><span class="pre">RWTexture2D</span></code>, and <code class="docutils literal notranslate"><span class="pre">RasterizerOrderedStructuredBuffer</span></code>. These map to a
set of DXIL kinds like <code class="docutils literal notranslate"><span class="pre">RawBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">Texture2D</span></code> with fields for
certain properties such as <code class="docutils literal notranslate"><span class="pre">IsUAV</span></code> and <code class="docutils literal notranslate"><span class="pre">IsROV</span></code>.</p>
<p>In LLVM we represent this in the <code class="docutils literal notranslate"><span class="pre">target()</span></code> type. We omit information
that’s deriveable from the type information, but we do have fields to encode
<code class="docutils literal notranslate"><span class="pre">IsWriteable</span></code>, <code class="docutils literal notranslate"><span class="pre">IsROV</span></code>, and <code class="docutils literal notranslate"><span class="pre">SampleCount</span></code> when needed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO: There are two fields in the DXIL metadata that are not
represented as part of the target type: <code class="docutils literal notranslate"><span class="pre">IsGloballyCoherent</span></code> and
<code class="docutils literal notranslate"><span class="pre">HasCounter</span></code>.</p>
<p>Since these are derived from analysis, storing them on the type would mean
we need to change the type during the compiler pipeline. That just isn’t
practical. It isn’t entirely clear to me that we need to serialize this info
into the IR during the compiler pipeline anyway - we can probably get away
with an analysis pass that can calculate the information when we need it.</p>
<p>If analysis is insufficient we’ll need something akin to <code class="docutils literal notranslate"><span class="pre">annotateHandle</span></code>
(but limited to these two properties) or to encode these in the handle
creation.</p>
</div>
</section>
<section id="types-of-resource">
<span id="dxil-resources-types-of-resource"></span><h2><a class="toc-backref" href="#id9" role="doc-backlink">Types of Resource</a><a class="headerlink" href="#types-of-resource" title="Link to this heading">¶</a></h2>
<p>We define a set of <code class="docutils literal notranslate"><span class="pre">TargetExtTypes</span></code> that is similar to the HLSL
representations for the various resources, albeit with a few things
parameterized. This is different than DXIL, as simplifying the types to
something like “dx.srv” and “dx.uav” types would mean the operations on these
types would have to be overly generic.</p>
<section id="buffers">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Buffers</a><a class="headerlink" href="#buffers" title="Link to this heading">¶</a></h3>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="err">ElementType</span><span class="p">,</span><span class="w"> </span><span class="err">IsWriteable</span><span class="p">,</span><span class="w"> </span><span class="err">IsROV</span><span class="p">)</span>
<span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="err">ElementType</span><span class="p">,</span><span class="w"> </span><span class="err">IsWriteable</span><span class="p">,</span><span class="w"> </span><span class="err">IsROV</span><span class="p">)</span>
</pre></div>
</div>
<p>We need two separate buffer types to account for the differences between the
16-byte <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#bufferload">bufferLoad</a> / <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#bufferstore">bufferStore</a> operations that work on DXIL’s
TypedBuffers and the <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#rawbufferload">rawBufferLoad</a> / <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#rawbufferstore">rawBufferStore</a> operations that are
used for DXIL’s RawBuffers and StructuredBuffers. We call the latter
“RawBuffer” to match the naming of the operations, but it can represent both
the Raw and Structured variants.</p>
<p>For TypedBuffer, the element type must be an integer or floating point type.
For RawBuffer the type can be an integer, floating point, or struct type.
HLSL’s ByteAddressBuffer is represented by an <cite>i8</cite> element type.</p>
<p>These types are generally used by BufferLoad and BufferStore operations, as
well as atomics.</p>
<p>There are a few fields to describe variants of all of these types:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-number">Table 100 </span><span class="caption-text">Buffer Fields</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ElementType</p></td>
<td><p>Type for a single element, such as <code class="docutils literal notranslate"><span class="pre">i8</span></code>, <code class="docutils literal notranslate"><span class="pre">v4f32</span></code>, or a structure
type.</p></td>
</tr>
<tr class="row-odd"><td><p>IsWriteable</p></td>
<td><p>Whether or not the field is writeable. This distinguishes SRVs (not
writeable) and UAVs (writeable).</p></td>
</tr>
<tr class="row-even"><td><p>IsROV</p></td>
<td><p>Whether the UAV is a rasterizer ordered view. Always <code class="docutils literal notranslate"><span class="pre">0</span></code> for SRVs.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="resource-operations">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Resource Operations</a><a class="headerlink" href="#resource-operations" title="Link to this heading">¶</a></h2>
<section id="resource-handles">
<span id="dxil-resources-handles"></span><h3><a class="toc-backref" href="#id12" role="doc-backlink">Resource Handles</a><a class="headerlink" href="#resource-handles" title="Link to this heading">¶</a></h3>
<p>We provide a few different ways to instantiate resources in the IR via the
<code class="docutils literal notranslate"><span class="pre">llvm.dx.handle.*</span></code> intrinsics. These intrinsics are overloaded on return
type, returning an appropriate handle for the resource, and represent binding
information in the arguments to the intrinsic.</p>
<p>The three operations we need are <code class="docutils literal notranslate"><span class="pre">llvm.dx.handle.fromBinding</span></code>,
<code class="docutils literal notranslate"><span class="pre">llvm.dx.handle.fromHeap</span></code>, and <code class="docutils literal notranslate"><span class="pre">llvm.dx.handle.fromPointer</span></code>. These are
rougly equivalent to the DXIL operations <code class="docutils literal notranslate"><span class="pre">dx.op.createHandleFromBinding</span></code>,
<code class="docutils literal notranslate"><span class="pre">dx.op.createHandleFromHeap</span></code>, and <code class="docutils literal notranslate"><span class="pre">dx.op.createHandleForLib</span></code>, but they fold
the subsequent <code class="docutils literal notranslate"><span class="pre">dx.op.annotateHandle</span></code> operation in. Note that we don’t have
an analogue for <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#resource-handles">dx.op.createHandle</a>, since <code class="docutils literal notranslate"><span class="pre">dx.op.createHandleFromBinding</span></code>
subsumes it.</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-number">Table 101 </span><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">&#64;llvm.dx.handle.fromBinding</span></code></span><a class="headerlink" href="#id2" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Return value</p></td>
<td></td>
<td><p>A <code class="docutils literal notranslate"><span class="pre">target()</span></code> type</p></td>
<td><p>A handle which can be operated on</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%reg_space</span></code></p></td>
<td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Register space ID in the root signature for this resource.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%lower_bound</span></code></p></td>
<td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Lower bound of the binding in its register space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%range_size</span></code></p></td>
<td><p>3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Range size of the binding.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%index</span></code></p></td>
<td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Index of the resource to access.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%non-uniform</span></code></p></td>
<td><p>5</p></td>
<td><p>i1</p></td>
<td><p>Must be <code class="docutils literal notranslate"><span class="pre">true</span></code> if the resource index may be non-uniform.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO: Can we drop the uniformity bit? I suspect we can derive it from
uniformity analysis…</p>
</div>
<p>Examples:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; RWBuffer&lt;float4&gt; Buf : register(u5, space3)</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="vg">@llvm.dx.handle.fromBinding.tdx.TypedBuffer_f32_1_0</span><span class="p">(</span>
<span class="w">                </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>

<span class="c">; RWBuffer&lt;uint&gt; Buf : register(u7, space2)</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="vg">@llvm.dx.handle.fromBinding.tdx.TypedBuffer_i32_1_0t</span><span class="p">(</span>
<span class="w">                </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>

<span class="c">; Buffer&lt;uint4&gt; Buf[24] : register(t3, space5)</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="vg">@llvm.dx.handle.fromBinding.tdx.TypedBuffer_i32_0_0t</span><span class="p">(</span>
<span class="w">                </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">24</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>

<span class="c">; struct S { float4 a; uint4 b; };</span>
<span class="c">; StructuredBuffer&lt;S&gt; Buf : register(t2, space4)</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">&gt;},</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="vg">@llvm.dx.handle.fromBinding.tdx.RawBuffer_sl_v4f32v4i32s_0_0t</span><span class="p">(</span>
<span class="w">                </span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>

<span class="c">; ByteAddressBuffer Buf : register(t8, space1)</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="vg">@llvm.dx.handle.fromBinding.tdx.RawBuffer_i8_0_0t</span><span class="p">(</span>
<span class="w">                </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils align-default" id="id3">
<caption><span class="caption-number">Table 102 </span><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">&#64;llvm.dx.handle.fromHeap</span></code></span><a class="headerlink" href="#id3" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Return value</p></td>
<td></td>
<td><p>A <code class="docutils literal notranslate"><span class="pre">target()</span></code> type</p></td>
<td><p>A handle which can be operated on</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%index</span></code></p></td>
<td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Index of the resource to access.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%non-uniform</span></code></p></td>
<td><p>1</p></td>
<td><p>i1</p></td>
<td><p>Must be <code class="docutils literal notranslate"><span class="pre">true</span></code> if the resource index may be non-uniform.</p></td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; RWStructuredBuffer&lt;float4&gt; Buf = ResourceDescriptorHeap[2];</span>
<span class="k">declare</span>
<span class="w">  </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">float</span><span class="p">&gt;,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">  </span><span class="vg">@llvm.dx.handle.fromHeap.tdx.RawBuffer_v4f32_1_0</span><span class="p">(</span>
<span class="w">      </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%non_uniform</span><span class="p">)</span>
<span class="c">; ...</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">&gt;,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">            </span><span class="vg">@llvm.dx.handle.fromHeap.tdx.RawBuffer_v4f32_1_0</span><span class="p">(</span>
<span class="w">                </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="buffer-loads-and-stores">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Buffer Loads and Stores</a><a class="headerlink" href="#buffer-loads-and-stores" title="Link to this heading">¶</a></h3>
<p><em>relevant types: Buffers</em></p>
<p>We need to treat buffer loads and stores from “dx.TypedBuffer” and
“dx.RawBuffer” separately. For TypedBuffer, we have <code class="docutils literal notranslate"><span class="pre">llvm.dx.typedBufferLoad</span></code>
and <code class="docutils literal notranslate"><span class="pre">llvm.dx.typedBufferStore</span></code>, which load and store 16-byte “rows” of data
via a simple index. For RawBuffer, we have <code class="docutils literal notranslate"><span class="pre">llvm.dx.rawBufferPtr</span></code>, which
return a pointer that can be indexed, loaded, and stored to as needed.</p>
<p>The typed load and store operations always operate on exactly 16 bytes of data,
so there are only a few valid overloads. For types that are 32-bits or smaller,
we operate on 4-element vectors, such as <code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">i32&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">float&gt;</span></code>, or
<code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">half&gt;</span></code>. Note that in 16-bit cases each 16-bit value occupies 32-bits of
storage. For 64-bit types we operate on 2-element vectors - <code class="docutils literal notranslate"><span class="pre">&lt;2</span> <span class="pre">x</span> <span class="pre">double&gt;</span></code> or
<code class="docutils literal notranslate"><span class="pre">&lt;2</span> <span class="pre">x</span> <span class="pre">i64&gt;</span></code>. When a type like <cite>Buffer&lt;float&gt;</cite> is used at the HLSL level, it
is expected that this will operate on a single float in each 16 byte row - that
is, a load would use the <code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">float&gt;</span></code> variant and then extract the first
element.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In DXC, trying to operate on a <code class="docutils literal notranslate"><span class="pre">Buffer&lt;double4&gt;</span></code> crashes the
compiler. We should probably just reject this in the frontend.</p>
</div>
<p>The TypedBuffer intrinsics are lowered to the <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#bufferload">bufferLoad</a> and <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#bufferstore">bufferStore</a>
operations, and the operations on the memory accessed by RawBufferPtr are
lowered to <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#rawbufferload">rawBufferLoad</a> and <a class="reference external" href="https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/DXIL.rst#rawbufferstore">rawBufferStore</a>. Note that if we want to
support DXIL versions prior to 1.2 we’ll need to lower the RawBuffer loads and
stores to the non-raw operations as well.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO: We need to account for <a class="reference external" href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/checkaccessfullymapped">CheckAccessFullyMapped</a> here.</p>
<p>In DXIL the load operations always return an <code class="docutils literal notranslate"><span class="pre">i32</span></code> status value, but this
isn’t very ergonomic when it isn’t used. We can (1) bite the bullet and have
the loads return <cite>{%ret_type, %i32}</cite> all the time, (2) create a variant or
update the signature iff the status is used, or (3) hide this in a sideband
channel somewhere. I’m leaning towards (2), but could probably be convinced
that the ugliness of (1) is worth the simplicity.</p>
</div>
<table class="docutils align-default" id="id4">
<caption><span class="caption-number">Table 103 </span><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">&#64;llvm.dx.typedBufferLoad</span></code></span><a class="headerlink" href="#id4" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Return value</p></td>
<td></td>
<td><p>A 4- or 2-element vector of the type of the buffer</p></td>
<td><p>The data loaded from the buffer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%buffer</span></code></p></td>
<td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target(dx.TypedBuffer,</span> <span class="pre">...)</span></code></p></td>
<td><p>The buffer to load from</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%index</span></code></p></td>
<td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Index into the buffer</p></td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">float</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.dx.typedBufferLoad.tdx.TypedBuffer_f32_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.dx.typedBufferLoad.tdx.TypedBuffer_i32_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">half</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.dx.typedBufferLoad.tdx.TypedBuffer_f16_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">16</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">double</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.dx.typedBufferLoad.tdx.TypedBuffer_f64_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils align-default" id="id5">
<caption><span class="caption-number">Table 104 </span><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">&#64;llvm.dx.typedBufferStore</span></code></span><a class="headerlink" href="#id5" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Return value</p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">void</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%buffer</span></code></p></td>
<td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target(dx.TypedBuffer,</span> <span class="pre">...)</span></code></p></td>
<td><p>The buffer to store into</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%index</span></code></p></td>
<td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Index into the buffer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%data</span></code></p></td>
<td><p>2</p></td>
<td><p>A 4- or 2-element vector of the type of the buffer</p></td>
<td><p>The data to store</p></td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dx.bufferStore.tdx.Buffer_f32_1_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%data</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dx.bufferStore.tdx.Buffer_f16_1_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">16</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="err">f</span><span class="m">16</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%data</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dx.bufferStore.tdx.Buffer_f64_1_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.TypedBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">64</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="err">f</span><span class="m">64</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%data</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils align-default" id="id6">
<caption><span class="caption-number">Table 105 </span><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">&#64;llvm.dx.rawBufferPtr</span></code></span><a class="headerlink" href="#id6" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Argument</p></th>
<th class="head"></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Return value</p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ptr</span></code></p></td>
<td><p>Pointer to an element of the buffer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%buffer</span></code></p></td>
<td><p>0</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">target(dx.RawBuffer,</span> <span class="pre">...)</span></code></p></td>
<td><p>The buffer to load from</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%index</span></code></p></td>
<td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i32</span></code></p></td>
<td><p>Index into the buffer</p></td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; Load a float4 from a buffer</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.dx.rawBufferPtr.tdx.RawBuffer_v4f32_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">&gt;,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">float</span><span class="p">&gt;,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span>

<span class="c">; Load the double from a struct containing an int, a float, and a double</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.dx.rawBufferPtr.tdx.RawBuffer_sl_i32f32f64s_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">64</span><span class="p">},</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="p">{</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">64</span><span class="p">},</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span>
<span class="nv">%d</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%val</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span>

<span class="c">; Load a float from a byte address buffer</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.dx.rawBufferPtr.tdx.RawBuffer_i8_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span>
<span class="nv">%f</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%val</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="c">; Store to a buffer containing float4</span>
<span class="nv">%addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.dx.rawBufferPtr.tdx.RawBuffer_v4f32_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">&gt;,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="k">store</span><span class="w"> </span><span class="p">&lt;</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">float</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%val</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span>

<span class="c">; Store the double in a struct containing an int, a float, and a double</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.dx.rawBufferPtr.tdx.RawBuffer_sl_i32f32f64s_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">64</span><span class="p">},</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="p">{</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">32</span><span class="p">,</span><span class="w"> </span><span class="err">f</span><span class="m">64</span><span class="p">},</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span>
<span class="k">store</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nv">%d</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span>

<span class="c">; Store a float into a byte address buffer</span>
<span class="nv">%buf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.dx.rawBufferPtr.tdx.RawBuffer_i8_0_0t</span><span class="p">(</span>
<span class="w">    </span><span class="k">target</span><span class="p">(</span><span class="s">&quot;dx.RawBuffer&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%index</span><span class="p">)</span>
<span class="nv">%addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buf</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span>
<span class="k">store</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%f</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%val</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../Docker.html" title="A guide to Dockerfiles for building LLVM"
             >next</a> |</li>
        <li class="right" >
          <a href="DXILOpTableGenDesign.html" title="Specification of DXIL Operations using TableGen Representation"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../DirectXUsage.html" >User Guide for the DirectX Target</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DXIL Resource Handling</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-10-28.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>