# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../Proposals/GitHubMove.rst:3
msgid "Moving LLVM Projects to GitHub"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:6
msgid "Current Status"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:8
msgid ""
"We are planning to complete the transition to GitHub by Oct 21, 2019.  See "
"the GitHub migration `status page <https://llvm.org/GitHubMigrationStatus."
"html>`_ for the latest updates and instructions for how to migrate your "
"workflows."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:17
msgid "Introduction"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:19
msgid ""
"This is a proposal to move our current revision control system from our own "
"hosted Subversion to GitHub. Below are the financial and technical arguments "
"as to why we are proposing such a move and how people (and validation "
"infrastructure) will continue to work with a Git-based LLVM."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:25
msgid "What This Proposal is *Not* About"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:27
msgid "Changing the development policy."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:29
msgid ""
"This proposal relates only to moving the hosting of our source-code "
"repository from SVN hosted on our own servers to Git hosted on GitHub. We "
"are not proposing using GitHub's issue tracker, pull-requests, or code-"
"review."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:33
msgid ""
"Contributors will continue to earn commit access on demand under the "
"Developer Policy, except that that a GitHub account will be required instead "
"of SVN username/password-hash."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:38
msgid "Why Git, and Why GitHub?"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:41
msgid "Why Move At All?"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:43
msgid ""
"This discussion began because we currently host our own Subversion server "
"and Git mirror on a voluntary basis. The LLVM Foundation sponsors the server "
"and provides limited support, but there is only so much it can do."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:47
msgid ""
"Volunteers are not sysadmins themselves, but compiler engineers that happen "
"to know a thing or two about hosting servers. We also don't have 24/7 "
"support, and we sometimes wake up to see that continuous integration is "
"broken because the SVN server is either down or unresponsive."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:52
msgid ""
"We should take advantage of one of the services out there (GitHub, GitLab, "
"and BitBucket, among others) that offer better service (24/7 stability, disk "
"space, Git server, code browsing, forking facilities, etc) for free."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:57
msgid "Why Git?"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:59
msgid ""
"Many new coders nowadays start with Git, and a lot of people have never used "
"SVN, CVS, or anything else. Websites like GitHub have changed the landscape "
"of open source contributions, reducing the cost of first contribution and "
"fostering collaboration."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:64
msgid ""
"Git is also the version control many LLVM developers use. Despite the "
"sources being stored in a SVN server, these developers are already using Git "
"through the Git-SVN integration."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:68
msgid "Git allows you to:"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:70
msgid ""
"Commit, squash, merge, and fork locally without touching the remote server."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:71
msgid "Maintain local branches, enabling multiple threads of development."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:72
msgid ""
"Collaborate on these branches (e.g. through your own fork of llvm on GitHub)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:73
msgid ""
"Inspect the repository history (blame, log, bisect) without Internet access."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:74
msgid ""
"Maintain remote forks and branches on Git hosting services and integrate "
"back to the main repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:77
msgid ""
"In addition, because Git seems to be replacing many OSS projects' version "
"control systems, there are many tools that are built over Git. Future "
"tooling may support Git first (if not only)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:82
msgid "Why GitHub?"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:84
msgid ""
"GitHub, like GitLab and BitBucket, provides free code hosting for open "
"source projects. Any of these could replace the code-hosting infrastructure "
"that we have today."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:88
msgid ""
"These services also have a dedicated team to monitor, migrate, improve and "
"distribute the contents of the repositories depending on region and load."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:91
msgid ""
"GitHub has one important advantage over GitLab and BitBucket: it offers read-"
"write **SVN** access to the repository (https://github.com/blog/626-"
"announcing-svn-support). This would enable people to continue working post-"
"migration as though our code were still canonically in an SVN repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:97
msgid ""
"In addition, there are already multiple LLVM mirrors on GitHub, indicating "
"that part of our community has already settled there."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:101
msgid "On Managing Revision Numbers with Git"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:103
msgid ""
"The current SVN repository hosts all the LLVM sub-projects alongside each "
"other. A single revision number (e.g. r123456) thus identifies a consistent "
"version of all LLVM sub-projects."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:107
msgid ""
"Git does not use sequential integer revision number but instead uses a hash "
"to identify each commit."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:110
msgid ""
"The loss of a sequential integer revision number has been a sticking point "
"in past discussions about Git:"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:113
msgid ""
"\"The 'branch' I most care about is mainline, and losing the ability to say "
"'fixed in r1234' (with some sort of monotonically increasing number) would "
"be a tragic loss.\" [LattnerRevNum]_"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:116
msgid ""
"\"I like those results sorted by time and the chronology should be obvious, "
"but timestamps are incredibly cumbersome and make it difficult to verify "
"that a given checkout matches a given set of results.\" [TrickRevNum]_"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:119
msgid ""
"\"There is still the major regression with unreadable version numbers. Given "
"the amount of Bugzilla traffic with 'Fixed in...', that's a non-trivial "
"issue.\" [JSonnRevNum]_"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:122
msgid ""
"\"Sequential IDs are important for LNT and llvmlab bisection tool."
"\" [MatthewsRevNum]_."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:124
msgid ""
"However, Git can emulate this increasing revision number: ``git rev-list --"
"count <commit-hash>``. This identifier is unique only within a single "
"branch, but this means the tuple `(num, branch-name)` uniquely identifies a "
"commit."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:129
msgid ""
"We can thus use this revision number to ensure that e.g. `clang -v` reports "
"a user-friendly revision number (e.g. `main-12345` or `4.0-5321`), "
"addressing the objections raised above with respect to this aspect of Git."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:134
msgid "What About Branches and Merges?"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:136
msgid ""
"In contrast to SVN, Git makes branching easy. Git's commit history is "
"represented as a DAG, a departure from SVN's linear history. However, we "
"propose to mandate making merge commits illegal in our canonical Git "
"repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:140
msgid ""
"Unfortunately, GitHub does not support server side hooks to enforce such a "
"policy.  We must rely on the community to avoid pushing merge commits."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:143
msgid ""
"GitHub offers a feature called `Status Checks`: a branch protected by "
"`status checks` requires commits to be explicitly allowed before the push "
"can happen. We could supply a pre-push hook on the client side that would "
"run and check the history, before allowing the commit being pushed "
"[statuschecks]_. However this solution would be somewhat fragile (how do you "
"update a script installed on every developer machine?) and prevents SVN "
"access to the repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:152
msgid "What About Commit Emails?"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:154
msgid ""
"We will need a new bot to send emails for each commit. This proposal leaves "
"the email format unchanged besides the commit URL."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:158
msgid "Straw Man Migration Plan"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:161
msgid "Step #1 : Before The Move"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:163
msgid ""
"Update docs to mention the move, so people are aware of what is going on."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:164
msgid ""
"Set up a read-only version of the GitHub project, mirroring our current SVN "
"repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:166
msgid ""
"Add the required bots to implement the commit emails, as well as the "
"umbrella repository update (if the multirepo is selected) or the read-only "
"Git views for the sub-projects (if the monorepo is selected)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:171
msgid "Step #2 : Git Move"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:173
msgid ""
"Update the buildbots to pick up updates and commits from the GitHub "
"repository. Not all bots have to migrate at this point, but it'll help "
"provide infrastructure testing."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:176
msgid "Update Phabricator to pick up commits from the GitHub repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:177
msgid ""
"LNT and llvmlab have to be updated: they rely on unique monotonically "
"increasing integer across branch [MatthewsRevNum]_."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:179
msgid ""
"Instruct downstream integrators to pick up commits from the GitHub "
"repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:181
msgid "Review and prepare an update for the LLVM documentation."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:183
msgid ""
"Until this point nothing has changed for developers, it will just boil down "
"to a lot of work for buildbot and other infrastructure owners."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:187
msgid ""
"The migration will pause here until all dependencies have cleared, and all "
"problems have been solved."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:191
msgid "Step #3: Write Access Move"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:193
msgid ""
"Collect developers' GitHub account information, and add them to the project."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:194
msgid ""
"Switch the SVN repository to read-only and allow pushes to the GitHub "
"repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:195
msgid "Update the documentation."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:196
msgid "Mirror Git to SVN."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:199
msgid "Step #4 : Post Move"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:201
msgid "Archive the SVN repository."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:202
msgid ""
"Update links on the LLVM website pointing to viewvc/klaus/phab etc. to point "
"to GitHub instead."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:206
msgid "GitHub Repository Description"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:209
msgid "Monorepo"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:211
msgid ""
"The LLVM git repository hosted at https://github.com/llvm/llvm-project "
"contains all sub-projects in a single source tree.  It is often referred to "
"as a monorepo and mimics an export of the current SVN repository, with each "
"sub-project having its own top-level directory. Not all sub-projects are "
"used for building toolchains. For example, www/ and test-suite/ are not part "
"of the monorepo."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:217
msgid ""
"Putting all sub-projects in a single checkout makes cross-project "
"refactoring naturally simple:"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:220
msgid ""
"New sub-projects can be trivially split out for better reuse and/or layering "
"(e.g., to allow libSupport and/or LIT to be used by runtimes without adding "
"a dependency on LLVM)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:223
msgid ""
"Changing an API in LLVM and upgrading the sub-projects will always be done "
"in a single commit, designing away a common source of temporary build "
"breakage."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:225
msgid ""
"Moving code across sub-project (during refactoring for instance) in a single "
"commit enables accurate `git blame` when tracking code change history."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:227
msgid ""
"Tooling based on `git grep` works natively across sub-projects, allowing to "
"easier find refactoring opportunities across projects (for example reusing a "
"datastructure initially in LLDB by moving it into libSupport)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:230
msgid ""
"Having all the sources present encourages maintaining the other sub-projects "
"when changing API."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:233
msgid ""
"Finally, the monorepo maintains the property of the existing SVN repository "
"that the sub-projects move synchronously, and a single revision number (or "
"commit hash) identifies the state of the development across all projects."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:240
msgid "Building a single sub-project"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:242
msgid ""
"Even though there is a single source tree, you are not required to build all "
"sub-projects together.  It is trivial to configure builds for a single sub-"
"project."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:246
msgid "For example::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:259
msgid "Outstanding Questions"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:262
msgid "Read-only sub-project mirrors"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:264
msgid ""
"With the Monorepo, it is undecided whether the existing single-subproject "
"mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to be "
"maintained."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:269
msgid "Read/write SVN bridge"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:271
msgid ""
"GitHub supports a read/write SVN bridge for its repositories.  However, "
"there have been issues with this bridge working correctly in the past, so "
"it's not clear if this is something that will be supported going forward."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:276
msgid "Monorepo Drawbacks"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:278
msgid ""
"Using the monolithic repository may add overhead for those contributing to a "
"standalone sub-project, particularly on runtimes like libcxx and compiler-rt "
"that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB "
"(vs. 1GB for the monorepo), and the commit rate of LLVM may cause more "
"frequent `git push` collisions when upstreaming. Affected contributors may "
"be able to use the SVN bridge or the single-subproject Git mirrors. However, "
"it's undecided if these projects will continue to be maintained."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:285
msgid ""
"Using the monolithic repository may add overhead for those *integrating* a "
"standalone sub-project, even if they aren't contributing to it, due to the "
"same disk space concern as the point above. The availability of the sub-"
"project Git mirrors would addresses this."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:289
msgid ""
"Preservation of the existing read/write SVN-based workflows relies on the "
"GitHub SVN bridge, which is an extra dependency. Maintaining this locks us "
"into GitHub and could restrict future workflow changes."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:294
msgid "Workflows"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:296
msgid ""
":ref:`Checkout/Clone a Single Project, without Commit Access <workflow-"
"checkout-commit>`."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:297
msgid ""
":ref:`Checkout/Clone Multiple Projects, with Commit Access <workflow-"
"monocheckout-multicommit>`."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:298
msgid ""
":ref:`Commit an API Change in LLVM and Update the Sub-projects <workflow-"
"cross-repo-commit>`."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:299
msgid ""
":ref:`Branching/Stashing/Updating for Local Development or Experiments "
"<workflow-mono-branching>`."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:300
msgid ":ref:`Bisecting <workflow-mono-bisecting>`."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:303
msgid "Workflow Before/After"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:305
msgid ""
"This section goes through a few examples of workflows, intended to "
"illustrate how end-users or developers would interact with the repository "
"for various use-cases."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:312
msgid "Checkout/Clone a Single Project, with Commit Access"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:315 ../../../Proposals/GitHubMove.rst:380
#: ../../../Proposals/GitHubMove.rst:450 ../../../Proposals/GitHubMove.rst:506
msgid "Currently"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:328
msgid ""
"Commits are performed using `svn commit` or with the sequence `git commit` "
"and `git svn dcommit`."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:334 ../../../Proposals/GitHubMove.rst:418
#: ../../../Proposals/GitHubMove.rst:483 ../../../Proposals/GitHubMove.rst:518
msgid "Monorepo Variant"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:336
msgid ""
"With the monorepo variant, there are a few options, depending on your "
"constraints. First, you could just clone the full repository:"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:339
msgid "git clone https://github.com/llvm/llvm-project.git"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:341
msgid ""
"At this point you have every sub-project (llvm, clang, lld, lldb, ...), "
"which :ref:`doesn't imply you have to build all of them "
"<build_single_project>`. You can still build only compiler-rt for instance. "
"In this way it's not different from someone who would check out all the "
"projects with SVN today."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:346
msgid ""
"If you want to avoid checking out all the sources, you can hide the other "
"directories using a Git sparse checkout::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:353
msgid ""
"The data for all sub-projects is still in your `.git` directory, but in your "
"checkout, you only see `compiler-rt`. Before you push, you'll need to fetch "
"and rebase (`git pull --rebase`) as usual."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:358
msgid ""
"Note that when you fetch you'll likely pull in changes to sub-projects you "
"don't care about. If you are using sparse checkout, the files from other "
"projects won't appear on your disk. The only effect is that your commit hash "
"changes."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:362
msgid ""
"You can check whether the changes in the last fetch are relevant to your "
"commit by running::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:367
msgid ""
"This command can be hidden in a script so that `git llvmpush` would perform "
"all these steps, fail only if such a dependent change exists, and show "
"immediately the change that prevented the push. An immediate repeat of the "
"command would (almost) certainly result in a successful push. Note that "
"today with SVN or git-svn, this step is not possible since the \"rebase\" "
"implicitly happens while committing (unless a conflict occurs)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:375
msgid "Checkout/Clone Multiple Projects, with Commit Access"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:377
msgid "Let's look how to assemble llvm+clang+libcxx at a given revision."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:390
msgid "Or using git-svn::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:413
msgid "Note that the list would be longer with more sub-projects."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:420
msgid ""
"The repository contains natively the source for every sub-projects at the "
"right revision, which makes this straightforward::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:427
msgid ""
"As before, at this point clang, llvm, and libcxx are stored in directories "
"alongside each other."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:433
msgid "Commit an API Change in LLVM and Update the Sub-projects"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:435
msgid ""
"Today this is possible, even though not common (at least not documented) for "
"subversion users and for git-svn users. For example, few Git users try to "
"update LLD or Clang in the same commit as they change an LLVM API."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:439
msgid ""
"The multirepo variant does not address this: one would have to commit and "
"push separately in every individual repository. It would be possible to "
"establish a protocol whereby users add a special token to their commit "
"messages that causes the umbrella repo's updater bot to group all of them "
"into a single revision."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:444
msgid "The monorepo variant handles this natively."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:447
msgid "Branching/Stashing/Updating for Local Development or Experiments"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:452
msgid ""
"SVN does not allow this use case, but developers that are currently using "
"git-svn can do it. Let's look in practice what it means when dealing with "
"multiple sub-projects."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:456 ../../../Proposals/GitHubMove.rst:488
msgid "To update the repository to tip of trunk::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:464 ../../../Proposals/GitHubMove.rst:492
msgid "To create a new branch::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:472 ../../../Proposals/GitHubMove.rst:496
msgid "To switch branches::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:485
msgid ""
"Regular Git commands are sufficient, because everything is in a single "
"repository:"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:501
msgid "Bisecting"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:503
msgid ""
"Assuming a developer is looking for a bug in clang (or lld, or lldb, ...)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:508
msgid ""
"SVN does not have builtin bisection support, but the single revision across "
"sub-projects makes it possible to script around."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:511
msgid ""
"Using the existing Git read-only view of the repositories, it is possible to "
"use the native Git bisection script over the llvm repository, and use some "
"scripting to synchronize the clang repository to match the llvm revision."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:520
msgid ""
"Bisecting on the monorepo is straightforward, and very similar to the above, "
"except that the bisection script does not need to include the `git submodule "
"update` step."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:524
msgid ""
"The same example, finding which commit introduces a regression where "
"clang-3.9 crashes but not clang-3.8 passes, will look like::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:530
msgid "With the `bisect_script.sh` script being::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:540
msgid ""
"Also, since the monorepo handles commits update across multiple projects, "
"you're less like to encounter a build failure where a commit change an API "
"in LLVM and another later one \"fixes\" the build in clang."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:545
msgid "Moving Local Branches to the Monorepo"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:547
msgid ""
"Suppose you have been developing against the existing LLVM git mirrors.  You "
"have one or more git branches that you want to migrate to the \"final "
"monorepo\"."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:551
msgid ""
"The simplest way to migrate such branches is with the ``migrate-downstream-"
"fork.py`` tool at https://github.com/jyknight/llvm-git-migration."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:556
msgid "Basic migration"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:558
msgid ""
"Basic instructions for ``migrate-downstream-fork.py`` are in the Python "
"script and are expanded on below to a more general recipe::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:641
msgid "The above gets you to a state like the following::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:651
msgid ""
"Each branched component has its branch rewritten on top of the monorepo and "
"all components are unified by a giant octopus merge."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:654
msgid ""
"If additional active local branches need to be preserved, the above "
"operations following the assignment to ``my_local_branch`` should be done "
"for each branch.  Ref paths will need to be updated to map the local branch "
"to the corresponding upstream branch.  If local branches have no "
"corresponding upstream branch, then the creation of ``local/octopus/<local "
"branch>`` need not use ``git-merge-base`` to pinpoint its root commit; it "
"may simply be branched from the appropriate component branch (say, ``llvm/"
"local_release_X``)."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:664
msgid "Zipping local history"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:666
msgid ""
"The octopus merge is suboptimal for many cases, because walking back through "
"the history of one component leaves the other components fixed at a history "
"that likely makes things unbuildable."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:670
msgid ""
"Some downstream users track the order commits were made to subprojects with "
"some kind of \"umbrella\" project that imports the project git mirrors as "
"submodules, similar to the multirepo umbrella proposed above.  Such an "
"umbrella repository looks something like this::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:679
msgid ""
"The vertical bars represent submodule updates to a particular local commit "
"in the project mirror.  ``UM3`` in this case is a commit of some local "
"umbrella repository state that is not a submodule update, perhaps a "
"``README`` or project build script update.  Commit ``UM8`` updates a "
"submodule of local project ``myproj``."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:685
msgid ""
"The tool ``zip-downstream-fork.py`` at https://github.com/greened/llvm-git-"
"migration/tree/zip can be used to convert the umbrella history into a "
"monorepo-based history with commits in the order implied by submodule "
"updates::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:697
msgid ""
"The ``U*`` commits represent upstream commits to the monorepo main branch.  "
"Each submodule update in the local ``UM*`` commits brought in a subproject "
"tree at some local commit.  The trees in the ``L*1`` commits represent "
"merges from upstream.  These result in edges from the ``U*`` commits to "
"their corresponding rewritten ``L*1`` commits. The ``L*2`` commits did not "
"do any merges from upstream."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:704
msgid ""
"Note that the merge from ``U2`` to ``Lclang1`` appears redundant, but if, "
"say, ``U3`` changed some files in upstream clang, the ``Lclang1`` commit "
"appearing after the ``Llld1`` commit would actually represent a clang tree "
"*earlier* in the upstream clang history.  We want the ``local/zip`` branch "
"to accurately represent the state of our umbrella history and so the edge "
"``U2 -> Lclang1`` is a visual reminder of what clang's tree actually looks "
"like in ``Lclang1``."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:712
msgid ""
"Even so, the edge ``U3 -> Llld1`` could be problematic for future merges "
"from upstream.  git will think that we've already merged from ``U3``, and we "
"have, except for the state of the clang tree.  One possible mitigation "
"strategy is to manually diff clang between ``U2`` and ``U3`` and apply those "
"updates to ``local/zip``.  Another, possibly simpler strategy is to freeze "
"local work on downstream branches and merge all submodules from the latest "
"upstream before running ``zip-downstream-fork.py``.  If downstream merged "
"each project from upstream in lockstep without any intervening local "
"commits, then things should be fine without any special action.  We "
"anticipate this to be the common case."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:724
msgid ""
"The tree for ``Lclang1`` outside of clang will represent the state of things "
"at ``U3`` since all of the upstream projects not participating in the "
"umbrella history should be in a state respecting the commit ``U3``.  The "
"trees for llvm and lld should correctly represent commits ``Lllvm1`` and "
"``Llld1``, respectively."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:730
msgid ""
"Commit ``UM3`` changed files not related to submodules and we need somewhere "
"to put them.  It is not safe in general to put them in the monorepo root "
"directory because they may conflict with files in the monorepo.  Let's "
"assume we want them in a directory ``local`` in the monorepo."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:736
msgid "**Example 1: Umbrella looks like the monorepo**"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:738
msgid ""
"For this example, we'll assume that each subproject appears in its own top-"
"level directory in the umbrella, just as they do in the monorepo . Let's "
"also assume that we want the files in directory ``myproj`` to appear in "
"``local/myproj``."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:743
msgid ""
"Given the above run of ``migrate-downstream-fork.py``, a recipe to create "
"the zipped history is below::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:796
msgid ""
"Note that if the umbrella has submodules to non-LLVM repositories, ``zip-"
"downstream-fork.py`` needs to know about them to be able to rewrite "
"commits.  That is why the first step above is to fetch commits from such "
"repositories."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:801
msgid ""
"With ``--update-tags`` the tool will migrate annotated tags pointing to "
"submodule commits that were inlined into the zipped history.  If the "
"umbrella pulled in an upstream commit that happened to have a tag pointing "
"to it, that tag will be migrated, which is almost certainly not what is "
"wanted.  The tag can always be moved back to its original commit after "
"rewriting, or the ``--update-tags`` option may be discarded and any local "
"tags would then be migrated manually."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:809
msgid "**Example 2: Nested sources layout**"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:811
msgid ""
"The tool handles nested submodules (e.g. llvm is a submodule in umbrella and "
"clang is a submodule in llvm).  The file ``submodule-map.txt`` is a list of "
"pairs, one per line.  The first pair item describes the path to a submodule "
"in the umbrella repository.  The second pair item describes the path where "
"trees for that submodule should be written in the zipped history."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:818
msgid ""
"Let's say your umbrella repository is actually the llvm repository and it "
"has submodules in the \"nested sources\" layout (clang in tools/clang, "
"etc.).  Let's also say ``projects/myproj`` is a submodule pointing to some "
"downstream repository.  The submodule map file should look like this (we "
"still want myproj mapped the same way as previously)::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:839
msgid ""
"If a submodule path does not appear in the map, the tools assumes it should "
"be placed in the same place in the monorepo.  That means if you use the "
"\"nested sources\" layout in your umrella, you *must* provide map entries "
"for all of the projects in your umbrella (except llvm). Otherwise trees from "
"submodule updates will appear underneath llvm in the zippped history."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:846
msgid ""
"Because llvm is itself the umbrella, we use --subdir to write its content "
"into ``llvm`` in the zippped history::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:913
msgid ""
"Comments at the top of ``zip-downstream-fork.py`` describe in more detail "
"how the tool works and various implications of its operation."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:917
msgid "Importing local repositories"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:919
msgid ""
"You may have additional repositories that integrate with the LLVM ecosystem, "
"essentially extending it with new tools.  If such repositories are tightly "
"coupled with LLVM, it may make sense to import them into your local mirror "
"of the monorepo."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:924
msgid ""
"If such repositories participated in the umbrella repository used during the "
"zipping process above, they will automatically be added to the monorepo.  "
"For downstream repositories that don't participate in an umbrella setup, the "
"``import-downstream-repo.py`` tool at https://github.com/greened/llvm-git-"
"migration/tree/import can help with getting them into the monorepo.  A "
"recipe follows::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:962
msgid ""
"You may want to merge other corresponding branches, for example ``myrepo`` "
"release branches if they were in lockstep with LLVM project releases."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:966
msgid ""
"``--tag-prefix`` tells ``import-downstream-repo.py`` to rename annotated "
"tags with the given prefix.  Due to limitations with ``fast_filter_branch."
"py``, unannotated tags cannot be renamed (``fast_filter_branch.py`` "
"considers them branches, not tags).  Since the upstream monorepo had its "
"tags rewritten with an \"llvmorg-\" prefix, name conflicts should not be an "
"issue.  ``--tag-prefix`` can be used to more clearly indicate which tags "
"correspond to various imported repositories."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:975
msgid "Given this repository history::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:982
msgid "The above recipe results in a history like this::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:997
msgid ""
"Commits ``R1``, ``R2`` and ``R3`` have trees that *only* contain blobs from "
"``myrepo``.  If you require commits from ``myrepo`` to be interleaved with "
"commits on local project branches (for example, interleaved with ``llvm1``, "
"``llvm2``, etc. above) and myrepo doesn't appear in an umbrella repository, "
"a new tool will need to be developed.  Creating such a tool would involve:"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1004
msgid ""
"Modifying ``fast_filter_branch.py`` to optionally take a revlist directly "
"rather than generating it itself"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1007
msgid ""
"Creating a tool to generate an interleaved ordering of local commits based "
"on some criteria (``zip-downstream-fork.py`` uses the umbrella history as "
"its criterion)"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1011
msgid ""
"Generating such an ordering and feeding it to ``fast_filter_branch.py`` as a "
"revlist"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1014
msgid ""
"Some care will also likely need to be taken to handle merge commits, to "
"ensure the parents of such commits migrate correctly."
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1018
msgid "Scrubbing the Local Monorepo"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1020
msgid ""
"Once all of the migrating, zipping and importing is done, it's time to clean "
"up.  The python tools use ``git-fast-import`` which leaves a lot of cruft "
"around and we want to shrink our new monorepo mirror as much as possible.  "
"Here is one way to do it::"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1076
msgid ""
"You should now have a trim monorepo.  Upload it to your git server and happy "
"hacking!"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1080
msgid "References"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1082
msgid ""
"Chris Lattner, http://lists.llvm.org/pipermail/llvm-dev/2011-July/041739.html"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1083
msgid ""
"Andrew Trick, http://lists.llvm.org/pipermail/llvm-dev/2011-July/041721.html"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1084
msgid ""
"Joerg Sonnenberger, http://lists.llvm.org/pipermail/llvm-dev/2011-"
"July/041688.html"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1085
msgid ""
"Chris Matthews, http://lists.llvm.org/pipermail/cfe-dev/2016-July/049886.html"
msgstr ""

#: ../../../Proposals/GitHubMove.rst:1086
msgid ""
"GitHub status-checks, https://help.github.com/articles/about-required-status-"
"checks/"
msgstr ""
