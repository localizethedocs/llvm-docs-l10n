# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../MIRLangRef.rst:3
msgid "Machine IR (MIR) Format Reference Manual"
msgstr ""

#: ../../../MIRLangRef.rst:9
msgid "This is a work in progress."
msgstr ""

#: ../../../MIRLangRef.rst:12
msgid "Introduction"
msgstr ""

#: ../../../MIRLangRef.rst:14
msgid ""
"This document is a reference manual for the Machine IR (MIR) serialization "
"format. MIR is a human readable serialization format that is used to "
"represent LLVM's :ref:`machine specific intermediate representation <machine "
"code representation>`."
msgstr ""

#: ../../../MIRLangRef.rst:19
msgid ""
"The MIR serialization format is designed to be used for testing the code "
"generation passes in LLVM."
msgstr ""

#: ../../../MIRLangRef.rst:23
msgid "Overview"
msgstr ""

#: ../../../MIRLangRef.rst:25
msgid ""
"The MIR serialization format uses a YAML container. YAML is a standard data "
"serialization language, and the full YAML language spec can be read at `yaml."
"org <http://www.yaml.org/spec/1.2/spec.html#Introduction>`_."
msgstr ""

#: ../../../MIRLangRef.rst:30
msgid ""
"A MIR file is split up into a series of `YAML documents`_. The first "
"document can contain an optional embedded LLVM IR module, and the rest of "
"the documents contain the serialized machine functions."
msgstr ""

#: ../../../MIRLangRef.rst:37
msgid "MIR Testing Guide"
msgstr ""

#: ../../../MIRLangRef.rst:39
msgid "You can use the MIR format for testing in two different ways:"
msgstr ""

#: ../../../MIRLangRef.rst:41
msgid ""
"You can write MIR tests that invoke a single code generation pass using the "
"``-run-pass`` option in llc."
msgstr ""

#: ../../../MIRLangRef.rst:44
msgid ""
"You can use llc's ``-stop-after`` option with existing or new LLVM assembly "
"tests and check the MIR output of a specific code generation pass."
msgstr ""

#: ../../../MIRLangRef.rst:48
msgid "Testing Individual Code Generation Passes"
msgstr ""

#: ../../../MIRLangRef.rst:50
msgid ""
"The ``-run-pass`` option in llc allows you to create MIR tests that invoke "
"just a single code generation pass. When this option is used, llc will parse "
"an input MIR file, run the specified code generation pass(es), and output "
"the resulting MIR code."
msgstr ""

#: ../../../MIRLangRef.rst:55
msgid ""
"You can generate an input MIR file for the test by using the ``-stop-after`` "
"or ``-stop-before`` option in llc. For example, if you would like to write a "
"test for the post register allocation pseudo instruction expansion pass, you "
"can specify the machine copy propagation pass in the ``-stop-after`` option, "
"as it runs just before the pass that we are trying to test:"
msgstr ""

#: ../../../MIRLangRef.rst:61
msgid "``llc -stop-after=machine-cp bug-trigger.ll > test.mir``"
msgstr ""

#: ../../../MIRLangRef.rst:63
msgid ""
"If the same pass is run multiple times, a run index can be included after "
"the name with a comma."
msgstr ""

#: ../../../MIRLangRef.rst:66
msgid "``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll > test.mir``"
msgstr ""

#: ../../../MIRLangRef.rst:68
msgid ""
"After generating the input MIR file, you'll have to add a run line that uses "
"the ``-run-pass`` option to it. In order to test the post register "
"allocation pseudo instruction expansion pass on X86-64, a run line like the "
"one shown below can be used:"
msgstr ""

#: ../../../MIRLangRef.rst:73
msgid ""
"``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck "
"%s``"
msgstr ""

#: ../../../MIRLangRef.rst:75
msgid ""
"The MIR files are target dependent, so they have to be placed in the target "
"specific test directories (``lib/CodeGen/TARGETNAME``). They also need to "
"specify a target triple or a target architecture either in the run line or "
"in the embedded LLVM IR module."
msgstr ""

#: ../../../MIRLangRef.rst:81
msgid "Simplifying MIR files"
msgstr ""

#: ../../../MIRLangRef.rst:83
msgid ""
"The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose; "
"Tests are more accessible and future proof when simplified:"
msgstr ""

#: ../../../MIRLangRef.rst:86
msgid "Use the ``-simplify-mir`` option with llc."
msgstr ""

#: ../../../MIRLangRef.rst:88
msgid ""
"Machine function attributes often have default values or the test works just "
"as well with default values. Typical candidates for this are: `alignment:`, "
"`exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`. The whole "
"`frameInfo` section is often unnecessary if there is no special frame usage "
"in the function. `tracksRegLiveness` on the other hand is often necessary "
"for some passes that care about block livein lists."
msgstr ""

#: ../../../MIRLangRef.rst:95
msgid ""
"The (global) `liveins:` list is typically only interesting for early "
"instruction selection passes and can be removed when testing later passes. "
"The per-block `liveins:` on the other hand are necessary if "
"`tracksRegLiveness` is true."
msgstr ""

#: ../../../MIRLangRef.rst:100
msgid ""
"Branch probability data in block `successors:` lists can be dropped if the "
"test doesn't depend on it. Example: `successors: %bb.1(0x40000000), "
"%bb.2(0x40000000)` can be replaced with `successors: %bb.1, %bb.2`."
msgstr ""

#: ../../../MIRLangRef.rst:105
msgid ""
"MIR code contains a whole IR module. This is necessary because there are no "
"equivalents in MIR for global variables, references to external functions, "
"function attributes, metadata, debug info. Instead some MIR data references "
"the IR constructs. You can often remove them if the test doesn't depend on "
"them."
msgstr ""

#: ../../../MIRLangRef.rst:111
msgid ""
"Alias Analysis is performed on IR values. These are referenced by memory "
"operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`. If "
"the test doesn't depend on (good) alias analysis the references can be "
"dropped: `:: (load 8)`"
msgstr ""

#: ../../../MIRLangRef.rst:116
msgid ""
"MIR blocks can reference IR blocks for debug printing, profile information "
"or debug locations. Example: `bb.42.myblock` in MIR references the IR block "
"`myblock`. It is usually possible to drop the `.myblock` reference and "
"simply use `bb.42`."
msgstr ""

#: ../../../MIRLangRef.rst:121
msgid ""
"If there are no memory operands or blocks referencing the IR then the IR "
"function can be replaced by a parameterless dummy function like `define "
"@func() { ret void }`."
msgstr ""

#: ../../../MIRLangRef.rst:125
msgid ""
"It is possible to drop the whole IR section of the MIR file if it only "
"contains dummy functions (see above). The .mir loader will create the IR "
"functions automatically in this case."
msgstr ""

#: ../../../MIRLangRef.rst:132
msgid "Limitations"
msgstr ""

#: ../../../MIRLangRef.rst:134
msgid ""
"Currently the MIR format has several limitations in terms of which state it "
"can serialize:"
msgstr ""

#: ../../../MIRLangRef.rst:137
msgid ""
"The target-specific state in the target-specific ``MachineFunctionInfo`` "
"subclasses isn't serialized at the moment."
msgstr ""

#: ../../../MIRLangRef.rst:140
msgid ""
"The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and "
"SystemZ backends) aren't serialized at the moment."
msgstr ""

#: ../../../MIRLangRef.rst:143
msgid ""
"The ``MCSymbol`` machine operands don't support temporary or local symbols."
msgstr ""

#: ../../../MIRLangRef.rst:145
msgid ""
"A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI "
"instructions and the variable debug information from MMI is serialized right "
"now."
msgstr ""

#: ../../../MIRLangRef.rst:149
msgid ""
"These limitations impose restrictions on what you can test with the MIR "
"format. For now, tests that would like to test some behaviour that depends "
"on the state of temporary or local ``MCSymbol``  operands or the exception "
"handling state in MMI, can't use the MIR format. As well as that, tests that "
"test some behaviour that depends on the state of the target specific "
"``MachineFunctionInfo`` or ``MachineConstantPoolValue`` subclasses can't use "
"the MIR format at the moment."
msgstr ""

#: ../../../MIRLangRef.rst:157
msgid "High Level Structure"
msgstr ""

#: ../../../MIRLangRef.rst:162
msgid "Embedded Module"
msgstr ""

#: ../../../MIRLangRef.rst:164
msgid ""
"When the first YAML document contains a `YAML block literal string`_, the "
"MIR parser will treat this string as an LLVM assembly language string that "
"represents an embedded LLVM IR module. Here is an example of a YAML document "
"that contains an LLVM module:"
msgstr ""

#: ../../../MIRLangRef.rst:182
msgid "Machine Functions"
msgstr ""

#: ../../../MIRLangRef.rst:184
msgid ""
"The remaining YAML documents contain the machine functions. This is an "
"example of such YAML document:"
msgstr ""

#: ../../../MIRLangRef.rst:208
msgid ""
"The document above consists of attributes that represent the various "
"properties and data structures in a machine function."
msgstr ""

#: ../../../MIRLangRef.rst:211
msgid ""
"The attribute ``name`` is required, and its value should be identical to the "
"name of a function that this machine function is based on."
msgstr ""

#: ../../../MIRLangRef.rst:214
msgid ""
"The attribute ``body`` is a `YAML block literal string`_. Its value "
"represents the function's machine basic blocks and their machine "
"instructions."
msgstr ""

#: ../../../MIRLangRef.rst:217
msgid ""
"The attribute ``callSites`` is a representation of call site information "
"which keeps track of call instructions and registers used to transfer call "
"arguments."
msgstr ""

#: ../../../MIRLangRef.rst:221
msgid "Machine Instructions Format Reference"
msgstr ""

#: ../../../MIRLangRef.rst:223
msgid ""
"The machine basic blocks and their instructions are represented using a "
"custom, human readable serialization language. This language is used in the "
"`YAML block literal string`_ that corresponds to the machine function's body."
msgstr ""

#: ../../../MIRLangRef.rst:227
msgid ""
"A source string that uses this language contains a list of machine basic "
"blocks, which are described in the section below."
msgstr ""

#: ../../../MIRLangRef.rst:231
msgid "Machine Basic Blocks"
msgstr ""

#: ../../../MIRLangRef.rst:233
msgid ""
"A machine basic block is defined in a single block definition source "
"construct that contains the block's ID. The example below defines two blocks "
"that have an ID of zero and one:"
msgstr ""

#: ../../../MIRLangRef.rst:244
msgid ""
"A machine basic block can also have a name. It should be specified after the "
"ID in the block's definition:"
msgstr ""

#: ../../../MIRLangRef.rst:252
msgid ""
"The block's name should be identical to the name of the IR block that this "
"machine block is based on."
msgstr ""

#: ../../../MIRLangRef.rst:258
msgid "Block References"
msgstr ""

#: ../../../MIRLangRef.rst:260
msgid ""
"The machine basic blocks are identified by their ID numbers. Individual "
"blocks are referenced using the following syntax:"
msgstr ""

#: ../../../MIRLangRef.rst:267 ../../../MIRLangRef.rst:280
#: ../../../MIRLangRef.rst:448 ../../../MIRLangRef.rst:634
#: ../../../MIRLangRef.rst:702 ../../../MIRLangRef.rst:721
msgid "Example:"
msgstr ""

#: ../../../MIRLangRef.rst:273
msgid ""
"The following syntax is also supported, but the former syntax is preferred "
"for block references:"
msgstr ""

#: ../../../MIRLangRef.rst:287
msgid "Successors"
msgstr ""

#: ../../../MIRLangRef.rst:289
msgid ""
"The machine basic block's successors have to be specified before any of the "
"instructions:"
msgstr ""

#: ../../../MIRLangRef.rst:302
msgid ""
"The branch weights can be specified in brackets after the successor blocks. "
"The example below defines a block that has two successors with branch "
"weights of 32 and 16:"
msgstr ""

#: ../../../MIRLangRef.rst:314
msgid "Live In Registers"
msgstr ""

#: ../../../MIRLangRef.rst:316
msgid ""
"The machine basic block's live in registers have to be specified before any "
"of the instructions:"
msgstr ""

#: ../../../MIRLangRef.rst:324
msgid ""
"The list of live in registers and successors can be empty. The language also "
"allows multiple live in register and successor lists - they are combined "
"into one list by the parser."
msgstr ""

#: ../../../MIRLangRef.rst:329
msgid "Miscellaneous Attributes"
msgstr ""

#: ../../../MIRLangRef.rst:331
msgid ""
"The attributes ``IsAddressTaken``, ``IsLandingPad``, "
"``IsInlineAsmBrIndirectTarget`` and ``Alignment`` can be specified in "
"brackets after the block's definition:"
msgstr ""

#: ../../../MIRLangRef.rst:349
msgid "``Alignment`` is specified in bytes, and must be a power of two."
msgstr ""

#: ../../../MIRLangRef.rst:354
msgid "Machine Instructions"
msgstr ""

#: ../../../MIRLangRef.rst:356
msgid ""
"A machine instruction is composed of a name, :ref:`machine operands <machine-"
"operands>`, :ref:`instruction flags <instruction-flags>`, and machine memory "
"operands."
msgstr ""

#: ../../../MIRLangRef.rst:360
msgid ""
"The instruction's name is usually specified before the operands. The example "
"below shows an instance of the X86 ``RETQ`` instruction with a single "
"machine operand:"
msgstr ""

#: ../../../MIRLangRef.rst:368
msgid ""
"However, if the machine instruction has one or more explicitly defined "
"register operands, the instruction's name has to be specified after them. "
"The example below shows an instance of the AArch64 ``LDPXpost`` instruction "
"with three defined register operands:"
msgstr ""

#: ../../../MIRLangRef.rst:377
msgid ""
"The instruction names are serialized using the exact definitions from the "
"target's ``*InstrInfo.td`` files, and they are case sensitive. This means "
"that similar instruction names like ``TSTri`` and ``tSTRi`` represent "
"different machine instructions."
msgstr ""

#: ../../../MIRLangRef.rst:385
msgid "Instruction Flags"
msgstr ""

#: ../../../MIRLangRef.rst:387
msgid ""
"The flag ``frame-setup`` or ``frame-destroy`` can be specified before the "
"instruction's name:"
msgstr ""

#: ../../../MIRLangRef.rst:401
msgid "Bundled Instructions"
msgstr ""

#: ../../../MIRLangRef.rst:403
msgid "The syntax for bundled instructions is the following:"
msgstr ""

#: ../../../MIRLangRef.rst:412
msgid ""
"The first instruction is often a bundle header. The instructions between "
"``{`` and ``}`` are bundled with the first instruction."
msgstr ""

#: ../../../MIRLangRef.rst:418
msgid "Registers"
msgstr ""

#: ../../../MIRLangRef.rst:420
msgid ""
"Registers are one of the key primitives in the machine instructions "
"serialization language. They are primarily used in the :ref:`register "
"machine operands <register-operands>`, but they can also be used in a number "
"of other places, like the :ref:`basic block's live in list <bb-liveins>`."
msgstr ""

#: ../../../MIRLangRef.rst:426
msgid ""
"The physical registers are identified by their name and by the '$' prefix "
"sigil. They use the following syntax:"
msgstr ""

#: ../../../MIRLangRef.rst:433
msgid "The example below shows three X86 physical registers:"
msgstr ""

#: ../../../MIRLangRef.rst:441
msgid ""
"The virtual registers are identified by their ID number and by the '%' "
"sigil. They use the following syntax:"
msgstr ""

#: ../../../MIRLangRef.rst:454
msgid ""
"The null registers are represented using an underscore ('``_``'). They can "
"also be represented using a '``$noreg``' named register, although the former "
"syntax is preferred."
msgstr ""

#: ../../../MIRLangRef.rst:461
msgid "Machine Operands"
msgstr ""

#: ../../../MIRLangRef.rst:463
msgid ""
"There are seventeen different kinds of machine operands, and all of them can "
"be serialized."
msgstr ""

#: ../../../MIRLangRef.rst:467
msgid "Immediate Operands"
msgstr ""

#: ../../../MIRLangRef.rst:469
msgid ""
"The immediate machine operands are untyped, 64-bit signed integers. The "
"example below shows an instance of the X86 ``MOV32ri`` instruction that has "
"an immediate machine operand ``-42``:"
msgstr ""

#: ../../../MIRLangRef.rst:477
msgid ""
"An immediate operand is also used to represent a subregister index when the "
"machine instruction has one of the following opcodes:"
msgstr ""

#: ../../../MIRLangRef.rst:480
msgid "``EXTRACT_SUBREG``"
msgstr ""

#: ../../../MIRLangRef.rst:482
msgid "``INSERT_SUBREG``"
msgstr ""

#: ../../../MIRLangRef.rst:484
msgid "``REG_SEQUENCE``"
msgstr ""

#: ../../../MIRLangRef.rst:486
msgid "``SUBREG_TO_REG``"
msgstr ""

#: ../../../MIRLangRef.rst:488
msgid ""
"In case this is true, the Machine Operand is printed according to the target."
msgstr ""

#: ../../../MIRLangRef.rst:490
msgid "For example:"
msgstr ""

#: ../../../MIRLangRef.rst:492
msgid "In AArch64RegisterInfo.td:"
msgstr ""

#: ../../../MIRLangRef.rst:498
msgid ""
"If the third operand is an immediate with the value ``15`` (target-dependent "
"value), based on the instruction's opcode and the operand's index the "
"operand will be printed as ``%subreg.sub_32``:"
msgstr ""

#: ../../../MIRLangRef.rst:506
msgid ""
"For integers > 64bit, we use a special machine operand, ``MO_CImmediate``, "
"which stores the immediate in a ``ConstantInt`` using an ``APInt`` (LLVM's "
"arbitrary precision integers)."
msgstr ""

#: ../../../MIRLangRef.rst:515
msgid "Register Operands"
msgstr ""

#: ../../../MIRLangRef.rst:517
msgid ""
"The :ref:`register <registers>` primitive is used to represent the register "
"machine operands. The register operands can also have optional :ref:"
"`register flags <register-flags>`, :ref:`a subregister index <subregister-"
"indices>`, and a reference to the tied register operand. The full syntax of "
"a register operand is shown below:"
msgstr ""

#: ../../../MIRLangRef.rst:528
msgid ""
"This example shows an instance of the X86 ``XOR32rr`` instruction that has 5 "
"register operands with different register flags:"
msgstr ""

#: ../../../MIRLangRef.rst:538
msgid "Register Flags"
msgstr ""

#: ../../../MIRLangRef.rst:540
msgid ""
"The table below shows all of the possible register flags along with the "
"corresponding internal ``llvm::RegState`` representation:"
msgstr ""

#: ../../../MIRLangRef.rst:546
msgid "Flag"
msgstr ""

#: ../../../MIRLangRef.rst:547
msgid "Internal Value"
msgstr ""

#: ../../../MIRLangRef.rst:549
msgid "``implicit``"
msgstr ""

#: ../../../MIRLangRef.rst:550
msgid "``RegState::Implicit``"
msgstr ""

#: ../../../MIRLangRef.rst:552
msgid "``implicit-def``"
msgstr ""

#: ../../../MIRLangRef.rst:553
msgid "``RegState::ImplicitDefine``"
msgstr ""

#: ../../../MIRLangRef.rst:555
msgid "``def``"
msgstr ""

#: ../../../MIRLangRef.rst:556
msgid "``RegState::Define``"
msgstr ""

#: ../../../MIRLangRef.rst:558
msgid "``dead``"
msgstr ""

#: ../../../MIRLangRef.rst:559
msgid "``RegState::Dead``"
msgstr ""

#: ../../../MIRLangRef.rst:561
msgid "``killed``"
msgstr ""

#: ../../../MIRLangRef.rst:562
msgid "``RegState::Kill``"
msgstr ""

#: ../../../MIRLangRef.rst:564
msgid "``undef``"
msgstr ""

#: ../../../MIRLangRef.rst:565
msgid "``RegState::Undef``"
msgstr ""

#: ../../../MIRLangRef.rst:567
msgid "``internal``"
msgstr ""

#: ../../../MIRLangRef.rst:568
msgid "``RegState::InternalRead``"
msgstr ""

#: ../../../MIRLangRef.rst:570
msgid "``early-clobber``"
msgstr ""

#: ../../../MIRLangRef.rst:571
msgid "``RegState::EarlyClobber``"
msgstr ""

#: ../../../MIRLangRef.rst:573
msgid "``debug-use``"
msgstr ""

#: ../../../MIRLangRef.rst:574
msgid "``RegState::Debug``"
msgstr ""

#: ../../../MIRLangRef.rst:576
msgid "``renamable``"
msgstr ""

#: ../../../MIRLangRef.rst:577
msgid "``RegState::Renamable``"
msgstr ""

#: ../../../MIRLangRef.rst:582
msgid "Subregister Indices"
msgstr ""

#: ../../../MIRLangRef.rst:584
msgid ""
"The register machine operands can reference a portion of a register by using "
"the subregister indices. The example below shows an instance of the ``COPY`` "
"pseudo instruction that uses the X86 ``sub_8bit`` subregister index to copy "
"8 lower bits from the 32-bit virtual register 0 to the 8-bit virtual "
"register 1:"
msgstr ""

#: ../../../MIRLangRef.rst:593
msgid ""
"The names of the subregister indices are target specific, and are typically "
"defined in the target's ``*RegisterInfo.td`` file."
msgstr ""

#: ../../../MIRLangRef.rst:597
msgid "Constant Pool Indices"
msgstr ""

#: ../../../MIRLangRef.rst:599
msgid ""
"A constant pool index (CPI) operand is printed using its index in the "
"function's ``MachineConstantPool`` and an offset."
msgstr ""

#: ../../../MIRLangRef.rst:602
msgid "For example, a CPI with the index 1 and offset 8:"
msgstr ""

#: ../../../MIRLangRef.rst:608
msgid "For a CPI with the index 0 and offset -12:"
msgstr ""

#: ../../../MIRLangRef.rst:614
msgid ""
"A constant pool entry is bound to a LLVM IR ``Constant`` or a target-"
"specific ``MachineConstantPoolValue``. When serializing all the function's "
"constants the following format is used:"
msgstr ""

#: ../../../MIRLangRef.rst:632
msgid "where:"
msgstr ""

#: ../../../MIRLangRef.rst:627
msgid "``<index>`` is a 32-bit unsigned integer;"
msgstr ""

#: ../../../MIRLangRef.rst:628
msgid ""
"``<value>`` is a `LLVM IR Constant <https://www.llvm.org/docs/LangRef."
"html#constants>`_;"
msgstr ""

#: ../../../MIRLangRef.rst:630
msgid ""
"``<alignment>`` is a 32-bit unsigned integer specified in bytes, and must be "
"power of two;"
msgstr ""

#: ../../../MIRLangRef.rst:632
msgid "``<target-specific>`` is either true or false."
msgstr ""

#: ../../../MIRLangRef.rst:648
msgid "Global Value Operands"
msgstr ""

#: ../../../MIRLangRef.rst:650
msgid ""
"The global value machine operands reference the global values from the :ref:"
"`embedded LLVM IR module <embedded-module>`. The example below shows an "
"instance of the X86 ``MOV64rm`` instruction that has a global value operand "
"named ``G``:"
msgstr ""

#: ../../../MIRLangRef.rst:659
msgid ""
"The named global values are represented using an identifier with the '@' "
"prefix. If the identifier doesn't match the regular expression `[-a-zA-Z$._]"
"[-a-zA-Z$._0-9]*`, then this identifier must be quoted."
msgstr ""

#: ../../../MIRLangRef.rst:663
msgid ""
"The unnamed global values are represented using an unsigned numeric value "
"with the '@' prefix, like in the following examples: ``@0``, ``@989``."
msgstr ""

#: ../../../MIRLangRef.rst:667
msgid "Target-dependent Index Operands"
msgstr ""

#: ../../../MIRLangRef.rst:669
msgid ""
"A target index operand is a target-specific index and an offset. The target-"
"specific index is printed using target-specific names and a positive or "
"negative offset."
msgstr ""

#: ../../../MIRLangRef.rst:673
msgid ""
"For example, the ``amdgpu-constdata-start`` is associated with the index "
"``0`` in the AMDGPU backend. So if we have a target index operand with the "
"index 0 and the offset 8:"
msgstr ""

#: ../../../MIRLangRef.rst:682
msgid "Jump-table Index Operands"
msgstr ""

#: ../../../MIRLangRef.rst:684
msgid "A jump-table index operand with the index 0 is printed as following:"
msgstr ""

#: ../../../MIRLangRef.rst:690
msgid ""
"A machine jump-table entry contains a list of ``MachineBasicBlocks``. When "
"serializing all the function's jump-table entries, the following format is "
"used:"
msgstr ""

#: ../../../MIRLangRef.rst:700
msgid ""
"where ``<kind>`` is describing how the jump table is represented and emitted "
"(plain address, relocations, PIC, etc.), and each ``<index>`` is a 32-bit "
"unsigned integer and ``blocks`` contains a list of :ref:`machine basic block "
"references <block-references>`."
msgstr ""

#: ../../../MIRLangRef.rst:715
msgid "External Symbol Operands"
msgstr ""

#: ../../../MIRLangRef.rst:717
msgid ""
"An external symbol operand is represented using an identifier with the ``&`` "
"prefix. The identifier is surrounded with \"\"'s and escaped if it has any "
"special non-printable characters in it."
msgstr ""

#: ../../../MIRLangRef.rst:728
msgid "MCSymbol Operands"
msgstr ""

#: ../../../MIRLangRef.rst:730
msgid ""
"A MCSymbol operand is holding a pointer to a ``MCSymbol``. For the "
"limitations of this operand in MIR, see :ref:`limitations <limitations>`."
msgstr ""

#: ../../../MIRLangRef.rst:733 ../../../MIRLangRef.rst:748
msgid "The syntax is:"
msgstr ""

#: ../../../MIRLangRef.rst:740
msgid "CFIIndex Operands"
msgstr ""

#: ../../../MIRLangRef.rst:742
msgid ""
"A CFI Index operand is holding an index into a per-function side-table, "
"``MachineFunction::getFrameInstructions()``, which references all the frame "
"instructions in a ``MachineFunction``. A ``CFI_INSTRUCTION`` may look like "
"it contains multiple operands, but the only operand it contains is the CFI "
"Index. The other operands are tracked by the ``MCCFIInstruction`` object."
msgstr ""

#: ../../../MIRLangRef.rst:754
msgid "which may be emitted later in the MC layer as:"
msgstr ""

#: ../../../MIRLangRef.rst:761
msgid "IntrinsicID Operands"
msgstr ""

#: ../../../MIRLangRef.rst:763
msgid ""
"An Intrinsic ID operand contains a generic intrinsic ID or a target-specific "
"ID."
msgstr ""

#: ../../../MIRLangRef.rst:765
msgid "The syntax for the ``returnaddress`` intrinsic is:"
msgstr ""

#: ../../../MIRLangRef.rst:772
msgid "Predicate Operands"
msgstr ""

#: ../../../MIRLangRef.rst:774
msgid ""
"A Predicate operand contains an IR predicate from ``CmpInst::Predicate``, "
"like ``ICMP_EQ``, etc."
msgstr ""

#: ../../../MIRLangRef.rst:777
msgid "For an int eq predicate ``ICMP_EQ``, the syntax is:"
msgstr ""

#: ../../../MIRLangRef.rst:798
msgid "Comments"
msgstr ""

#: ../../../MIRLangRef.rst:800
msgid ""
"Machine operands can have C/C++ style comments, which are annotations "
"enclosed between ``/*`` and ``*/`` to improve readability of e.g. immediate "
"operands. In the example below, ARM instructions EOR and BCC and immediate "
"operands ``14`` and ``0`` have been annotated with their condition codes "
"(CC) definitions, i.e. the ``always`` and ``eq`` condition codes:"
msgstr ""

#: ../../../MIRLangRef.rst:811
msgid ""
"As these annotations are comments, they are ignored by the MI parser. "
"Comments can be added or customized by overriding InstrInfo's hook "
"``createMIROperandComment()``."
msgstr ""

#: ../../../MIRLangRef.rst:816
msgid "Debug-Info constructs"
msgstr ""

#: ../../../MIRLangRef.rst:818
msgid ""
"Most of the debugging information in a MIR file is to be found in the "
"metadata of the embedded module. Within a machine function, that metadata is "
"referred to by various constructs to describe source locations and variable "
"locations."
msgstr ""

#: ../../../MIRLangRef.rst:823
msgid "Source locations"
msgstr ""

#: ../../../MIRLangRef.rst:825
msgid ""
"Every MIR instruction may optionally have a trailing reference to a "
"``DILocation`` metadata node, after all operands and symbols, but before "
"memory operands:"
msgstr ""

#: ../../../MIRLangRef.rst:833
msgid ""
"The source location attachment is synonymous with the ``!dbg`` metadata "
"attachment in LLVM-IR. The absence of a source location attachment will be "
"represented by an empty ``DebugLoc`` object in the machine instruction."
msgstr ""

#: ../../../MIRLangRef.rst:838
msgid "Fixed variable locations"
msgstr ""

#: ../../../MIRLangRef.rst:840
msgid ""
"There are several ways of specifying variable locations. The simplest is "
"describing a variable that is permanently located on the stack. In the stack "
"or fixedStack attribute of the machine function, the variable, scope, and "
"any qualifying location modifier are provided:"
msgstr ""

#: ../../../MIRLangRef.rst:851
msgid "Where:"
msgstr ""

#: ../../../MIRLangRef.rst:853
msgid "``debug-info-variable`` identifies a DILocalVariable metadata node,"
msgstr ""

#: ../../../MIRLangRef.rst:855
msgid "``debug-info-expression`` adds qualifiers to the variable location,"
msgstr ""

#: ../../../MIRLangRef.rst:857
msgid "``debug-info-location`` identifies a DILocation metadata node."
msgstr ""

#: ../../../MIRLangRef.rst:859
msgid ""
"These metadata attributes correspond to the operands of a ``llvm.dbg."
"declare`` IR intrinsic, see the :ref:`source level "
"debugging<format_common_intrinsics>` documentation."
msgstr ""

#: ../../../MIRLangRef.rst:864
msgid "Varying variable locations"
msgstr ""

#: ../../../MIRLangRef.rst:866
msgid ""
"Variables that are not always on the stack or change location are specified "
"with the ``DBG_VALUE``  meta machine instruction. It is synonymous with the "
"``llvm.dbg.value`` IR intrinsic, and is written:"
msgstr ""

#: ../../../MIRLangRef.rst:874
msgid "The operands to which respectively:"
msgstr ""

#: ../../../MIRLangRef.rst:876
msgid ""
"Identifies a machine location such as a register, immediate, or frame index,"
msgstr ""

#: ../../../MIRLangRef.rst:878
msgid ""
"Is either $noreg, or immediate value zero if an extra level of indirection "
"is to be added to the first operand,"
msgstr ""

#: ../../../MIRLangRef.rst:880
msgid "Identifies a ``DILocalVariable`` metadata node,"
msgstr ""

#: ../../../MIRLangRef.rst:882
msgid ""
"Specifies an expression qualifying the variable location, either inline or "
"as a metadata node reference,"
msgstr ""

#: ../../../MIRLangRef.rst:884
msgid ""
"While the source location identifies the ``DILocation`` for the scope of the "
"variable. The second operand (``IsIndirect``) is deprecated and to be "
"deleted. All additional qualifiers for the variable location should be made "
"through the expression metadata."
msgstr ""

#: ../../../MIRLangRef.rst:890
msgid "Instruction referencing locations"
msgstr ""

#: ../../../MIRLangRef.rst:892
msgid ""
"This experimental feature aims to separate the specification of variable "
"*values* from the program point where a variable takes on that value. "
"Changes in variable value occur in the same manner as ``DBG_VALUE`` meta "
"instructions but using ``DBG_INSTR_REF``. Variable values are identified by "
"a pair of instruction number and operand number. Consider the example below:"
msgstr ""

#: ../../../MIRLangRef.rst:903
msgid ""
"Instruction numbers are directly attached to machine instructions with an "
"optional ``debug-instr-number`` attachment, before the optional ``debug-"
"location`` attachment. The value defined in ``$rbp`` in the code above would "
"be identified by the pair ``<1, 0>``."
msgstr ""

#: ../../../MIRLangRef.rst:908
msgid ""
"The first two operands of the ``DBG_INSTR_REF`` above record the instruction "
"and operand number ``<1, 0>``, identifying the value defined by the "
"``MOV64ri``. The additional operands to ``DBG_INSTR_REF`` are identical to "
"``DBG_VALUE``, and the ``DBG_INSTR_REF`` s position records where the "
"variable takes on the designated value in the same way."
msgstr ""

#: ../../../MIRLangRef.rst:914
msgid ""
"More information about how these constructs are used is available in :doc:"
"`InstrRefDebugInfo`. The related documents :doc:`SourceLevelDebugging` and :"
"doc:`HowToUpdateDebugInfo` may be useful as well."
msgstr ""
