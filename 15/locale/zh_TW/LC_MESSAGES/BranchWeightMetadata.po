# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../BranchWeightMetadata.rst:3
msgid "LLVM Branch Weight Metadata"
msgstr ""

#: ../../../BranchWeightMetadata.rst:9
msgid "Introduction"
msgstr ""

#: ../../../BranchWeightMetadata.rst:11
msgid ""
"Branch Weight Metadata represents branch weights as its likeliness to be "
"taken (see :doc:`BlockFrequencyTerminology`). Metadata is assigned to an "
"``Instruction`` that is a terminator as a ``MDNode`` of the ``MD_prof`` "
"kind. The first operator is always a ``MDString`` node with the string "
"\"branch_weights\".  Number of operators depends on the terminator type."
msgstr ""

#: ../../../BranchWeightMetadata.rst:17
msgid ""
"Branch weights might be fetch from the profiling file, or generated based on "
"`__builtin_expect`_ and `__builtin_expect_with_probability`_ instruction."
msgstr ""

#: ../../../BranchWeightMetadata.rst:20
msgid ""
"All weights are represented as an unsigned 32-bit values, where higher value "
"indicates greater chance to be taken."
msgstr ""

#: ../../../BranchWeightMetadata.rst:24
msgid "Supported Instructions"
msgstr ""

#: ../../../BranchWeightMetadata.rst:27
msgid "``BranchInst``"
msgstr ""

#: ../../../BranchWeightMetadata.rst:29
msgid ""
"Metadata is only assigned to the conditional branches. There are two extra "
"operands for the true and the false branch."
msgstr ""

#: ../../../BranchWeightMetadata.rst:41
msgid "``SwitchInst``"
msgstr ""

#: ../../../BranchWeightMetadata.rst:43
msgid ""
"Branch weights are assigned to every case (including the ``default`` case "
"which is always case #0)."
msgstr ""

#: ../../../BranchWeightMetadata.rst:55
msgid "``IndirectBrInst``"
msgstr ""

#: ../../../BranchWeightMetadata.rst:57
msgid "Branch weights are assigned to every destination."
msgstr ""

#: ../../../BranchWeightMetadata.rst:68
msgid "``CallInst``"
msgstr ""

#: ../../../BranchWeightMetadata.rst:70
msgid ""
"Calls may have branch weight metadata, containing the execution count of the "
"call. It is currently used in SamplePGO mode only, to augment the block and "
"entry counts which may not be accurate with sampling."
msgstr ""

#: ../../../BranchWeightMetadata.rst:82
msgid "``InvokeInst``"
msgstr ""

#: ../../../BranchWeightMetadata.rst:84
msgid ""
"Invoke instruction may have branch weight metadata with one or two weights. "
"The second weight is optional and corresponds to the unwind branch. If only "
"one weight is set then it contains the execution count of the call and used "
"in SamplePGO mode only as described for the call instruction. If both "
"weights are specified then the second weight contains count of unwind branch "
"taken and the first weights contains the execution count of the call minus "
"the count of unwind branch taken. Both weights specified are used to "
"calculate BranchProbability as for BranchInst and for SamplePGO the sum of "
"both weights is used."
msgstr ""

#: ../../../BranchWeightMetadata.rst:103
msgid "Other"
msgstr ""

#: ../../../BranchWeightMetadata.rst:105
msgid ""
"Other terminator instructions are not allowed to contain Branch Weight "
"Metadata."
msgstr ""

#: ../../../BranchWeightMetadata.rst:110
msgid "Built-in ``expect`` Instructions"
msgstr ""

#: ../../../BranchWeightMetadata.rst:112
msgid ""
"``__builtin_expect(long exp, long c)`` instruction provides branch "
"prediction information. The return value is the value of ``exp``."
msgstr ""

#: ../../../BranchWeightMetadata.rst:115
msgid ""
"It is especially useful in conditional statements. Currently Clang supports "
"two conditional statements:"
msgstr ""

#: ../../../BranchWeightMetadata.rst:119 ../../../BranchWeightMetadata.rst:159
msgid "``if`` statement"
msgstr ""

#: ../../../BranchWeightMetadata.rst:121
msgid ""
"The ``exp`` parameter is the condition. The ``c`` parameter is the expected "
"comparison value. If it is equal to 1 (true), the condition is likely to be "
"true, in other case condition is likely to be false. For example:"
msgstr ""

#: ../../../BranchWeightMetadata.rst:132 ../../../BranchWeightMetadata.rst:172
msgid "``switch`` statement"
msgstr ""

#: ../../../BranchWeightMetadata.rst:134
msgid ""
"The ``exp`` parameter is the value. The ``c`` parameter is the expected "
"value. If the expected value doesn't show on the cases list, the ``default`` "
"case is assumed to be likely taken."
msgstr ""

#: ../../../BranchWeightMetadata.rst:150
msgid "Built-in ``expect.with.probability`` Instruction"
msgstr ""

#: ../../../BranchWeightMetadata.rst:152
msgid ""
"``__builtin_expect_with_probability(long exp, long c, double probability)`` "
"has the same semantics as ``__builtin_expect``, but the caller provides the "
"probability that ``exp == c``. The last argument ``probability`` must be "
"constant floating-point expression and be in the range [0.0, 1.0] inclusive. "
"The usage is also similar as ``__builtin_expect``, for example:"
msgstr ""

#: ../../../BranchWeightMetadata.rst:161
msgid ""
"If the expect comparison value ``c`` is equal to 1(true), and probability "
"value ``probability`` is set to 0.8, that means the probability of condition "
"to be true is 80% while that of false is 20%."
msgstr ""

#: ../../../BranchWeightMetadata.rst:174
msgid ""
"This is basically the same as ``switch`` statement in ``__builtin_expect``. "
"The probability that ``exp`` is equal to the expect value is given in the "
"third argument ``probability``, while the probability of other value is the "
"average of remaining probability(``1.0 - probability``). For example:"
msgstr ""

#: ../../../BranchWeightMetadata.rst:189
msgid "CFG Modifications"
msgstr ""

#: ../../../BranchWeightMetadata.rst:191
msgid ""
"Branch Weight Metatada is not proof against CFG changes. If terminator "
"operands' are changed some action should be taken. In other case some "
"misoptimizations may occur due to incorrect branch prediction information."
msgstr ""

#: ../../../BranchWeightMetadata.rst:196
msgid "Function Entry Counts"
msgstr ""

#: ../../../BranchWeightMetadata.rst:198
msgid ""
"To allow comparing different functions during inter-procedural analysis and "
"optimization, ``MD_prof`` nodes can also be assigned to a function "
"definition. The first operand is a string indicating the name of the "
"associated counter."
msgstr ""

#: ../../../BranchWeightMetadata.rst:202
msgid ""
"Currently, one counter is supported: \"function_entry_count\". The second "
"operand is a 64-bit counter that indicates the number of times that this "
"function was invoked (in the case of instrumentation-based profiles). In the "
"case of sampling-based profiles, this operand is an approximation of how "
"many times the function was invoked."
msgstr ""

#: ../../../BranchWeightMetadata.rst:208
msgid ""
"For example, in the code below, the instrumentation for function foo() "
"indicates that it was called 2,590 times at runtime."
msgstr ""

#: ../../../BranchWeightMetadata.rst:218
msgid ""
"If \"function_entry_count\" has more than 2 operands, the later operands are "
"the GUID of the functions that needs to be imported by ThinLTO. This is only "
"set by sampling based profile. It is needed because the sampling based "
"profile was collected on a binary that had already imported and inlined "
"these functions, and we need to ensure the IR matches in the ThinLTO "
"backends for profile annotation. The reason why we cannot annotate this on "
"the callsite is that it can only goes down 1 level in the call chain. For "
"the cases where foo_in_a_cc()->bar_in_b_cc()->baz_in_c_cc(), we will need to "
"go down 2 levels in the call chain to import both bar_in_b_cc and "
"baz_in_c_cc."
msgstr ""
