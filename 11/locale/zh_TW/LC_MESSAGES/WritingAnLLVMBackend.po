# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../WritingAnLLVMBackend.rst:3
msgid "Writing an LLVM Backend"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:14
msgid "Introduction"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:16
msgid ""
"This document describes techniques for writing compiler backends that "
"convert the LLVM Intermediate Representation (IR) to code for a specified "
"machine or other languages.  Code intended for a specific machine can take "
"the form of either assembly code or binary code (usable for a JIT compiler)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:21
msgid ""
"The backend of LLVM features a target-independent code generator that may "
"create output for several types of target CPUs --- including X86, PowerPC, "
"ARM, and SPARC.  The backend may also be used to generate code targeted at "
"SPUs of the Cell processor or GPUs to support the execution of compute "
"kernels."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:26
msgid ""
"The document focuses on existing examples found in subdirectories of ``llvm/"
"lib/Target`` in a downloaded LLVM release.  In particular, this document "
"focuses on the example of creating a static compiler (one that emits text "
"assembly) for a SPARC target, because SPARC has fairly standard "
"characteristics, such as a RISC instruction set and straightforward calling "
"conventions."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:34
msgid "Audience"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:36
msgid ""
"The audience for this document is anyone who needs to write an LLVM backend "
"to generate code for a specific hardware or software target."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:40
msgid "Prerequisite Reading"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:42
msgid "These essential documents must be read before reading this document:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:44
msgid ""
"`LLVM Language Reference Manual <LangRef.html>`_ --- a reference manual for "
"the LLVM assembly language."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:47
msgid ""
":doc:`CodeGenerator` --- a guide to the components (classes and code "
"generation algorithms) for translating the LLVM internal representation into "
"machine code for a specified target.  Pay particular attention to the "
"descriptions of code generation stages: Instruction Selection, Scheduling "
"and Formation, SSA-based Optimization, Register Allocation, Prolog/Epilog "
"Code Insertion, Late Machine Code Optimizations, and Code Emission."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:54
msgid ""
":doc:`TableGen/index` --- a document that describes the TableGen "
"(``tblgen``) application that manages domain-specific information to support "
"LLVM code generation.  TableGen processes input from a target description "
"file (``.td`` suffix) and generates C++ code that can be used for code "
"generation."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:60
msgid ""
":doc:`WritingAnLLVMPass` --- The assembly printer is a ``FunctionPass``, as "
"are several ``SelectionDAG`` processing steps."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:63
msgid ""
"To follow the SPARC examples in this document, have a copy of `The SPARC "
"Architecture Manual, Version 8 <http://www.sparc.org/standards/V8.pdf>`_ for "
"reference.  For details about the ARM instruction set, refer to the `ARM "
"Architecture Reference Manual <http://infocenter.arm.com/>`_.  For more "
"about the GNU Assembler format (``GAS``), see `Using As <http://sourceware."
"org/binutils/docs/as/index.html>`_, especially for the assembly printer.  "
"\"Using As\" contains a list of target machine dependent features."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:73
msgid "Basic Steps"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:75
msgid ""
"To write a compiler backend for LLVM that converts the LLVM IR to code for a "
"specified target (machine or other language), follow these steps:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:78
msgid ""
"Create a subclass of the ``TargetMachine`` class that describes "
"characteristics of your target machine.  Copy existing examples of specific "
"``TargetMachine`` class and header files; for example, start with "
"``SparcTargetMachine.cpp`` and ``SparcTargetMachine.h``, but change the file "
"names for your target.  Similarly, change code that references \"``Sparc``\" "
"to reference your target."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:85
msgid ""
"Describe the register set of the target.  Use TableGen to generate code for "
"register definition, register aliases, and register classes from a target-"
"specific ``RegisterInfo.td`` input file.  You should also write additional "
"code for a subclass of the ``TargetRegisterInfo`` class that represents the "
"class register file data used for register allocation and also describes the "
"interactions between registers."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:92
msgid ""
"Describe the instruction set of the target.  Use TableGen to generate code "
"for target-specific instructions from target-specific versions of "
"``TargetInstrFormats.td`` and ``TargetInstrInfo.td``.  You should write "
"additional code for a subclass of the ``TargetInstrInfo`` class to represent "
"machine instructions supported by the target machine."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:98
msgid ""
"Describe the selection and conversion of the LLVM IR from a Directed Acyclic "
"Graph (DAG) representation of instructions to native target-specific "
"instructions.  Use TableGen to generate code that matches patterns and "
"selects instructions based on additional information in a target-specific "
"version of ``TargetInstrInfo.td``.  Write code for ``XXXISelDAGToDAG.cpp``, "
"where ``XXX`` identifies the specific target, to perform pattern matching "
"and DAG-to-DAG instruction selection.  Also write code in ``XXXISelLowering."
"cpp`` to replace or remove operations and data types that are not supported "
"natively in a SelectionDAG."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:108
msgid ""
"Write code for an assembly printer that converts LLVM IR to a GAS format for "
"your target machine.  You should add assembly strings to the instructions "
"defined in your target-specific version of ``TargetInstrInfo.td``.  You "
"should also write code for a subclass of ``AsmPrinter`` that performs the "
"LLVM-to-assembly conversion and a trivial subclass of ``TargetAsmInfo``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:114
msgid ""
"Optionally, add support for subtargets (i.e., variants with different "
"capabilities).  You should also write code for a subclass of the "
"``TargetSubtarget`` class, which allows you to use the ``-mcpu=`` and ``-"
"mattr=`` command-line options."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:119
msgid ""
"Optionally, add JIT support and create a machine code emitter (subclass of "
"``TargetJITInfo``) that is used to emit binary code directly into memory."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:122
msgid ""
"In the ``.cpp`` and ``.h``. files, initially stub up these methods and then "
"implement them later.  Initially, you may not know which private members "
"that the class will need and which components will need to be subclassed."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:127
msgid "Preliminaries"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:129
msgid ""
"To actually create your compiler backend, you need to create and modify a "
"few files.  The absolute minimum is discussed here.  But to actually use the "
"LLVM target-independent code generator, you must perform the steps described "
"in the :doc:`LLVM Target-Independent Code Generator <CodeGenerator>` "
"document."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:134
msgid ""
"First, you should create a subdirectory under ``lib/Target`` to hold all the "
"files related to your target.  If your target is called \"Dummy\", create "
"the directory ``lib/Target/Dummy``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:138
msgid ""
"In this new directory, create a ``CMakeLists.txt``.  It is easiest to copy a "
"``CMakeLists.txt`` of another target and modify it.  It should at least "
"contain the ``LLVM_TARGET_DEFINITIONS`` variable. The library can be named "
"``LLVMDummy`` (for example, see the MIPS target).  Alternatively, you can "
"split the library into ``LLVMDummyCodeGen`` and ``LLVMDummyAsmPrinter``, the "
"latter of which should be implemented in a subdirectory below ``lib/Target/"
"Dummy`` (for example, see the PowerPC target)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:146
msgid ""
"Note that these two naming schemes are hardcoded into ``llvm-config``.  "
"Using any other naming scheme will confuse ``llvm-config`` and produce a lot "
"of (seemingly unrelated) linker errors when linking ``llc``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:150
msgid ""
"To make your target actually do something, you need to implement a subclass "
"of ``TargetMachine``.  This implementation should typically be in the file "
"``lib/Target/DummyTargetMachine.cpp``, but any file in the ``lib/Target`` "
"directory will be built and should work.  To use LLVM's target independent "
"code generator, you should do what all current machine backends do: create a "
"subclass of ``LLVMTargetMachine``.  (To create a target from scratch, create "
"a subclass of ``TargetMachine``.)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:158
msgid ""
"To get LLVM to actually build and link your target, you need to run "
"``cmake`` with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=Dummy``. This will "
"build your target without needing to add it to the list of all the targets."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:162
msgid ""
"Once your target is stable, you can add it to the ``LLVM_ALL_TARGETS`` "
"variable located in the main ``CMakeLists.txt``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:166
msgid "Target Machine"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:168
msgid ""
"``LLVMTargetMachine`` is designed as a base class for targets implemented "
"with the LLVM target-independent code generator.  The ``LLVMTargetMachine`` "
"class should be specialized by a concrete target class that implements the "
"various virtual methods.  ``LLVMTargetMachine`` is defined as a subclass of "
"``TargetMachine`` in ``include/llvm/Target/TargetMachine.h``.  The "
"``TargetMachine`` class implementation (``TargetMachine.cpp``) also "
"processes numerous command-line options."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:176
msgid ""
"To create a concrete target-specific subclass of ``LLVMTargetMachine``, "
"start by copying an existing ``TargetMachine`` class and header.  You should "
"name the files that you create to reflect your specific target.  For "
"instance, for the SPARC target, name the files ``SparcTargetMachine.h`` and "
"``SparcTargetMachine.cpp``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:182
msgid ""
"For a target machine ``XXX``, the implementation of ``XXXTargetMachine`` "
"must have access methods to obtain objects that represent target "
"components.  These methods are named ``get*Info``, and are intended to "
"obtain the instruction set (``getInstrInfo``), register set "
"(``getRegisterInfo``), stack frame layout (``getFrameInfo``), and similar "
"information.  ``XXXTargetMachine`` must also implement the ``getDataLayout`` "
"method to access an object with target-specific data characteristics, such "
"as data type size and alignment requirements."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:190
msgid ""
"For instance, for the SPARC target, the header file ``SparcTargetMachine.h`` "
"declares prototypes for several ``get*Info`` and ``getDataLayout`` methods "
"that simply return a class member."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:228
msgid "``getInstrInfo()``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:229
msgid "``getRegisterInfo()``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:230
msgid "``getFrameInfo()``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:231
msgid "``getDataLayout()``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:232
msgid "``getSubtargetImpl()``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:234
msgid "For some targets, you also need to support the following methods:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:236
msgid "``getTargetLowering()``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:237
msgid "``getJITInfo()``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:239
msgid ""
"Some architectures, such as GPUs, do not support jumping to an arbitrary "
"program location and implement branching using masked execution and loop "
"using special instructions around the loop body. In order to avoid CFG "
"modifications that introduce irreducible control flow not handled by such "
"hardware, a target must call `setRequiresStructuredCFG(true)` when being "
"initialized."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:245
msgid ""
"In addition, the ``XXXTargetMachine`` constructor should specify a "
"``TargetDescription`` string that determines the data layout for the target "
"machine, including characteristics such as pointer size, alignment, and "
"endianness.  For example, the constructor for ``SparcTargetMachine`` "
"contains the following:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:259
msgid "Hyphens separate portions of the ``TargetDescription`` string."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:261
msgid ""
"An upper-case \"``E``\" in the string indicates a big-endian target data "
"model. A lower-case \"``e``\" indicates little-endian."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:264
msgid ""
"\"``p:``\" is followed by pointer information: size, ABI alignment, and "
"preferred alignment.  If only two figures follow \"``p:``\", then the first "
"value is pointer size, and the second value is both ABI and preferred "
"alignment."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:269
msgid ""
"Then a letter for numeric type alignment: \"``i``\", \"``f``\", \"``v``\", "
"or \"``a``\" (corresponding to integer, floating point, vector, or "
"aggregate). \"``i``\", \"``v``\", or \"``a``\" are followed by ABI alignment "
"and preferred alignment. \"``f``\" is followed by three values: the first "
"indicates the size of a long double, then ABI alignment, and then ABI "
"preferred alignment."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:276
msgid "Target Registration"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:278
msgid ""
"You must also register your target with the ``TargetRegistry``, which is "
"what other LLVM tools use to be able to lookup and use your target at "
"runtime.  The ``TargetRegistry`` can be used directly, but for most targets "
"there are helper templates which should take care of the work for you."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:283
msgid ""
"All targets should declare a global ``Target`` object which is used to "
"represent the target during registration.  Then, in the target's "
"``TargetInfo`` library, the target should define that object and use the "
"``RegisterTarget`` template to register the target.  For example, the Sparc "
"registration code looks like this:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:298
msgid ""
"This allows the ``TargetRegistry`` to look up the target by name or by "
"target triple.  In addition, most targets will also register additional "
"features which are available in separate libraries.  These registration "
"steps are separate, because some clients may wish to only link in some parts "
"of the target --- the JIT code generator does not require the use of the "
"assembler printer, for example.  Here is an example of registering the Sparc "
"assembly printer:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:311
msgid ""
"For more information, see \"`llvm/Target/TargetRegistry.h </doxygen/"
"TargetRegistry_8h-source.html>`_\"."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:315
msgid "Register Set and Register Classes"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:317
msgid ""
"You should describe a concrete target-specific class that represents the "
"register file of a target machine.  This class is called ``XXXRegisterInfo`` "
"(where ``XXX`` identifies the target) and represents the class register file "
"data that is used for register allocation.  It also describes the "
"interactions between registers."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:323
msgid ""
"You also need to define register classes to categorize related registers.  A "
"register class should be added for groups of registers that are all treated "
"the same way for some instruction.  Typical examples are register classes "
"for integer, floating-point, or vector registers.  A register allocator "
"allows an instruction to use any register in a specified register class to "
"perform the instruction in a similar manner.  Register classes allocate "
"virtual registers to instructions from these sets, and register classes let "
"the target-independent register allocator automatically choose the actual "
"registers."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:333
msgid ""
"Much of the code for registers, including register definition, register "
"aliases, and register classes, is generated by TableGen from "
"``XXXRegisterInfo.td`` input files and placed in ``XXXGenRegisterInfo.h."
"inc`` and ``XXXGenRegisterInfo.inc`` output files.  Some of the code in the "
"implementation of ``XXXRegisterInfo`` requires hand-coding."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:340
msgid "Defining a Register"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:342
msgid ""
"The ``XXXRegisterInfo.td`` file typically starts with register definitions "
"for a target machine.  The ``Register`` class (specified in ``Target.td``) "
"is used to define an object for each register.  The specified string ``n`` "
"becomes the ``Name`` of the register.  The basic ``Register`` object does "
"not have any subregisters and does not specify any aliases."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:361
msgid ""
"For example, in the ``X86RegisterInfo.td`` file, there are register "
"definitions that utilize the ``Register`` class, such as:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:368
msgid ""
"This defines the register ``AL`` and assigns it values (with "
"``DwarfRegNum``) that are used by ``gcc``, ``gdb``, or a debug information "
"writer to identify a register.  For register ``AL``, ``DwarfRegNum`` takes "
"an array of 3 values representing 3 different modes: the first element is "
"for X86-64, the second for exception handling (EH) on X86-32, and the third "
"is generic. -1 is a special Dwarf number that indicates the gcc number is "
"undefined, and -2 indicates the register number is invalid for this mode."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:376
msgid ""
"From the previously described line in the ``X86RegisterInfo.td`` file, "
"TableGen generates this code in the ``X86GenRegisterInfo.inc`` file:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:389
msgid ""
"From the register info file, TableGen generates a ``TargetRegisterDesc`` "
"object for each register.  ``TargetRegisterDesc`` is defined in ``include/"
"llvm/Target/TargetRegisterInfo.h`` with the following fields:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:404
msgid ""
"TableGen uses the entire target description file (``.td``) to determine text "
"names for the register (in the ``AsmName`` and ``Name`` fields of "
"``TargetRegisterDesc``) and the relationships of other registers to the "
"defined register (in the other ``TargetRegisterDesc`` fields).  In this "
"example, other definitions establish the registers \"``AX``\", \"``EAX``\", "
"and \"``RAX``\" as aliases for one another, so TableGen generates a null-"
"terminated array (``AL_AliasSet``) for this register alias set."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:412
msgid ""
"The ``Register`` class is commonly used as a base class for more complex "
"classes.  In ``Target.td``, the ``Register`` class is the base for the "
"``RegisterWithSubRegs`` class that is used to define registers that need to "
"specify subregisters in the ``SubRegs`` list, as shown here:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:423
msgid ""
"In ``SparcRegisterInfo.td``, additional register classes are defined for "
"SPARC: a ``Register`` subclass, ``SparcReg``, and further subclasses: "
"``Ri``, ``Rf``, and ``Rd``.  SPARC registers are identified by 5-bit ID "
"numbers, which is a feature common to these subclasses.  Note the use of "
"\"``let``\" expressions to override values that are initially defined in a "
"superclass (such as ``SubRegs`` field in the ``Rd`` class)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:452
msgid ""
"In the ``SparcRegisterInfo.td`` file, there are register definitions that "
"utilize these subclasses of ``Register``, such as:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:466
msgid ""
"The last two registers shown above (``D0`` and ``D1``) are double-precision "
"floating-point registers that are aliases for pairs of single-precision "
"floating-point sub-registers.  In addition to aliases, the sub-register and "
"super-register relationships of the defined register are in fields of a "
"register's ``TargetRegisterDesc``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:473
msgid "Defining a Register Class"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:475
msgid ""
"The ``RegisterClass`` class (specified in ``Target.td``) is used to define "
"an object that represents a group of related registers and also defines the "
"default allocation order of the registers.  A target description file "
"``XXXRegisterInfo.td`` that uses ``Target.td`` can construct register "
"classes using the following class:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:503
msgid "To define a ``RegisterClass``, use the following 4 arguments:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:505
msgid "The first argument of the definition is the name of the namespace."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:507
msgid ""
"The second argument is a list of ``ValueType`` register type values that are "
"defined in ``include/llvm/CodeGen/ValueTypes.td``.  Defined values include "
"integer types (such as ``i16``, ``i32``, and ``i1`` for Boolean), floating-"
"point types (``f32``, ``f64``), and vector types (for example, ``v8i16`` for "
"an ``8 x i16`` vector).  All registers in a ``RegisterClass`` must have the "
"same ``ValueType``, but some registers may store vector data in different "
"configurations.  For example a register that can process a 128-bit vector "
"may be able to handle 16 8-bit integer elements, 8 16-bit integers, 4 32-bit "
"integers, and so on."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:517
msgid ""
"The third argument of the ``RegisterClass`` definition specifies the "
"alignment required of the registers when they are stored or loaded to memory."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:521
msgid ""
"The final argument, ``regList``, specifies which registers are in this "
"class. If an alternative allocation order method is not specified, then "
"``regList`` also defines the order of allocation used by the register "
"allocator.  Besides simply listing registers with ``(add R0, R1, ...)``, "
"more advanced set operators are available.  See ``include/llvm/Target/Target."
"td`` for more information."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:528
msgid ""
"In ``SparcRegisterInfo.td``, three ``RegisterClass`` objects are defined: "
"``FPRegs``, ``DFPRegs``, and ``IntRegs``.  For all three register classes, "
"the first argument defines the namespace with the string \"``SP``\".  "
"``FPRegs`` defines a group of 32 single-precision floating-point registers "
"(``F0`` to ``F31``); ``DFPRegs`` defines a group of 16 double-precision "
"registers (``D0-D15``)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:558
msgid ""
"Using ``SparcRegisterInfo.td`` with TableGen generates several output files "
"that are intended for inclusion in other source code that you write. "
"``SparcRegisterInfo.td`` generates ``SparcGenRegisterInfo.h.inc``, which "
"should be included in the header file for the implementation of the SPARC "
"register implementation that you write (``SparcRegisterInfo.h``).  In "
"``SparcGenRegisterInfo.h.inc`` a new structure is defined called "
"``SparcGenRegisterInfo`` that uses ``TargetRegisterInfo`` as its base.  It "
"also specifies types, based upon the defined register classes: "
"``DFPRegsClass``, ``FPRegsClass``, and ``IntRegsClass``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:568
msgid ""
"``SparcRegisterInfo.td`` also generates ``SparcGenRegisterInfo.inc``, which "
"is included at the bottom of ``SparcRegisterInfo.cpp``, the SPARC register "
"implementation.  The code below shows only the generated integer registers "
"and associated register classes.  The order of registers in ``IntRegs`` "
"reflects the order in the definition of ``IntRegs`` in the target "
"description file."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:621
msgid ""
"The register allocators will avoid using reserved registers, and callee "
"saved registers are not used until all the volatile registers have been "
"used.  That is usually good enough, but in some cases it may be necessary to "
"provide custom allocation orders."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:627
msgid "Implement a subclass of ``TargetRegisterInfo``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:629
msgid ""
"The final step is to hand code portions of ``XXXRegisterInfo``, which "
"implements the interface described in ``TargetRegisterInfo.h`` (see :ref:"
"`TargetRegisterInfo`).  These functions return ``0``, ``NULL``, or "
"``false``, unless overridden.  Here is a list of functions that are "
"overridden for the SPARC implementation in ``SparcRegisterInfo.cpp``:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:635
msgid ""
"``getCalleeSavedRegs`` --- Returns a list of callee-saved registers in the "
"order of the desired callee-save stack frame offset."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:638
msgid ""
"``getReservedRegs`` --- Returns a bitset indexed by physical register "
"numbers, indicating if a particular register is unavailable."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:641
msgid ""
"``hasFP`` --- Return a Boolean indicating if a function should have a "
"dedicated frame pointer register."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:644
msgid ""
"``eliminateCallFramePseudoInstr`` --- If call frame setup or destroy pseudo "
"instructions are used, this can be called to eliminate them."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:647
msgid ""
"``eliminateFrameIndex`` --- Eliminate abstract frame indices from "
"instructions that may use them."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:650
msgid "``emitPrologue`` --- Insert prologue code into the function."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:652
msgid "``emitEpilogue`` --- Insert epilogue code into the function."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:657
msgid "Instruction Set"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:659
msgid ""
"During the early stages of code generation, the LLVM IR code is converted to "
"a ``SelectionDAG`` with nodes that are instances of the ``SDNode`` class "
"containing target instructions.  An ``SDNode`` has an opcode, operands, type "
"requirements, and operation properties.  For example, is an operation "
"commutative, does an operation load from memory.  The various operation node "
"types are described in the ``include/llvm/CodeGen/SelectionDAGNodes.h`` file "
"(values of the ``NodeType`` enum in the ``ISD`` namespace)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:667
msgid ""
"TableGen uses the following target description (``.td``) input files to "
"generate much of the code for instruction definition:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:670
msgid ""
"``Target.td`` --- Where the ``Instruction``, ``Operand``, ``InstrInfo``, and "
"other fundamental classes are defined."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:673
msgid ""
"``TargetSelectionDAG.td`` --- Used by ``SelectionDAG`` instruction selection "
"generators, contains ``SDTC*`` classes (selection DAG type constraint), "
"definitions of ``SelectionDAG`` nodes (such as ``imm``, ``cond``, ``bb``, "
"``add``, ``fadd``, ``sub``), and pattern support (``Pattern``, ``Pat``, "
"``PatFrag``, ``PatLeaf``, ``ComplexPattern``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:679
msgid ""
"``XXXInstrFormats.td`` --- Patterns for definitions of target-specific "
"instructions."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:682
msgid ""
"``XXXInstrInfo.td`` --- Target-specific definitions of instruction "
"templates, condition codes, and instructions of an instruction set.  For "
"architecture modifications, a different file name may be used.  For example, "
"for Pentium with SSE instruction, this file is ``X86InstrSSE.td``, and for "
"Pentium with MMX, this file is ``X86InstrMMX.td``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:688
msgid ""
"There is also a target-specific ``XXX.td`` file, where ``XXX`` is the name "
"of the target.  The ``XXX.td`` file includes the other ``.td`` input files, "
"but its contents are only directly important for subtargets."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:692
msgid ""
"You should describe a concrete target-specific class ``XXXInstrInfo`` that "
"represents machine instructions supported by a target machine. "
"``XXXInstrInfo`` contains an array of ``XXXInstrDescriptor`` objects, each "
"of which describes one instruction.  An instruction descriptor defines:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:697
msgid "Opcode mnemonic"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:698
msgid "Number of operands"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:699
msgid "List of implicit register definitions and uses"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:700
msgid "Target-independent properties (such as memory access, is commutable)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:701
msgid "Target-specific flags"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:703
msgid ""
"The Instruction class (defined in ``Target.td``) is mostly used as a base "
"for more complex instruction classes."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:720
msgid ""
"A ``SelectionDAG`` node (``SDNode``) should contain an object representing a "
"target-specific instruction that is defined in ``XXXInstrInfo.td``.  The "
"instruction objects should represent instructions from the architecture "
"manual of the target machine (such as the SPARC Architecture Manual for the "
"SPARC target)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:726
msgid ""
"A single instruction from the architecture manual is often modeled as "
"multiple target instructions, depending upon its operands.  For example, a "
"manual might describe an add instruction that takes a register or an "
"immediate operand.  An LLVM target could model this with two instructions "
"named ``ADDri`` and ``ADDrr``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:732
msgid ""
"You should define a class for each instruction category and define each "
"opcode as a subclass of the category with appropriate parameters such as the "
"fixed binary encoding of opcodes and extended opcodes.  You should map the "
"register bits to the bits of the instruction in which they are encoded (for "
"the JIT). Also you should specify how the instruction should be printed when "
"the automatic assembly printer is used."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:739
msgid ""
"As is described in the SPARC Architecture Manual, Version 8, there are three "
"major 32-bit formats for instructions.  Format 1 is only for the ``CALL`` "
"instruction.  Format 2 is for branch on condition codes and ``SETHI`` (set "
"high bits of a register) instructions.  Format 3 is for other instructions."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:744
msgid ""
"Each of these formats has corresponding classes in ``SparcInstrFormat.td``. "
"``InstSP`` is a base class for other instruction classes.  Additional base "
"classes are specified for more precise formats: for example in "
"``SparcInstrFormat.td``, ``F2_1`` is for ``SETHI``, and ``F2_2`` is for "
"branches.  There are three other base classes: ``F3_1`` for register/"
"register operations, ``F3_2`` for register/immediate operations, and "
"``F3_3`` for floating-point operations.  ``SparcInstrInfo.td`` also adds the "
"base class ``Pseudo`` for synthetic SPARC instructions."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:753
msgid ""
"``SparcInstrInfo.td`` largely consists of operand and instruction "
"definitions for the SPARC target.  In ``SparcInstrInfo.td``, the following "
"target description file entry, ``LDrr``, defines the Load Integer "
"instruction for a Word (the ``LD`` SPARC opcode) from a memory address to a "
"register.  The first parameter, the value 3 (``11``\\ :sub:`2`), is the "
"operation value for this category of operation.  The second parameter "
"(``000000``\\ :sub:`2`) is the specific operation value for ``LD``/Load "
"Word.  The third parameter is the output destination, which is a register "
"operand and defined in the ``Register`` target description file "
"(``IntRegs``)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:769
msgid ""
"The fourth parameter is the input source, which uses the address operand "
"``MEMrr`` that is defined earlier in ``SparcInstrInfo.td``:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:779
msgid ""
"The fifth parameter is a string that is used by the assembly printer and can "
"be left as an empty string until the assembly printer interface is "
"implemented. The sixth and final parameter is the pattern used to match the "
"instruction during the SelectionDAG Select Phase described in :doc:"
"`CodeGenerator`. This parameter is detailed in the next section, :ref:"
"`instruction-selector`."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:785
msgid ""
"Instruction class definitions are not overloaded for different operand "
"types, so separate versions of instructions are needed for register, memory, "
"or immediate value operands.  For example, to perform a Load Integer "
"instruction for a Word from an immediate operand to a register, the "
"following instruction class is defined:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:797
msgid ""
"Writing these definitions for so many similar instructions can involve a lot "
"of cut and paste.  In ``.td`` files, the ``multiclass`` directive enables "
"the creation of templates to define several instruction classes at once "
"(using the ``defm`` directive).  For example in ``SparcInstrInfo.td``, the "
"``multiclass`` pattern ``F3_12`` is defined to create 2 instruction classes "
"each time ``F3_12`` is invoked:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:817
msgid ""
"So when the ``defm`` directive is used for the ``XOR`` and ``ADD`` "
"instructions, as seen below, it creates four instruction objects: ``XORrr``, "
"``XORri``, ``ADDrr``, and ``ADDri``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:826
msgid ""
"``SparcInstrInfo.td`` also includes definitions for condition codes that are "
"referenced by branch instructions.  The following definitions in "
"``SparcInstrInfo.td`` indicate the bit location of the SPARC condition code. "
"For example, the 10\\ :sup:`th` bit represents the \"greater than\" "
"condition for integers, and the 22\\ :sup:`nd` bit represents the \"greater "
"than\" condition for floats."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:844
msgid ""
"(Note that ``Sparc.h`` also defines enums that correspond to the same SPARC "
"condition codes.  Care must be taken to ensure the values in ``Sparc.h`` "
"correspond to the values in ``SparcInstrInfo.td``.  I.e., ``SPCC::ICC_NE = "
"9``, ``SPCC::FCC_U = 23`` and so on.)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:850
msgid "Instruction Operand Mapping"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:852
msgid ""
"The code generator backend maps instruction operands to fields in the "
"instruction.  Operands are assigned to unbound fields in the instruction in "
"the order they are defined.  Fields are bound when they are assigned a "
"value.  For example, the Sparc target defines the ``XNORrr`` instruction as "
"a ``F3_1`` format instruction having three operands."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:865
msgid ""
"The instruction templates in ``SparcInstrFormats.td`` show the base class "
"for ``F3_1`` is ``InstSP``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:881
msgid "``InstSP`` leaves the ``op`` field unbound."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:896
msgid ""
"``F3`` binds the ``op`` field and defines the ``rd``, ``op3``, and ``rs1`` "
"fields.  ``F3`` format instructions will bind the operands ``rd``, ``op3``, "
"and ``rs1`` fields."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:913
msgid ""
"``F3_1`` binds the ``op3`` field and defines the ``rs2`` fields.  ``F3_1`` "
"format instructions will bind the operands to the ``rd``, ``rs1``, and "
"``rs2`` fields.  This results in the ``XNORrr`` instruction binding "
"``$dst``, ``$b``, and ``$c`` operands to the ``rd``, ``rs1``, and ``rs2`` "
"fields respectively."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:919
msgid "Instruction Operand Name Mapping"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:921
msgid ""
"TableGen will also generate a function called getNamedOperandIdx() which can "
"be used to look up an operand's index in a MachineInstr based on its "
"TableGen name.  Setting the UseNamedOperandTable bit in an instruction's "
"TableGen definition will add all of its operands to an enumeration in the "
"llvm::XXX:OpName namespace and also add an entry for it into the OperandMap "
"table, which can be queried using getNamedOperandIdx()"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:937
msgid ""
"The entries in the OpName enum are taken verbatim from the TableGen "
"definitions, so operands with lowercase names will have lower case entries "
"in the enum."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:940
msgid ""
"To include the getNamedOperandIdx() function in your backend, you will need "
"to define a few preprocessor macros in XXXInstrInfo.cpp and XXXInstrInfo.h. "
"For example:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:944
msgid "XXXInstrInfo.cpp:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:951
msgid "XXXInstrInfo.h:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:963
msgid "Instruction Operand Types"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:965
msgid ""
"TableGen will also generate an enumeration consisting of all named Operand "
"types defined in the backend, in the llvm::XXX::OpTypes namespace. Some "
"common immediate Operand types (for instance i8, i32, i64, f32, f64) are "
"defined for all targets in ``include/llvm/Target/Target.td``, and are "
"available in each Target's OpTypes enum.  Also, only named Operand types "
"appear in the enumeration: anonymous types are ignored. For example, the X86 "
"backend defines ``brtarget`` and ``brtarget8``, both instances of the "
"TableGen ``Operand`` class, which represent branch target operands:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:980
msgid "This results in:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:998
msgid ""
"In typical TableGen fashion, to use the enum, you will need to define a "
"preprocessor macro:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1008
msgid "Instruction Scheduling"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1010
msgid ""
"Instruction itineraries can be queried using MCDesc::getSchedClass(). The "
"value can be named by an enumeration in llvm::XXX::Sched namespace generated "
"by TableGen in XXXGenInstrInfo.inc. The name of the schedule classes are the "
"same as provided in XXXSchedule.td plus a default NoItinerary class."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1015
msgid ""
"The schedule models are generated by TableGen by the SubtargetEmitter, using "
"the ``CodeGenSchedModels`` class. This is distinct from the itinerary method "
"of specifying machine resource use.  The tool ``utils/schedcover.py`` can be "
"used to determine which instructions have been covered by the schedule model "
"description and which haven't. The first step is to use the instructions "
"below to create an output file. Then run ``schedcover.py`` on the output "
"file:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1031
msgid ""
"To capture the debug output from generating a schedule model, change to the "
"appropriate target directory and use the following command: command with the "
"``subtarget-emitter`` debug option:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1043
msgid ""
"Where ``<build>`` is the build directory, ``src`` is the source directory, "
"and ``<target>`` is the name of the target. To double check that the above "
"command is what is needed, one can capture the exact TableGen command from a "
"build by using:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1052
msgid "and search for ``llvm-tblgen`` commands in the output."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1056
msgid "Instruction Relation Mapping"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1058
msgid ""
"This TableGen feature is used to relate instructions with each other.  It is "
"particularly useful when you have multiple instruction formats and need to "
"switch between them after instruction selection.  This entire feature is "
"driven by relation models which can be defined in ``XXXInstrInfo.td`` files "
"according to the target-specific instruction set.  Relation models are "
"defined using ``InstrMapping`` class as a base.  TableGen parses all the "
"models and generates instruction relation maps using the specified "
"information. Relation maps are emitted as tables in the ``XXXGenInstrInfo."
"inc`` file along with the functions to query them.  For the detailed "
"information on how to use this feature, please refer to :doc:"
"`HowToUseInstrMappings`."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1070
msgid "Implement a subclass of ``TargetInstrInfo``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1072
msgid ""
"The final step is to hand code portions of ``XXXInstrInfo``, which "
"implements the interface described in ``TargetInstrInfo.h`` (see :ref:"
"`TargetInstrInfo`). These functions return ``0`` or a Boolean or they "
"assert, unless overridden. Here's a list of functions that are overridden "
"for the SPARC implementation in ``SparcInstrInfo.cpp``:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1078
msgid ""
"``isLoadFromStackSlot`` --- If the specified machine instruction is a direct "
"load from a stack slot, return the register number of the destination and "
"the ``FrameIndex`` of the stack slot."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1082
msgid ""
"``isStoreToStackSlot`` --- If the specified machine instruction is a direct "
"store to a stack slot, return the register number of the destination and the "
"``FrameIndex`` of the stack slot."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1086
msgid "``copyPhysReg`` --- Copy values between a pair of physical registers."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1088
msgid "``storeRegToStackSlot`` --- Store a register value to a stack slot."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1090
msgid "``loadRegFromStackSlot`` --- Load a register value from a stack slot."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1092
msgid "``storeRegToAddr`` --- Store a register value to memory."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1094
msgid "``loadRegFromAddr`` --- Load a register value from memory."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1096
msgid ""
"``foldMemoryOperand`` --- Attempt to combine instructions of any load or "
"store instruction for the specified operand(s)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1100
msgid "Branch Folding and If Conversion"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1102
msgid ""
"Performance can be improved by combining instructions or by eliminating "
"instructions that are never reached.  The ``analyzeBranch`` method in "
"``XXXInstrInfo`` may be implemented to examine conditional instructions and "
"remove unnecessary instructions.  ``analyzeBranch`` looks at the end of a "
"machine basic block (MBB) for opportunities for improvement, such as branch "
"folding and if conversion.  The ``BranchFolder`` and ``IfConverter`` machine "
"function passes (see the source files ``BranchFolding.cpp`` and "
"``IfConversion.cpp`` in the ``lib/CodeGen`` directory) call "
"``analyzeBranch`` to improve the control flow graph that represents the "
"instructions."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1112
msgid ""
"Several implementations of ``analyzeBranch`` (for ARM, Alpha, and X86) can "
"be examined as models for your own ``analyzeBranch`` implementation.  Since "
"SPARC does not implement a useful ``analyzeBranch``, the ARM target "
"implementation is shown below."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1117
msgid "``analyzeBranch`` returns a Boolean value and takes four parameters:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1119
msgid "``MachineBasicBlock &MBB`` --- The incoming block to be examined."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1121
msgid ""
"``MachineBasicBlock *&TBB`` --- A destination block that is returned.  For a "
"conditional branch that evaluates to true, ``TBB`` is the destination."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1124
msgid ""
"``MachineBasicBlock *&FBB`` --- For a conditional branch that evaluates to "
"false, ``FBB`` is returned as the destination."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1127
msgid ""
"``std::vector<MachineOperand> &Cond`` --- List of operands to evaluate a "
"condition for a conditional branch."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1130
msgid ""
"In the simplest case, if a block ends without a branch, then it falls "
"through to the successor block.  No destination blocks are specified for "
"either ``TBB`` or ``FBB``, so both parameters return ``NULL``.  The start of "
"the ``analyzeBranch`` (see code below for the ARM target) shows the function "
"parameters and the code for the simplest case."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1147
msgid ""
"If a block ends with a single unconditional branch instruction, then "
"``analyzeBranch`` (shown below) should return the destination of that branch "
"in the ``TBB`` parameter."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1158
msgid ""
"If a block ends with two unconditional branches, then the second branch is "
"never reached.  In that situation, as shown below, remove the last branch "
"instruction and return the penultimate branch in the ``TBB`` parameter."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1172
msgid ""
"A block may end with a single conditional branch instruction that falls "
"through to successor block if the condition evaluates to false.  In that "
"case, ``analyzeBranch`` (shown below) should return the destination of that "
"conditional branch in the ``TBB`` parameter and a list of operands in the "
"``Cond`` parameter to evaluate the condition."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1188
msgid ""
"If a block ends with both a conditional branch and an ensuing unconditional "
"branch, then ``analyzeBranch`` (shown below) should return the conditional "
"branch destination (assuming it corresponds to a conditional evaluation of "
"\"``true``\") in the ``TBB`` parameter and the unconditional branch "
"destination in the ``FBB`` (corresponding to a conditional evaluation of "
"\"``false``\").  A list of operands to evaluate the condition should be "
"returned in the ``Cond`` parameter."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1209
msgid ""
"For the last two cases (ending with a single conditional branch or ending "
"with one conditional and one unconditional branch), the operands returned in "
"the ``Cond`` parameter can be passed to methods of other instructions to "
"create new branches or perform other operations.  An implementation of "
"``analyzeBranch`` requires the helper methods ``removeBranch`` and "
"``insertBranch`` to manage subsequent operations."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1216
msgid ""
"``analyzeBranch`` should return false indicating success in most "
"circumstances. ``analyzeBranch`` should only return true when the method is "
"stumped about what to do, for example, if a block has three terminating "
"branches. ``analyzeBranch`` may return true if it encounters a terminator it "
"cannot handle, such as an indirect branch."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1225
msgid "Instruction Selector"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1227
msgid ""
"LLVM uses a ``SelectionDAG`` to represent LLVM IR instructions, and nodes of "
"the ``SelectionDAG`` ideally represent native target instructions.  During "
"code generation, instruction selection passes are performed to convert non-"
"native DAG instructions into native target-specific instructions.  The pass "
"described in ``XXXISelDAGToDAG.cpp`` is used to match patterns and perform "
"DAG-to-DAG instruction selection.  Optionally, a pass may be defined (in "
"``XXXBranchSelector.cpp``) to perform similar DAG-to-DAG operations for "
"branch instructions.  Later, the code in ``XXXISelLowering.cpp`` replaces or "
"removes operations and data types not supported natively (legalizes) in a "
"``SelectionDAG``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1238
msgid ""
"TableGen generates code for instruction selection using the following target "
"description input files:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1241
msgid ""
"``XXXInstrInfo.td`` --- Contains definitions of instructions in a target-"
"specific instruction set, generates ``XXXGenDAGISel.inc``, which is included "
"in ``XXXISelDAGToDAG.cpp``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1245
msgid ""
"``XXXCallingConv.td`` --- Contains the calling and return value conventions "
"for the target architecture, and it generates ``XXXGenCallingConv.inc``, "
"which is included in ``XXXISelLowering.cpp``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1249
msgid ""
"The implementation of an instruction selection pass must include a header "
"that declares the ``FunctionPass`` class or a subclass of ``FunctionPass``.  "
"In ``XXXTargetMachine.cpp``, a Pass Manager (PM) should add each instruction "
"selection pass into the queue of passes to run."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1254
msgid ""
"The LLVM static compiler (``llc``) is an excellent tool for visualizing the "
"contents of DAGs.  To display the ``SelectionDAG`` before or after specific "
"processing phases, use the command line options for ``llc``, described at :"
"ref:`SelectionDAG-Process`."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1259
msgid ""
"To describe instruction selector behavior, you should add patterns for "
"lowering LLVM code into a ``SelectionDAG`` as the last parameter of the "
"instruction definitions in ``XXXInstrInfo.td``.  For example, in "
"``SparcInstrInfo.td``, this entry defines a register store operation, and "
"the last parameter describes a pattern with the store DAG operator."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1270
msgid ""
"``ADDRrr`` is a memory mode that is also defined in ``SparcInstrInfo.td``:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1276
msgid ""
"The definition of ``ADDRrr`` refers to ``SelectADDRrr``, which is a function "
"defined in an implementation of the Instructor Selector (such as "
"``SparcISelDAGToDAG.cpp``)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1280
msgid ""
"In ``lib/Target/TargetSelectionDAG.td``, the DAG operator for store is "
"defined below:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1293
msgid ""
"``XXXInstrInfo.td`` also generates (in ``XXXGenDAGISel.inc``) the "
"``SelectCode`` method that is used to call the appropriate processing method "
"for an instruction.  In this example, ``SelectCode`` calls "
"``Select_ISD_STORE`` for the ``ISD::STORE`` opcode."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1314
msgid ""
"The pattern for ``STrr`` is matched, so elsewhere in ``XXXGenDAGISel.inc``, "
"code for ``STrr`` is created for ``Select_ISD_STORE``.  The ``Emit_22`` "
"method is also generated in ``XXXGenDAGISel.inc`` to complete the processing "
"of this instruction."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1341
msgid "The SelectionDAG Legalize Phase"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1343
msgid ""
"The Legalize phase converts a DAG to use types and operations that are "
"natively supported by the target.  For natively unsupported types and "
"operations, you need to add code to the target-specific "
"``XXXTargetLowering`` implementation to convert unsupported types and "
"operations to supported ones."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1348
msgid ""
"In the constructor for the ``XXXTargetLowering`` class, first use the "
"``addRegisterClass`` method to specify which types are supported and which "
"register classes are associated with them.  The code for the register "
"classes are generated by TableGen from ``XXXRegisterInfo.td`` and placed in "
"``XXXGenRegisterInfo.h.inc``.  For example, the implementation of the "
"constructor for the SparcTargetLowering class (in ``SparcISelLowering.cpp``) "
"starts with the following code:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1362
msgid ""
"You should examine the node types in the ``ISD`` namespace (``include/llvm/"
"CodeGen/SelectionDAGNodes.h``) and determine which operations the target "
"natively supports.  For operations that do **not** have native support, add "
"a callback to the constructor for the ``XXXTargetLowering`` class, so the "
"instruction selection process knows what to do.  The ``TargetLowering`` "
"class callback methods (declared in ``llvm/Target/TargetLowering.h``) are:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1369
msgid "``setOperationAction`` --- General operation."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1370
msgid "``setLoadExtAction`` --- Load with extension."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1371
msgid "``setTruncStoreAction`` --- Truncating store."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1372
msgid "``setIndexedLoadAction`` --- Indexed load."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1373
msgid "``setIndexedStoreAction`` --- Indexed store."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1374
msgid "``setConvertAction`` --- Type conversion."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1375
msgid "``setCondCodeAction`` --- Support for a given condition code."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1377
msgid ""
"Note: on older releases, ``setLoadXAction`` is used instead of "
"``setLoadExtAction``.  Also, on older releases, ``setCondCodeAction`` may "
"not be supported.  Examine your release to see what methods are specifically "
"supported."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1382
msgid ""
"These callbacks are used to determine that an operation does or does not "
"work with a specified type (or types).  And in all cases, the third "
"parameter is a ``LegalAction`` type enum value: ``Promote``, ``Expand``, "
"``Custom``, or ``Legal``.  ``SparcISelLowering.cpp`` contains examples of "
"all four ``LegalAction`` values."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1389
msgid "Promote"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1391
msgid ""
"For an operation without native support for a given type, the specified type "
"may be promoted to a larger type that is supported.  For example, SPARC does "
"not support a sign-extending load for Boolean values (``i1`` type), so in "
"``SparcISelLowering.cpp`` the third parameter below, ``Promote``, changes "
"``i1`` type values to a large type before loading."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1402
msgid "Expand"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1404
msgid ""
"For a type without native support, a value may need to be broken down "
"further, rather than promoted.  For an operation without native support, a "
"combination of other operations may be used to similar effect.  In SPARC, "
"the floating-point sine and cosine trig operations are supported by "
"expansion to other operations, as indicated by the third parameter, "
"``Expand``, to ``setOperationAction``:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1417
msgid "Custom"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1419
msgid ""
"For some operations, simple type promotion or operation expansion may be "
"insufficient.  In some cases, a special intrinsic function must be "
"implemented."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1422
msgid ""
"For example, a constant value may require special treatment, or an operation "
"may require spilling and restoring registers in the stack and working with "
"register allocators."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1426
msgid ""
"As seen in ``SparcISelLowering.cpp`` code below, to perform a type "
"conversion from a floating point value to a signed integer, first the "
"``setOperationAction`` should be called with ``Custom`` as the third "
"parameter:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1434
msgid ""
"In the ``LowerOperation`` method, for each ``Custom`` operation, a case "
"statement should be added to indicate what function to call.  In the "
"following code, an ``FP_TO_SINT`` opcode will call the ``LowerFP_TO_SINT`` "
"method:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1447
msgid ""
"Finally, the ``LowerFP_TO_SINT`` method is implemented, using an FP register "
"to convert the floating-point value to an integer."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1459
msgid "Legal"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1461
msgid ""
"The ``Legal`` ``LegalizeAction`` enum value simply indicates that an "
"operation **is** natively supported.  ``Legal`` represents the default "
"condition, so it is rarely used.  In ``SparcISelLowering.cpp``, the action "
"for ``CTPOP`` (an operation to count the bits set in an integer) is natively "
"supported only for SPARC v9.  The following code enables the ``Expand`` "
"conversion technique for non-v9 SPARC implementations."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1476
msgid "Calling Conventions"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1478
msgid ""
"To support target-specific calling conventions, ``XXXGenCallingConv.td`` "
"uses interfaces (such as ``CCIfType`` and ``CCAssignToReg``) that are "
"defined in ``lib/Target/TargetCallingConv.td``.  TableGen can take the "
"target descriptor file ``XXXGenCallingConv.td`` and generate the header file "
"``XXXGenCallingConv.inc``, which is typically included in ``XXXISelLowering."
"cpp``.  You can use the interfaces in ``TargetCallingConv.td`` to specify:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1486
msgid "The order of parameter allocation."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1488
msgid ""
"Where parameters and return values are placed (that is, on the stack or in "
"registers)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1491
msgid "Which registers may be used."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1493
msgid "Whether the caller or callee unwinds the stack."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1495
msgid ""
"The following example demonstrates the use of the ``CCIfType`` and "
"``CCAssignToReg`` interfaces.  If the ``CCIfType`` predicate is true (that "
"is, if the current argument is of type ``f32`` or ``f64``), then the action "
"is performed.  In this case, the ``CCAssignToReg`` action assigns the "
"argument value to the first available register: either ``R0`` or ``R1``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1505
msgid ""
"``SparcCallingConv.td`` contains definitions for a target-specific return-"
"value calling convention (``RetCC_Sparc32``) and a basic 32-bit C calling "
"convention (``CC_Sparc32``).  The definition of ``RetCC_Sparc32`` (shown "
"below) indicates which registers are used for specified scalar return "
"types.  A single-precision float is returned to register ``F0``, and a "
"double-precision float goes to register ``D0``.  A 32-bit integer is "
"returned in register ``I0`` or ``I1``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1520
msgid ""
"The definition of ``CC_Sparc32`` in ``SparcCallingConv.td`` introduces "
"``CCAssignToStack``, which assigns the value to a stack slot with the "
"specified size and alignment.  In the example below, the first parameter, 4, "
"indicates the size of the slot, and the second parameter, also 4, indicates "
"the stack alignment along 4-byte units.  (Special cases: if size is zero, "
"then the ABI size is used; if alignment is zero, then the ABI alignment is "
"used.)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1535
msgid ""
"``CCDelegateTo`` is another commonly used interface, which tries to find a "
"specified sub-calling convention, and, if a match is found, it is invoked.  "
"In the following example (in ``X86CallingConv.td``), the definition of "
"``RetCC_X86_32_C`` ends with ``CCDelegateTo``.  After the current value is "
"assigned to the register ``ST0`` or ``ST1``, the ``RetCC_X86Common`` is "
"invoked."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1550
msgid ""
"``CCIfCC`` is an interface that attempts to match the given name to the "
"current calling convention.  If the name identifies the current calling "
"convention, then a specified action is invoked.  In the following example "
"(in ``X86CallingConv.td``), if the ``Fast`` calling convention is in use, "
"then ``RetCC_X86_32_Fast`` is invoked.  If the ``SSECall`` calling "
"convention is in use, then ``RetCC_X86_32_SSE`` is invoked."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1565
msgid "Other calling convention interfaces include:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1567
msgid ""
"``CCIf <predicate, action>`` --- If the predicate matches, apply the action."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1569
msgid ""
"``CCIfInReg <action>`` --- If the argument is marked with the \"``inreg``\" "
"attribute, then apply the action."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1572
msgid ""
"``CCIfNest <action>`` --- If the argument is marked with the \"``nest``\" "
"attribute, then apply the action."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1575
msgid ""
"``CCIfNotVarArg <action>`` --- If the current function does not take a "
"variable number of arguments, apply the action."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1578
msgid ""
"``CCAssignToRegWithShadow <registerList, shadowList>`` --- similar to "
"``CCAssignToReg``, but with a shadow list of registers."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1581
msgid ""
"``CCPassByVal <size, align>`` --- Assign value to a stack slot with the "
"minimum specified size and alignment."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1584
msgid ""
"``CCPromoteToType <type>`` --- Promote the current value to the specified "
"type."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1587
msgid ""
"``CallingConv <[actions]>`` --- Define each calling convention that is "
"supported."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1591
msgid "Assembly Printer"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1593
msgid ""
"During the code emission stage, the code generator may utilize an LLVM pass "
"to produce assembly output.  To do this, you want to implement the code for "
"a printer that converts LLVM IR to a GAS-format assembly language for your "
"target machine, using the following steps:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1598
msgid ""
"Define all the assembly strings for your target, adding them to the "
"instructions defined in the ``XXXInstrInfo.td`` file.  (See :ref:"
"`instruction-set`.)  TableGen will produce an output file (``XXXGenAsmWriter."
"inc``) with an implementation of the ``printInstruction`` method for the "
"``XXXAsmPrinter`` class."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1604
msgid ""
"Write ``XXXTargetAsmInfo.h``, which contains the bare-bones declaration of "
"the ``XXXTargetAsmInfo`` class (a subclass of ``TargetAsmInfo``)."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1607
msgid ""
"Write ``XXXTargetAsmInfo.cpp``, which contains target-specific values for "
"``TargetAsmInfo`` properties and sometimes new implementations for methods."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1610
msgid ""
"Write ``XXXAsmPrinter.cpp``, which implements the ``AsmPrinter`` class that "
"performs the LLVM-to-assembly conversion."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1613
msgid ""
"The code in ``XXXTargetAsmInfo.h`` is usually a trivial declaration of the "
"``XXXTargetAsmInfo`` class for use in ``XXXTargetAsmInfo.cpp``.  Similarly, "
"``XXXTargetAsmInfo.cpp`` usually has a few declarations of "
"``XXXTargetAsmInfo`` replacement values that override the default values in "
"``TargetAsmInfo.cpp``. For example in ``SparcTargetAsmInfo.cpp``:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1630
msgid ""
"The X86 assembly printer implementation (``X86TargetAsmInfo``) is an example "
"where the target specific ``TargetAsmInfo`` class uses an overridden "
"methods: ``ExpandInlineAsm``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1634
msgid ""
"A target-specific implementation of ``AsmPrinter`` is written in "
"``XXXAsmPrinter.cpp``, which implements the ``AsmPrinter`` class that "
"converts the LLVM to printable assembly.  The implementation must include "
"the following headers that have declarations for the ``AsmPrinter`` and "
"``MachineFunctionPass`` classes.  The ``MachineFunctionPass`` is a subclass "
"of ``FunctionPass``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1646
msgid ""
"As a ``FunctionPass``, ``AsmPrinter`` first calls ``doInitialization`` to "
"set up the ``AsmPrinter``.  In ``SparcAsmPrinter``, a ``Mangler`` object is "
"instantiated to process variable names."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1650
msgid ""
"In ``XXXAsmPrinter.cpp``, the ``runOnMachineFunction`` method (declared in "
"``MachineFunctionPass``) must be implemented for ``XXXAsmPrinter``.  In "
"``MachineFunctionPass``, the ``runOnFunction`` method invokes "
"``runOnMachineFunction``.  Target-specific implementations of "
"``runOnMachineFunction`` differ, but generally do the following to process "
"each machine function:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1657
msgid "Call ``SetupMachineFunction`` to perform initialization."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1659
msgid ""
"Call ``EmitConstantPool`` to print out (to the output stream) constants "
"which have been spilled to memory."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1662
msgid ""
"Call ``EmitJumpTableInfo`` to print out jump tables used by the current "
"function."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1665
msgid "Print out the label for the current function."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1667
msgid ""
"Print out the code for the function, including basic block labels and the "
"assembly for the instruction (using ``printInstruction``)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1670
msgid ""
"The ``XXXAsmPrinter`` implementation must also include the code generated by "
"TableGen that is output in the ``XXXGenAsmWriter.inc`` file.  The code in "
"``XXXGenAsmWriter.inc`` contains an implementation of the "
"``printInstruction`` method that may call these methods:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1675
msgid "``printOperand``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1676
msgid "``printMemOperand``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1677
msgid "``printCCOperand`` (for conditional statements)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1678
msgid "``printDataDirective``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1679
msgid "``printDeclare``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1680
msgid "``printImplicitDef``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1681
msgid "``printInlineAsm``"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1683
msgid ""
"The implementations of ``printDeclare``, ``printImplicitDef``, "
"``printInlineAsm``, and ``printLabel`` in ``AsmPrinter.cpp`` are generally "
"adequate for printing assembly and do not need to be overridden."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1687
msgid ""
"The ``printOperand`` method is implemented with a long ``switch``/``case`` "
"statement for the type of operand: register, immediate, basic block, "
"external symbol, global address, constant pool index, or jump table index.  "
"For an instruction with a memory address operand, the ``printMemOperand`` "
"method should be implemented to generate the proper output.  Similarly, "
"``printCCOperand`` should be used to print a conditional operand."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1694
msgid ""
"``doFinalization`` should be overridden in ``XXXAsmPrinter``, and it should "
"be called to shut down the assembly printer.  During ``doFinalization``, "
"global variables and constants are printed to output."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1699
msgid "Subtarget Support"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1701
msgid ""
"Subtarget support is used to inform the code generation process of "
"instruction set variations for a given chip set.  For example, the LLVM "
"SPARC implementation provided covers three major versions of the SPARC "
"microprocessor architecture: Version 8 (V8, which is a 32-bit architecture), "
"Version 9 (V9, a 64-bit architecture), and the UltraSPARC architecture.  V8 "
"has 16 double-precision floating-point registers that are also usable as "
"either 32 single-precision or 8 quad-precision registers.  V8 is also purely "
"big-endian. V9 has 32 double-precision floating-point registers that are "
"also usable as 16 quad-precision registers, but cannot be used as single-"
"precision registers. The UltraSPARC architecture combines V9 with UltraSPARC "
"Visual Instruction Set extensions."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1713
msgid ""
"If subtarget support is needed, you should implement a target-specific "
"``XXXSubtarget`` class for your architecture.  This class should process the "
"command-line options ``-mcpu=`` and ``-mattr=``."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1717
msgid ""
"TableGen uses definitions in the ``Target.td`` and ``Sparc.td`` files to "
"generate code in ``SparcGenSubtarget.inc``.  In ``Target.td``, shown below, "
"the ``SubtargetFeature`` interface is defined.  The first 4 string "
"parameters of the ``SubtargetFeature`` interface are a feature name, an "
"attribute set by the feature, the value of the attribute, and a description "
"of the feature.  (The fifth parameter is a list of features whose presence "
"is implied, and its default value is an empty array.)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1736
msgid ""
"In the ``Sparc.td`` file, the ``SubtargetFeature`` is used to define the "
"following features."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1749
msgid ""
"Elsewhere in ``Sparc.td``, the ``Proc`` class is defined and then is used to "
"define particular SPARC processor subtypes that may have the previously "
"described features."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1772
msgid ""
"From ``Target.td`` and ``Sparc.td`` files, the resulting ``SparcGenSubtarget."
"inc`` specifies enum values to identify the features, arrays of constants to "
"represent the CPU features and CPU subtypes, and the "
"``ParseSubtargetFeatures`` method that parses the features string that sets "
"specified subtarget options.  The generated ``SparcGenSubtarget.inc`` file "
"should be included in the ``SparcSubtarget.cpp``.  The target-specific "
"implementation of the ``XXXSubtarget`` method should follow this pseudocode:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1790
msgid "JIT Support"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1792
msgid ""
"The implementation of a target machine optionally includes a Just-In-Time "
"(JIT) code generator that emits machine code and auxiliary structures as "
"binary output that can be written directly to memory.  To do this, implement "
"JIT code generation by performing the following steps:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1797
msgid ""
"Write an ``XXXCodeEmitter.cpp`` file that contains a machine function pass "
"that transforms target-machine instructions into relocatable machine code."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1801
msgid ""
"Write an ``XXXJITInfo.cpp`` file that implements the JIT interfaces for "
"target-specific code-generation activities, such as emitting machine code "
"and stubs."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1805
msgid ""
"Modify ``XXXTargetMachine`` so that it provides a ``TargetJITInfo`` object "
"through its ``getJITInfo`` method."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1808
msgid ""
"There are several different approaches to writing the JIT support code.  For "
"instance, TableGen and target descriptor files may be used for creating a "
"JIT code generator, but are not mandatory.  For the Alpha and PowerPC target "
"machines, TableGen is used to generate ``XXXGenCodeEmitter.inc``, which "
"contains the binary coding of machine instructions and the "
"``getBinaryCodeForInstr`` method to access those codes.  Other JIT "
"implementations do not."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1816
msgid ""
"Both ``XXXJITInfo.cpp`` and ``XXXCodeEmitter.cpp`` must include the ``llvm/"
"CodeGen/MachineCodeEmitter.h`` header file that defines the "
"``MachineCodeEmitter`` class containing code for several callback functions "
"that write data (in bytes, words, strings, etc.) to the output stream."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1822
msgid "Machine Code Emitter"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1824
msgid ""
"In ``XXXCodeEmitter.cpp``, a target-specific of the ``Emitter`` class is "
"implemented as a function pass (subclass of ``MachineFunctionPass``).  The "
"target-specific implementation of ``runOnMachineFunction`` (invoked by "
"``runOnFunction`` in ``MachineFunctionPass``) iterates through the "
"``MachineBasicBlock`` calls ``emitInstruction`` to process each instruction "
"and emit binary code.  ``emitInstruction`` is largely implemented with case "
"statements on the instruction types defined in ``XXXInstrInfo.h``.  For "
"example, in ``X86CodeEmitter.cpp``, the ``emitInstruction`` method is built "
"around the following ``switch``/``case`` statements:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1875
msgid ""
"The implementations of these case statements often first emit the opcode and "
"then get the operand(s).  Then depending upon the operand, helper methods "
"may be called to process the operand(s).  For example, in ``X86CodeEmitter."
"cpp``, for the ``X86II::AddRegFrm`` case, the first data emitted (by "
"``emitByte``) is the opcode added to the register operand.  Then an object "
"representing the machine operand, ``MO1``, is extracted.  The helper methods "
"such as ``isImmediate``, ``isGlobalAddress``, ``isExternalSymbol``, "
"``isConstantPoolIndex``, and ``isJumpTableIndex`` determine the operand "
"type. (``X86CodeEmitter.cpp`` also has private methods such as "
"``emitConstant``, ``emitGlobalAddress``, ``emitExternalSymbolAddress``, "
"``emitConstPoolAddress``, and ``emitJumpTableAddress`` that emit the data "
"into the output stream.)"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1917
msgid ""
"In the previous example, ``XXXCodeEmitter.cpp`` uses the variable ``rt``, "
"which is a ``RelocationType`` enum that may be used to relocate addresses "
"(for example, a global address with a PIC base offset).  The "
"``RelocationType`` enum for that target is defined in the short target-"
"specific ``XXXRelocations.h`` file.  The ``RelocationType`` is used by the "
"``relocate`` method defined in ``XXXJITInfo.cpp`` to rewrite addresses for "
"referenced global symbols."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1924
msgid ""
"For example, ``X86Relocations.h`` specifies the following relocation types "
"for the X86 addresses.  In all four cases, the relocated value is added to "
"the value already in memory.  For ``reloc_pcrel_word`` and "
"``reloc_picrel_word``, there is an additional initial adjustment."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1939
msgid "Target JIT Info"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1941
msgid ""
"``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific code-"
"generation activities, such as emitting machine code and stubs.  At minimum, "
"a target-specific version of ``XXXJITInfo`` implements the following:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1945
msgid ""
"``getLazyResolverFunction`` --- Initializes the JIT, gives the target a "
"function that is used for compilation."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1948
msgid ""
"``emitFunctionStub`` --- Returns a native function with a specified address "
"for a callback function."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1951
msgid ""
"``relocate`` --- Changes the addresses of referenced globals, based on "
"relocation types."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1954
msgid ""
"Callback function that are wrappers to a function stub that is used when the "
"real target is not initially known."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1957
msgid ""
"``getLazyResolverFunction`` is generally trivial to implement.  It makes the "
"incoming parameter as the global ``JITCompilerFunction`` and returns the "
"callback function that will be used a function wrapper.  For the Alpha "
"target (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` "
"implementation is simply:"
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1971
msgid ""
"For the X86 target, the ``getLazyResolverFunction`` implementation is a "
"little more complicated, because it returns a different callback function "
"for processors with SSE instructions and XMM registers."
msgstr ""

#: ../../../WritingAnLLVMBackend.rst:1975
msgid ""
"The callback function initially saves and later restores the callee register "
"values, incoming arguments, and frame and return address.  The callback "
"function needs low-level access to the registers or stack, so it is "
"typically implemented with assembler."
msgstr ""
