# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../MemTagSanitizer.rst:3
msgid "MemTagSanitizer"
msgstr ""

#: ../../../MemTagSanitizer.rst:9
msgid "Introduction"
msgstr ""

#: ../../../MemTagSanitizer.rst:11
msgid ""
"**Note:** this page describes a tool under development. Part of this "
"functionality is planned but not implemented.  Hardware capable of running "
"MemTagSanitizer does not exist as of Oct 2019."
msgstr ""

#: ../../../MemTagSanitizer.rst:15
msgid ""
"MemTagSanitizer is a fast memory error detector and **a code hardening "
"tool** based on the Armv8.5-A `Memory Tagging Extension`_. It detects a "
"similar class of errors as `AddressSanitizer`_ or "
"`HardwareAssistedAddressSanitizer`_, but with **much** lower overhead."
msgstr ""

#: ../../../MemTagSanitizer.rst:20
msgid ""
"MemTagSanitizer overhead is expected to be in low single digits, both CPU "
"and memory. There are plans for a debug mode with slightly higher memory "
"overhead and better diagnostics. The primary use case of MemTagSanitizer is "
"code hardening in production binaries, where it is expected to be a strong "
"mitigation for both stack and heap-based memory bugs."
msgstr ""

#: ../../../MemTagSanitizer.rst:29
msgid "Usage"
msgstr ""

#: ../../../MemTagSanitizer.rst:31
msgid ""
"Compile and link your program with ``-fsanitize=memtag`` flag. This will "
"only work when targeting AArch64 with MemTag extension. One possible way to "
"achieve that is to add ``-target aarch64-linux -march=armv8+memtag`` to "
"compilation flags."
msgstr ""

#: ../../../MemTagSanitizer.rst:37
msgid "Implementation"
msgstr ""

#: ../../../MemTagSanitizer.rst:39
msgid ""
"See `HardwareAssistedAddressSanitizer`_ for a general overview of a tag-"
"based approach to memory safety.  MemTagSanitizer follows a similar "
"implementation strategy, but with the tag storage (shadow) provided by the "
"hardware."
msgstr ""

#: ../../../MemTagSanitizer.rst:44
msgid "A quick overview of MTE hardware capabilities:"
msgstr ""

#: ../../../MemTagSanitizer.rst:46
msgid ""
"Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag."
msgstr ""

#: ../../../MemTagSanitizer.rst:47
msgid ""
"Every pointer can have a 4-bit Address Tag that is in its most significant "
"byte."
msgstr ""

#: ../../../MemTagSanitizer.rst:48
msgid ""
"Most memory access instructions generate an exception if Address Tag != "
"Allocation Tag."
msgstr ""

#: ../../../MemTagSanitizer.rst:49
msgid "Special instructions are provided for fast tag manipulation."
msgstr ""

#: ../../../MemTagSanitizer.rst:52
msgid "Stack instrumentation"
msgstr ""

#: ../../../MemTagSanitizer.rst:54
msgid ""
"Stack-based memory errors are detected by updating Allocation Tag for each "
"local variable to a random value at the start of its lifetime, and resetting "
"it to the stack pointer Address Tag at the end of it. Unallocated stack "
"space is expected to match the Address Tag of SP; this allows to skip "
"tagging of any variable when memory safety can be statically proven."
msgstr ""

#: ../../../MemTagSanitizer.rst:61
msgid ""
"Allocating a truly random tag for each stack variable in a large function "
"may incur significant code size overhead, because it means that each "
"variable's address is an independent, non-rematerializable value; thus a "
"function with N local variables will have extra N live values to keep "
"through most of its life time."
msgstr ""

#: ../../../MemTagSanitizer.rst:67
msgid ""
"For this reason MemTagSanitizer generates at most one random tag per "
"function, called a \"base tag\". Other stack variables, if there are any, "
"are assigned tags at a fixed offset from the base."
msgstr ""

#: ../../../MemTagSanitizer.rst:71
msgid ""
"Please refer to `this document <https://github.com/google/sanitizers/wiki/"
"Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_ for more "
"details about stack instrumentation."
msgstr ""

#: ../../../MemTagSanitizer.rst:76
msgid "Heap tagging"
msgstr ""

#: ../../../MemTagSanitizer.rst:78
msgid "**Note:** this part is not implemented as of Oct 2019."
msgstr ""

#: ../../../MemTagSanitizer.rst:80
msgid ""
"MemTagSanitizer will use :doc:`ScudoHardenedAllocator` with additional code "
"to update memory tags when"
msgstr ""

#: ../../../MemTagSanitizer.rst:83
msgid "New memory is obtained from the system."
msgstr ""

#: ../../../MemTagSanitizer.rst:84
msgid "An allocation is freed."
msgstr ""

#: ../../../MemTagSanitizer.rst:86
msgid ""
"There is no need to change Allocation Tags for the bulk of the allocated "
"memory in malloc(), as long as a pointer with the matching Address Tag is "
"returned."
msgstr ""

#: ../../../MemTagSanitizer.rst:91
msgid "More information"
msgstr ""

#: ../../../MemTagSanitizer.rst:93
msgid ""
"`LLVM Developer Meeting 2018 talk on Memory Tagging <https://llvm.org/"
"devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-"
"LLVM-2018.pdf>`_"
msgstr ""

#: ../../../MemTagSanitizer.rst:94
msgid "`Memory Tagging Whitepaper <https://arxiv.org/pdf/1802.09517.pdf>`_"
msgstr ""
