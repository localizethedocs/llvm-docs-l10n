# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/OCamlLangImpl3.rst:3
msgid "Kaleidoscope: Code generation to LLVM IR"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:9
msgid "Chapter 3 Introduction"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:11
msgid ""
"Welcome to Chapter 3 of the \"`Implementing a language with LLVM <index."
"html>`_\" tutorial. This chapter shows you how to transform the `Abstract "
"Syntax Tree <OCamlLangImpl2.html>`_, built in Chapter 2, into LLVM IR. This "
"will teach you a little bit about how LLVM does things, as well as "
"demonstrate how easy it is to use. It's much more work to build a lexer and "
"parser than it is to generate LLVM IR code. :)"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:18
msgid ""
"**Please note**: the code in this chapter and later require LLVM 2.3 or LLVM "
"SVN to work. LLVM 2.2 and before will not work with it."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:22
msgid "Code Generation Setup"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:24
msgid ""
"In order to generate LLVM IR, we want some simple setup to get started. "
"First we define virtual code generation (codegen) methods in each AST class:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:34
msgid ""
"The ``Codegen.codegen_expr`` function says to emit IR for that AST node "
"along with all the things it depends on, and they all return an LLVM Value "
"object. \"Value\" is the class used to represent a \"`Static Single "
"Assignment (SSA) <http://en.wikipedia.org/wiki/"
"Static_single_assignment_form>`_ register\" or \"SSA value\" in LLVM. The "
"most distinct aspect of SSA values is that their value is computed as the "
"related instruction executes, and it does not get a new value until (and if) "
"the instruction re-executes. In other words, there is no way to \"change\" "
"an SSA value. For more information, please read up on `Static Single "
"Assignment <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_ - "
"the concepts are really quite natural once you grok them."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:47
msgid ""
"The second thing we want is an \"Error\" exception like we used for the "
"parser, which will be used to report errors found during code generation "
"(for example, use of an undeclared parameter):"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:61
msgid ""
"The static variables will be used during code generation. ``Codegen."
"the_module`` is the LLVM construct that contains all of the functions and "
"global variables in a chunk of code. In many ways, it is the top-level "
"structure that the LLVM IR uses to contain code."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:66
msgid ""
"The ``Codegen.builder`` object is a helper object that makes it easy to "
"generate LLVM instructions. Instances of the `IRBuilder <https://llvm.org/"
"doxygen/IRBuilder_8h-source.html>`_ class keep track of the current place to "
"insert instructions and has methods to create new instructions."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:72
msgid ""
"The ``Codegen.named_values`` map keeps track of which values are defined in "
"the current scope and what their LLVM representation is. (In other words, it "
"is a symbol table for the code). In this form of Kaleidoscope, the only "
"things that can be referenced are function parameters. As such, function "
"parameters will be in this map when generating code for their function body."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:79
msgid ""
"With these basics in place, we can start talking about how to generate code "
"for each expression. Note that this assumes that the ``Codegen.builder`` has "
"been set up to generate code *into* something. For now, we'll assume that "
"this has already been done, and we'll just use it to emit code."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:86
msgid "Expression Code Generation"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:88
msgid ""
"Generating LLVM code for expression nodes is very straightforward: less than "
"30 lines of commented code for all four of our expression nodes. First we'll "
"do numeric literals:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:96
msgid ""
"In the LLVM IR, numeric constants are represented with the ``ConstantFP`` "
"class, which holds the numeric value in an ``APFloat`` internally "
"(``APFloat`` has the capability of holding floating point constants of "
"Arbitrary Precision). This code basically just creates and returns a "
"``ConstantFP``. Note that in the LLVM IR that constants are all uniqued "
"together and shared. For this reason, the API uses \"the foo::get(..)\" "
"idiom instead of \"new foo(..)\" or \"foo::Create(..)\"."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:110
msgid ""
"References to variables are also quite simple using LLVM. In the simple "
"version of Kaleidoscope, we assume that the variable has already been "
"emitted somewhere and its value is available. In practice, the only values "
"that can be in the ``Codegen.named_values`` map are function arguments. This "
"code simply checks to see that the specified name is in the map (if not, an "
"unknown variable is being referenced) and returns the value for it. In "
"future chapters, we'll add support for `loop induction variables <LangImpl5."
"html#for-loop-expression>`_ in the symbol table, and for `local variables "
"<LangImpl7.html#user-defined-local-variables>`_."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:137
msgid ""
"Binary operators start to get more interesting. The basic idea here is that "
"we recursively emit code for the left-hand side of the expression, then the "
"right-hand side, then we compute the result of the binary expression. In "
"this code, we do a simple switch on the opcode to create the right LLVM "
"instruction."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:143
msgid ""
"In the example above, the LLVM builder class is starting to show its value. "
"IRBuilder knows where to insert the newly created instruction, all you have "
"to do is specify what instruction to create (e.g. with ``Llvm.create_add``), "
"which operands to use (``lhs`` and ``rhs`` here) and optionally provide a "
"name for the generated instruction."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:149
msgid ""
"One nice thing about LLVM is that the name is just a hint. For instance, if "
"the code above emits multiple \"addtmp\" variables, LLVM will automatically "
"provide each one with an increasing, unique numeric suffix. Local value "
"names for instructions are purely optional, but it makes it much easier to "
"read the IR dumps."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:155
msgid ""
"`LLVM instructions <../LangRef.html#instruction-reference>`_ are constrained "
"by strict rules: for example, the Left and Right operators of an `add "
"instruction <../LangRef.html#add-instruction>`_ must have the same type, and "
"the result type of the add must match the operand types. Because all values "
"in Kaleidoscope are doubles, this makes for very simple code for add, sub "
"and mul."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:162
msgid ""
"On the other hand, LLVM specifies that the `fcmp instruction <../LangRef."
"html#fcmp-instruction>`_ always returns an 'i1' value (a one bit integer). "
"The problem with this is that Kaleidoscope wants the value to be a 0.0 or "
"1.0 value. In order to get these semantics, we combine the fcmp instruction "
"with a `uitofp instruction <../LangRef.html#uitofp-to-instruction>`_. This "
"instruction converts its input integer into a floating point value by "
"treating the input as an unsigned value. In contrast, if we used the `sitofp "
"instruction <../LangRef.html#sitofp-to-instruction>`_, the Kaleidoscope '<' "
"operator would return 0.0 and -1.0, depending on the input value."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:190
msgid ""
"Code generation for function calls is quite straightforward with LLVM. The "
"code above initially does a function name lookup in the LLVM Module's symbol "
"table. Recall that the LLVM Module is the container that holds all of the "
"functions we are JIT'ing. By giving each function the same name as what the "
"user specifies, we can use the LLVM symbol table to resolve function names "
"for us."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:197
msgid ""
"Once we have the function to call, we recursively codegen each argument that "
"is to be passed in, and create an LLVM `call instruction <../LangRef."
"html#call-instruction>`_. Note that LLVM uses the native C calling "
"conventions by default, allowing these calls to also call into standard "
"library functions like \"sin\" and \"cos\", with no additional effort."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:204
msgid ""
"This wraps up our handling of the four basic expressions that we have so far "
"in Kaleidoscope. Feel free to go in and add some more. For example, by "
"browsing the `LLVM language reference <../LangRef.html>`_ you'll find "
"several other interesting instructions that are really easy to plug into our "
"basic framework."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:211
msgid "Function Code Generation"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:213
msgid ""
"Code generation for prototypes and functions must handle a number of "
"details, which make their code less beautiful than expression code "
"generation, but allows us to illustrate some important points. First, lets "
"talk about code generation for prototypes: they are used both for function "
"bodies and external function declarations. The code starts with:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:230
msgid ""
"This code packs a lot of power into a few lines. Note first that this "
"function returns a \"Function\\*\" instead of a \"Value\\*\" (although at "
"the moment they both are modeled by ``llvalue`` in ocaml). Because a "
"\"prototype\" really talks about the external interface for a function (not "
"the value computed by an expression), it makes sense for it to return the "
"LLVM Function it corresponds to when codegen'd."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:237
msgid ""
"The call to ``Llvm.function_type`` creates the ``Llvm.llvalue`` that should "
"be used for a given Prototype. Since all function arguments in Kaleidoscope "
"are of type double, the first line creates a vector of \"N\" LLVM double "
"types. It then uses the ``Llvm.function_type`` method to create a function "
"type that takes \"N\" doubles as arguments, returns one double as a result, "
"and that is not vararg (that uses the function ``Llvm."
"var_arg_function_type``). Note that Types in LLVM are uniqued just like "
"``Constant``'s are, so you don't \"new\" a type, you \"get\" it."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:246
msgid ""
"The final line above checks if the function has already been defined in "
"``Codegen.the_module``. If not, we will create it."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:253
msgid ""
"This indicates the type and name to use, as well as which module to insert "
"into. By default we assume a function has ``Llvm.Linkage.ExternalLinkage``. "
"\"`external linkage <../LangRef.html#linkage>`_\" means that the function "
"may be defined outside the current module and/or that it is callable by "
"functions outside the module. The \"``name``\" passed in is the name the "
"user specified: this name is registered in \"``Codegen.the_module``\"s "
"symbol table, which is used by the function call code above."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:262
msgid ""
"In Kaleidoscope, I choose to allow redefinitions of functions in two cases: "
"first, we want to allow 'extern'ing a function more than once, as long as "
"the prototypes for the externs match (since all arguments have the same "
"type, we just have to check that the number of arguments match). Second, we "
"want to allow 'extern'ing a function and then defining a body for it. This "
"is useful when defining mutually recursive functions."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:285
msgid ""
"In order to verify the logic above, we first check to see if the pre-"
"existing function is \"empty\". In this case, empty means that it has no "
"basic blocks in it, which means it has no body. If it has no body, it is a "
"forward declaration. Since we don't allow anything after a full definition "
"of the function, the code rejects this case. If the previous reference to a "
"function was an 'extern', we simply verify that the number of arguments for "
"that definition and this one match up. If not, we emit an error."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:304
msgid ""
"The last bit of code for prototypes loops over all of the arguments in the "
"function, setting the name of the LLVM Argument objects to match, and "
"registering the arguments in the ``Codegen.named_values`` map for future use "
"by the ``Ast.Variable`` variant. Once this is set up, it returns the "
"Function object to the caller. Note that we don't check for conflicting "
"argument names here (e.g. \"extern foo(a b a)\"). Doing so would be very "
"straight-forward with the mechanics we have already used above."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:320
msgid ""
"Code generation for function definitions starts out simply enough: we just "
"codegen the prototype (Proto) and verify that it is ok. We then clear out "
"the ``Codegen.named_values`` map to make sure that there isn't anything in "
"it from the last function we compiled. Code generation of the prototype "
"ensures that there is an LLVM Function object that is ready to go for us."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:336
msgid ""
"Now we get to the point where the ``Codegen.builder`` is set up. The first "
"line creates a new `basic block <http://en.wikipedia.org/wiki/Basic_block>`_ "
"(named \"entry\"), which is inserted into ``the_function``. The second line "
"then tells the builder that new instructions should be inserted into the end "
"of the new basic block. Basic blocks in LLVM are an important part of "
"functions that define the `Control Flow Graph <http://en.wikipedia.org/wiki/"
"Control_flow_graph>`_. Since we don't have any control flow, our functions "
"will only contain one block at this point. We'll fix this in `Chapter 5 "
"<OCamlLangImpl5.html>`_ :)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:359
msgid ""
"Once the insertion point is set up, we call the ``Codegen.codegen_func`` "
"method for the root expression of the function. If no error happens, this "
"emits code to compute the expression into the entry block and returns the "
"value that was computed. Assuming no error, we then create an LLVM `ret "
"instruction <../LangRef.html#ret-instruction>`_, which completes the "
"function. Once the function is built, we call ``Llvm_analysis."
"assert_valid_function``, which is provided by LLVM. This function does a "
"variety of consistency checks on the generated code, to determine if our "
"compiler is doing everything right. Using this is important: it can catch a "
"lot of bugs. Once the function is finished and validated, we return it."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:377
msgid ""
"The only piece left here is handling of the error case. For simplicity, we "
"handle this by merely deleting the function we produced with the ``Llvm."
"delete_function`` method. This allows the user to redefine a function that "
"they incorrectly typed in before: if we didn't delete it, it would live in "
"the symbol table, with a body, preventing future redefinition."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:384
msgid ""
"This code does have a bug, though. Since the ``Codegen.codegen_proto`` can "
"return a previously defined forward declaration, our code can actually "
"delete a forward declaration. There are a number of ways to fix this bug, "
"see what you can come up with! Here is a testcase:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:396
msgid "Driver Changes and Closing Thoughts"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:398
msgid ""
"For now, code generation to LLVM doesn't really get us much, except that we "
"can look at the pretty IR calls. The sample code inserts calls to Codegen "
"into the \"``Toplevel.main_loop``\", and then dumps out the LLVM IR. This "
"gives a nice way to look at the LLVM IR for simple functions. For example:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:414
msgid ""
"Note how the parser turns the top-level expression into anonymous functions "
"for us. This will be handy when we add `JIT support <OCamlLangImpl4."
"html#adding-a-jit-compiler>`_ in the next chapter. Also note that the code "
"is very literally transcribed, no optimizations are being performed. We will "
"`add optimizations <OCamlLangImpl4.html#trivial-constant-folding>`_ "
"explicitly in the next chapter."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:437
msgid ""
"This shows some simple arithmetic. Notice the striking similarity to the "
"LLVM builder calls that we use to create the instructions."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:452
msgid ""
"This shows some function calls. Note that this function will take a long "
"time to execute if you call it. In the future we'll add conditional control "
"flow to actually make recursion useful :)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:470
msgid "This shows an extern for the libm \"cos\" function, and a call to it."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:510
msgid ""
"When you quit the current demo, it dumps out the IR for the entire module "
"generated. Here you can see the big picture with all the functions "
"referencing each other."
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:514
msgid ""
"This wraps up the third chapter of the Kaleidoscope tutorial. Up next, we'll "
"describe how to `add JIT codegen and optimizer support <OCamlLangImpl4."
"html>`_ to this so we can actually start running code!"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:520
msgid "Full Code Listing"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:522
msgid ""
"Here is the complete code listing for our running example, enhanced with the "
"LLVM code generator. Because this uses the LLVM libraries, we need to link "
"them in. To do this, we use the `llvm-config <https://llvm.org/cmds/llvm-"
"config.html>`_ tool to inform our makefile/command line about which options "
"to use:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:535
msgid "Here is the code:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:541
msgid "\\_tags:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:551
msgid "myocamlbuild.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:570
msgid "token.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:626
msgid "lexer.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:655
msgid "ast.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:781
msgid "parser.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:885
msgid "codegen.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:928
msgid "toplevel.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:958
msgid "toy.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl3.rst:960
msgid "`Next: Adding JIT and Optimizer Support <OCamlLangImpl4.html>`_"
msgstr ""
