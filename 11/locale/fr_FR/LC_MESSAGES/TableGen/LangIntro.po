# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TableGen/LangIntro.rst:3
msgid "TableGen Language Introduction"
msgstr ""

#: ../../../TableGen/LangIntro.rst:9
msgid ""
"This document is extremely rough. If you find something lacking, please fix "
"it, file a documentation bug, or ask about it on llvm-dev."
msgstr ""

#: ../../../TableGen/LangIntro.rst:13
msgid "Introduction"
msgstr ""

#: ../../../TableGen/LangIntro.rst:15
msgid ""
"This document is not meant to be a normative spec about the TableGen "
"language in and of itself (i.e. how to understand a given construct in terms "
"of how it affects the final set of records represented by the TableGen "
"file). For the formal language specification, see :doc:`LangRef`."
msgstr ""

#: ../../../TableGen/LangIntro.rst:21
msgid "TableGen syntax"
msgstr ""

#: ../../../TableGen/LangIntro.rst:23
msgid ""
"TableGen doesn't care about the meaning of data (that is up to the backend "
"to define), but it does care about syntax, and it enforces a simple type "
"system. This section describes the syntax and the constructs allowed in a "
"TableGen file."
msgstr ""

#: ../../../TableGen/LangIntro.rst:28
msgid "TableGen primitives"
msgstr ""

#: ../../../TableGen/LangIntro.rst:31
msgid "TableGen comments"
msgstr ""

#: ../../../TableGen/LangIntro.rst:33
msgid ""
"TableGen supports C++ style \"``//``\" comments, which run to the end of the "
"line, and it also supports **nestable** \"``/* */``\" comments."
msgstr ""

#: ../../../TableGen/LangIntro.rst:39
msgid "The TableGen type system"
msgstr ""

#: ../../../TableGen/LangIntro.rst:41
msgid ""
"TableGen files are strongly typed, in a simple (but complete) type-system. "
"These types are used to perform automatic conversions, check for errors, and "
"to help interface designers constrain the input that they allow.  Every "
"`value definition`_ is required to have an associated type."
msgstr ""

#: ../../../TableGen/LangIntro.rst:46
msgid ""
"TableGen supports a mixture of very low-level types (such as ``bit``) and "
"very high-level types (such as ``dag``).  This flexibility is what allows it "
"to describe a wide range of information conveniently and compactly.  The "
"TableGen types are:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:52
msgid "``bit``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:52
msgid "A 'bit' is a boolean value that can hold either 0 or 1."
msgstr ""

#: ../../../TableGen/LangIntro.rst:55
msgid "``int``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:55
msgid "The 'int' type represents a simple 32-bit integer value, such as 5."
msgstr ""

#: ../../../TableGen/LangIntro.rst:59
msgid "``string``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:58
msgid ""
"The 'string' type represents an ordered sequence of characters of arbitrary "
"length."
msgstr ""

#: ../../../TableGen/LangIntro.rst:63
msgid "``code``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:62
msgid ""
"The `code` type represents a code fragment, which can be single/multi-line "
"string literal."
msgstr ""

#: ../../../TableGen/LangIntro.rst:68
msgid "``bits<n>``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:66
msgid ""
"A 'bits' type is an arbitrary, but fixed, size integer that is broken up "
"into individual bits.  This type is useful because it can handle some bits "
"being defined while others are undefined."
msgstr ""

#: ../../../TableGen/LangIntro.rst:72
msgid "``list<ty>``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:71
msgid ""
"This type represents a list whose elements are some other type.  The "
"contained type is arbitrary: it can even be another list type."
msgstr ""

#: ../../../TableGen/LangIntro.rst:79
msgid "Class type"
msgstr ""

#: ../../../TableGen/LangIntro.rst:75
msgid ""
"Specifying a class name in a type context means that the defined value must "
"be a subclass of the specified class.  This is useful in conjunction with "
"the ``list`` type, for example, to constrain the elements of the list to a "
"common base class (e.g., a ``list<Register>`` can only contain definitions "
"derived from the \"``Register``\" class)."
msgstr ""

#: ../../../TableGen/LangIntro.rst:82
msgid "``dag``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:82
msgid "This type represents a nestable directed graph of elements."
msgstr ""

#: ../../../TableGen/LangIntro.rst:84
msgid ""
"To date, these types have been sufficient for describing things that "
"TableGen has been used for, but it is straight-forward to extend this list "
"if needed."
msgstr ""

#: ../../../TableGen/LangIntro.rst:90
msgid "TableGen values and expressions"
msgstr ""

#: ../../../TableGen/LangIntro.rst:92
msgid ""
"TableGen allows for a pretty reasonable number of different expression forms "
"when building up values.  These forms allow the TableGen file to be written "
"in a natural syntax and flavor for the application.  The current expression "
"forms supported include:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:98
msgid "``?``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:98
msgid "uninitialized field"
msgstr ""

#: ../../../TableGen/LangIntro.rst:103
msgid "``0b1001011``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:101
msgid ""
"binary integer value. Note that this is sized by the number of bits given "
"and will not be silently extended/truncated."
msgstr ""

#: ../../../TableGen/LangIntro.rst:106
msgid "``7``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:106
msgid "decimal integer value"
msgstr ""

#: ../../../TableGen/LangIntro.rst:109
msgid "``0x7F``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:109
msgid "hexadecimal integer value"
msgstr ""

#: ../../../TableGen/LangIntro.rst:112
msgid "``\"foo\"``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:112
msgid ""
"a single-line string value, can be assigned to ``string`` or ``code`` "
"variable."
msgstr ""

#: ../../../TableGen/LangIntro.rst:115
msgid "``[{ ... }]``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:115
msgid ""
"usually called a \"code fragment\", but is just a multiline string literal"
msgstr ""

#: ../../../TableGen/LangIntro.rst:120
msgid "``[ X, Y, Z ]<type>``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:118
msgid ""
"list value.  <type> is the type of the list element and is usually optional. "
"In rare cases, TableGen is unable to deduce the element type in which case "
"the user must specify it explicitly."
msgstr ""

#: ../../../TableGen/LangIntro.rst:124
msgid "``{ a, b, 0b10 }``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:123
msgid ""
"initializer for a \"bits<4>\" value. 1-bit from \"a\", 1-bit from \"b\", 2-"
"bits from 0b10."
msgstr ""

#: ../../../TableGen/LangIntro.rst:127
msgid "``value``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:127
msgid "value reference"
msgstr ""

#: ../../../TableGen/LangIntro.rst:130
msgid "``value{17}``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:130
msgid "access to one bit of a value"
msgstr ""

#: ../../../TableGen/LangIntro.rst:134
msgid "``value{15-17}``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:133
msgid ""
"access to an ordered sequence of bits of a value, in particular "
"``value{15-17}`` produces an order that is the reverse of ``value{17-15}``."
msgstr ""

#: ../../../TableGen/LangIntro.rst:137
msgid "``DEF``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:137
msgid "reference to a record definition"
msgstr ""

#: ../../../TableGen/LangIntro.rst:141
msgid "``CLASS<val list>``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:140
msgid ""
"reference to a new anonymous definition of CLASS with the specified template "
"arguments."
msgstr ""

#: ../../../TableGen/LangIntro.rst:144
msgid "``X.Y``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:144
msgid "reference to the subfield of a value"
msgstr ""

#: ../../../TableGen/LangIntro.rst:148
msgid "``list[4-7,17,2-3]``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:147
msgid ""
"A slice of the 'list' list, including elements 4,5,6,7,17,2, and 3 from it. "
"Elements may be included multiple times."
msgstr ""

#: ../../../TableGen/LangIntro.rst:150
msgid "``foreach <var> = [ <list> ] in { <body> }``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:156
msgid "``foreach <var> = [ <list> ] in <def>``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:153
msgid ""
"Replicate <body> or <def>, replacing instances of <var> with each value in "
"<list>.  <var> is scoped at the level of the ``foreach`` loop and must not "
"conflict with any other object introduced in <body> or <def>.  Only "
"``def``\\s and ``defm``\\s are expanded within <body>."
msgstr ""

#: ../../../TableGen/LangIntro.rst:158
msgid "``foreach <var> = 0-15 in ...``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:161
msgid "``foreach <var> = {0-15,32-47} in ...``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:161
msgid ""
"Loop over ranges of integers. The braces are required for multiple ranges."
msgstr ""

#: ../../../TableGen/LangIntro.rst:166
msgid "``(DEF a, b)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:164
msgid ""
"a dag value.  The first element is required to be a record definition, the "
"remaining elements in the list may be arbitrary other values, including "
"nested ```dag``' values."
msgstr ""

#: ../../../TableGen/LangIntro.rst:172
msgid "``!con(a, b, ...)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:169
msgid "Concatenate two or more DAG nodes. Their operations must equal."
msgstr ""

#: ../../../TableGen/LangIntro.rst:171
msgid ""
"Example: !con((op a1:$name1, a2:$name2), (op b1:$name3)) results in the DAG "
"node (op a1:$name1, a2:$name2, b1:$name3)."
msgstr ""

#: ../../../TableGen/LangIntro.rst:184
msgid "``!dag(op, children, names)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:175
msgid ""
"Generate a DAG node programmatically. 'children' and 'names' must be lists "
"of equal length or unset ('?'). 'names' must be a 'list<string>'."
msgstr ""

#: ../../../TableGen/LangIntro.rst:178
msgid ""
"Due to limitations of the type system, 'children' must be a list of items of "
"a common type. In practice, this means that they should either have the same "
"type or be records with a common superclass. Mixing dag and non-dag items is "
"not possible. However, '?' can be used."
msgstr ""

#: ../../../TableGen/LangIntro.rst:183
msgid ""
"Example: !dag(op, [a1, a2, ?], [\"name1\", \"name2\", \"name3\"]) results in "
"(op a1:$name1, a2:$name2, ?:$name3)."
msgstr ""

#: ../../../TableGen/LangIntro.rst:190
msgid "``!setop(dag, op)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:187
msgid ""
"Return a DAG node with the same arguments as ``dag``, but with its operator "
"replaced with ``op``."
msgstr ""

#: ../../../TableGen/LangIntro.rst:190
msgid "Example: ``!setop((foo 1, 2), bar)`` results in ``(bar 1, 2)``."
msgstr ""

#: ../../../TableGen/LangIntro.rst:192
msgid "``!getop(dag)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:212
msgid "``!getop<type>(dag)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:195
msgid ""
"Return the operator of the given DAG node. Example: ``!getop((foo 1, 2))`` "
"results in ``foo``."
msgstr ""

#: ../../../TableGen/LangIntro.rst:198
msgid ""
"The result of ``!getop`` can be used directly in a context where any record "
"value at all is acceptable (typically placing it into another dag value). "
"But in other contexts, it must be explicitly cast to a particular class "
"type. The ``!getop<type>`` syntax is provided to make this easy."
msgstr ""

#: ../../../TableGen/LangIntro.rst:204
msgid ""
"For example, to assign the result to a class-typed value, you could write "
"either of these: ``BaseClass b = !getop<BaseClass>(someDag);``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:208
msgid "``BaseClass b = !cast<BaseClass>(!getop(someDag));``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:210
msgid ""
"But to build a new dag node reusing the operator from another, no cast is "
"necessary: ``dag d = !dag(!getop(someDag), args, names);``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:218
msgid "``!listconcat(a, b, ...)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:215
msgid ""
"A list value that is the result of concatenating the 'a' and 'b' lists. The "
"lists must have the same element type. More than two arguments are accepted "
"with the result being the concatenation of all the lists given."
msgstr ""

#: ../../../TableGen/LangIntro.rst:222
msgid "``!listsplat(a, size)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:221
msgid ""
"A list value that contains the value ``a`` ``size`` times. Example: ``!"
"listsplat(0, 2)`` results in ``[0, 0]``."
msgstr ""

#: ../../../TableGen/LangIntro.rst:227
msgid "``!strconcat(a, b, ...)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:225
msgid ""
"A string value that is the result of concatenating the 'a' and 'b' strings. "
"More than two arguments are accepted with the result being the concatenation "
"of all the strings given."
msgstr ""

#: ../../../TableGen/LangIntro.rst:232
msgid "``str1#str2``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:230
msgid ""
"\"#\" (paste) is a shorthand for !strconcat.  It may concatenate things that "
"are not quoted strings, in which case an implicit !cast<string> is done on "
"the operand of the paste."
msgstr ""

#: ../../../TableGen/LangIntro.rst:255
msgid "``!cast<type>(a)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:235
msgid ""
"If 'a' is a string, a record of type *type* obtained by looking up the "
"string 'a' in the list of all records defined by the time that all template "
"arguments in 'a' are fully resolved."
msgstr ""

#: ../../../TableGen/LangIntro.rst:239
msgid ""
"For example, if !cast<type>(a) appears in a multiclass definition, or in a "
"class instantiated inside of a multiclass definition, and 'a' does not "
"reference any template arguments of the multiclass, then a record of name "
"'a' must be instantiated earlier in the source file. If 'a' does reference a "
"template argument, then the lookup is delayed until defm statements "
"instantiating the multiclass (or later, if the defm occurs in another "
"multiclass and template arguments of the inner multiclass that are "
"referenced by 'a' are substituted by values that themselves contain "
"references to template arguments of the outer multiclass)."
msgstr ""

#: ../../../TableGen/LangIntro.rst:249
msgid ""
"If the type of 'a' does not match *type*, TableGen aborts with an error."
msgstr ""

#: ../../../TableGen/LangIntro.rst:251
msgid ""
"Otherwise, perform a normal type cast e.g. between an int and a bit, or "
"between record types. This allows casting a record to a subclass, though if "
"the types do not match, constant folding will be inhibited. !cast<string> is "
"a special case in that the argument can be an int or a record. In the latter "
"case, the record's name is returned."
msgstr ""

#: ../../../TableGen/LangIntro.rst:258
msgid "``!isa<type>(a)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:258
msgid ""
"Returns an integer: 1 if 'a' is dynamically of the given type, 0 otherwise."
msgstr ""

#: ../../../TableGen/LangIntro.rst:262
msgid "``!subst(a, b, c)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:261
msgid ""
"If 'a' and 'b' are of string type or are symbol references, substitute 'b' "
"for 'a' in 'c.'  This operation is analogous to $(subst) in GNU make."
msgstr ""

#: ../../../TableGen/LangIntro.rst:267
msgid "``!foreach(a, b, c)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:265
msgid ""
"For each member of dag or list 'b' apply operator 'c'. 'a' is the name of a "
"variable that will be substituted by members of 'b' in 'c'. This operation "
"is analogous to $(foreach) in GNU make."
msgstr ""

#: ../../../TableGen/LangIntro.rst:276
msgid "``!foldl(start, lst, a, b, expr)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:270
msgid ""
"Perform a left-fold over 'lst' with the given starting value. 'a' and 'b' "
"are variable names which will be substituted in 'expr'. If you think of expr "
"as a function f(a,b), the fold will compute 'f(...f(f(start, lst[0]), "
"lst[1]), ...), lst[n-1])' for a list of length n. As usual, 'a' will be of "
"the type of 'start', and 'b' will be of the type of elements of 'lst'. These "
"types need not be the same, but 'expr' must be of the same type as 'start'."
msgstr ""

#: ../../../TableGen/LangIntro.rst:279
msgid "``!head(a)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:279
msgid "The first element of list 'a.'"
msgstr ""

#: ../../../TableGen/LangIntro.rst:282
msgid "``!tail(a)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:282
msgid "The 2nd-N elements of list 'a.'"
msgstr ""

#: ../../../TableGen/LangIntro.rst:285
msgid "``!empty(a)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:285
msgid "An integer {0,1} indicating whether list 'a' is empty."
msgstr ""

#: ../../../TableGen/LangIntro.rst:288
msgid "``!size(a)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:288
msgid "An integer indicating the number of elements in list 'a'."
msgstr ""

#: ../../../TableGen/LangIntro.rst:291
msgid "``!if(a,b,c)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:291
msgid ""
"'b' if the result of 'int' or 'bit' operator 'a' is nonzero, 'c' otherwise."
msgstr ""

#: ../../../TableGen/LangIntro.rst:301
msgid ""
"``!cond(condition_1 : val1, condition_2 : val2, ..., condition_n : valn)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:294
msgid ""
"Instead of embedding !if inside !if which can get cumbersome, one can use !"
"cond. !cond returns 'val1' if the result of 'int' or 'bit' operator "
"'condition1' is nonzero. Otherwise, it checks 'condition2'. If 'condition2' "
"is nonzero, returns 'val2', and so on. If all conditions are zero, it "
"reports an error."
msgstr ""

#: ../../../TableGen/LangIntro.rst:301
msgid "For example, to convert an integer 'x' into a string:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:301
msgid "!cond(!lt(x,0) : \"negative\", !eq(x,0) : \"zero\", 1 : \"positive\")"
msgstr ""

#: ../../../TableGen/LangIntro.rst:306
msgid "``!eq(a,b)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:304
msgid ""
"'bit 1' if string a is equal to string b, 0 otherwise.  This only operates "
"on string, int and bit objects.  Use !cast<string> to compare other types of "
"objects."
msgstr ""

#: ../../../TableGen/LangIntro.rst:309
msgid "``!ne(a,b)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:309
msgid "The negation of ``!eq(a,b)``."
msgstr ""

#: ../../../TableGen/LangIntro.rst:313
msgid "``!le(a,b), !lt(a,b), !ge(a,b), !gt(a,b)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:312
msgid ""
"(Signed) comparison of integer values that returns bit 1 or 0 depending on "
"the result of the comparison."
msgstr ""

#: ../../../TableGen/LangIntro.rst:317
msgid "``!shl(a,b)`` ``!srl(a,b)`` ``!sra(a,b)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:316
msgid ""
"The usual shift operators. Operations are on 64-bit integers, the result is "
"undefined for shift counts outside [0, 63]."
msgstr ""

#: ../../../TableGen/LangIntro.rst:320
msgid "``!add(a,b,...)`` ``!mul(a,b,...)`` ``!and(a,b,...)`` ``!or(a,b,...)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:320
msgid "The usual arithmetic and binary operators."
msgstr ""

#: ../../../TableGen/LangIntro.rst:322
msgid ""
"Note that all of the values have rules specifying how they convert to values "
"for different types.  These rules allow you to assign a value like \"``7``\" "
"to a \"``bits<4>``\" value, for example."
msgstr ""

#: ../../../TableGen/LangIntro.rst:327
msgid "Classes and definitions"
msgstr ""

#: ../../../TableGen/LangIntro.rst:329
msgid ""
"As mentioned in the :doc:`introduction <index>`, classes and definitions "
"(collectively known as 'records') in TableGen are the main high-level unit "
"of information that TableGen collects.  Records are defined with a ``def`` "
"or ``class`` keyword, the record name, and an optional list of \"`template "
"arguments`_\".  If the record has superclasses, they are specified as a "
"comma separated list that starts with a colon character (\"``:``\").  If "
"`value definitions`_ or `let expressions`_ are needed for the class, they "
"are enclosed in curly braces (\"``{}``\"); otherwise, the record ends with a "
"semicolon."
msgstr ""

#: ../../../TableGen/LangIntro.rst:338
msgid "Here is a simple TableGen file:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:348
msgid ""
"This example defines two definitions, ``X`` and ``Y``, both of which derive "
"from the ``C`` class.  Because of this, they both get the ``V`` bit value.  "
"The ``Y`` definition also gets the Greeting member as well."
msgstr ""

#: ../../../TableGen/LangIntro.rst:352
msgid ""
"In general, classes are useful for collecting together the commonality "
"between a group of records and isolating it in a single place.  Also, "
"classes permit the specification of default values for their subclasses, "
"allowing the subclasses to override them as they wish."
msgstr ""

#: ../../../TableGen/LangIntro.rst:361
msgid "Value definitions"
msgstr ""

#: ../../../TableGen/LangIntro.rst:363
msgid ""
"Value definitions define named entries in records.  A value must be defined "
"before it can be referred to as the operand for another value definition or "
"before the value is reset with a `let expression`_.  A value is defined by "
"specifying a `TableGen type`_ and a name.  If an initial value is available, "
"it may be specified after the type with an equal sign.  Value definitions "
"require terminating semicolons."
msgstr ""

#: ../../../TableGen/LangIntro.rst:375 ../../../TableGen/LangIntro.rst:646
msgid "'let' expressions"
msgstr ""

#: ../../../TableGen/LangIntro.rst:377
msgid ""
"A record-level let expression is used to change the value of a value "
"definition in a record.  This is primarily useful when a superclass defines "
"a value that a derived class or definition wants to override.  Let "
"expressions consist of the '``let``' keyword followed by a value name, an "
"equal sign (\"``=``\"), and a new value.  For example, a new class could be "
"added to the example above, redefining the ``V`` field for all of its "
"subclasses:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:389
msgid ""
"In this case, the ``Z`` definition will have a zero value for its ``V`` "
"value, despite the fact that it derives (indirectly) from the ``C`` class, "
"because the ``D`` class overrode its value."
msgstr ""

#: ../../../TableGen/LangIntro.rst:393
msgid ""
"References between variables in a record are substituted late, which gives "
"``let`` expressions unusual power. Consider this admittedly silly example:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:407
msgid ""
"The value of ``Z.xplus1`` will be 6, but the value of ``Z.Yplus1`` is 11. "
"Use this power wisely."
msgstr ""

#: ../../../TableGen/LangIntro.rst:413
msgid "Class template arguments"
msgstr ""

#: ../../../TableGen/LangIntro.rst:415
msgid ""
"TableGen permits the definition of parameterized classes as well as normal "
"concrete classes.  Parameterized TableGen classes specify a list of variable "
"bindings (which may optionally have defaults) that are bound when used.  "
"Here is a simple example:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:434
msgid ""
"In this case, template arguments are used as a space efficient way to "
"specify a list of \"enumeration values\", each with a \"``Value``\" field "
"set to the specified integer."
msgstr ""

#: ../../../TableGen/LangIntro.rst:438
msgid ""
"The more esoteric forms of `TableGen expressions`_ are useful in conjunction "
"with template arguments.  As an example:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:466
msgid ""
"This is obviously a contrived example, but it shows how template arguments "
"can be used to decouple the interface provided to the user of the class from "
"the actual internal data representation expected by the class.  In this "
"case, running ``llvm-tblgen`` on the example prints the following "
"definitions:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:486
msgid ""
"This shows that TableGen was able to dig into the argument and extract a "
"piece of information that was requested by the designer of the \"Value\" "
"class.  For more realistic examples, please see existing users of TableGen, "
"such as the X86 backend."
msgstr ""

#: ../../../TableGen/LangIntro.rst:492
msgid "Multiclass definitions and instances"
msgstr ""

#: ../../../TableGen/LangIntro.rst:494
msgid ""
"While classes with template arguments are a good way to factor commonality "
"between two instances of a definition, multiclasses allow a convenient "
"notation for defining multiple definitions at once (instances of implicitly "
"constructed classes).  For example, consider an 3-address instruction set "
"whose instructions come in two forms: \"``reg = reg op reg``\" and \"``reg = "
"reg op imm``\" (e.g. SPARC). In this case, you'd like to specify in one "
"place that this commonality exists, then in a separate place indicate what "
"all the ops are."
msgstr ""

#: ../../../TableGen/LangIntro.rst:502
msgid "Here is an example TableGen fragment that shows this idea:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:524
msgid ""
"The name of the resultant definitions has the multidef fragment names "
"appended to them, so this defines ``ADD_rr``, ``ADD_ri``, ``SUB_rr``, etc.  "
"A defm may inherit from multiple multiclasses, instantiating definitions "
"from each multiclass.  Using a multiclass this way is exactly equivalent to "
"instantiating the classes multiple times yourself, e.g. by writing:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:554
msgid ""
"A ``defm`` can also be used inside a multiclass providing several levels of "
"multiclass instantiations."
msgstr ""

#: ../../../TableGen/LangIntro.rst:594
msgid ""
"``defm`` declarations can inherit from classes too, the rule to follow is "
"that the class list must start after the last multiclass, and there must be "
"at least one multiclass before them."
msgstr ""

#: ../../../TableGen/LangIntro.rst:631
msgid "File scope entities"
msgstr ""

#: ../../../TableGen/LangIntro.rst:634
msgid "File inclusion"
msgstr ""

#: ../../../TableGen/LangIntro.rst:636
msgid ""
"TableGen supports the '``include``' token, which textually substitutes the "
"specified file in place of the include directive.  The filename should be "
"specified as a double quoted string immediately after the '``include``' "
"keyword. Example:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:648
msgid ""
"\"Let\" expressions at file scope are similar to `\"let\" expressions within "
"a record`_, except they can specify a value binding for multiple records at "
"a time, and may be useful in certain other cases.  File-scope let "
"expressions are really just another way that TableGen allows the end-user to "
"factor out commonality from the records."
msgstr ""

#: ../../../TableGen/LangIntro.rst:654
msgid ""
"File-scope \"let\" expressions take a comma-separated list of bindings to "
"apply, and one or more records to bind the values in.  Here are some "
"examples:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:675
msgid ""
"File-scope \"let\" expressions are often useful when a couple of definitions "
"need to be added to several records, and the records do not otherwise need "
"to be opened, as in the case with the ``CALL*`` instructions above."
msgstr ""

#: ../../../TableGen/LangIntro.rst:679
msgid ""
"It's also possible to use \"let\" expressions inside multiclasses, providing "
"more ways to factor out commonality from the records, specially if using "
"several levels of multiclass instantiations. This also avoids the need of "
"using \"let\" expressions within subsequent records inside a multiclass."
msgstr ""

#: ../../../TableGen/LangIntro.rst:706
msgid "Looping"
msgstr ""

#: ../../../TableGen/LangIntro.rst:708
msgid ""
"TableGen supports the '``foreach``' block, which textually replicates the "
"loop body, substituting iterator values for iterator references in the body. "
"Example:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:719
msgid ""
"This will create objects ``R0``, ``R1``, ``R2`` and ``R3``.  ``foreach`` "
"blocks may be nested. If there is only one item in the body the braces may "
"be elided:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:729
msgid "Code Generator backend info"
msgstr ""

#: ../../../TableGen/LangIntro.rst:731
msgid ""
"Expressions used by code generator to describe instructions and isel "
"patterns:"
msgstr ""

#: ../../../TableGen/LangIntro.rst:736
msgid "``(implicit a)``"
msgstr ""

#: ../../../TableGen/LangIntro.rst:734
msgid ""
"an implicitly defined physical register.  This tells the dag instruction "
"selection emitter the input pattern's extra definitions matches implicit "
"physical register definitions."
msgstr ""
