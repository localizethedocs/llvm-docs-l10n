# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TableGen/LangRef.rst:3
msgid "TableGen Language Reference"
msgstr ""

#: ../../../TableGen/LangRef.rst:9
msgid ""
"This document is extremely rough. If you find something lacking, please fix "
"it, file a documentation bug, or ask about it on llvm-dev."
msgstr ""

#: ../../../TableGen/LangRef.rst:13
msgid "Introduction"
msgstr ""

#: ../../../TableGen/LangRef.rst:15
msgid ""
"This document is meant to be a normative spec about the TableGen language in "
"and of itself (i.e. how to understand a given construct in terms of how it "
"affects the final set of records represented by the TableGen file). If you "
"are unsure if this document is really what you are looking for, please read "
"the :doc:`introduction to TableGen <index>` first."
msgstr ""

#: ../../../TableGen/LangRef.rst:22
msgid "Notation"
msgstr ""

#: ../../../TableGen/LangRef.rst:24
msgid ""
"The lexical and syntax notation used here is intended to imitate "
"`Python's`_. In particular, for lexical definitions, the productions operate "
"at the character level and there is no implied whitespace between elements. "
"The syntax definitions operate at the token level, so there is implied "
"whitespace between tokens."
msgstr ""

#: ../../../TableGen/LangRef.rst:33
msgid "Lexical Analysis"
msgstr ""

#: ../../../TableGen/LangRef.rst:35
msgid ""
"TableGen supports BCPL (``// ...``) and nestable C-style (``/* ... */``) "
"comments.  TableGen also provides simple `Preprocessing Support`_."
msgstr ""

#: ../../../TableGen/LangRef.rst:38
msgid "The following is a listing of the basic punctuation tokens::"
msgstr ""

#: ../../../TableGen/LangRef.rst:42
msgid "Numeric literals take one of the following forms:"
msgstr ""

#: ../../../TableGen/LangRef.rst:54
msgid ""
"One aspect to note is that the :token:`DecimalInteger` token *includes* the "
"``+`` or ``-``, as opposed to having ``+`` and ``-`` be unary operators as "
"most languages do."
msgstr ""

#: ../../../TableGen/LangRef.rst:58
msgid ""
"Also note that :token:`BinInteger` creates a value of type ``bits<n>`` "
"(where ``n`` is the number of bits).  This will implicitly convert to "
"integers when needed."
msgstr ""

#: ../../../TableGen/LangRef.rst:62
msgid "TableGen has identifier-like tokens:"
msgstr ""

#: ../../../TableGen/LangRef.rst:69
msgid ""
"Note that unlike most languages, TableGen allows :token:`TokIdentifier` to "
"begin with a number. In case of ambiguity, a token will be interpreted as a "
"numeric literal rather than an identifier."
msgstr ""

#: ../../../TableGen/LangRef.rst:73
msgid "TableGen also has two string-like literals:"
msgstr ""

#: ../../../TableGen/LangRef.rst:79
msgid ""
":token:`TokCodeFragment` is essentially a multiline string literal delimited "
"by ``[{`` and ``}]``."
msgstr ""

#: ../../../TableGen/LangRef.rst:83
msgid "The current implementation accepts the following C-like escapes::"
msgstr ""

#: ../../../TableGen/LangRef.rst:87
msgid "TableGen also has the following keywords::"
msgstr ""

#: ../../../TableGen/LangRef.rst:94
msgid ""
"TableGen also has \"bang operators\" which have a wide variety of meanings:"
msgstr ""

#: ../../../TableGen/LangRef.rst:107
msgid ""
"TableGen also has !cond operator that needs a slightly different syntax "
"compared to other \"bang operators\":"
msgstr ""

#: ../../../TableGen/LangRef.rst:115
msgid "Syntax"
msgstr ""

#: ../../../TableGen/LangRef.rst:117
msgid ""
"TableGen has an ``include`` mechanism. It does not play a role in the syntax "
"per se, since it is lexically replaced with the contents of the included "
"file."
msgstr ""

#: ../../../TableGen/LangRef.rst:124
msgid "TableGen's top-level production consists of \"objects\"."
msgstr ""

#: ../../../TableGen/LangRef.rst:132
msgid "``class``\\es"
msgstr ""

#: ../../../TableGen/LangRef.rst:138
msgid ""
"A ``class`` declaration creates a record which other records can inherit "
"from. A class can be parameterized by a list of \"template arguments\", "
"whose values can be used in the class body."
msgstr ""

#: ../../../TableGen/LangRef.rst:142
msgid ""
"A given class can only be defined once. A ``class`` declaration is "
"considered to define the class if any of the following is true:"
msgstr ""

#: ../../../TableGen/LangRef.rst:147
msgid "The :token:`TemplateArgList` is present."
msgstr ""

#: ../../../TableGen/LangRef.rst:148
msgid ""
"The :token:`Body` in the :token:`ObjectBody` is present and is not empty."
msgstr ""

#: ../../../TableGen/LangRef.rst:149
msgid "The :token:`BaseClassList` in the :token:`ObjectBody` is present."
msgstr ""

#: ../../../TableGen/LangRef.rst:151
msgid ""
"You can declare an empty class by giving an empty :token:`TemplateArgList` "
"and an empty :token:`ObjectBody`. This can serve as a restricted form of "
"forward declaration: note that records deriving from the forward-declared "
"class will inherit no fields from it since the record expansion is done when "
"the record is parsed."
msgstr ""

#: ../../../TableGen/LangRef.rst:157
msgid ""
"Every class has an implicit template argument called ``NAME``, which is set "
"to the name of the instantiating ``def`` or ``defm``. The result is "
"undefined if the class is instantiated by an anonymous record."
msgstr ""

#: ../../../TableGen/LangRef.rst:162
msgid "Declarations"
msgstr ""

#: ../../../TableGen/LangRef.rst:166
msgid ""
"The declaration syntax is pretty much what you would expect as a C++ "
"programmer."
msgstr ""

#: ../../../TableGen/LangRef.rst:172
msgid "It assigns the value to the identifier."
msgstr ""

#: ../../../TableGen/LangRef.rst:175
msgid "Types"
msgstr ""

#: ../../../TableGen/LangRef.rst:184
msgid ""
"Both ``string`` and ``code`` correspond to the string type; the difference "
"is purely to indicate programmer intention."
msgstr ""

#: ../../../TableGen/LangRef.rst:187
msgid ""
"The :token:`ClassID` must identify a class that has been previously declared "
"or defined."
msgstr ""

#: ../../../TableGen/LangRef.rst:191
msgid "Values"
msgstr ""

#: ../../../TableGen/LangRef.rst:203
msgid ""
"The peculiar last form of :token:`RangePiece` is due to the fact that the "
"\"``-``\" is included in the :token:`TokInteger`, hence ``1-5`` gets lexed "
"as two consecutive :token:`TokInteger`'s, with values ``1`` and ``-5``, "
"instead of \"1\", \"-\", and \"5\". The :token:`RangeList` can be thought of "
"as specifying \"list slice\" in some contexts."
msgstr ""

#: ../../../TableGen/LangRef.rst:211
msgid ":token:`SimpleValue` has a number of forms:"
msgstr ""

#: ../../../TableGen/LangRef.rst:217
msgid ""
"The value will be the variable referenced by the identifier. It can be one "
"of:"
msgstr ""

#: ../../../TableGen/LangRef.rst:223
msgid "name of a ``def``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:233
msgid "value local to a ``def``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:240
msgid "Values defined in superclasses can be accessed the same way."
msgstr ""

#: ../../../TableGen/LangRef.rst:242
msgid "a template arg of a ``class``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:248
msgid "value local to a ``class``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:255
msgid "a template arg to a ``multiclass``, such as the use of ``Bar`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:261
msgid "the iteration variable of a ``foreach``, such as the use of ``i`` in::"
msgstr ""

#: ../../../TableGen/LangRef.rst:266
msgid "a variable defined by ``defset`` or ``defvar``"
msgstr ""

#: ../../../TableGen/LangRef.rst:268
msgid ""
"the implicit template argument ``NAME`` in a ``class`` or ``multiclass``"
msgstr ""

#: ../../../TableGen/LangRef.rst:273
msgid "This represents the numeric value of the integer."
msgstr ""

#: ../../../TableGen/LangRef.rst:278
msgid ""
"Multiple adjacent string literals are concatenated like in C/C++. The value "
"is the concatenation of the strings."
msgstr ""

#: ../../../TableGen/LangRef.rst:284
msgid "The value is the string value of the code fragment."
msgstr ""

#: ../../../TableGen/LangRef.rst:289
msgid "``?`` represents an \"unset\" initializer."
msgstr ""

#: ../../../TableGen/LangRef.rst:296
msgid ""
"This represents a sequence of bits, as would be used to initialize a "
"``bits<n>`` field (where ``n`` is the number of bits)."
msgstr ""

#: ../../../TableGen/LangRef.rst:302
msgid ""
"This generates a new anonymous record definition (as would be created by an "
"unnamed ``def`` inheriting from the given class with the given template "
"arguments) and the value is the value of that record definition."
msgstr ""

#: ../../../TableGen/LangRef.rst:309
msgid ""
"A list initializer. The optional :token:`Type` can be used to indicate a "
"specific element type, otherwise the element type will be deduced from the "
"given values."
msgstr ""

#: ../../../TableGen/LangRef.rst:322
msgid "The initial :token:`DagArg` is called the \"operator\" of the dag."
msgstr ""

#: ../../../TableGen/LangRef.rst:330
msgid "Bodies"
msgstr ""

#: ../../../TableGen/LangRef.rst:339
msgid ""
"The version with the :token:`MultiClassID` is only valid in the :token:"
"`BaseClassList` of a ``defm``. The :token:`MultiClassID` should be the name "
"of a ``multiclass``."
msgstr ""

#: ../../../TableGen/LangRef.rst:345
msgid ""
"It is after parsing the base class list that the \"let stack\" is applied."
msgstr ""

#: ../../../TableGen/LangRef.rst:354
msgid "The ``let`` form allows overriding the value of an inherited field."
msgstr ""

#: ../../../TableGen/LangRef.rst:357
msgid "``def``"
msgstr ""

#: ../../../TableGen/LangRef.rst:362
msgid ""
"Defines a record whose name is given by the optional :token:`Value`. The "
"value is parsed in a special mode where global identifiers (records and "
"variables defined by ``defset``, and variables defined at global scope by "
"``defvar``) are not recognized, and all unrecognized identifiers are "
"interpreted as strings."
msgstr ""

#: ../../../TableGen/LangRef.rst:367
msgid ""
"If no name is given, the record is anonymous. The final name of anonymous "
"records is undefined, but globally unique."
msgstr ""

#: ../../../TableGen/LangRef.rst:370
msgid ""
"Special handling occurs if this ``def`` appears inside a ``multiclass`` or a "
"``foreach``."
msgstr ""

#: ../../../TableGen/LangRef.rst:373
msgid ""
"When a non-anonymous record is defined in a multiclass and the given name "
"does not contain a reference to the implicit template argument ``NAME``, "
"such a reference will automatically be prepended. That is, the following are "
"equivalent inside a multiclass::"
msgstr ""

#: ../../../TableGen/LangRef.rst:382
msgid "``defm``"
msgstr ""

#: ../../../TableGen/LangRef.rst:387
msgid ""
"The :token:`BaseClassList` is a list of at least one ``multiclass`` and any "
"number of ``class``'s. The ``multiclass``'s must occur before any "
"``class``'s."
msgstr ""

#: ../../../TableGen/LangRef.rst:390
msgid ""
"Instantiates all records defined in all given ``multiclass``'s and adds the "
"given ``class``'s as superclasses."
msgstr ""

#: ../../../TableGen/LangRef.rst:393
msgid ""
"The name is parsed in the same special mode used by ``def``. If the name is "
"missing, a globally unique string is used instead (but instantiated records "
"are not considered to be anonymous, unless they were originally defined by "
"an anonymous ``def``) That is, the following have different semantics::"
msgstr ""

#: ../../../TableGen/LangRef.rst:401
msgid ""
"When it occurs inside a multiclass, the second variant is equivalent to "
"``defm NAME : ...``. More generally, when ``defm`` occurs in a multiclass "
"and its name does not contain a reference to the implicit template argument "
"``NAME``, such a reference will automatically be prepended. That is, the "
"following are equivalent inside a multiclass::"
msgstr ""

#: ../../../TableGen/LangRef.rst:411
msgid "``defset``"
msgstr ""

#: ../../../TableGen/LangRef.rst:415
msgid ""
"All records defined inside the braces via ``def`` and ``defm`` are collected "
"in a globally accessible list of the given name (in addition to being added "
"to the global collection of records as usual). Anonymous records created "
"inside initializier expressions using the ``Class<args...>`` syntax are "
"never collected in a defset."
msgstr ""

#: ../../../TableGen/LangRef.rst:421
msgid ""
"The given type must be ``list<A>``, where ``A`` is some class. It is an "
"error to define a record (via ``def`` or ``defm``) inside the braces which "
"doesn't derive from ``A``."
msgstr ""

#: ../../../TableGen/LangRef.rst:426
msgid "``defvar``"
msgstr ""

#: ../../../TableGen/LangRef.rst:430
msgid ""
"The identifier on the left of the ``=`` is defined to be a global or local "
"variable, whose value is given by the expression on the right of the ``=``. "
"The type of the variable is automatically inferred."
msgstr ""

#: ../../../TableGen/LangRef.rst:434
msgid ""
"A ``defvar`` statement at the top level of the file defines a global "
"variable, in the same scope used by ``defset``. If a ``defvar`` statement "
"appears inside any other construction, including classes, multiclasses and "
"``foreach`` statements, then the variable is scoped to the inside of that "
"construction only."
msgstr ""

#: ../../../TableGen/LangRef.rst:440
msgid ""
"In contexts where the ``defvar`` statement will be encountered multiple "
"times, the definition is re-evaluated for each instance. For example, a "
"``defvar`` inside a ``foreach`` can construct a value based on the iteration "
"variable, which will be different every time round the loop; a ``defvar`` "
"inside a templated class or multiclass can have a definition depending on "
"the template parameters."
msgstr ""

#: ../../../TableGen/LangRef.rst:447
msgid ""
"Variables local to a ``foreach`` go out of scope at the end of each loop "
"iteration, so their previous value is not accessible in the next iteration. "
"(It won't work to ``defvar i=!add(i,1)`` each time you go round the loop.)"
msgstr ""

#: ../../../TableGen/LangRef.rst:451
msgid ""
"In general, ``defvar`` variables are immutable once they are defined. It is "
"an error to define the same variable name twice in the same scope (but legal "
"to shadow the first definition temporarily in an inner scope)."
msgstr ""

#: ../../../TableGen/LangRef.rst:456
msgid "``foreach``"
msgstr ""

#: ../../../TableGen/LangRef.rst:463
msgid ""
"The value assigned to the variable in the declaration is iterated over and "
"the object or object list is reevaluated with the variable set at each "
"iterated value."
msgstr ""

#: ../../../TableGen/LangRef.rst:467
msgid ""
"Note that the productions involving RangeList and RangePiece have precedence "
"over the more generic value parsing based on the first token."
msgstr ""

#: ../../../TableGen/LangRef.rst:471
msgid "``if``"
msgstr ""

#: ../../../TableGen/LangRef.rst:478
msgid ""
"The value expression after the ``if`` keyword is evaluated, and if it "
"evaluates to true (in the same sense used by the ``!if`` operator), then the "
"object definition(s) after the ``then`` keyword are executed. Otherwise, if "
"there is an ``else`` keyword, the definition(s) after the ``else`` are "
"executed instead."
msgstr ""

#: ../../../TableGen/LangRef.rst:483
msgid ""
"Because the braces around the ``then`` clause are optional, this grammar "
"rule has the usual ambiguity about dangling ``else`` clauses, and it is "
"resolved in the usual way: in a case like ``if v1 then if v2 then {...} else "
"{...}``, the ``else`` binds to the inner ``if`` rather than the outer one."
msgstr ""

#: ../../../TableGen/LangRef.rst:489
msgid "Top-Level ``let``"
msgstr ""

#: ../../../TableGen/LangRef.rst:497
msgid ""
"This is effectively equivalent to ``let`` inside the body of a record except "
"that it applies to multiple records at a time. The bindings are applied at "
"the end of parsing the base classes of a record."
msgstr ""

#: ../../../TableGen/LangRef.rst:502
msgid "``multiclass``"
msgstr ""

#: ../../../TableGen/LangRef.rst:512
msgid "Preprocessing Support"
msgstr ""

#: ../../../TableGen/LangRef.rst:514
msgid ""
"TableGen's embedded preprocessor is only intended for conditional "
"compilation. It supports the following directives:"
msgstr ""

#: ../../../TableGen/LangRef.rst:544
msgid ""
":token:`PrepRegion` may occur anywhere in a TD file, as long as it matches "
"the grammar specification."
msgstr ""

#: ../../../TableGen/LangRef.rst:547
msgid ""
":token:`PrepDefine` allows defining a :token:`MacroName` so that any "
"following :token:`PrepIfdef` - :token:`PrepElse` preprocessing region part "
"and :token:`PrepIfdef` - :token:`PrepEndif` preprocessing region are enabled "
"for TableGen tokens parsing."
msgstr ""

#: ../../../TableGen/LangRef.rst:552
msgid ""
"A preprocessing region, starting (i.e. having its :token:`PrepIfdef`) in a "
"file, must end (i.e. have its :token:`PrepEndif`) in the same file."
msgstr ""

#: ../../../TableGen/LangRef.rst:555
msgid ""
"A :token:`MacroName` may be defined externally by using ``{ -D<NAME> }`` "
"option of TableGen."
msgstr ""
