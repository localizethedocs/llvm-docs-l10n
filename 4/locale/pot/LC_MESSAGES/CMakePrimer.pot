# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CMakePrimer.rst:3
msgid "CMake Primer"
msgstr ""

#: ../../../CMakePrimer.rst:9
msgid ""
"Disclaimer: This documentation is written by LLVM project contributors `not` "
"anyone affiliated with the CMake project. This document may contain "
"inaccurate terminology, phrasing, or technical details. It is provided with "
"the best intentions."
msgstr ""

#: ../../../CMakePrimer.rst:16
msgid "Introduction"
msgstr ""

#: ../../../CMakePrimer.rst:18
msgid ""
"The LLVM project and many of the core projects built on LLVM build using "
"CMake. This document aims to provide a brief overview of CMake for "
"developers modifying LLVM projects or building their own projects on top of "
"LLVM."
msgstr ""

#: ../../../CMakePrimer.rst:22
msgid ""
"The official CMake language references is available in the cmake-language "
"manpage and `cmake-language online documentation <https://cmake.org/cmake/"
"help/v3.4/manual/cmake-language.7.html>`_."
msgstr ""

#: ../../../CMakePrimer.rst:27
msgid "10,000 ft View"
msgstr ""

#: ../../../CMakePrimer.rst:29
msgid ""
"CMake is a tool that reads script files in its own language that describe "
"how a software project builds. As CMake evaluates the scripts it constructs "
"an internal representation of the software project. Once the scripts have "
"been fully processed, if there are no errors, CMake will generate build "
"files to actually build the project. CMake supports generating build files "
"for a variety of command line build tools as well as for popular IDEs."
msgstr ""

#: ../../../CMakePrimer.rst:36
msgid ""
"When a user runs CMake it performs a variety of checks similar to how "
"autoconf worked historically. During the checks and the evaluation of the "
"build description scripts CMake caches values into the CMakeCache. This is "
"useful because it allows the build system to skip long-running checks during "
"incremental development. CMake caching also has some drawbacks, but that "
"will be discussed later."
msgstr ""

#: ../../../CMakePrimer.rst:44
msgid "Scripting Overview"
msgstr ""

#: ../../../CMakePrimer.rst:46
msgid ""
"CMake's scripting language has a very simple grammar. Every language "
"construct is a command that matches the pattern _name_(_args_). Commands "
"come in three primary types: language-defined (commands implemented in C++ "
"in CMake), defined functions, and defined macros. The CMake distribution "
"also contains a suite of CMake modules that contain definitions for useful "
"functionality."
msgstr ""

#: ../../../CMakePrimer.rst:52
msgid ""
"The example below is the full CMake build for building a C++ \"Hello World\" "
"program. The example uses only CMake language-defined functions."
msgstr ""

#: ../../../CMakePrimer.rst:61
msgid ""
"The CMake language provides control flow constructs in the form of foreach "
"loops and if blocks. To make the example above more complicated you could "
"add an if block to define \"APPLE\" when targeting Apple platforms:"
msgstr ""

#: ../../../CMakePrimer.rst:75
msgid "Variables, Types, and Scope"
msgstr ""

#: ../../../CMakePrimer.rst:78
msgid "Dereferencing"
msgstr ""

#: ../../../CMakePrimer.rst:80
msgid ""
"In CMake variables are \"stringly\" typed. All variables are represented as "
"strings throughout evaluation. Wrapping a variable in ``${}`` dereferences "
"it and results in a literal substitution of the name for the value. CMake "
"refers to this as \"variable evaluation\" in their documentation. "
"Dereferences are performed *before* the command being called receives the "
"arguments. This means dereferencing a list results in multiple separate "
"arguments being passed to the command."
msgstr ""

#: ../../../CMakePrimer.rst:88
msgid ""
"Variable dereferences can be nested and be used to model complex data. For "
"example:"
msgstr ""

#: ../../../CMakePrimer.rst:97
msgid ""
"Dereferencing an unset variable results in an empty expansion. It is a "
"common pattern in CMake to conditionally set variables knowing that it will "
"be used in code paths that the variable isn't set. There are examples of "
"this throughout the LLVM CMake build system."
msgstr ""

#: ../../../CMakePrimer.rst:102
msgid "An example of variable empty expansion is:"
msgstr ""

#: ../../../CMakePrimer.rst:111
msgid ""
"In this example the ``extra_sources`` variable is only defined if you're "
"targeting an Apple platform. For all other targets the ``extra_sources`` "
"will be evaluated as empty before add_executable is given its arguments."
msgstr ""

#: ../../../CMakePrimer.rst:115
msgid ""
"One big \"Gotcha\" with variable dereferencing is that ``if`` commands "
"implicitly dereference values. This has some unexpected results. For example:"
msgstr ""

#: ../../../CMakePrimer.rst:122
msgid ""
"In this code sample MSVC will be implicitly dereferenced, which will result "
"in the if command comparing the value of the dereferenced variables "
"``SOME_VAR`` and ``MSVC``. A common workaround to this solution is to "
"prepend strings being compared with an ``x``."
msgstr ""

#: ../../../CMakePrimer.rst:131
msgid ""
"This works because while ``MSVC`` is a defined variable, ``xMSVC`` is not. "
"This pattern is uncommon, but it does occur in LLVM's CMake scripts."
msgstr ""

#: ../../../CMakePrimer.rst:136
msgid ""
"Once the LLVM project upgrades its minimum CMake version to 3.1 or later we "
"can prevent this behavior by setting CMP0054 to new. For more information on "
"CMake policies please see the cmake-policies manpage or the `cmake-policies "
"online documentation <https://cmake.org/cmake/help/v3.4/manual/cmake-"
"policies.7.html>`_."
msgstr ""

#: ../../../CMakePrimer.rst:143
msgid "Lists"
msgstr ""

#: ../../../CMakePrimer.rst:145
msgid ""
"In CMake lists are semi-colon delimited strings, and it is strongly advised "
"that you avoid using semi-colons in lists; it doesn't go smoothly. A few "
"examples of defining lists:"
msgstr ""

#: ../../../CMakePrimer.rst:159
msgid "Lists of Lists"
msgstr ""

#: ../../../CMakePrimer.rst:161
msgid ""
"One of the more complicated patterns in CMake is lists of lists. Because a "
"list cannot contain an element with a semi-colon to construct a list of "
"lists you make a list of variable names that refer to other lists. For "
"example:"
msgstr ""

#: ../../../CMakePrimer.rst:172
msgid ""
"With this layout you can iterate through the list of lists printing each "
"value with the following code:"
msgstr ""

#: ../../../CMakePrimer.rst:183
msgid ""
"You'll notice that the inner foreach loop's list is doubly dereferenced. "
"This is because the first dereference turns ``list_name`` into the name of "
"the sub-list (a, b, or c in the example), then the second dereference is to "
"get the value of the list."
msgstr ""

#: ../../../CMakePrimer.rst:188
msgid ""
"This pattern is used throughout CMake, the most common example is the "
"compiler flags options, which CMake refers to using the following variable "
"expansions: CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}"
"_FLAGS_${CMAKE_BUILD_TYPE}."
msgstr ""

#: ../../../CMakePrimer.rst:193
msgid "Other Types"
msgstr ""

#: ../../../CMakePrimer.rst:195
msgid ""
"Variables that are cached or specified on the command line can have types "
"associated with them. The variable's type is used by CMake's UI tool to "
"display the right input field. The variable's type generally doesn't impact "
"evaluation. One of the few examples is PATH variables, which CMake does have "
"some special handling for. You can read more about the special handling in "
"`CMake's set documentation <https://cmake.org/cmake/help/v3.5/command/set."
"html#set-cache-entry>`_."
msgstr ""

#: ../../../CMakePrimer.rst:204
msgid "Scope"
msgstr ""

#: ../../../CMakePrimer.rst:206
msgid ""
"CMake inherently has a directory-based scoping. Setting a variable in a "
"CMakeLists file, will set the variable for that file, and all "
"subdirectories. Variables set in a CMake module that is included in a "
"CMakeLists file will be set in the scope they are included from, and all "
"subdirectories."
msgstr ""

#: ../../../CMakePrimer.rst:211
msgid ""
"When a variable that is already set is set again in a subdirectory it "
"overrides the value in that scope and any deeper subdirectories."
msgstr ""

#: ../../../CMakePrimer.rst:214
msgid ""
"The CMake set command provides two scope-related options. PARENT_SCOPE sets "
"a variable into the parent scope, and not the current scope. The CACHE "
"option sets the variable in the CMakeCache, which results in it being set in "
"all scopes. The CACHE option will not set a variable that already exists in "
"the CACHE unless the FORCE option is specified."
msgstr ""

#: ../../../CMakePrimer.rst:220
msgid ""
"In addition to directory-based scope, CMake functions also have their own "
"scope. This means variables set inside functions do not bleed into the "
"parent scope. This is not true of macros, and it is for this reason LLVM "
"prefers functions over macros whenever reasonable."
msgstr ""

#: ../../../CMakePrimer.rst:226
msgid ""
"Unlike C-based languages, CMake's loop and control flow blocks do not have "
"their own scopes."
msgstr ""

#: ../../../CMakePrimer.rst:230
msgid "Control Flow"
msgstr ""

#: ../../../CMakePrimer.rst:232
msgid ""
"CMake features the same basic control flow constructs you would expect in "
"any scripting language, but there are a few quarks because, as with "
"everything in CMake, control flow constructs are commands."
msgstr ""

#: ../../../CMakePrimer.rst:237
msgid "If, ElseIf, Else"
msgstr ""

#: ../../../CMakePrimer.rst:240
msgid ""
"For the full documentation on the CMake if command go `here <https://cmake."
"org/cmake/help/v3.4/command/if.html>`_. That resource is far more complete."
msgstr ""

#: ../../../CMakePrimer.rst:244
msgid "In general CMake if blocks work the way you'd expect:"
msgstr ""

#: ../../../CMakePrimer.rst:256
msgid ""
"The single most important thing to know about CMake's if blocks coming from "
"a C background is that they do not have their own scope. Variables set "
"inside conditional blocks persist after the ``endif()``."
msgstr ""

#: ../../../CMakePrimer.rst:261
msgid "Loops"
msgstr ""

#: ../../../CMakePrimer.rst:263
msgid "The most common form of the CMake ``foreach`` block is:"
msgstr ""

#: ../../../CMakePrimer.rst:271
msgid ""
"The variable argument portion of the ``foreach`` block can contain "
"dereferenced lists, values to iterate, or a mix of both:"
msgstr ""

#: ../../../CMakePrimer.rst:302
msgid ""
"There is also a more modern CMake foreach syntax. The code below is "
"equivalent to the code above:"
msgstr ""

#: ../../../CMakePrimer.rst:333
msgid ""
"Similar to the conditional statements, these generally behave how you would "
"expect, and they do not have their own scope."
msgstr ""

#: ../../../CMakePrimer.rst:336
msgid ""
"CMake also supports ``while`` loops, although they are not widely used in "
"LLVM."
msgstr ""

#: ../../../CMakePrimer.rst:339
msgid "Modules, Functions and Macros"
msgstr ""

#: ../../../CMakePrimer.rst:342
msgid "Modules"
msgstr ""

#: ../../../CMakePrimer.rst:344
msgid ""
"Modules are CMake's vehicle for enabling code reuse. CMake modules are just "
"CMake script files. They can contain code to execute on include as well as "
"definitions for commands."
msgstr ""

#: ../../../CMakePrimer.rst:348
msgid ""
"In CMake macros and functions are universally referred to as commands, and "
"they are the primary method of defining code that can be called multiple "
"times."
msgstr ""

#: ../../../CMakePrimer.rst:351
msgid ""
"In LLVM we have several CMake modules that are included as part of our "
"distribution for developers who don't build our project from source. Those "
"modules are the fundamental pieces needed to build LLVM-based projects with "
"CMake. We also rely on modules as a way of organizing the build system's "
"functionality for maintainability and re-use within LLVM projects."
msgstr ""

#: ../../../CMakePrimer.rst:358
msgid "Argument Handling"
msgstr ""

#: ../../../CMakePrimer.rst:360
msgid ""
"When defining a CMake command handling arguments is very useful. The "
"examples in this section will all use the CMake ``function`` block, but this "
"all applies to the ``macro`` block as well."
msgstr ""

#: ../../../CMakePrimer.rst:364
msgid ""
"CMake commands can have named arguments, but all commands are implicitly "
"variable argument. If the command has named arguments they are required and "
"must be specified at every call site. Below is a trivial example of "
"providing a wrapper function for CMake's built in function "
"``add_dependencies``."
msgstr ""

#: ../../../CMakePrimer.rst:375
msgid ""
"This example defines a new macro named ``add_deps`` which takes a required "
"first argument, and just calls another function passing through the first "
"argument and all trailing arguments. When variable arguments are present "
"CMake defines them in a list named ``ARGV``, and the count of the arguments "
"is defined in ``ARGN``."
msgstr ""

#: ../../../CMakePrimer.rst:380
msgid ""
"CMake provides a module ``CMakeParseArguments`` which provides an "
"implementation of advanced argument parsing. We use this all over LLVM, and "
"it is recommended for any function that has complex argument-based behaviors "
"or optional arguments. CMake's official documentation for the module is in "
"the ``cmake-modules`` manpage, and is also available at the `cmake-modules "
"online documentation <https://cmake.org/cmake/help/v3.4/module/"
"CMakeParseArguments.html>`_."
msgstr ""

#: ../../../CMakePrimer.rst:389
msgid ""
"As of CMake 3.5 the cmake_parse_arguments command has become a native "
"command and the CMakeParseArguments module is empty and only left around for "
"compatibility."
msgstr ""

#: ../../../CMakePrimer.rst:394
msgid "Functions Vs Macros"
msgstr ""

#: ../../../CMakePrimer.rst:396
msgid ""
"Functions and Macros look very similar in how they are used, but there is "
"one fundamental difference between the two. Functions have their own scope, "
"and macros don't. This means variables set in macros will bleed out into the "
"calling scope. That makes macros suitable for defining very small bits of "
"functionality only."
msgstr ""

#: ../../../CMakePrimer.rst:402
msgid ""
"The other difference between CMake functions and macros is how arguments are "
"passed. Arguments to macros are not set as variables, instead dereferences "
"to the parameters are resolved across the macro before executing it. This "
"can result in some unexpected behavior if using unreferenced variables. For "
"example:"
msgstr ""

#: ../../../CMakePrimer.rst:424
msgid ""
"Generally speaking this issue is uncommon because it requires using non-"
"dereferenced variables with names that overlap in the parent scope, but it "
"is important to be aware of because it can lead to subtle bugs."
msgstr ""

#: ../../../CMakePrimer.rst:429
msgid "LLVM Project Wrappers"
msgstr ""

#: ../../../CMakePrimer.rst:431
msgid ""
"LLVM projects provide lots of wrappers around critical CMake built-in "
"commands. We use these wrappers to provide consistent behaviors across LLVM "
"components and to reduce code duplication."
msgstr ""

#: ../../../CMakePrimer.rst:435
msgid ""
"We generally (but not always) follow the convention that commands prefaced "
"with ``llvm_`` are intended to be used only as building blocks for other "
"commands. Wrapper commands that are intended for direct use are generally "
"named following with the project in the middle of the command name (i.e. "
"``add_llvm_executable`` is the wrapper for ``add_executable``). The LLVM "
"``add_*`` wrapper functions are all defined in ``AddLLVM.cmake`` which is "
"installed as part of the LLVM distribution. It can be included and used by "
"any LLVM sub-project that requires LLVM."
msgstr ""

#: ../../../CMakePrimer.rst:446
msgid ""
"Not all LLVM projects require LLVM for all use cases. For example compiler-"
"rt can be built without LLVM, and the compiler-rt sanitizer libraries are "
"used with GCC."
msgstr ""

#: ../../../CMakePrimer.rst:451
msgid "Useful Built-in Commands"
msgstr ""

#: ../../../CMakePrimer.rst:453
msgid ""
"CMake has a bunch of useful built-in commands. This document isn't going to "
"go into details about them because The CMake project has excellent "
"documentation. To highlight a few useful functions see:"
msgstr ""

#: ../../../CMakePrimer.rst:457
msgid ""
"`add_custom_command <https://cmake.org/cmake/help/v3.4/command/"
"add_custom_command.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:458
msgid ""
"`add_custom_target <https://cmake.org/cmake/help/v3.4/command/"
"add_custom_target.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:459
msgid "`file <https://cmake.org/cmake/help/v3.4/command/file.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:460
msgid "`list <https://cmake.org/cmake/help/v3.4/command/list.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:461
msgid "`math <https://cmake.org/cmake/help/v3.4/command/math.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:462
msgid "`string <https://cmake.org/cmake/help/v3.4/command/string.html>`_"
msgstr ""

#: ../../../CMakePrimer.rst:464
msgid ""
"The full documentation for CMake commands is in the ``cmake-commands`` "
"manpage and available on `CMake's website <https://cmake.org/cmake/help/v3.4/"
"manual/cmake-commands.7.html>`_"
msgstr ""
