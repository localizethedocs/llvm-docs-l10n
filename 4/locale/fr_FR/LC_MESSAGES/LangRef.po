# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../LangRef.rst:3
msgid "LLVM Language Reference Manual"
msgstr ""

#: ../../../LangRef.rst:10
msgid "Abstract"
msgstr ""

#: ../../../LangRef.rst:12
msgid ""
"This document is a reference manual for the LLVM assembly language. LLVM is "
"a Static Single Assignment (SSA) based representation that provides type "
"safety, low-level operations, flexibility, and the capability of "
"representing 'all' high-level languages cleanly. It is the common code "
"representation used throughout all phases of the LLVM compilation strategy."
msgstr ""

#: ../../../LangRef.rst:20
msgid "Introduction"
msgstr ""

#: ../../../LangRef.rst:22
msgid ""
"The LLVM code representation is designed to be used in three different "
"forms: as an in-memory compiler IR, as an on-disk bitcode representation "
"(suitable for fast loading by a Just-In-Time compiler), and as a human "
"readable assembly language representation. This allows LLVM to provide a "
"powerful intermediate representation for efficient compiler transformations "
"and analysis, while providing a natural means to debug and visualize the "
"transformations. The three different forms of LLVM are all equivalent. This "
"document describes the human readable representation and notation."
msgstr ""

#: ../../../LangRef.rst:32
msgid ""
"The LLVM representation aims to be light-weight and low-level while being "
"expressive, typed, and extensible at the same time. It aims to be a "
"\"universal IR\" of sorts, by being at a low enough level that high-level "
"ideas may be cleanly mapped to it (similar to how microprocessors are "
"\"universal IR's\", allowing many source languages to be mapped to them). By "
"providing type information, LLVM can be used as the target of optimizations: "
"for example, through pointer analysis, it can be proven that a C automatic "
"variable is never accessed outside of the current function, allowing it to "
"be promoted to a simple SSA value instead of a memory location."
msgstr ""

#: ../../../LangRef.rst:46
msgid "Well-Formedness"
msgstr ""

#: ../../../LangRef.rst:48
msgid ""
"It is important to note that this document describes 'well formed' LLVM "
"assembly language. There is a difference between what the parser accepts and "
"what is considered 'well formed'. For example, the following instruction is "
"syntactically okay, but not well formed:"
msgstr ""

#: ../../../LangRef.rst:57
msgid ""
"because the definition of ``%x`` does not dominate all of its uses. The LLVM "
"infrastructure provides a verification pass that may be used to verify that "
"an LLVM module is well formed. This pass is automatically run by the parser "
"after parsing input assembly and by the optimizer before it outputs bitcode. "
"The violations pointed out by the verifier pass indicate bugs in "
"transformation passes or input to the parser."
msgstr ""

#: ../../../LangRef.rst:67
msgid "Identifiers"
msgstr ""

#: ../../../LangRef.rst:69
msgid ""
"LLVM identifiers come in two basic types: global and local. Global "
"identifiers (functions, global variables) begin with the ``'@'`` character. "
"Local identifiers (register names, types) begin with the ``'%'`` character. "
"Additionally, there are three different formats for identifiers, for "
"different purposes:"
msgstr ""

#: ../../../LangRef.rst:75
msgid ""
"Named values are represented as a string of characters with their prefix. "
"For example, ``%foo``, ``@DivisionByZero``, ``%a.really.long.identifier``. "
"The actual regular expression used is '``[%@][-a-zA-Z$._][-a-zA-Z$."
"_0-9]*``'. Identifiers that require other characters in their names can be "
"surrounded with quotes. Special characters may be escaped using ``\"\\xx\"`` "
"where ``xx`` is the ASCII code for the character in hexadecimal. In this "
"way, any character can be used in a name value, even quotes themselves. The "
"``\"\\01\"`` prefix can be used on global variables to suppress mangling."
msgstr ""

#: ../../../LangRef.rst:84
msgid ""
"Unnamed values are represented as an unsigned numeric value with their "
"prefix. For example, ``%12``, ``@2``, ``%44``."
msgstr ""

#: ../../../LangRef.rst:86
msgid "Constants, which are described in the section Constants_ below."
msgstr ""

#: ../../../LangRef.rst:88
msgid ""
"LLVM requires that values start with a prefix for two reasons: Compilers "
"don't need to worry about name clashes with reserved words, and the set of "
"reserved words may be expanded in the future without penalty. Additionally, "
"unnamed identifiers allow a compiler to quickly come up with a temporary "
"variable without having to avoid symbol table conflicts."
msgstr ""

#: ../../../LangRef.rst:95
msgid ""
"Reserved words in LLVM are very similar to reserved words in other "
"languages. There are keywords for different opcodes ('``add``', "
"'``bitcast``', '``ret``', etc...), for primitive type names ('``void``', "
"'``i32``', etc...), and others. These reserved words cannot conflict with "
"variable names, because none of them start with a prefix character (``'%'`` "
"or ``'@'``)."
msgstr ""

#: ../../../LangRef.rst:102
msgid ""
"Here is an example of LLVM code to multiply the integer variable '``%X``' by "
"8:"
msgstr ""

#: ../../../LangRef.rst:105
msgid "The easy way:"
msgstr ""

#: ../../../LangRef.rst:111
msgid "After strength reduction:"
msgstr ""

#: ../../../LangRef.rst:117
msgid "And the hard way:"
msgstr ""

#: ../../../LangRef.rst:125
msgid ""
"This last way of multiplying ``%X`` by 8 illustrates several important "
"lexical features of LLVM:"
msgstr ""

#: ../../../LangRef.rst:128
msgid "Comments are delimited with a '``;``' and go until the end of line."
msgstr ""

#: ../../../LangRef.rst:129
msgid ""
"Unnamed temporaries are created when the result of a computation is not "
"assigned to a named value."
msgstr ""

#: ../../../LangRef.rst:131
msgid ""
"Unnamed temporaries are numbered sequentially (using a per-function "
"incrementing counter, starting with 0). Note that basic blocks and unnamed "
"function parameters are included in this numbering. For example, if the "
"entry basic block is not given a label name and all function parameters are "
"named, then it will get number 0."
msgstr ""

#: ../../../LangRef.rst:137
msgid ""
"It also shows a convention that we follow in this document. When "
"demonstrating instructions, we will follow an instruction with a comment "
"that defines the type and name of value produced."
msgstr ""

#: ../../../LangRef.rst:142
msgid "High Level Structure"
msgstr ""

#: ../../../LangRef.rst:145
msgid "Module Structure"
msgstr ""

#: ../../../LangRef.rst:147
msgid ""
"LLVM programs are composed of ``Module``'s, each of which is a translation "
"unit of the input programs. Each module consists of functions, global "
"variables, and symbol table entries. Modules may be combined together with "
"the LLVM linker, which merges function (and global variable) definitions, "
"resolves forward declarations, and merges symbol table entries. Here is an "
"example of the \"hello world\" module:"
msgstr ""

#: ../../../LangRef.rst:176
msgid ""
"This example is made up of a :ref:`global variable <globalvars>` named \"``."
"str``\", an external declaration of the \"``puts``\" function, a :ref:"
"`function definition <functionstructure>` for \"``main``\" and :ref:`named "
"metadata <namedmetadatastructure>` \"``foo``\"."
msgstr ""

#: ../../../LangRef.rst:181
msgid ""
"In general, a module is made up of a list of global values (where both "
"functions and global variables are global values). Global values are "
"represented by a pointer to a memory location (in this case, a pointer to an "
"array of char, and a pointer to a function), and have one of the following :"
"ref:`linkage types <linkage>`."
msgstr ""

#: ../../../LangRef.rst:190
msgid "Linkage Types"
msgstr ""

#: ../../../LangRef.rst:192
msgid ""
"All Global Variables and Functions have one of the following types of "
"linkage:"
msgstr ""

#: ../../../LangRef.rst:200
msgid "``private``"
msgstr ""

#: ../../../LangRef.rst:196
msgid ""
"Global values with \"``private``\" linkage are only directly accessible by "
"objects in the current module. In particular, linking code into a module "
"with an private global value may cause the private to be renamed as "
"necessary to avoid collisions. Because the symbol is private to the module, "
"all references can be updated. This doesn't show up in any symbol table in "
"the object file."
msgstr ""

#: ../../../LangRef.rst:204
msgid "``internal``"
msgstr ""

#: ../../../LangRef.rst:203
msgid ""
"Similar to private, but the value shows as a local symbol (``STB_LOCAL`` in "
"the case of ELF) in the object file. This corresponds to the notion of the "
"'``static``' keyword in C."
msgstr ""

#: ../../../LangRef.rst:214
msgid "``available_externally``"
msgstr ""

#: ../../../LangRef.rst:207
msgid ""
"Globals with \"``available_externally``\" linkage are never emitted into the "
"object file corresponding to the LLVM module. From the linker's perspective, "
"an ``available_externally`` global is equivalent to an external declaration. "
"They exist to allow inlining and other optimizations to take place given "
"knowledge of the definition of the global, which is known to be somewhere "
"outside the module. Globals with ``available_externally`` linkage are "
"allowed to be discarded at will, and allow inlining and other optimizations. "
"This linkage type is only allowed on definitions, not declarations."
msgstr ""

#: ../../../LangRef.rst:227
msgid "``linkonce``"
msgstr ""

#: ../../../LangRef.rst:217
msgid ""
"Globals with \"``linkonce``\" linkage are merged with other globals of the "
"same name when linkage occurs. This can be used to implement some forms of "
"inline functions, templates, or other code which must be generated in each "
"translation unit that uses it, but where the body may be overridden with a "
"more definitive definition later. Unreferenced ``linkonce`` globals are "
"allowed to be discarded. Note that ``linkonce`` linkage does not actually "
"allow the optimizer to inline the body of this function into callers because "
"it doesn't know if this definition of the function is the definitive "
"definition within the program or whether it will be overridden by a stronger "
"definition. To enable inlining and other optimizations, use "
"\"``linkonce_odr``\" linkage."
msgstr ""

#: ../../../LangRef.rst:232
msgid "``weak``"
msgstr ""

#: ../../../LangRef.rst:230
msgid ""
"\"``weak``\" linkage has the same merging semantics as ``linkonce`` linkage, "
"except that unreferenced globals with ``weak`` linkage may not be discarded. "
"This is used for globals that are declared \"weak\" in C source code."
msgstr ""

#: ../../../LangRef.rst:242
msgid "``common``"
msgstr ""

#: ../../../LangRef.rst:235
msgid ""
"\"``common``\" linkage is most similar to \"``weak``\" linkage, but they are "
"used for tentative definitions in C, such as \"``int X;``\" at global scope. "
"Symbols with \"``common``\" linkage are merged in the same way as ``weak "
"symbols``, and they may not be deleted if unreferenced. ``common`` symbols "
"may not have an explicit section, must have a zero initializer, and may not "
"be marked ':ref:`constant <globalvars>`'. Functions and aliases may not have "
"common linkage."
msgstr ""

#: ../../../LangRef.rst:256
msgid "``appending``"
msgstr ""

#: ../../../LangRef.rst:247
msgid ""
"\"``appending``\" linkage may only be applied to global variables of pointer "
"to array type. When two global variables with appending linkage are linked "
"together, the two global arrays are appended together. This is the LLVM, "
"typesafe, equivalent of having the system linker append together "
"\"sections\" with identical names when .o files are linked."
msgstr ""

#: ../../../LangRef.rst:254
msgid ""
"Unfortunately this doesn't correspond to any feature in .o files, so it can "
"only be used for variables like ``llvm.global_ctors`` which llvm interprets "
"specially."
msgstr ""

#: ../../../LangRef.rst:260
msgid "``extern_weak``"
msgstr ""

#: ../../../LangRef.rst:259
msgid ""
"The semantics of this linkage follow the ELF object file model: the symbol "
"is weak until linked, if not linked, the symbol becomes null instead of "
"being an undefined reference."
msgstr ""

#: ../../../LangRef.rst:268
msgid "``linkonce_odr``, ``weak_odr``"
msgstr ""

#: ../../../LangRef.rst:263
msgid ""
"Some languages allow differing globals to be merged, such as two functions "
"with different semantics. Other languages, such as ``C++``, ensure that only "
"equivalent globals are ever merged (the \"one definition rule\" --- "
"\"ODR\"). Such languages can use the ``linkonce_odr`` and ``weak_odr`` "
"linkage types to indicate that the global will only be merged with "
"equivalent globals. These linkage types are otherwise the same as their non-"
"``odr`` versions."
msgstr ""

#: ../../../LangRef.rst:273
msgid "``external``"
msgstr ""

#: ../../../LangRef.rst:271
msgid ""
"If none of the above identifiers are used, the global is externally visible, "
"meaning that it participates in linkage and can be used to resolve external "
"symbol references."
msgstr ""

#: ../../../LangRef.rst:275
msgid ""
"It is illegal for a function *declaration* to have any linkage type other "
"than ``external`` or ``extern_weak``."
msgstr ""

#: ../../../LangRef.rst:281
msgid "Calling Conventions"
msgstr ""

#: ../../../LangRef.rst:283
msgid ""
"LLVM :ref:`functions <functionstructure>`, :ref:`calls <i_call>` and :ref:"
"`invokes <i_invoke>` can all have an optional calling convention specified "
"for the call. The calling convention of any pair of dynamic caller/callee "
"must match, or the behavior of the program is undefined. The following "
"calling conventions are supported by LLVM, and more may be added in the "
"future:"
msgstr ""

#: ../../../LangRef.rst:294
msgid "\"``ccc``\" - The C calling convention"
msgstr ""

#: ../../../LangRef.rst:291
msgid ""
"This calling convention (the default if no other calling convention is "
"specified) matches the target C calling conventions. This calling convention "
"supports varargs function calls and tolerates some mismatch in the declared "
"prototype and implemented declaration of the function (as does normal C)."
msgstr ""

#: ../../../LangRef.rst:304
msgid "\"``fastcc``\" - The fast calling convention"
msgstr ""

#: ../../../LangRef.rst:297
msgid ""
"This calling convention attempts to make calls as fast as possible (e.g. by "
"passing things in registers). This calling convention allows the target to "
"use whatever tricks it wants to produce fast code for the target, without "
"having to conform to an externally specified ABI (Application Binary "
"Interface). `Tail calls can only be optimized when this, the GHC or the HiPE "
"convention is used. <CodeGenerator.html#id80>`_ This calling convention does "
"not support varargs and requires the prototype of all callees to exactly "
"match the prototype of the function definition."
msgstr ""

#: ../../../LangRef.rst:313
msgid "\"``coldcc``\" - The cold calling convention"
msgstr ""

#: ../../../LangRef.rst:307
msgid ""
"This calling convention attempts to make code in the caller as efficient as "
"possible under the assumption that the call is not commonly executed. As "
"such, these calls often preserve all registers so that the call does not "
"break any live ranges in the caller side. This calling convention does not "
"support varargs and requires the prototype of all callees to exactly match "
"the prototype of the function definition. Furthermore the inliner doesn't "
"consider such function calls for inlining."
msgstr ""

#: ../../../LangRef.rst:332
msgid "\"``cc 10``\" - GHC convention"
msgstr ""

#: ../../../LangRef.rst:316
msgid ""
"This calling convention has been implemented specifically for use by the "
"`Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_. It passes "
"everything in registers, going to extremes to achieve this by disabling "
"callee save registers. This calling convention should not be used lightly "
"but only for specific situations such as an alternative to the *register "
"pinning* performance technique often used when implementing functional "
"programming languages. At the moment only X86 supports this convention and "
"it has the following limitations:"
msgstr ""

#: ../../../LangRef.rst:326
msgid ""
"On *X86-32* only supports up to 4 bit type parameters. No floating point "
"types are supported."
msgstr ""

#: ../../../LangRef.rst:328
msgid ""
"On *X86-64* only supports up to 10 bit type parameters and 6 floating point "
"parameters."
msgstr ""

#: ../../../LangRef.rst:331
msgid ""
"This calling convention supports `tail call optimization <CodeGenerator."
"html#id80>`_ but requires both the caller and callee are using it."
msgstr ""

#: ../../../LangRef.rst:347
msgid "\"``cc 11``\" - The HiPE calling convention"
msgstr ""

#: ../../../LangRef.rst:335
msgid ""
"This calling convention has been implemented specifically for use by the "
"`High-Performance Erlang (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ "
"compiler, *the* native code compiler of the `Ericsson's Open Source Erlang/"
"OTP system <http://www.erlang.org/download.shtml>`_. It uses more registers "
"for argument passing than the ordinary C calling convention and defines no "
"callee-saved registers. The calling convention properly supports `tail call "
"optimization <CodeGenerator.html#id80>`_ but requires that both the caller "
"and the callee use it. It uses a *register pinning* mechanism, similar to "
"GHC's convention, for keeping frequently accessed runtime components pinned "
"to specific hardware registers. At the moment only X86 supports this "
"convention (both 32 and 64 bit)."
msgstr ""

#: ../../../LangRef.rst:352
msgid "\"``webkit_jscc``\" - WebKit's JavaScript calling convention"
msgstr ""

#: ../../../LangRef.rst:350
msgid ""
"This calling convention has been implemented for `WebKit FTL JIT <https://"
"trac.webkit.org/wiki/FTLJIT>`_. It passes arguments on the stack right to "
"left (as cdecl does), and returns a value in the platform's customary return "
"register."
msgstr ""

#: ../../../LangRef.rst:359
msgid "\"``anyregcc``\" - Dynamic calling convention for code patching"
msgstr ""

#: ../../../LangRef.rst:355
msgid ""
"This is a special convention that supports patching an arbitrary code "
"sequence in place of a call site. This convention forces the call arguments "
"into registers but allows them to be dynamically allocated. This can "
"currently only be used with calls to llvm.experimental.patchpoint because "
"only this intrinsic records the location of its arguments in a side table. "
"See :doc:`StackMaps`."
msgstr ""

#: ../../../LangRef.rst:392
msgid "\"``preserve_mostcc``\" - The `PreserveMost` calling convention"
msgstr ""

#: ../../../LangRef.rst:362
msgid ""
"This calling convention attempts to make the code in the caller as "
"unintrusive as possible. This convention behaves identically to the `C` "
"calling convention on how arguments and return values are passed, but it "
"uses a different set of caller/callee-saved registers. This alleviates the "
"burden of saving and recovering a large register set before and after the "
"call in the caller. If the arguments are passed in callee-saved registers, "
"then they will be preserved by the callee across the call. This doesn't "
"apply for values returned in callee-saved registers."
msgstr ""

#: ../../../LangRef.rst:371
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for "
"R11. R11 can be used as a scratch register. Floating-point registers (XMMs/"
"YMMs) are not preserved and need to be saved by the caller."
msgstr ""

#: ../../../LangRef.rst:375
msgid ""
"The idea behind this convention is to support calls to runtime functions "
"that have a hot path and a cold path. The hot path is usually a small piece "
"of code that doesn't use many registers. The cold path might need to call "
"out to another function and therefore only needs to preserve the caller-"
"saved registers, which haven't already been saved by the caller. The "
"`PreserveMost` calling convention is very similar to the `cold` calling "
"convention in terms of caller/callee-saved registers, but they are used for "
"different types of function calls. `coldcc` is for function calls that are "
"rarely executed, whereas `preserve_mostcc` function calls are intended to be "
"on the hot path and definitely executed a lot. Furthermore `preserve_mostcc` "
"doesn't prevent the inliner from inlining the function call."
msgstr ""

#: ../../../LangRef.rst:387
msgid ""
"This calling convention will be used by a future version of the ObjectiveC "
"runtime and should therefore still be considered experimental at this time. "
"Although this convention was created to optimize certain runtime calls to "
"the ObjectiveC runtime, it is not limited to this runtime and might be used "
"by other runtimes in the future too. The current implementation only "
"supports X86-64, but the intention is to support more architectures in the "
"future."
msgstr ""

#: ../../../LangRef.rst:413
msgid "\"``preserve_allcc``\" - The `PreserveAll` calling convention"
msgstr ""

#: ../../../LangRef.rst:395
msgid ""
"This calling convention attempts to make the code in the caller even less "
"intrusive than the `PreserveMost` calling convention. This calling "
"convention also behaves identical to the `C` calling convention on how "
"arguments and return values are passed, but it uses a different set of "
"caller/callee-saved registers. This removes the burden of saving and "
"recovering a large register set before and after the call in the caller. If "
"the arguments are passed in callee-saved registers, then they will be "
"preserved by the callee across the call. This doesn't apply for values "
"returned in callee-saved registers."
msgstr ""

#: ../../../LangRef.rst:405
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for "
"R11. R11 can be used as a scratch register. Furthermore it also preserves "
"all floating-point registers (XMMs/YMMs)."
msgstr ""

#: ../../../LangRef.rst:409
msgid ""
"The idea behind this convention is to support calls to runtime functions "
"that don't need to call out to any other functions."
msgstr ""

#: ../../../LangRef.rst:412
msgid ""
"This calling convention, like the `PreserveMost` calling convention, will be "
"used by a future version of the ObjectiveC runtime and should be considered "
"experimental at this time."
msgstr ""

#: ../../../LangRef.rst:433
msgid ""
"\"``cxx_fast_tlscc``\" - The `CXX_FAST_TLS` calling convention for access "
"functions"
msgstr ""

#: ../../../LangRef.rst:416
msgid ""
"Clang generates an access function to access C++-style TLS. The access "
"function generally has an entry block, an exit block and an initialization "
"block that is run at the first time. The entry and exit blocks can access a "
"few TLS IR variables, each access will be lowered to a platform-specific "
"sequence."
msgstr ""

#: ../../../LangRef.rst:422
msgid ""
"This calling convention aims to minimize overhead in the caller by "
"preserving as many registers as possible (all the registers that are "
"perserved on the fast path, composed of the entry and exit blocks)."
msgstr ""

#: ../../../LangRef.rst:426
msgid ""
"This calling convention behaves identical to the `C` calling convention on "
"how arguments and return values are passed, but it uses a different set of "
"caller/callee-saved registers."
msgstr ""

#: ../../../LangRef.rst:430
msgid ""
"Given that each platform has its own lowering sequence, hence its own set of "
"preserved registers, we can't use the existing `PreserveMost`."
msgstr ""

#: ../../../LangRef.rst:433
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for RDI "
"and RAX."
msgstr ""

#: ../../../LangRef.rst:437
msgid "\"``swiftcc``\" - This calling convention is used for Swift language."
msgstr ""

#: ../../../LangRef.rst:436
msgid ""
"On X86-64 RCX and R8 are available for additional integer returns, and XMM2 "
"and XMM3 are available for additional FP/vector returns."
msgstr ""

#: ../../../LangRef.rst:438
msgid "On iOS platforms, we use AAPCS-VFP calling convention."
msgstr ""

#: ../../../LangRef.rst:442
msgid "\"``cc <n>``\" - Numbered convention"
msgstr ""

#: ../../../LangRef.rst:440
msgid ""
"Any calling convention may be specified by number, allowing target-specific "
"calling conventions to be used. Target specific calling conventions start at "
"64."
msgstr ""

#: ../../../LangRef.rst:444
msgid ""
"More calling conventions can be added/defined on an as-needed basis, to "
"support Pascal conventions or any other well-known target-independent "
"convention."
msgstr ""

#: ../../../LangRef.rst:451
msgid "Visibility Styles"
msgstr ""

#: ../../../LangRef.rst:453
msgid ""
"All Global Variables and Functions have one of the following visibility "
"styles:"
msgstr ""

#: ../../../LangRef.rst:461
msgid "\"``default``\" - Default style"
msgstr ""

#: ../../../LangRef.rst:457
msgid ""
"On targets that use the ELF object file format, default visibility means "
"that the declaration is visible to other modules and, in shared libraries, "
"means that the declared entity may be overridden. On Darwin, default "
"visibility means that the declaration is visible to other modules. Default "
"visibility corresponds to \"external linkage\" in the language."
msgstr ""

#: ../../../LangRef.rst:467
msgid "\"``hidden``\" - Hidden style"
msgstr ""

#: ../../../LangRef.rst:464
msgid ""
"Two declarations of an object with hidden visibility refer to the same "
"object if they are in the same shared object. Usually, hidden visibility "
"indicates that the symbol will not be placed into the dynamic symbol table, "
"so no other module (executable or shared library) can reference it directly."
msgstr ""

#: ../../../LangRef.rst:473
msgid "\"``protected``\" - Protected style"
msgstr ""

#: ../../../LangRef.rst:470
msgid ""
"On ELF, protected visibility indicates that the symbol will be placed in the "
"dynamic symbol table, but that references within the defining module will "
"bind to the local symbol. That is, the symbol cannot be overridden by "
"another module."
msgstr ""

#: ../../../LangRef.rst:475
msgid ""
"A symbol with ``internal`` or ``private`` linkage must have ``default`` "
"visibility."
msgstr ""

#: ../../../LangRef.rst:481
msgid "DLL Storage Classes"
msgstr ""

#: ../../../LangRef.rst:483
msgid ""
"All Global Variables, Functions and Aliases can have one of the following "
"DLL storage class:"
msgstr ""

#: ../../../LangRef.rst:489
msgid "``dllimport``"
msgstr ""

#: ../../../LangRef.rst:487
msgid ""
"\"``dllimport``\" causes the compiler to reference a function or variable "
"via a global pointer to a pointer that is set up by the DLL exporting the "
"symbol. On Microsoft Windows targets, the pointer name is formed by "
"combining ``__imp_`` and the function or variable name."
msgstr ""

#: ../../../LangRef.rst:497
msgid "``dllexport``"
msgstr ""

#: ../../../LangRef.rst:492
msgid ""
"\"``dllexport``\" causes the compiler to provide a global pointer to a "
"pointer in a DLL, so that it can be referenced with the ``dllimport`` "
"attribute. On Microsoft Windows targets, the pointer name is formed by "
"combining ``__imp_`` and the function or variable name. Since this storage "
"class exists for defining a dll interface, the compiler, assembler and "
"linker know it is externally referenced and must refrain from deleting the "
"symbol."
msgstr ""

#: ../../../LangRef.rst:502
msgid "Thread Local Storage Models"
msgstr ""

#: ../../../LangRef.rst:504
msgid ""
"A variable may be defined as ``thread_local``, which means that it will not "
"be shared by threads (each thread will have a separated copy of the "
"variable). Not all targets support thread-local variables. Optionally, a TLS "
"model may be specified:"
msgstr ""

#: ../../../LangRef.rst:509
msgid "``localdynamic``"
msgstr ""

#: ../../../LangRef.rst:510
msgid "For variables that are only used within the current shared library."
msgstr ""

#: ../../../LangRef.rst:511
msgid "``initialexec``"
msgstr ""

#: ../../../LangRef.rst:512
msgid "For variables in modules that will not be loaded dynamically."
msgstr ""

#: ../../../LangRef.rst:514
msgid "``localexec``"
msgstr ""

#: ../../../LangRef.rst:514
msgid "For variables defined in the executable and only used within it."
msgstr ""

#: ../../../LangRef.rst:516
msgid "If no explicit model is given, the \"general dynamic\" model is used."
msgstr ""

#: ../../../LangRef.rst:518
msgid ""
"The models correspond to the ELF TLS models; see `ELF Handling For Thread-"
"Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for more "
"information on under which circumstances the different models may be used. "
"The target may choose a different TLS model if the specified model is not "
"supported, or if a better choice of model can be made."
msgstr ""

#: ../../../LangRef.rst:524
msgid ""
"A model can also be specified in an alias, but then it only governs how the "
"alias is accessed. It will not have any effect in the aliasee."
msgstr ""

#: ../../../LangRef.rst:527
msgid ""
"For platforms without linker support of ELF TLS model, the -femulated-tls "
"flag can be used to generate GCC compatible emulated TLS code."
msgstr ""

#: ../../../LangRef.rst:533
msgid "Structure Types"
msgstr ""

#: ../../../LangRef.rst:535
msgid ""
"LLVM IR allows you to specify both \"identified\" and \"literal\" :ref:"
"`structure types <t_struct>`. Literal types are uniqued structurally, but "
"identified types are never uniqued. An :ref:`opaque structural type "
"<t_opaque>` can also be used to forward declare a type that is not yet "
"available."
msgstr ""

#: ../../../LangRef.rst:540
msgid "An example of an identified structure specification is:"
msgstr ""

#: ../../../LangRef.rst:546
msgid ""
"Prior to the LLVM 3.0 release, identified types were structurally uniqued. "
"Only literal types are uniqued in recent versions of LLVM."
msgstr ""

#: ../../../LangRef.rst:552
msgid "Non-Integral Pointer Type"
msgstr ""

#: ../../../LangRef.rst:554
msgid ""
"Note: non-integral pointer types are a work in progress, and they should be "
"considered experimental at this time."
msgstr ""

#: ../../../LangRef.rst:557
msgid ""
"LLVM IR optionally allows the frontend to denote pointers in certain address "
"spaces as \"non-integral\" via the :ref:`datalayout "
"string<langref_datalayout>`. Non-integral pointer types represent pointers "
"that have an *unspecified* bitwise representation; that is, the integral "
"representation may be target dependent or unstable (not backed by a fixed "
"integer)."
msgstr ""

#: ../../../LangRef.rst:563
msgid ""
"``inttoptr`` instructions converting integers to non-integral pointer types "
"are ill-typed, and so are ``ptrtoint`` instructions converting values of non-"
"integral pointer types to integers.  Vector versions of said instructions "
"are ill-typed as well."
msgstr ""

#: ../../../LangRef.rst:571
msgid "Global Variables"
msgstr ""

#: ../../../LangRef.rst:573
msgid ""
"Global variables define regions of memory allocated at compilation time "
"instead of run-time."
msgstr ""

#: ../../../LangRef.rst:576
msgid "Global variable definitions must be initialized."
msgstr ""

#: ../../../LangRef.rst:578
msgid ""
"Global variables in other translation units can also be declared, in which "
"case they don't have an initializer."
msgstr ""

#: ../../../LangRef.rst:581
msgid ""
"Either global variable definitions or declarations may have an explicit "
"section to be placed in and may have an optional explicit alignment "
"specified."
msgstr ""

#: ../../../LangRef.rst:584
msgid ""
"A variable may be defined as a global ``constant``, which indicates that the "
"contents of the variable will **never** be modified (enabling better "
"optimization, allowing the global data to be placed in the read-only section "
"of an executable, etc). Note that variables that need runtime initialization "
"cannot be marked ``constant`` as there is a store to the variable."
msgstr ""

#: ../../../LangRef.rst:591
msgid ""
"LLVM explicitly allows *declarations* of global variables to be marked "
"constant, even if the final definition of the global is not. This capability "
"can be used to enable slightly better optimization of the program, but "
"requires the language definition to guarantee that optimizations based on "
"the 'constantness' are valid for the translation units that do not include "
"the definition."
msgstr ""

#: ../../../LangRef.rst:598
msgid ""
"As SSA values, global variables define pointer values that are in scope (i."
"e. they dominate) all basic blocks in the program. Global variables always "
"define a pointer to their \"content\" type because they describe a region of "
"memory, and all memory objects in LLVM are accessed through pointers."
msgstr ""

#: ../../../LangRef.rst:604
msgid ""
"Global variables can be marked with ``unnamed_addr`` which indicates that "
"the address is not significant, only the content. Constants marked like this "
"can be merged with other constants if they have the same initializer. Note "
"that a constant with significant address *can* be merged with a "
"``unnamed_addr`` constant, the result being a constant whose address is "
"significant."
msgstr ""

#: ../../../LangRef.rst:611 ../../../LangRef.rst:739 ../../../LangRef.rst:786
msgid ""
"If the ``local_unnamed_addr`` attribute is given, the address is known to "
"not be significant within the module."
msgstr ""

#: ../../../LangRef.rst:614
msgid ""
"A global variable may be declared to reside in a target-specific numbered "
"address space. For targets that support them, address spaces may affect how "
"optimizations are performed and/or what target instructions are used to "
"access the variable. The default address space is zero. The address space "
"qualifier must precede any other attributes."
msgstr ""

#: ../../../LangRef.rst:620
msgid ""
"LLVM allows an explicit section to be specified for globals. If the target "
"supports it, it will emit globals to the section specified. Additionally, "
"the global can placed in a comdat if the target has the necessary support."
msgstr ""

#: ../../../LangRef.rst:625
msgid ""
"By default, global initializers are optimized by assuming that global "
"variables defined within the module are not modified from their initial "
"values before the start of the global initializer. This is true even for "
"variables potentially accessible from outside the module, including those "
"with external linkage or appearing in ``@llvm.used`` or dllexported "
"variables. This assumption may be suppressed by marking the variable with "
"``externally_initialized``."
msgstr ""

#: ../../../LangRef.rst:633
msgid ""
"An explicit alignment may be specified for a global, which must be a power "
"of 2. If not present, or if the alignment is set to zero, the alignment of "
"the global is set by the target to whatever it feels convenient. If an "
"explicit alignment is specified, the global is forced to have exactly that "
"alignment. Targets and optimizers are not allowed to over-align the global "
"if the global has an assigned section. In this case, the extra alignment "
"could be observable: for example, code could assume that the globals are "
"densely packed in their section and try to iterate over them as an array, "
"alignment padding would break this iteration. The maximum alignment is ``1 "
"<< 29``."
msgstr ""

#: ../../../LangRef.rst:644
msgid ""
"Globals can also have a :ref:`DLL storage class <dllstorageclass>` and an "
"optional list of attached :ref:`metadata <metadata>`,"
msgstr ""

#: ../../../LangRef.rst:647
msgid ""
"Variables and aliases can have a :ref:`Thread Local Storage Model "
"<tls_model>`."
msgstr ""

#: ../../../LangRef.rst:650 ../../../LangRef.rst:742 ../../../LangRef.rst:754
#: ../../../LangRef.rst:774 ../../../LangRef.rst:816 ../../../LangRef.rst:836
#: ../../../LangRef.rst:929 ../../../LangRef.rst:1624
msgid "Syntax::"
msgstr ""

#: ../../../LangRef.rst:659
msgid ""
"For example, the following defines a global in a numbered address space with "
"an initializer, section, and alignment:"
msgstr ""

#: ../../../LangRef.rst:666
msgid "The following example just declares a global variable"
msgstr ""

#: ../../../LangRef.rst:672
msgid ""
"The following example defines a thread-local global with the ``initialexec`` "
"TLS model:"
msgstr ""

#: ../../../LangRef.rst:682
msgid "Functions"
msgstr ""

#: ../../../LangRef.rst:684
msgid ""
"LLVM function definitions consist of the \"``define``\" keyword, an "
"optional :ref:`linkage type <linkage>`, an optional :ref:`visibility style "
"<visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`, an "
"optional :ref:`calling convention <callingconv>`, an optional "
"``unnamed_addr`` attribute, a return type, an optional :ref:`parameter "
"attribute <paramattrs>` for the return type, a function name, a (possibly "
"empty) argument list (each with optional :ref:`parameter attributes "
"<paramattrs>`), optional :ref:`function attributes <fnattrs>`, an optional "
"section, an optional alignment, an optional :ref:`comdat <langref_comdats>`, "
"an optional :ref:`garbage collector name <gc>`, an optional :ref:`prefix "
"<prefixdata>`, an optional :ref:`prologue <prologuedata>`, an optional :ref:"
"`personality <personalityfn>`, an optional list of attached :ref:`metadata "
"<metadata>`, an opening curly brace, a list of basic blocks, and a closing "
"curly brace."
msgstr ""

#: ../../../LangRef.rst:700
msgid ""
"LLVM function declarations consist of the \"``declare``\" keyword, an "
"optional :ref:`linkage type <linkage>`, an optional :ref:`visibility style "
"<visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`, an "
"optional :ref:`calling convention <callingconv>`, an optional "
"``unnamed_addr`` or ``local_unnamed_addr`` attribute, a return type, an "
"optional :ref:`parameter attribute <paramattrs>` for the return type, a "
"function name, a possibly empty list of arguments, an optional alignment, an "
"optional :ref:`garbage collector name <gc>`, an optional :ref:`prefix "
"<prefixdata>`, and an optional :ref:`prologue <prologuedata>`."
msgstr ""

#: ../../../LangRef.rst:710
msgid ""
"A function definition contains a list of basic blocks, forming the CFG "
"(Control Flow Graph) for the function. Each basic block may optionally start "
"with a label (giving the basic block a symbol table entry), contains a list "
"of instructions, and ends with a :ref:`terminator <terminators>` instruction "
"(such as a branch or function return). If an explicit label is not provided, "
"a block is assigned an implicit numbered label, using the next value from "
"the same counter as used for unnamed temporaries (:ref:`see "
"above<identifiers>`). For example, if a function entry block does not have "
"an explicit label, it will be assigned label \"%0\", then the first unnamed "
"temporary in that block will be \"%1\", etc."
msgstr ""

#: ../../../LangRef.rst:720
msgid ""
"The first basic block in a function is special in two ways: it is "
"immediately executed on entrance to the function, and it is not allowed to "
"have predecessor basic blocks (i.e. there can not be any branches to the "
"entry block of a function). Because the block can have no predecessors, it "
"also cannot have any :ref:`PHI nodes <i_phi>`."
msgstr ""

#: ../../../LangRef.rst:726
msgid ""
"LLVM allows an explicit section to be specified for functions. If the target "
"supports it, it will emit functions to the section specified. Additionally, "
"the function can be placed in a COMDAT."
msgstr ""

#: ../../../LangRef.rst:730
msgid ""
"An explicit alignment may be specified for a function. If not present, or if "
"the alignment is set to zero, the alignment of the function is set by the "
"target to whatever it feels convenient. If an explicit alignment is "
"specified, the function is forced to have at least that much alignment. All "
"alignments must be a power of 2."
msgstr ""

#: ../../../LangRef.rst:736
msgid ""
"If the ``unnamed_addr`` attribute is given, the address is known to not be "
"significant and two identical functions can be merged."
msgstr ""

#: ../../../LangRef.rst:751
msgid ""
"The argument list is a comma separated sequence of arguments where each "
"argument is of the following form:"
msgstr ""

#: ../../../LangRef.rst:762
msgid "Aliases"
msgstr ""

#: ../../../LangRef.rst:764
msgid ""
"Aliases, unlike function or variables, don't create any new data. They are "
"just a new symbol and metadata for an existing position."
msgstr ""

#: ../../../LangRef.rst:767
msgid ""
"Aliases have a name and an aliasee that is either a global value or a "
"constant expression."
msgstr ""

#: ../../../LangRef.rst:770
msgid ""
"Aliases may have an optional :ref:`linkage type <linkage>`, an optional :ref:"
"`visibility style <visibility>`, an optional :ref:`DLL storage class "
"<dllstorageclass>` and an optional :ref:`tls model <tls_model>`."
msgstr ""

#: ../../../LangRef.rst:778
msgid ""
"The linkage must be one of ``private``, ``internal``, ``linkonce``, "
"``weak``, ``linkonce_odr``, ``weak_odr``, ``external``. Note that some "
"system linkers might not correctly handle dropping a weak symbol that is "
"aliased."
msgstr ""

#: ../../../LangRef.rst:782
msgid ""
"Aliases that are not ``unnamed_addr`` are guaranteed to have the same "
"address as the aliasee expression. ``unnamed_addr`` ones are only guaranteed "
"to point to the same content."
msgstr ""

#: ../../../LangRef.rst:789
msgid ""
"Since aliases are only a second name, some restrictions apply, of which some "
"can only be checked when producing an object file:"
msgstr ""

#: ../../../LangRef.rst:792
msgid ""
"The expression defining the aliasee must be computable at assembly time. "
"Since it is just a name, no relocations can be used."
msgstr ""

#: ../../../LangRef.rst:795
msgid ""
"No alias in the expression can be weak as the possibility of the "
"intermediate alias being overridden cannot be represented in an object file."
msgstr ""

#: ../../../LangRef.rst:799
msgid ""
"No global value in the expression can be a declaration, since that would "
"require a relocation, which is not possible."
msgstr ""

#: ../../../LangRef.rst:805
msgid "IFuncs"
msgstr ""

#: ../../../LangRef.rst:807
msgid ""
"IFuncs, like as aliases, don't create any new data or func. They are just a "
"new symbol that dynamic linker resolves at runtime by calling a resolver "
"function."
msgstr ""

#: ../../../LangRef.rst:810
msgid ""
"IFuncs have a name and a resolver that is a function called by dynamic "
"linker that returns address of another function associated with the name."
msgstr ""

#: ../../../LangRef.rst:813
msgid ""
"IFunc may have an optional :ref:`linkage type <linkage>` and an optional :"
"ref:`visibility style <visibility>`."
msgstr ""

#: ../../../LangRef.rst:824
msgid "Comdats"
msgstr ""

#: ../../../LangRef.rst:826
msgid ""
"Comdat IR provides access to COFF and ELF object file COMDAT functionality."
msgstr ""

#: ../../../LangRef.rst:828
msgid ""
"Comdats have a name which represents the COMDAT key. All global objects that "
"specify this key will only end up in the final object file if the linker "
"chooses that key over some other key. Aliases are placed in the same COMDAT "
"that their aliasee computes to, if any."
msgstr ""

#: ../../../LangRef.rst:833
msgid ""
"Comdats have a selection kind to provide input on how the linker should "
"choose between keys in two different object files."
msgstr ""

#: ../../../LangRef.rst:840
msgid "The selection kind must be one of the following:"
msgstr ""

#: ../../../LangRef.rst:842
msgid "``any``"
msgstr ""

#: ../../../LangRef.rst:843
msgid "The linker may choose any COMDAT key, the choice is arbitrary."
msgstr ""

#: ../../../LangRef.rst:845
msgid "``exactmatch``"
msgstr ""

#: ../../../LangRef.rst:845
msgid ""
"The linker may choose any COMDAT key but the sections must contain the same "
"data."
msgstr ""

#: ../../../LangRef.rst:847
msgid "``largest``"
msgstr ""

#: ../../../LangRef.rst:848
msgid "The linker will choose the section containing the largest COMDAT key."
msgstr ""

#: ../../../LangRef.rst:849
msgid "``noduplicates``"
msgstr ""

#: ../../../LangRef.rst:850
msgid "The linker requires that only section with this COMDAT key exist."
msgstr ""

#: ../../../LangRef.rst:853
msgid "``samesize``"
msgstr ""

#: ../../../LangRef.rst:852
msgid ""
"The linker may choose any COMDAT key but the sections must contain the same "
"amount of data."
msgstr ""

#: ../../../LangRef.rst:855
msgid ""
"Note that the Mach-O platform doesn't support COMDATs and ELF only supports "
"``any`` as a selection kind."
msgstr ""

#: ../../../LangRef.rst:858
msgid ""
"Here is an example of a COMDAT group where a function will only be selected "
"if the COMDAT key's section is the largest:"
msgstr ""

#: ../../../LangRef.rst:870
msgid ""
"As a syntactic sugar the ``$name`` can be omitted if the name is the same as "
"the global name:"
msgstr ""

#: ../../../LangRef.rst:879
msgid ""
"In a COFF object file, this will create a COMDAT section with selection kind "
"``IMAGE_COMDAT_SELECT_LARGEST`` containing the contents of the ``@foo`` "
"symbol and another COMDAT section with selection kind "
"``IMAGE_COMDAT_SELECT_ASSOCIATIVE`` which is associated with the first "
"COMDAT section and contains the contents of the ``@bar`` symbol."
msgstr ""

#: ../../../LangRef.rst:885
msgid ""
"There are some restrictions on the properties of the global object. It, or "
"an alias to it, must have the same name as the COMDAT group when targeting "
"COFF. The contents and size of this object may be used during link-time to "
"determine which COMDAT groups get selected depending on the selection kind. "
"Because the name of the object must match the name of the COMDAT group, the "
"linkage of the global object must not be local; local symbols can get "
"renamed if a collision occurs in the symbol table."
msgstr ""

#: ../../../LangRef.rst:894
msgid ""
"The combined use of COMDATS and section attributes may yield surprising "
"results. For example:"
msgstr ""

#: ../../../LangRef.rst:904
msgid ""
"From the object file perspective, this requires the creation of two sections "
"with the same name. This is necessary because both globals belong to "
"different COMDAT groups and COMDATs, at the object file level, are "
"represented by sections."
msgstr ""

#: ../../../LangRef.rst:909
msgid ""
"Note that certain IR constructs like global variables and functions may "
"create COMDATs in the object file in addition to any which are specified "
"using COMDAT IR. This arises when the code generator is configured to emit "
"globals in individual sections (e.g. when `-data-sections` or `-function-"
"sections` is supplied to `llc`)."
msgstr ""

#: ../../../LangRef.rst:918
msgid "Named Metadata"
msgstr ""

#: ../../../LangRef.rst:920
msgid ""
"Named metadata is a collection of metadata. :ref:`Metadata nodes <metadata>` "
"(but not metadata strings) are the only valid operands for a named metadata."
msgstr ""

#: ../../../LangRef.rst:924
msgid ""
"Named metadata are represented as a string of characters with the metadata "
"prefix. The rules for metadata names are the same as for identifiers, but "
"quoted names are not allowed. ``\"\\xx\"`` type escapes are still valid, "
"which allows any character to be part of a name."
msgstr ""

#: ../../../LangRef.rst:941
msgid "Parameter Attributes"
msgstr ""

#: ../../../LangRef.rst:943
msgid ""
"The return type and each parameter of a function type may have a set of "
"*parameter attributes* associated with them. Parameter attributes are used "
"to communicate additional information about the result or parameters of a "
"function. Parameter attributes are considered to be part of the function, "
"not of the function type, so functions with different parameter attributes "
"can have the same function type."
msgstr ""

#: ../../../LangRef.rst:950
msgid ""
"Parameter attributes are simple keywords that follow the type specified. If "
"multiple parameter attributes are needed, they are space separated. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:960
msgid ""
"Note that any attributes for the function result (``nounwind``, "
"``readonly``) come immediately after the argument list."
msgstr ""

#: ../../../LangRef.rst:963
msgid "Currently, only the following parameter attributes are defined:"
msgstr ""

#: ../../../LangRef.rst:967
msgid "``zeroext``"
msgstr ""

#: ../../../LangRef.rst:966
msgid ""
"This indicates to the code generator that the parameter or return value "
"should be zero-extended to the extent required by the target's ABI by the "
"caller (for a parameter) or the callee (for a return value)."
msgstr ""

#: ../../../LangRef.rst:972
msgid "``signext``"
msgstr ""

#: ../../../LangRef.rst:970
msgid ""
"This indicates to the code generator that the parameter or return value "
"should be sign-extended to the extent required by the target's ABI (which is "
"usually 32-bits) by the caller (for a parameter) or the callee (for a return "
"value)."
msgstr ""

#: ../../../LangRef.rst:979
msgid "``inreg``"
msgstr ""

#: ../../../LangRef.rst:975
msgid ""
"This indicates that this parameter or return value should be treated in a "
"special target-dependent fashion while emitting code for a function call or "
"return (usually, by putting it in a register as opposed to memory, though "
"some targets use it to distinguish between two different kinds of "
"registers). Use of this attribute is target-specific."
msgstr ""

#: ../../../LangRef.rst:997
msgid "``byval``"
msgstr ""

#: ../../../LangRef.rst:982
msgid ""
"This indicates that the pointer parameter should really be passed by value "
"to the function. The attribute implies that a hidden copy of the pointee is "
"made between the caller and the callee, so the callee is unable to modify "
"the value in the caller. This attribute is only valid on LLVM pointer "
"arguments. It is generally used to pass structs and arrays by value, but is "
"also valid on pointers to scalars. The copy is considered to belong to the "
"caller not the callee (for example, ``readonly`` functions should not write "
"to ``byval`` parameters). This is not a valid attribute for return values."
msgstr ""

#: ../../../LangRef.rst:993
msgid ""
"The byval attribute also supports specifying an alignment with the align "
"attribute. It indicates the alignment of the stack slot to form and the "
"known alignment of the pointer specified to the call site. If the alignment "
"is not specified, then the code generator makes a target-specific assumption."
msgstr ""

#: ../../../LangRef.rst:1001
msgid "``inalloca``"
msgstr ""

#: ../../../LangRef.rst:1003
msgid ""
"The ``inalloca`` argument attribute allows the caller to take the address of "
"outgoing stack arguments. An ``inalloca`` argument must be a pointer to "
"stack memory produced by an ``alloca`` instruction. The alloca, or argument "
"allocation, must also be tagged with the inalloca keyword. Only the last "
"argument may have the ``inalloca`` attribute, and that argument is "
"guaranteed to be passed in memory."
msgstr ""

#: ../../../LangRef.rst:1010
msgid ""
"An argument allocation may be used by a call at most once because the call "
"may deallocate it. The ``inalloca`` attribute cannot be used in conjunction "
"with other attributes that affect argument storage, like ``inreg``, "
"``nest``, ``sret``, or ``byval``. The ``inalloca`` attribute also disables "
"LLVM's implicit lowering of large aggregate return values, which means that "
"frontend authors must lower them with ``sret`` pointers."
msgstr ""

#: ../../../LangRef.rst:1018
msgid ""
"When the call site is reached, the argument allocation must have been the "
"most recent stack allocation that is still live, or the results are "
"undefined. It is possible to allocate additional stack space after an "
"argument allocation and before its call site, but it must be cleared off "
"with :ref:`llvm.stackrestore <int_stackrestore>`."
msgstr ""

#: ../../../LangRef.rst:1025
msgid "See :doc:`InAlloca` for more information on how to use this attribute."
msgstr ""

#: ../../../LangRef.rst:1034
msgid "``sret``"
msgstr ""

#: ../../../LangRef.rst:1029
msgid ""
"This indicates that the pointer parameter specifies the address of a "
"structure that is the return value of the function in the source program. "
"This pointer must be guaranteed by the caller to be valid: loads and stores "
"to the structure may be assumed by the callee not to trap and to be properly "
"aligned. This is not a valid attribute for return values."
msgstr ""

#: ../../../LangRef.rst:1041
msgid "``align <n>``"
msgstr ""

#: ../../../LangRef.rst:1037
msgid ""
"This indicates that the pointer value may be assumed by the optimizer to "
"have the specified alignment."
msgstr ""

#: ../../../LangRef.rst:1040
msgid ""
"Note that this attribute has additional semantics when combined with the "
"``byval`` attribute."
msgstr ""

#: ../../../LangRef.rst:1064
msgid "``noalias``"
msgstr ""

#: ../../../LangRef.rst:1046
msgid ""
"This indicates that objects accessed via pointer values :ref:`based "
"<pointeraliasing>` on the argument or return value are not also accessed, "
"during the execution of the function, via pointer values not *based* on the "
"argument or return value. The attribute on a return value also has "
"additional semantics described below. The caller shares the responsibility "
"with the callee for ensuring that these requirements are met. For further "
"details, please see the discussion of the NoAlias response in :ref:`alias "
"analysis <Must, May, or No>`."
msgstr ""

#: ../../../LangRef.rst:1055
msgid ""
"Note that this definition of ``noalias`` is intentionally similar to the "
"definition of ``restrict`` in C99 for function arguments."
msgstr ""

#: ../../../LangRef.rst:1058
msgid ""
"For function return values, C99's ``restrict`` is not meaningful, while "
"LLVM's ``noalias`` is. Furthermore, the semantics of the ``noalias`` "
"attribute on return values are stronger than the semantics of the attribute "
"when used on function arguments. On function return values, the ``noalias`` "
"attribute indicates that the function acts like a system memory allocation "
"function, returning a pointer to allocated storage disjoint from the storage "
"for any other object accessible to the caller."
msgstr ""

#: ../../../LangRef.rst:1070
msgid "``nocapture``"
msgstr ""

#: ../../../LangRef.rst:1067
msgid ""
"This indicates that the callee does not make any copies of the pointer that "
"outlive the callee itself. This is not a valid attribute for return values.  "
"Addresses used in volatile operations are considered to be captured."
msgstr ""

#: ../../../LangRef.rst:1077
msgid "``nest``"
msgstr ""

#: ../../../LangRef.rst:1075
msgid ""
"This indicates that the pointer parameter can be excised using the :ref:"
"`trampoline intrinsics <int_trampoline>`. This is not a valid attribute for "
"return values and can only be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1087
msgid "``returned``"
msgstr ""

#: ../../../LangRef.rst:1080
msgid ""
"This indicates that the function always returns the argument as its return "
"value. This is a hint to the optimizer and code generator used when "
"generating the caller, allowing value propagation, tail call optimization, "
"and omission of register saves and restores in some cases; it is not checked "
"or enforced when generating the callee. The parameter and the function "
"return type must be valid operands for the :ref:`bitcast instruction "
"<i_bitcast>`. This is not a valid attribute for return values and can only "
"be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1094
msgid "``nonnull``"
msgstr ""

#: ../../../LangRef.rst:1090
msgid ""
"This indicates that the parameter or return pointer is not null. This "
"attribute may only be applied to pointer typed parameters. This is not "
"checked or enforced by LLVM, the caller must ensure that the pointer passed "
"in is non-null, or the callee must ensure that the returned pointer is non-"
"null."
msgstr ""

#: ../../../LangRef.rst:1105
msgid "``dereferenceable(<n>)``"
msgstr ""

#: ../../../LangRef.rst:1097
msgid ""
"This indicates that the parameter or return pointer is dereferenceable. This "
"attribute may only be applied to pointer typed parameters. A pointer that is "
"dereferenceable can be loaded from speculatively without a risk of trapping. "
"The number of bytes known to be dereferenceable must be provided in "
"parentheses. It is legal for the number of bytes to be less than the size of "
"the pointee type. The ``nonnull`` attribute does not imply "
"dereferenceability (consider a pointer to one element past the end of an "
"array), however ``dereferenceable(<n>)`` does imply ``nonnull`` in "
"``addrspace(0)`` (which is the default address space)."
msgstr ""

#: ../../../LangRef.rst:1118
msgid "``dereferenceable_or_null(<n>)``"
msgstr ""

#: ../../../LangRef.rst:1108
msgid ""
"This indicates that the parameter or return value isn't both non-null and "
"non-dereferenceable (up to ``<n>`` bytes) at the same time. All non-null "
"pointers tagged with ``dereferenceable_or_null(<n>)`` are "
"``dereferenceable(<n>)``. For address space 0 "
"``dereferenceable_or_null(<n>)`` implies that a pointer is exactly one of "
"``dereferenceable(<n>)`` or ``null``, and in other address spaces "
"``dereferenceable_or_null(<n>)`` implies that a pointer is at least one of "
"``dereferenceable(<n>)`` or ``null`` (i.e. it may be both ``null`` and "
"``dereferenceable(<n>)``). This attribute may only be applied to pointer "
"typed parameters."
msgstr ""

#: ../../../LangRef.rst:1123
msgid "``swiftself``"
msgstr ""

#: ../../../LangRef.rst:1121
msgid ""
"This indicates that the parameter is the self/context parameter. This is not "
"a valid attribute for return values and can only be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1143
msgid "``swifterror``"
msgstr ""

#: ../../../LangRef.rst:1126
msgid ""
"This attribute is motivated to model and optimize Swift error handling. It "
"can be applied to a parameter with pointer to pointer type or a pointer-"
"sized alloca. At the call site, the actual argument that corresponds to a "
"``swifterror`` parameter has to come from a ``swifterror`` alloca or the "
"``swifterror`` parameter of the caller. A ``swifterror`` value (either the "
"parameter or the alloca) can only be loaded and stored from, or used as a "
"``swifterror`` argument. This is not a valid attribute for return values and "
"can only be applied to one parameter."
msgstr ""

#: ../../../LangRef.rst:1135
msgid ""
"These constraints allow the calling convention to optimize access to "
"``swifterror`` variables by associating them with a specific register at "
"call boundaries rather than placing them in memory. Since this does change "
"the calling convention, a function which uses the ``swifterror`` attribute "
"on a parameter is not ABI-compatible with one which does not."
msgstr ""

#: ../../../LangRef.rst:1141
msgid ""
"These constraints also allow LLVM to assume that a ``swifterror`` argument "
"does not alias any other memory visible within a function and that a "
"``swifterror`` alloca passed as an argument does not escape."
msgstr ""

#: ../../../LangRef.rst:1148
msgid "Garbage Collector Strategy Names"
msgstr ""

#: ../../../LangRef.rst:1150
msgid ""
"Each function may specify a garbage collector strategy name, which is simply "
"a string:"
msgstr ""

#: ../../../LangRef.rst:1157
msgid ""
"The supported values of *name* includes those :ref:`built in to LLVM "
"<builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC "
"strategy will cause the compiler to alter its output in order to support the "
"named garbage collection algorithm. Note that LLVM itself does not contain a "
"garbage collector, this functionality is restricted to generating machine "
"code which can interoperate with a collector provided externally."
msgstr ""

#: ../../../LangRef.rst:1167
msgid "Prefix Data"
msgstr ""

#: ../../../LangRef.rst:1169
msgid ""
"Prefix data is data associated with a function which the code generator will "
"emit immediately before the function's entrypoint. The purpose of this "
"feature is to allow frontends to associate language-specific runtime "
"metadata with specific functions and make it available through the function "
"pointer while still allowing the function pointer to be called."
msgstr ""

#: ../../../LangRef.rst:1176
msgid ""
"To access the data for a given function, a program may bitcast the function "
"pointer to a pointer to the constant's type and dereference index -1. This "
"implies that the IR symbol points just past the end of the prefix data. For "
"instance, take the example of a function annotated with a single ``i32``,"
msgstr ""

#: ../../../LangRef.rst:1186
msgid "The prefix data can be referenced as,"
msgstr ""

#: ../../../LangRef.rst:1194
msgid ""
"Prefix data is laid out as if it were an initializer for a global variable "
"of the prefix data's type. The function will be placed such that the "
"beginning of the prefix data is aligned. This means that if the size of the "
"prefix data is not a multiple of the alignment size, the function's "
"entrypoint will not be aligned. If alignment of the function's entrypoint is "
"desired, padding must be added to the prefix data."
msgstr ""

#: ../../../LangRef.rst:1202
msgid ""
"A function may have prefix data but no body. This has similar semantics to "
"the ``available_externally`` linkage in that the data may be used by the "
"optimizers but will not be emitted in the object file."
msgstr ""

#: ../../../LangRef.rst:1209
msgid "Prologue Data"
msgstr ""

#: ../../../LangRef.rst:1211
msgid ""
"The ``prologue`` attribute allows arbitrary code (encoded as bytes) to be "
"inserted prior to the function body. This can be used for enabling function "
"hot-patching and instrumentation."
msgstr ""

#: ../../../LangRef.rst:1215
msgid ""
"To maintain the semantics of ordinary function calls, the prologue data must "
"have a particular format. Specifically, it must begin with a sequence of "
"bytes which decode to a sequence of machine instructions, valid for the "
"module's target, which transfer control to the point immediately succeeding "
"the prologue data, without performing any other visible action. This allows "
"the inliner and other passes to reason about the semantics of the function "
"definition without needing to reason about the prologue data. Obviously this "
"makes the format of the prologue data highly target dependent."
msgstr ""

#: ../../../LangRef.rst:1224
msgid ""
"A trivial example of valid prologue data for the x86 architecture is ``i8 "
"144``, which encodes the ``nop`` instruction:"
msgstr ""

#: ../../../LangRef.rst:1231
msgid ""
"Generally prologue data can be formed by encoding a relative branch "
"instruction which skips the metadata, as in this example of valid prologue "
"data for the x86_64 architecture, where the first two bytes encode ``jmp ."
"+10``:"
msgstr ""

#: ../../../LangRef.rst:1241
msgid ""
"A function may have prologue data but no body. This has similar semantics to "
"the ``available_externally`` linkage in that the data may be used by the "
"optimizers but will not be emitted in the object file."
msgstr ""

#: ../../../LangRef.rst:1248
msgid "Personality Function"
msgstr ""

#: ../../../LangRef.rst:1250
msgid ""
"The ``personality`` attribute permits functions to specify what function to "
"use for exception handling."
msgstr ""

#: ../../../LangRef.rst:1256
msgid "Attribute Groups"
msgstr ""

#: ../../../LangRef.rst:1258
msgid ""
"Attribute groups are groups of attributes that are referenced by objects "
"within the IR. They are important for keeping ``.ll`` files readable, "
"because a lot of functions will use the same set of attributes. In the "
"degenerative case of a ``.ll`` file that corresponds to a single ``.c`` "
"file, the single attribute group will capture the important command line "
"flags used to build that file."
msgstr ""

#: ../../../LangRef.rst:1264
msgid ""
"An attribute group is a module-level object. To use an attribute group, an "
"object references the attribute group's ID (e.g. ``#37``). An object may "
"refer to more than one attribute group. In that situation, the attributes "
"from the different groups are merged."
msgstr ""

#: ../../../LangRef.rst:1269
msgid ""
"Here is an example of attribute groups for a function that should always be "
"inlined, has a stack alignment of 4, and which shouldn't use SSE "
"instructions:"
msgstr ""

#: ../../../LangRef.rst:1286
msgid "Function Attributes"
msgstr ""

#: ../../../LangRef.rst:1288
msgid ""
"Function attributes are set to communicate additional information about a "
"function. Function attributes are considered to be part of the function, not "
"of the function type, so functions with different function attributes can "
"have the same function type."
msgstr ""

#: ../../../LangRef.rst:1293
msgid ""
"Function attributes are simple keywords that follow the type specified. If "
"multiple attributes are needed, they are space separated. For example:"
msgstr ""

#: ../../../LangRef.rst:1307
msgid "``alignstack(<n>)``"
msgstr ""

#: ../../../LangRef.rst:1305
msgid ""
"This attribute indicates that, when emitting the prologue and epilogue, the "
"backend should forcibly align the stack pointer. Specify the desired "
"alignment, which must be a power of two, in parentheses."
msgstr ""

#: ../../../LangRef.rst:1316
msgid "``allocsize(<EltSizeParam>[, <NumEltsParam>])``"
msgstr ""

#: ../../../LangRef.rst:1310
msgid ""
"This attribute indicates that the annotated function will always return at "
"least a given number of bytes (or null). Its arguments are zero-indexed "
"parameter numbers; if one argument is provided, then it's assumed that at "
"least ``CallSite.Args[EltSizeParam]`` bytes will be available at the "
"returned pointer. If two are provided, then it's assumed that ``CallSite."
"Args[EltSizeParam] * CallSite.Args[NumEltsParam]`` bytes are available. The "
"referenced parameters must be integer types. No assumptions are made about "
"the contents of the returned block of memory."
msgstr ""

#: ../../../LangRef.rst:1320
msgid "``alwaysinline``"
msgstr ""

#: ../../../LangRef.rst:1319
msgid ""
"This attribute indicates that the inliner should attempt to inline this "
"function into callers whenever possible, ignoring any active inlining size "
"threshold for this caller."
msgstr ""

#: ../../../LangRef.rst:1326
msgid "``builtin``"
msgstr ""

#: ../../../LangRef.rst:1323
msgid ""
"This indicates that the callee function at a call site should be recognized "
"as a built-in function, even though the function's declaration uses the "
"``nobuiltin`` attribute. This is only valid at call sites for direct calls "
"to functions that are declared with the ``nobuiltin`` attribute."
msgstr ""

#: ../../../LangRef.rst:1331
msgid "``cold``"
msgstr ""

#: ../../../LangRef.rst:1329
msgid ""
"This attribute indicates that this function is rarely called. When computing "
"edge weights, basic blocks post-dominated by a cold function call are also "
"considered to be cold; and, thus, given low weight."
msgstr ""

#: ../../../LangRef.rst:1352
msgid "``convergent``"
msgstr ""

#: ../../../LangRef.rst:1334
msgid ""
"In some parallel execution models, there exist operations that cannot be "
"made control-dependent on any additional values.  We call such operations "
"``convergent``, and mark them with this attribute."
msgstr ""

#: ../../../LangRef.rst:1338
msgid ""
"The ``convergent`` attribute may appear on functions or call/invoke "
"instructions.  When it appears on a function, it indicates that calls to "
"this function should not be made control-dependent on additional values. For "
"example, the intrinsic ``llvm.nvvm.barrier0`` is ``convergent``, so calls to "
"this intrinsic cannot be made control-dependent on additional values."
msgstr ""

#: ../../../LangRef.rst:1345
msgid ""
"When it appears on a call/invoke, the ``convergent`` attribute indicates "
"that we should treat the call as though we're calling a convergent "
"function.  This is particularly useful on indirect calls; without this we "
"may treat such calls as though the target is non-convergent."
msgstr ""

#: ../../../LangRef.rst:1350
msgid ""
"The optimizer may remove the ``convergent`` attribute on functions when it "
"can prove that the function does not execute any convergent operations. "
"Similarly, the optimizer may remove ``convergent`` on calls/invokes when it "
"can prove that the call/invoke cannot call a convergent function."
msgstr ""

#: ../../../LangRef.rst:1356
msgid "``inaccessiblememonly``"
msgstr ""

#: ../../../LangRef.rst:1355
msgid ""
"This attribute indicates that the function may only access memory that is "
"not accessible by the module being compiled. This is a weaker form of "
"``readnone``."
msgstr ""

#: ../../../LangRef.rst:1360
msgid "``inaccessiblemem_or_argmemonly``"
msgstr ""

#: ../../../LangRef.rst:1359
msgid ""
"This attribute indicates that the function may only access memory that is "
"either not accessible by the module being compiled, or is pointed to by its "
"pointer arguments. This is a weaker form of  ``argmemonly``"
msgstr ""

#: ../../../LangRef.rst:1365
msgid "``inlinehint``"
msgstr ""

#: ../../../LangRef.rst:1363
msgid ""
"This attribute indicates that the source code contained a hint that inlining "
"this function is desirable (such as the \"inline\" keyword in C/C++). It is "
"just a hint; it imposes no requirements on the inliner."
msgstr ""

#: ../../../LangRef.rst:1373
msgid "``jumptable``"
msgstr ""

#: ../../../LangRef.rst:1368
msgid ""
"This attribute indicates that the function should be added to a jump-"
"instruction table at code-generation time, and that all address-taken "
"references to this function should be replaced with a reference to the "
"appropriate jump-instruction-table function pointer. Note that this creates "
"a new pointer for the original function, which means that code that depends "
"on function-pointer identity can break. So, any function annotated with "
"``jumptable`` must also be ``unnamed_addr``."
msgstr ""

#: ../../../LangRef.rst:1378
msgid "``minsize``"
msgstr ""

#: ../../../LangRef.rst:1376
msgid ""
"This attribute suggests that optimization passes and code generator passes "
"make choices that keep the code size of this function as small as possible "
"and perform optimizations that may sacrifice runtime performance in order to "
"minimize the size of the generated code."
msgstr ""

#: ../../../LangRef.rst:1381
msgid "``naked``"
msgstr ""

#: ../../../LangRef.rst:1381
msgid ""
"This attribute disables prologue / epilogue emission for the function. This "
"can have very system-specific consequences."
msgstr ""

#: ../../../LangRef.rst:1387
msgid "``nobuiltin``"
msgstr ""

#: ../../../LangRef.rst:1384
msgid ""
"This indicates that the callee function at a call site is not recognized as "
"a built-in function. LLVM will retain the original call and not replace it "
"with equivalent code based on the semantics of the built-in function, unless "
"the call site uses the ``builtin`` attribute. This is valid at call sites "
"and on function declarations and definitions."
msgstr ""

#: ../../../LangRef.rst:1398
msgid "``noduplicate``"
msgstr ""

#: ../../../LangRef.rst:1390
msgid ""
"This attribute indicates that calls to the function cannot be duplicated. A "
"call to a ``noduplicate`` function may be moved within its parent function, "
"but may not be duplicated within its parent function."
msgstr ""

#: ../../../LangRef.rst:1395
msgid ""
"A function containing a ``noduplicate`` call may still be an inlining "
"candidate, provided that the call is not duplicated by inlining. That "
"implies that the function has internal linkage and only has one call site, "
"so the original call is dead after inlining."
msgstr ""

#: ../../../LangRef.rst:1400
msgid "``noimplicitfloat``"
msgstr ""

#: ../../../LangRef.rst:1401
msgid "This attributes disables implicit floating point instructions."
msgstr ""

#: ../../../LangRef.rst:1404
msgid "``noinline``"
msgstr ""

#: ../../../LangRef.rst:1403
msgid ""
"This attribute indicates that the inliner should never inline this function "
"in any situation. This attribute may not be used together with the "
"``alwaysinline`` attribute."
msgstr ""

#: ../../../LangRef.rst:1408
msgid "``nonlazybind``"
msgstr ""

#: ../../../LangRef.rst:1407
msgid ""
"This attribute suppresses lazy symbol binding for the function. This may "
"make calls to the function faster, at the cost of extra program startup time "
"if the function is not called during program startup."
msgstr ""

#: ../../../LangRef.rst:1411
msgid "``noredzone``"
msgstr ""

#: ../../../LangRef.rst:1411
msgid ""
"This attribute indicates that the code generator should not use a red zone, "
"even if the target-specific ABI normally permits it."
msgstr ""

#: ../../../LangRef.rst:1415
msgid "``noreturn``"
msgstr ""

#: ../../../LangRef.rst:1414
msgid ""
"This function attribute indicates that the function never returns normally. "
"This produces undefined behavior at runtime if the function ever does "
"dynamically return."
msgstr ""

#: ../../../LangRef.rst:1419
msgid "``norecurse``"
msgstr ""

#: ../../../LangRef.rst:1418
msgid ""
"This function attribute indicates that the function does not call itself "
"either directly or indirectly down any possible call path. This produces "
"undefined behavior at runtime if the function ever does recurse."
msgstr ""

#: ../../../LangRef.rst:1426
msgid "``nounwind``"
msgstr ""

#: ../../../LangRef.rst:1422
msgid ""
"This function attribute indicates that the function never raises an "
"exception. If the function does raise an exception, its runtime behavior is "
"undefined. However, functions marked nounwind may still trap or generate "
"asynchronous exceptions. Exception handling schemes that are recognized by "
"LLVM to handle asynchronous exceptions, such as SEH, will still provide "
"their implementation defined semantics."
msgstr ""

#: ../../../LangRef.rst:1438
msgid "``optnone``"
msgstr ""

#: ../../../LangRef.rst:1429
msgid ""
"This function attribute indicates that most optimization passes will skip "
"this function, with the exception of interprocedural optimization passes. "
"Code generation defaults to the \"fast\" instruction selector. This "
"attribute cannot be used together with the ``alwaysinline`` attribute; this "
"attribute is also incompatible with the ``minsize`` attribute and the "
"``optsize`` attribute."
msgstr ""

#: ../../../LangRef.rst:1436
msgid ""
"This attribute requires the ``noinline`` attribute to be specified on the "
"function as well, so the function is never inlined into any caller. Only "
"functions with the ``alwaysinline`` attribute are valid candidates for "
"inlining into the body of this function."
msgstr ""

#: ../../../LangRef.rst:1443
msgid "``optsize``"
msgstr ""

#: ../../../LangRef.rst:1441
msgid ""
"This attribute suggests that optimization passes and code generator passes "
"make choices that keep the code size of this function low, and otherwise do "
"optimizations specifically to reduce code size as long as they do not "
"significantly impact runtime performance."
msgstr ""

#: ../../../LangRef.rst:1468
msgid "``\"patchable-function\"``"
msgstr ""

#: ../../../LangRef.rst:1446
msgid ""
"This attribute tells the code generator that the code generated for this "
"function needs to follow certain conventions that make it possible for a "
"runtime function to patch over it later. The exact effect of this attribute "
"depends on its string value, for which there currently is one legal "
"possibility:"
msgstr ""

#: ../../../LangRef.rst:1452
msgid ""
"``\"prologue-short-redirect\"`` - This style of patchable function is "
"intended to support patching a function prologue to redirect control away "
"from the function in a thread safe manner.  It guarantees that the first "
"instruction of the function will be large enough to accommodate a short jump "
"instruction, and will be sufficiently aligned to allow being fully changed "
"via an atomic compare-and-swap instruction. While the first requirement can "
"be satisfied by inserting large enough NOP, LLVM can and will try to re-"
"purpose an existing instruction (i.e. one that would have to be emitted "
"anyway) as the patchable instruction larger than a short jump."
msgstr ""

#: ../../../LangRef.rst:1464
msgid "``\"prologue-short-redirect\"`` is currently only supported on x86-64."
msgstr ""

#: ../../../LangRef.rst:1467
msgid ""
"This attribute by itself does not imply restrictions on inter-procedural "
"optimizations.  All of the semantic effects the patching may have to be "
"separately conveyed via the linkage type."
msgstr ""

#: ../../../LangRef.rst:1481
msgid "``readnone``"
msgstr ""

#: ../../../LangRef.rst:1471
msgid ""
"On a function, this attribute indicates that the function computes its "
"result (or decides to unwind an exception) based strictly on its arguments, "
"without dereferencing any pointer arguments or otherwise accessing any "
"mutable state (e.g. memory, control registers, etc) visible to caller "
"functions. It does not write through any pointer arguments (including "
"``byval`` arguments) and never changes any state visible to callers. This "
"means that it cannot unwind exceptions by calling the ``C++`` exception "
"throwing methods."
msgstr ""

#: ../../../LangRef.rst:1480
msgid ""
"On an argument, this attribute indicates that the function does not "
"dereference that pointer argument, even though it may read or write the "
"memory that the pointer points to if accessed through other pointers."
msgstr ""

#: ../../../LangRef.rst:1495
msgid "``readonly``"
msgstr ""

#: ../../../LangRef.rst:1484
msgid ""
"On a function, this attribute indicates that the function does not write "
"through any pointer arguments (including ``byval`` arguments) or otherwise "
"modify any state (e.g. memory, control registers, etc) visible to caller "
"functions. It may dereference pointer arguments and read state that may be "
"set in the caller. A readonly function always returns the same value (or "
"unwinds an exception identically) when called with the same set of arguments "
"and global state. It cannot unwind an exception by calling the ``C++`` "
"exception throwing methods."
msgstr ""

#: ../../../LangRef.rst:1494
msgid ""
"On an argument, this attribute indicates that the function does not write "
"through this pointer argument, even though it may write to the memory that "
"the pointer points to."
msgstr ""

#: ../../../LangRef.rst:1502
msgid "``writeonly``"
msgstr ""

#: ../../../LangRef.rst:1498
msgid ""
"On a function, this attribute indicates that the function may write to but "
"does not read from memory."
msgstr ""

#: ../../../LangRef.rst:1501
msgid ""
"On an argument, this attribute indicates that the function may write to but "
"does not read through this pointer argument (even though it may read from "
"the memory that the pointer points to)."
msgstr ""

#: ../../../LangRef.rst:1510
msgid "``argmemonly``"
msgstr ""

#: ../../../LangRef.rst:1505
msgid ""
"This attribute indicates that the only memory accesses inside function are "
"loads and stores from objects pointed to by its pointer-typed arguments, "
"with arbitrary offsets. Or in other words, all memory operations in the "
"function can refer to memory only using pointers based on its function "
"arguments. Note that ``argmemonly`` can be used together with ``readonly`` "
"attribute in order to specify that function reads only from its arguments."
msgstr ""

#: ../../../LangRef.rst:1515
msgid "``returns_twice``"
msgstr ""

#: ../../../LangRef.rst:1513
msgid ""
"This attribute indicates that this function can return twice. The C "
"``setjmp`` is an example of such a function. The compiler disables some "
"optimizations (like tail calls) in the caller of these functions."
msgstr ""

#: ../../../LangRef.rst:1524
msgid "``safestack``"
msgstr ""

#: ../../../LangRef.rst:1518
msgid ""
"This attribute indicates that `SafeStack <http://clang.llvm.org/docs/"
"SafeStack.html>`_ protection is enabled for this function."
msgstr ""

#: ../../../LangRef.rst:1522
msgid ""
"If a function that has a ``safestack`` attribute is inlined into a function "
"that doesn't have a ``safestack`` attribute or which has an ``ssp``, "
"``sspstrong`` or ``sspreq`` attribute, then the resulting function will have "
"a ``safestack`` attribute."
msgstr ""

#: ../../../LangRef.rst:1527
msgid "``sanitize_address``"
msgstr ""

#: ../../../LangRef.rst:1527
msgid ""
"This attribute indicates that AddressSanitizer checks (dynamic address "
"safety analysis) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:1530
msgid "``sanitize_memory``"
msgstr ""

#: ../../../LangRef.rst:1530
msgid ""
"This attribute indicates that MemorySanitizer checks (dynamic detection of "
"accesses to uninitialized memory) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:1533
msgid "``sanitize_thread``"
msgstr ""

#: ../../../LangRef.rst:1533
msgid ""
"This attribute indicates that ThreadSanitizer checks (dynamic thread safety "
"analysis) are enabled for this function."
msgstr ""

#: ../../../LangRef.rst:1552
msgid "``ssp``"
msgstr ""

#: ../../../LangRef.rst:1536
msgid ""
"This attribute indicates that the function should emit a stack smashing "
"protector. It is in the form of a \"canary\" --- a random value placed on "
"the stack before the local variables that's checked upon return from the "
"function to see if it has been overwritten. A heuristic is used to determine "
"if a function needs stack protectors or not. The heuristic used will enable "
"protectors for functions with:"
msgstr ""

#: ../../../LangRef.rst:1543
msgid "Character arrays larger than ``ssp-buffer-size`` (default 8)."
msgstr ""

#: ../../../LangRef.rst:1544
msgid "Aggregates containing character arrays larger than ``ssp-buffer-size``."
msgstr ""

#: ../../../LangRef.rst:1545
msgid ""
"Calls to alloca() with variable sizes or constant sizes greater than ``ssp-"
"buffer-size``."
msgstr ""

#: ../../../LangRef.rst:1548
msgid ""
"Variables that are identified as requiring a protector will be arranged on "
"the stack such that they are adjacent to the stack protector guard."
msgstr ""

#: ../../../LangRef.rst:1551
msgid ""
"If a function that has an ``ssp`` attribute is inlined into a function that "
"doesn't have an ``ssp`` attribute, then the resulting function will have an "
"``ssp`` attribute."
msgstr ""

#: ../../../LangRef.rst:1572
msgid "``sspreq``"
msgstr ""

#: ../../../LangRef.rst:1555
msgid ""
"This attribute indicates that the function should *always* emit a stack "
"smashing protector. This overrides the ``ssp`` function attribute."
msgstr ""

#: ../../../LangRef.rst:1559 ../../../LangRef.rst:1585
msgid ""
"Variables that are identified as requiring a protector will be arranged on "
"the stack such that they are adjacent to the stack protector guard. The "
"specific layout rules are:"
msgstr ""

#: ../../../LangRef.rst:1563 ../../../LangRef.rst:1589
msgid ""
"Large arrays and structures containing large arrays (``>= ssp-buffer-size``) "
"are closest to the stack protector."
msgstr ""

#: ../../../LangRef.rst:1565 ../../../LangRef.rst:1591
msgid ""
"Small arrays and structures containing small arrays (``< ssp-buffer-size``) "
"are 2nd closest to the protector."
msgstr ""

#: ../../../LangRef.rst:1567 ../../../LangRef.rst:1593
msgid ""
"Variables that have had their address taken are 3rd closest to the protector."
msgstr ""

#: ../../../LangRef.rst:1570
msgid ""
"If a function that has an ``sspreq`` attribute is inlined into a function "
"that doesn't have an ``sspreq`` attribute or which has an ``ssp`` or "
"``sspstrong`` attribute, then the resulting function will have an ``sspreq`` "
"attribute."
msgstr ""

#: ../../../LangRef.rst:1599
msgid "``sspstrong``"
msgstr ""

#: ../../../LangRef.rst:1575
msgid ""
"This attribute indicates that the function should emit a stack smashing "
"protector. This attribute causes a strong heuristic to be used when "
"determining if a function needs stack protectors. The strong heuristic will "
"enable protectors for functions with:"
msgstr ""

#: ../../../LangRef.rst:1580
msgid "Arrays of any size and type"
msgstr ""

#: ../../../LangRef.rst:1581
msgid "Aggregates containing an array of any size and type."
msgstr ""

#: ../../../LangRef.rst:1582
msgid "Calls to alloca()."
msgstr ""

#: ../../../LangRef.rst:1583
msgid "Local variables that have had their address taken."
msgstr ""

#: ../../../LangRef.rst:1596
msgid "This overrides the ``ssp`` function attribute."
msgstr ""

#: ../../../LangRef.rst:1598
msgid ""
"If a function that has an ``sspstrong`` attribute is inlined into a function "
"that doesn't have an ``sspstrong`` attribute, then the resulting function "
"will have an ``sspstrong`` attribute."
msgstr ""

#: ../../../LangRef.rst:1604
msgid "``\"thunk\"``"
msgstr ""

#: ../../../LangRef.rst:1602
msgid ""
"This attribute indicates that the function will delegate to some other "
"function with a tail call. The prototype of a thunk should not be used for "
"optimization purposes. The caller is expected to cast the thunk prototype to "
"match the thunk target prototype."
msgstr ""

#: ../../../LangRef.rst:1612
msgid "``uwtable``"
msgstr ""

#: ../../../LangRef.rst:1607
msgid ""
"This attribute indicates that the ABI being targeted requires that an unwind "
"table entry be produced for this function even if we can show that no "
"exceptions passes by it. This is normally the case for the ELF x86-64 abi, "
"but it can be disabled for some compilation units."
msgstr ""

#: ../../../LangRef.rst:1617
msgid "Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:1619
msgid ""
"Operand bundles are tagged sets of SSA values that can be associated with "
"certain LLVM instructions (currently only ``call`` s and ``invoke`` s).  In "
"a way they are like metadata, but dropping them is incorrect and will change "
"program semantics."
msgstr ""

#: ../../../LangRef.rst:1631
msgid ""
"Operand bundles are **not** part of a function's signature, and a given "
"function may be called from multiple places with different kinds of operand "
"bundles.  This reflects the fact that the operand bundles are conceptually a "
"part of the ``call`` (or ``invoke``), not the callee being dispatched to."
msgstr ""

#: ../../../LangRef.rst:1637
msgid ""
"Operand bundles are a generic mechanism intended to support runtime-"
"introspection-like functionality for managed languages.  While the exact "
"semantics of an operand bundle depend on the bundle tag, there are certain "
"limitations to how much the presence of an operand bundle can influence the "
"semantics of a program.  These restrictions are described as the semantics "
"of an \"unknown\" operand bundle.  As long as the behavior of an operand "
"bundle is describable within these restrictions, LLVM does not need to have "
"special knowledge of the operand bundle to not miscompile programs "
"containing it."
msgstr ""

#: ../../../LangRef.rst:1647
msgid ""
"The bundle operands for an unknown operand bundle escape in unknown ways "
"before control is transferred to the callee or invokee."
msgstr ""

#: ../../../LangRef.rst:1649
msgid ""
"Calls and invokes with operand bundles have unknown read / write effect on "
"the heap on entry and exit (even if the call target is ``readnone`` or "
"``readonly``), unless they're overridden with callsite specific attributes."
msgstr ""

#: ../../../LangRef.rst:1653
msgid ""
"An operand bundle at a call site cannot change the implementation of the "
"called function.  Inter-procedural optimizations work as usual as long as "
"they take into account the first two properties."
msgstr ""

#: ../../../LangRef.rst:1657
msgid "More specific types of operand bundles are described below."
msgstr ""

#: ../../../LangRef.rst:1662
msgid "Deoptimization Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:1664
msgid ""
"Deoptimization operand bundles are characterized by the ``\"deopt\"`` "
"operand bundle tag.  These operand bundles represent an alternate \"safe\" "
"continuation for the call site they're attached to, and can be used by a "
"suitable runtime to deoptimize the compiled frame at the specified call "
"site.  There can be at most one ``\"deopt\"`` operand bundle attached to a "
"call site.  Exact details of deoptimization is out of scope for the language "
"reference, but it usually involves rewriting a compiled frame into a set of "
"interpreted frames."
msgstr ""

#: ../../../LangRef.rst:1673
msgid ""
"From the compiler's perspective, deoptimization operand bundles make the "
"call sites they're attached to at least ``readonly``.  They read through all "
"of their pointer typed operands (even if they're not otherwise escaped) and "
"the entire visible heap.  Deoptimization operand bundles do not capture "
"their operands except during deoptimization, in which case control will not "
"be returned to the compiled frame."
msgstr ""

#: ../../../LangRef.rst:1681
msgid ""
"The inliner knows how to inline through calls that have deoptimization "
"operand bundles.  Just like inlining through a normal call site involves "
"composing the normal and exceptional continuations, inlining through a call "
"site with a deoptimization operand bundle needs to appropriately compose the "
"\"safe\" deoptimization continuation.  The inliner does this by prepending "
"the parent's deoptimization continuation to every deoptimization "
"continuation in the inlined body. E.g. inlining ``@f`` into ``@g`` in the "
"following example"
msgstr ""

#: ../../../LangRef.rst:1704
msgid "will result in"
msgstr ""

#: ../../../LangRef.rst:1715
msgid ""
"It is the frontend's responsibility to structure or encode the "
"deoptimization state in a way that syntactically prepending the caller's "
"deoptimization state to the callee's deoptimization state is semantically "
"equivalent to composing the caller's deoptimization continuation after the "
"callee's deoptimization continuation."
msgstr ""

#: ../../../LangRef.rst:1724
msgid "Funclet Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:1726
msgid ""
"Funclet operand bundles are characterized by the ``\"funclet\"`` operand "
"bundle tag.  These operand bundles indicate that a call site is within a "
"particular funclet.  There can be at most one ``\"funclet\"`` operand bundle "
"attached to a call site and it must have exactly one bundle operand."
msgstr ""

#: ../../../LangRef.rst:1732
msgid ""
"If any funclet EH pads have been \"entered\" but not \"exited\" (per the "
"`description in the EH doc\\ <ExceptionHandling.html#wineh-constraints>`_), "
"it is undefined behavior to execute a ``call`` or ``invoke`` which:"
msgstr ""

#: ../../../LangRef.rst:1736
msgid ""
"does not have a ``\"funclet\"`` bundle and is not a ``call`` to a nounwind "
"intrinsic, or"
msgstr ""

#: ../../../LangRef.rst:1738
msgid ""
"has a ``\"funclet\"`` bundle whose operand is not the most-recently-entered "
"not-yet-exited funclet EH pad."
msgstr ""

#: ../../../LangRef.rst:1741
msgid ""
"Similarly, if no funclet EH pads have been entered-but-not-yet-exited, "
"executing a ``call`` or ``invoke`` with a ``\"funclet\"`` bundle is "
"undefined behavior."
msgstr ""

#: ../../../LangRef.rst:1745
msgid "GC Transition Operand Bundles"
msgstr ""

#: ../../../LangRef.rst:1747
msgid ""
"GC transition operand bundles are characterized by the ``\"gc-transition\"`` "
"operand bundle tag. These operand bundles mark a call as a transition "
"between a function with one GC strategy to a function with a different GC "
"strategy. If coordinating the transition between GC strategies requires "
"additional code generation at the call site, these bundles may contain any "
"values that are needed by the generated code.  For more details, see :ref:"
"`GC Transitions <gc_transition_args>`."
msgstr ""

#: ../../../LangRef.rst:1759
msgid "Module-Level Inline Assembly"
msgstr ""

#: ../../../LangRef.rst:1761
msgid ""
"Modules may contain \"module-level inline asm\" blocks, which corresponds to "
"the GCC \"file scope inline asm\" blocks. These blocks are internally "
"concatenated by LLVM and treated as a single unit, but may be separated in "
"the ``.ll`` file if desired. The syntax is very simple:"
msgstr ""

#: ../../../LangRef.rst:1771
msgid ""
"The strings can contain any character by escaping non-printable characters. "
"The escape sequence used is simply \"\\\\xx\" where \"xx\" is the two digit "
"hex code for the number."
msgstr ""

#: ../../../LangRef.rst:1775
msgid ""
"Note that the assembly string *must* be parseable by LLVM's integrated "
"assembler (unless it is disabled), even when emitting a ``.s`` file."
msgstr ""

#: ../../../LangRef.rst:1781
msgid "Data Layout"
msgstr ""

#: ../../../LangRef.rst:1783
msgid ""
"A module may specify a target specific data layout string that specifies how "
"data is to be laid out in memory. The syntax for the data layout is simply:"
msgstr ""

#: ../../../LangRef.rst:1791
msgid ""
"The *layout specification* consists of a list of specifications separated by "
"the minus sign character ('-'). Each specification starts with a letter and "
"may include other information after the letter to define some aspect of the "
"data layout. The specifications accepted are as follows:"
msgstr ""

#: ../../../LangRef.rst:1799
msgid "``E``"
msgstr ""

#: ../../../LangRef.rst:1798
msgid ""
"Specifies that the target lays out data in big-endian form. That is, the "
"bits with the most significance have the lowest address location."
msgstr ""

#: ../../../LangRef.rst:1803
msgid "``e``"
msgstr ""

#: ../../../LangRef.rst:1802
msgid ""
"Specifies that the target lays out data in little-endian form. That is, the "
"bits with the least significance have the lowest address location."
msgstr ""

#: ../../../LangRef.rst:1810
msgid "``S<size>``"
msgstr ""

#: ../../../LangRef.rst:1806
msgid ""
"Specifies the natural alignment of the stack in bits. Alignment promotion of "
"stack variables is limited to the natural stack alignment to avoid dynamic "
"stack realignment. The stack alignment must be a multiple of 8-bits. If "
"omitted, the natural stack alignment defaults to \"unspecified\", which does "
"not prevent any alignment promotions."
msgstr ""

#: ../../../LangRef.rst:1816
msgid "``p[n]:<size>:<abi>:<pref>``"
msgstr ""

#: ../../../LangRef.rst:1813
msgid ""
"This specifies the *size* of a pointer and its ``<abi>`` and "
"``<pref>``\\erred alignments for address space ``n``. All sizes are in bits. "
"The address space, ``n``, is optional, and if not specified, denotes the "
"default address space 0. The value of ``n`` must be in the range [1,2^23)."
msgstr ""

#: ../../../LangRef.rst:1819
msgid "``i<size>:<abi>:<pref>``"
msgstr ""

#: ../../../LangRef.rst:1819
msgid ""
"This specifies the alignment for an integer type of a given bit ``<size>``. "
"The value of ``<size>`` must be in the range [1,2^23)."
msgstr ""

#: ../../../LangRef.rst:1822
msgid "``v<size>:<abi>:<pref>``"
msgstr ""

#: ../../../LangRef.rst:1822
msgid ""
"This specifies the alignment for a vector type of a given bit ``<size>``."
msgstr ""

#: ../../../LangRef.rst:1828
msgid "``f<size>:<abi>:<pref>``"
msgstr ""

#: ../../../LangRef.rst:1825
msgid ""
"This specifies the alignment for a floating point type of a given bit "
"``<size>``. Only values of ``<size>`` that are supported by the target will "
"work. 32 (float) and 64 (double) are supported on all targets; 80 or 128 "
"(different flavors of long double) are also supported on some targets."
msgstr ""

#: ../../../LangRef.rst:1830
msgid "``a:<abi>:<pref>``"
msgstr ""

#: ../../../LangRef.rst:1831
msgid "This specifies the alignment for an object of aggregate type."
msgstr ""

#: ../../../LangRef.rst:1842
msgid "``m:<mangling>``"
msgstr ""

#: ../../../LangRef.rst:1833
msgid ""
"If present, specifies that llvm names are mangled in the output. The options "
"are"
msgstr ""

#: ../../../LangRef.rst:1836
msgid "``e``: ELF mangling: Private symbols get a ``.L`` prefix."
msgstr ""

#: ../../../LangRef.rst:1837
msgid "``m``: Mips mangling: Private symbols get a ``$`` prefix."
msgstr ""

#: ../../../LangRef.rst:1838
msgid ""
"``o``: Mach-O mangling: Private symbols get ``L`` prefix. Other symbols get "
"a ``_`` prefix."
msgstr ""

#: ../../../LangRef.rst:1840
msgid ""
"``w``: Windows COFF prefix:  Similar to Mach-O, but stdcall and fastcall "
"functions also get a suffix based on the frame size."
msgstr ""

#: ../../../LangRef.rst:1842
msgid ""
"``x``: Windows x86 COFF prefix:  Similar to Windows COFF, but use a ``_`` "
"prefix for ``__cdecl`` functions."
msgstr ""

#: ../../../LangRef.rst:1848
msgid "``n<size1>:<size2>:<size3>...``"
msgstr ""

#: ../../../LangRef.rst:1845
msgid ""
"This specifies a set of native integer widths for the target CPU in bits. "
"For example, it might contain ``n32`` for 32-bit PowerPC, ``n32:64`` for "
"PowerPC 64, or ``n8:16:32:64`` for X86-64. Elements of this set are "
"considered to support most general arithmetic operations efficiently."
msgstr ""

#: ../../../LangRef.rst:1853
msgid "``ni:<address space0>:<address space1>:<address space2>...``"
msgstr ""

#: ../../../LangRef.rst:1851
msgid ""
"This specifies pointer types with the specified address spaces as :ref:`Non-"
"Integral Pointer Type <nointptrtype>` s.  The ``0`` address space cannot be "
"specified as non-integral."
msgstr ""

#: ../../../LangRef.rst:1855
msgid ""
"On every specification that takes a ``<abi>:<pref>``, specifying the "
"``<pref>`` alignment is optional. If omitted, the preceding ``:`` should be "
"omitted too and ``<pref>`` will be equal to ``<abi>``."
msgstr ""

#: ../../../LangRef.rst:1859
msgid ""
"When constructing the data layout for a given target, LLVM starts with a "
"default set of specifications which are then (possibly) overridden by the "
"specifications in the ``datalayout`` keyword. The default specifications are "
"given in this list:"
msgstr ""

#: ../../../LangRef.rst:1864
msgid "``E`` - big endian"
msgstr ""

#: ../../../LangRef.rst:1865
msgid "``p:64:64:64`` - 64-bit pointers with 64-bit alignment."
msgstr ""

#: ../../../LangRef.rst:1866
msgid ""
"``p[n]:64:64:64`` - Other address spaces are assumed to be the same as the "
"default address space."
msgstr ""

#: ../../../LangRef.rst:1868
msgid "``S0`` - natural stack alignment is unspecified"
msgstr ""

#: ../../../LangRef.rst:1869
msgid "``i1:8:8`` - i1 is 8-bit (byte) aligned"
msgstr ""

#: ../../../LangRef.rst:1870
msgid "``i8:8:8`` - i8 is 8-bit (byte) aligned"
msgstr ""

#: ../../../LangRef.rst:1871
msgid "``i16:16:16`` - i16 is 16-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1872
msgid "``i32:32:32`` - i32 is 32-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1873
msgid ""
"``i64:32:64`` - i64 has ABI alignment of 32-bits but preferred alignment of "
"64-bits"
msgstr ""

#: ../../../LangRef.rst:1875
msgid "``f16:16:16`` - half is 16-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1876
msgid "``f32:32:32`` - float is 32-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1877
msgid "``f64:64:64`` - double is 64-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1878
msgid "``f128:128:128`` - quad is 128-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1879
msgid "``v64:64:64`` - 64-bit vector is 64-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1880
msgid "``v128:128:128`` - 128-bit vector is 128-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1881
msgid "``a:0:64`` - aggregates are 64-bit aligned"
msgstr ""

#: ../../../LangRef.rst:1883
msgid ""
"When LLVM is determining the alignment for a given type, it uses the "
"following rules:"
msgstr ""

#: ../../../LangRef.rst:1886
msgid ""
"If the type sought is an exact match for one of the specifications, that "
"specification is used."
msgstr ""

#: ../../../LangRef.rst:1888
msgid ""
"If no match is found, and the type sought is an integer type, then the "
"smallest integer type that is larger than the bitwidth of the sought type is "
"used. If none of the specifications are larger than the bitwidth then the "
"largest integer type is used. For example, given the default specifications "
"above, the i7 type will use the alignment of i8 (next largest) while both "
"i65 and i256 will use the alignment of i64 (largest specified)."
msgstr ""

#: ../../../LangRef.rst:1895
msgid ""
"If no match is found, and the type sought is a vector type, then the largest "
"vector type that is smaller than the sought vector type will be used as a "
"fall back. This happens because <128 x double> can be implemented in terms "
"of 64 <2 x double>, for example."
msgstr ""

#: ../../../LangRef.rst:1900
msgid ""
"The function of the data layout string may not be what you expect. Notably, "
"this is not a specification from the frontend of what alignment the code "
"generator should use."
msgstr ""

#: ../../../LangRef.rst:1904
msgid ""
"Instead, if specified, the target data layout is required to match what the "
"ultimate *code generator* expects. This string is used by the mid-level "
"optimizers to improve code, and this only works if it matches what the "
"ultimate code generator uses. There is no way to generate IR that does not "
"embed this target-specific detail into the IR. If you don't specify the "
"string, the default specifications will be used to generate a Data Layout "
"and the optimization phases will operate accordingly and introduce target "
"specificity into the IR with respect to these default specifications."
msgstr ""

#: ../../../LangRef.rst:1917
msgid "Target Triple"
msgstr ""

#: ../../../LangRef.rst:1919
msgid ""
"A module may specify a target triple string that describes the target host. "
"The syntax for the target triple is simply:"
msgstr ""

#: ../../../LangRef.rst:1926
msgid ""
"The *target triple* string consists of a series of identifiers delimited by "
"the minus sign character ('-'). The canonical forms are:"
msgstr ""

#: ../../../LangRef.rst:1934
msgid ""
"This information is passed along to the backend so that it generates code "
"for the proper architecture. It's possible to override this on the command "
"line with the ``-mtriple`` command line option."
msgstr ""

#: ../../../LangRef.rst:1941
msgid "Pointer Aliasing Rules"
msgstr ""

#: ../../../LangRef.rst:1943
msgid ""
"Any memory access must be done through a pointer value associated with an "
"address range of the memory access, otherwise the behavior is undefined. "
"Pointer values are associated with address ranges according to the following "
"rules:"
msgstr ""

#: ../../../LangRef.rst:1948
msgid ""
"A pointer value is associated with the addresses associated with any value "
"it is *based* on."
msgstr ""

#: ../../../LangRef.rst:1950
msgid ""
"An address of a global variable is associated with the address range of the "
"variable's storage."
msgstr ""

#: ../../../LangRef.rst:1952
msgid ""
"The result value of an allocation instruction is associated with the address "
"range of the allocated storage."
msgstr ""

#: ../../../LangRef.rst:1954
msgid ""
"A null pointer in the default address-space is associated with no address."
msgstr ""

#: ../../../LangRef.rst:1956
msgid ""
"An integer constant other than zero or a pointer value returned from a "
"function not defined within LLVM may be associated with address ranges "
"allocated through mechanisms other than those provided by LLVM. Such ranges "
"shall not overlap with any ranges of addresses allocated by mechanisms "
"provided by LLVM."
msgstr ""

#: ../../../LangRef.rst:1962
msgid ""
"A pointer value is *based* on another pointer value according to the "
"following rules:"
msgstr ""

#: ../../../LangRef.rst:1965
msgid ""
"A pointer value formed from a ``getelementptr`` operation is *based* on the "
"first value operand of the ``getelementptr``."
msgstr ""

#: ../../../LangRef.rst:1967
msgid ""
"The result value of a ``bitcast`` is *based* on the operand of the "
"``bitcast``."
msgstr ""

#: ../../../LangRef.rst:1969
msgid ""
"A pointer value formed by an ``inttoptr`` is *based* on all pointer values "
"that contribute (directly or indirectly) to the computation of the pointer's "
"value."
msgstr ""

#: ../../../LangRef.rst:1972
msgid "The \"*based* on\" relationship is transitive."
msgstr ""

#: ../../../LangRef.rst:1974
msgid ""
"Note that this definition of *\"based\"* is intentionally similar to the "
"definition of *\"based\"* in C99, though it is slightly weaker."
msgstr ""

#: ../../../LangRef.rst:1977
msgid ""
"LLVM IR does not associate types with memory. The result type of a ``load`` "
"merely indicates the size and alignment of the memory from which to load, as "
"well as the interpretation of the value. The first operand type of a "
"``store`` similarly only indicates the size and alignment of the store."
msgstr ""

#: ../../../LangRef.rst:1983
msgid ""
"Consequently, type-based alias analysis, aka TBAA, aka ``-fstrict-"
"aliasing``, is not applicable to general unadorned LLVM IR. :ref:`Metadata "
"<metadata>` may be used to encode additional information which specialized "
"optimization passes may use to implement type-based alias analysis."
msgstr ""

#: ../../../LangRef.rst:1992
msgid "Volatile Memory Accesses"
msgstr ""

#: ../../../LangRef.rst:1994
msgid ""
"Certain memory accesses, such as :ref:`load <i_load>`'s, :ref:`store "
"<i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be marked "
"``volatile``. The optimizers must not change the number of volatile "
"operations or change their order of execution relative to other volatile "
"operations. The optimizers *may* change the order of volatile operations "
"relative to non-volatile operations. This is not Java's \"volatile\" and has "
"no cross-thread synchronization behavior."
msgstr ""

#: ../../../LangRef.rst:2002
msgid ""
"IR-level volatile loads and stores cannot safely be optimized into llvm."
"memcpy or llvm.memmove intrinsics even when those intrinsics are flagged "
"volatile. Likewise, the backend should never split or merge target-legal "
"volatile load/store instructions."
msgstr ""

#: ../../../LangRef.rst:2007
msgid "Rationale"
msgstr ""

#: ../../../LangRef.rst:2009
msgid ""
"Platforms may rely on volatile loads and stores of natively supported data "
"width to be executed as single instruction. For example, in C this holds for "
"an l-value of volatile primitive type with native hardware support, but not "
"necessarily for aggregate types. The frontend upholds these expectations, "
"which are intentionally unspecified in the IR. The rules above ensure that "
"IR transformations do not violate the frontend's contract with the language."
msgstr ""

#: ../../../LangRef.rst:2020
msgid "Memory Model for Concurrent Operations"
msgstr ""

#: ../../../LangRef.rst:2022
msgid ""
"The LLVM IR does not define any way to start parallel threads of execution "
"or to register signal handlers. Nonetheless, there are platform-specific "
"ways to create them, and we define LLVM IR's behavior in their presence. "
"This model is inspired by the C++0x memory model."
msgstr ""

#: ../../../LangRef.rst:2027
msgid "For a more informal introduction to this model, see the :doc:`Atomics`."
msgstr ""

#: ../../../LangRef.rst:2029
msgid ""
"We define a *happens-before* partial order as the least partial order that"
msgstr ""

#: ../../../LangRef.rst:2032
msgid "Is a superset of single-thread program order, and"
msgstr ""

#: ../../../LangRef.rst:2033
msgid ""
"When a *synchronizes-with* ``b``, includes an edge from ``a`` to ``b``. "
"*Synchronizes-with* pairs are introduced by platform-specific techniques, "
"like pthread locks, thread creation, thread joining, etc., and by atomic "
"instructions. (See also :ref:`Atomic Memory Ordering Constraints "
"<ordering>`)."
msgstr ""

#: ../../../LangRef.rst:2039
msgid ""
"Note that program order does not introduce *happens-before* edges between a "
"thread and signals executing inside that thread."
msgstr ""

#: ../../../LangRef.rst:2042
msgid ""
"Every (defined) read operation (load instructions, memcpy, atomic loads/read-"
"modify-writes, etc.) R reads a series of bytes written by (defined) write "
"operations (store instructions, atomic stores/read-modify-writes, memcpy, "
"etc.). For the purposes of this section, initialized globals are considered "
"to have a write of the initializer which is atomic and happens before any "
"other read or write of the memory in question. For each byte of a read R, "
"R\\ :sub:`byte` may see any write to the same byte, except:"
msgstr ""

#: ../../../LangRef.rst:2051
msgid ""
"If write\\ :sub:`1`  happens before write\\ :sub:`2`, and write\\ :sub:`2` "
"happens before R\\ :sub:`byte`, then R\\ :sub:`byte` does not see write\\ :"
"sub:`1`."
msgstr ""

#: ../../../LangRef.rst:2054
msgid ""
"If R\\ :sub:`byte` happens before write\\ :sub:`3`, then R\\ :sub:`byte` "
"does not see write\\ :sub:`3`."
msgstr ""

#: ../../../LangRef.rst:2057
msgid "Given that definition, R\\ :sub:`byte` is defined as follows:"
msgstr ""

#: ../../../LangRef.rst:2059
msgid ""
"If R is volatile, the result is target-dependent. (Volatile is supposed to "
"give guarantees which can support ``sig_atomic_t`` in C/C++, and may be used "
"for accesses to addresses that do not behave like normal memory. It does not "
"generally provide cross-thread synchronization.)"
msgstr ""

#: ../../../LangRef.rst:2064
msgid ""
"Otherwise, if there is no write to the same byte that happens before R\\ :"
"sub:`byte`, R\\ :sub:`byte` returns ``undef`` for that byte."
msgstr ""

#: ../../../LangRef.rst:2066
msgid ""
"Otherwise, if R\\ :sub:`byte` may see exactly one write, R\\ :sub:`byte` "
"returns the value written by that write."
msgstr ""

#: ../../../LangRef.rst:2068
msgid ""
"Otherwise, if R is atomic, and all the writes R\\ :sub:`byte` may see are "
"atomic, it chooses one of the values written. See the :ref:`Atomic Memory "
"Ordering Constraints <ordering>` section for additional constraints on how "
"the choice is made."
msgstr ""

#: ../../../LangRef.rst:2072
msgid "Otherwise R\\ :sub:`byte` returns ``undef``."
msgstr ""

#: ../../../LangRef.rst:2074
msgid ""
"R returns the value composed of the series of bytes it read. This implies "
"that some bytes within the value may be ``undef`` **without** the entire "
"value being ``undef``. Note that this only defines the semantics of the "
"operation; it doesn't mean that targets will emit more than one instruction "
"to read the series of bytes."
msgstr ""

#: ../../../LangRef.rst:2080
msgid ""
"Note that in cases where none of the atomic intrinsics are used, this model "
"places only one restriction on IR transformations on top of what is required "
"for single-threaded execution: introducing a store to a byte which might not "
"otherwise be stored is not allowed in general. (Specifically, in the case "
"where another thread might write to and read from an address, introducing a "
"store can change a load that may see exactly one write into a load that may "
"see multiple writes.)"
msgstr ""

#: ../../../LangRef.rst:2091
msgid "Atomic Memory Ordering Constraints"
msgstr ""

#: ../../../LangRef.rst:2093
msgid ""
"Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`, :ref:`atomicrmw "
"<i_atomicrmw>`, :ref:`fence <i_fence>`, :ref:`atomic load <i_load>`, and :"
"ref:`atomic store <i_store>`) take ordering parameters that determine which "
"other atomic instructions on the same address they *synchronize with*. These "
"semantics are borrowed from Java and C++0x, but are somewhat more "
"colloquial. If these descriptions aren't precise enough, check those specs "
"(see spec references in the :doc:`atomics guide <Atomics>`). :ref:`fence "
"<i_fence>` instructions treat these orderings somewhat differently since "
"they don't take an address. See that instruction's documentation for details."
msgstr ""

#: ../../../LangRef.rst:2105
msgid ""
"For a simpler introduction to the ordering constraints, see the :doc:"
"`Atomics`."
msgstr ""

#: ../../../LangRef.rst:2113
msgid "``unordered``"
msgstr ""

#: ../../../LangRef.rst:2109
msgid ""
"The set of values that can be read is governed by the happens-before partial "
"order. A value cannot be read unless some operation wrote it. This is "
"intended to provide a guarantee strong enough to model Java's non-volatile "
"shared variables. This ordering cannot be specified for read-modify-write "
"operations; it is not strong enough to make them atomic in any interesting "
"way."
msgstr ""

#: ../../../LangRef.rst:2131
msgid "``monotonic``"
msgstr ""

#: ../../../LangRef.rst:2116
msgid ""
"In addition to the guarantees of ``unordered``, there is a single total "
"order for modifications by ``monotonic`` operations on each address. All "
"modification orders must be compatible with the happens-before order. There "
"is no guarantee that the modification orders can be combined to a global "
"total order for the whole program (and this often will not be possible). The "
"read in an atomic read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` "
"and :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification "
"order immediately before the value it writes. If one atomic read happens "
"before another atomic read of the same address, the later read must see the "
"same value or a later value in the address's modification order. This "
"disallows reordering of ``monotonic`` (or stronger) operations on the same "
"address. If an address is written ``monotonic``-ally by one thread, and "
"other threads ``monotonic``-ally read that address repeatedly, the other "
"threads must eventually see the write. This corresponds to the C++0x/C1x "
"``memory_order_relaxed``."
msgstr ""

#: ../../../LangRef.rst:2135
msgid "``acquire``"
msgstr ""

#: ../../../LangRef.rst:2134
msgid ""
"In addition to the guarantees of ``monotonic``, a *synchronizes-with* edge "
"may be formed with a ``release`` operation. This is intended to model C++'s "
"``memory_order_acquire``."
msgstr ""

#: ../../../LangRef.rst:2142
msgid "``release``"
msgstr ""

#: ../../../LangRef.rst:2138
msgid ""
"In addition to the guarantees of ``monotonic``, if this operation writes a "
"value which is subsequently read by an ``acquire`` operation, it "
"*synchronizes-with* that operation. (This isn't a complete description; see "
"the C++0x definition of a release sequence.) This corresponds to the C++0x/"
"C1x ``memory_order_release``."
msgstr ""

#: ../../../LangRef.rst:2145
msgid "``acq_rel`` (acquire+release)"
msgstr ""

#: ../../../LangRef.rst:2145
msgid ""
"Acts as both an ``acquire`` and ``release`` operation on its address. This "
"corresponds to the C++0x/C1x ``memory_order_acq_rel``."
msgstr ""

#: ../../../LangRef.rst:2156
msgid "``seq_cst`` (sequentially consistent)"
msgstr ""

#: ../../../LangRef.rst:2148
msgid ""
"In addition to the guarantees of ``acq_rel`` (``acquire`` for an operation "
"that only reads, ``release`` for an operation that only writes), there is a "
"global total order on all sequentially-consistent operations on all "
"addresses, which is consistent with the *happens-before* partial order and "
"with the modification orders of all the affected addresses. Each "
"sequentially-consistent read sees the last preceding write to the same "
"address in this global order. This corresponds to the C++0x/C1x "
"``memory_order_seq_cst`` and Java volatile."
msgstr ""

#: ../../../LangRef.rst:2160
msgid ""
"If an atomic operation is marked ``singlethread``, it only *synchronizes "
"with* or participates in modification and seq\\_cst total orderings with "
"other operations running in the same thread (for example, in signal "
"handlers)."
msgstr ""

#: ../../../LangRef.rst:2168
msgid "Fast-Math Flags"
msgstr ""

#: ../../../LangRef.rst:2170
msgid ""
"LLVM IR floating-point binary ops (:ref:`fadd <i_fadd>`, :ref:`fsub "
"<i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`, :ref:`frem "
"<i_frem>`, :ref:`fcmp <i_fcmp>`) and :ref:`call <i_call>` instructions have "
"the following flags that can be set to enable otherwise unsafe floating "
"point transformations."
msgstr ""

#: ../../../LangRef.rst:2179
msgid "``nnan``"
msgstr ""

#: ../../../LangRef.rst:2177
msgid ""
"No NaNs - Allow optimizations to assume the arguments and result are not "
"NaN. Such optimizations are required to retain defined behavior over NaNs, "
"but the value of the result is undefined."
msgstr ""

#: ../../../LangRef.rst:2184
msgid "``ninf``"
msgstr ""

#: ../../../LangRef.rst:2182
msgid ""
"No Infs - Allow optimizations to assume the arguments and result are not +/-"
"Inf. Such optimizations are required to retain defined behavior over +/-Inf, "
"but the value of the result is undefined."
msgstr ""

#: ../../../LangRef.rst:2188
msgid "``nsz``"
msgstr ""

#: ../../../LangRef.rst:2187
msgid ""
"No Signed Zeros - Allow optimizations to treat the sign of a zero argument "
"or result as insignificant."
msgstr ""

#: ../../../LangRef.rst:2192
msgid "``arcp``"
msgstr ""

#: ../../../LangRef.rst:2191
msgid ""
"Allow Reciprocal - Allow optimizations to use the reciprocal of an argument "
"rather than perform division."
msgstr ""

#: ../../../LangRef.rst:2197
msgid "``fast``"
msgstr ""

#: ../../../LangRef.rst:2195
msgid ""
"Fast - Allow algebraically equivalent transformations that may dramatically "
"change results in floating point (e.g. reassociate). This flag implies all "
"the others."
msgstr ""

#: ../../../LangRef.rst:2202
msgid "Use-list Order Directives"
msgstr ""

#: ../../../LangRef.rst:2204
msgid ""
"Use-list directives encode the in-memory order of each use-list, allowing "
"the order to be recreated. ``<order-indexes>`` is a comma-separated list of "
"indexes that are assigned to the referenced value's uses. The referenced "
"value's use-list is immediately sorted by these indexes."
msgstr ""

#: ../../../LangRef.rst:2209
msgid ""
"Use-list directives may appear at function scope or global scope. They are "
"not instructions, and have no effect on the semantics of the IR. When "
"they're at function scope, they must appear after the terminator of the "
"final basic block."
msgstr ""

#: ../../../LangRef.rst:2213
msgid ""
"If basic blocks have their address taken via ``blockaddress()`` expressions, "
"``uselistorder_bb`` can be used to reorder their use-lists from outside "
"their function's scope."
msgstr ""

#: ../../../LangRef.rst:0
msgid "Syntax"
msgstr ""

#: ../../../LangRef.rst:0
msgid "Examples"
msgstr ""

#: ../../../LangRef.rst:2248
msgid "Source Filename"
msgstr ""

#: ../../../LangRef.rst:2250
msgid ""
"The *source filename* string is set to the original module identifier, which "
"will be the name of the compiled source file when compiling from source "
"through the clang front end, for example. It is then preserved through the "
"IR and bitcode."
msgstr ""

#: ../../../LangRef.rst:2255
msgid ""
"This is currently necessary to generate a consistent unique global "
"identifier for local functions used in profile data, which prepends the "
"source file name to the local function name."
msgstr ""

#: ../../../LangRef.rst:2259
msgid "The syntax for the source file name is simply:"
msgstr ""

#: ../../../LangRef.rst:2268
msgid "Type System"
msgstr ""

#: ../../../LangRef.rst:2270
msgid ""
"The LLVM type system is one of the most important features of the "
"intermediate representation. Being typed enables a number of optimizations "
"to be performed on the intermediate representation directly, without having "
"to do extra analyses on the side before the transformation. A strong type "
"system makes it easier to read the generated code and enables novel analyses "
"and transformations that are not feasible to perform on normal three address "
"code representations."
msgstr ""

#: ../../../LangRef.rst:2281
msgid "Void Type"
msgstr ""

#: ../../../LangRef.rst:0
msgid "Overview"
msgstr ""

#: ../../../LangRef.rst:2286
msgid "The void type does not represent any value and has no size."
msgstr ""

#: ../../../LangRef.rst:2299
msgid "Function Type"
msgstr ""

#: ../../../LangRef.rst:2304
msgid ""
"The function type can be thought of as a function signature. It consists of "
"a return type and a list of formal parameter types. The return type of a "
"function type is a void type or first class type --- except for :ref:`label "
"<t_label>` and :ref:`metadata <t_metadata>` types."
msgstr ""

#: ../../../LangRef.rst:2315
msgid ""
"...where '``<parameter list>``' is a comma-separated list of type "
"specifiers. Optionally, the parameter list may include a type ``...``, which "
"indicates that the function takes a variable number of arguments. Variable "
"argument functions can access their arguments with the :ref:`variable "
"argument handling intrinsic <int_varargs>` functions. '``<returntype>``' is "
"any type except :ref:`label <t_label>` and :ref:`metadata <t_metadata>`."
msgstr ""

#: ../../../LangRef.rst:2325
msgid "``i32 (i32)``"
msgstr ""

#: ../../../LangRef.rst:2325
msgid "function taking an ``i32``, returning an ``i32``"
msgstr ""

#: ../../../LangRef.rst:2327
msgid "``float (i16, i32 *) *``"
msgstr ""

#: ../../../LangRef.rst:2327
msgid ""
":ref:`Pointer <t_pointer>` to a function that takes an ``i16`` and a :ref:"
"`pointer <t_pointer>` to ``i32``, returning ``float``."
msgstr ""

#: ../../../LangRef.rst:2329
msgid "``i32 (i8*, ...)``"
msgstr ""

#: ../../../LangRef.rst:2329
msgid ""
"A vararg function that takes at least one :ref:`pointer <t_pointer>` to "
"``i8`` (char in C), which returns an integer. This is the signature for "
"``printf`` in LLVM."
msgstr ""

#: ../../../LangRef.rst:2331
msgid "``{i32, i32} (i32)``"
msgstr ""

#: ../../../LangRef.rst:2331
msgid ""
"A function taking an ``i32``, returning a :ref:`structure <t_struct>` "
"containing two ``i32`` values"
msgstr ""

#: ../../../LangRef.rst:2337
msgid "First Class Types"
msgstr ""

#: ../../../LangRef.rst:2339
msgid ""
"The :ref:`first class <t_firstclass>` types are perhaps the most important. "
"Values of these types are the only ones which can be produced by "
"instructions."
msgstr ""

#: ../../../LangRef.rst:2346
msgid "Single Value Types"
msgstr ""

#: ../../../LangRef.rst:2348
msgid ""
"These are the types that are valid in registers from CodeGen's perspective."
msgstr ""

#: ../../../LangRef.rst:2353
msgid "Integer Type"
msgstr ""

#: ../../../LangRef.rst:2357
msgid ""
"The integer type is a very simple type that simply specifies an arbitrary "
"bit width for the integer type desired. Any bit width from 1 bit to 2\\ :sup:"
"`23`\\ -1 (about 8 million) can be specified."
msgstr ""

#: ../../../LangRef.rst:2367
msgid ""
"The number of bits the integer will occupy is specified by the ``N`` value."
msgstr ""

#: ../../../LangRef.rst:2371 ../../../LangRef.rst:4581
#: ../../../LangRef.rst:4911 ../../../LangRef.rst:7153
#: ../../../LangRef.rst:11077 ../../../LangRef.rst:11126
#: ../../../LangRef.rst:11176 ../../../LangRef.rst:11226
#: ../../../LangRef.rst:11276 ../../../LangRef.rst:11326
#: ../../../LangRef.rst:11450 ../../../LangRef.rst:11505
#: ../../../LangRef.rst:11547
msgid "Examples:"
msgstr ""

#: ../../../LangRef.rst:2374
msgid "``i1``"
msgstr ""

#: ../../../LangRef.rst:2374
msgid "a single-bit integer."
msgstr ""

#: ../../../LangRef.rst:2376
msgid "``i32``"
msgstr ""

#: ../../../LangRef.rst:2376
msgid "a 32-bit integer."
msgstr ""

#: ../../../LangRef.rst:2378
msgid "``i1942652``"
msgstr ""

#: ../../../LangRef.rst:2378
msgid "a really big integer of over 1 million bits."
msgstr ""

#: ../../../LangRef.rst:2384
msgid "Floating Point Types"
msgstr ""

#: ../../../LangRef.rst:2389
msgid "Type"
msgstr ""

#: ../../../LangRef.rst:2390
msgid "Description"
msgstr ""

#: ../../../LangRef.rst:2392
msgid "``half``"
msgstr ""

#: ../../../LangRef.rst:2393
msgid "16-bit floating point value"
msgstr ""

#: ../../../LangRef.rst:2395
msgid "``float``"
msgstr ""

#: ../../../LangRef.rst:2396
msgid "32-bit floating point value"
msgstr ""

#: ../../../LangRef.rst:2398
msgid "``double``"
msgstr ""

#: ../../../LangRef.rst:2399
msgid "64-bit floating point value"
msgstr ""

#: ../../../LangRef.rst:2401
msgid "``fp128``"
msgstr ""

#: ../../../LangRef.rst:2402
msgid "128-bit floating point value (112-bit mantissa)"
msgstr ""

#: ../../../LangRef.rst:2404
msgid "``x86_fp80``"
msgstr ""

#: ../../../LangRef.rst:2405
msgid "80-bit floating point value (X87)"
msgstr ""

#: ../../../LangRef.rst:2407
msgid "``ppc_fp128``"
msgstr ""

#: ../../../LangRef.rst:2408
msgid "128-bit floating point value (two 64-bits)"
msgstr ""

#: ../../../LangRef.rst:2411
msgid "X86_mmx Type"
msgstr ""

#: ../../../LangRef.rst:2415
msgid ""
"The x86_mmx type represents a value held in an MMX register on an x86 "
"machine. The operations allowed on it are quite limited: parameters and "
"return values, load and store, and bitcast. User-specified MMX instructions "
"are represented as intrinsic or asm calls with arguments and/or results of "
"this type. There are no arrays, vectors or constants of this type."
msgstr ""

#: ../../../LangRef.rst:2432
msgid "Pointer Type"
msgstr ""

#: ../../../LangRef.rst:2436
msgid ""
"The pointer type is used to specify memory locations. Pointers are commonly "
"used to reference objects in memory."
msgstr ""

#: ../../../LangRef.rst:2439
msgid ""
"Pointer types may have an optional address space attribute defining the "
"numbered address space where the pointed-to object resides. The default "
"address space is number zero. The semantics of non-zero address spaces are "
"target-specific."
msgstr ""

#: ../../../LangRef.rst:2444
msgid ""
"Note that LLVM does not permit pointers to void (``void*``) nor does it "
"permit pointers to labels (``label*``). Use ``i8*`` instead."
msgstr ""

#: ../../../LangRef.rst:2456
msgid "``[4 x i32]*``"
msgstr ""

#: ../../../LangRef.rst:2456
msgid ""
"A :ref:`pointer <t_pointer>` to :ref:`array <t_array>` of four ``i32`` "
"values."
msgstr ""

#: ../../../LangRef.rst:2458
msgid "``i32 (i32*) *``"
msgstr ""

#: ../../../LangRef.rst:2458
msgid ""
"A :ref:`pointer <t_pointer>` to a :ref:`function <t_function>` that takes an "
"``i32*``, returning an ``i32``."
msgstr ""

#: ../../../LangRef.rst:2460
msgid "``i32 addrspace(5)*``"
msgstr ""

#: ../../../LangRef.rst:2460
msgid ""
"A :ref:`pointer <t_pointer>` to an ``i32`` value that resides in address "
"space #5."
msgstr ""

#: ../../../LangRef.rst:2466
msgid "Vector Type"
msgstr ""

#: ../../../LangRef.rst:2470
msgid ""
"A vector type is a simple derived type that represents a vector of elements. "
"Vector types are used when multiple primitive data are operated in parallel "
"using a single instruction (SIMD). A vector type requires a size (number of "
"elements) and an underlying primitive data type. Vector types are "
"considered :ref:`first class <t_firstclass>`."
msgstr ""

#: ../../../LangRef.rst:2482
msgid ""
"The number of elements is a constant integer value larger than 0; "
"elementtype may be any integer, floating point or pointer type. Vectors of "
"size zero are not allowed."
msgstr ""

#: ../../../LangRef.rst:2489
msgid "``<4 x i32>``"
msgstr ""

#: ../../../LangRef.rst:2489
msgid "Vector of 4 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2491
msgid "``<8 x float>``"
msgstr ""

#: ../../../LangRef.rst:2491
msgid "Vector of 8 32-bit floating-point values."
msgstr ""

#: ../../../LangRef.rst:2493
msgid "``<2 x i64>``"
msgstr ""

#: ../../../LangRef.rst:2493
msgid "Vector of 2 64-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2495
msgid "``<4 x i64*>``"
msgstr ""

#: ../../../LangRef.rst:2495
msgid "Vector of 4 pointers to 64-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2501
msgid "Label Type"
msgstr ""

#: ../../../LangRef.rst:2505
msgid "The label type represents code labels."
msgstr ""

#: ../../../LangRef.rst:2516
msgid "Token Type"
msgstr ""

#: ../../../LangRef.rst:2520
msgid ""
"The token type is used when a value is associated with an instruction but "
"all uses of the value must not attempt to introspect or obscure it. As such, "
"it is not appropriate to have a :ref:`phi <i_phi>` or :ref:`select "
"<i_select>` of type token."
msgstr ""

#: ../../../LangRef.rst:2536
msgid "Metadata Type"
msgstr ""

#: ../../../LangRef.rst:2540
msgid ""
"The metadata type represents embedded metadata. No derived types may be "
"created from metadata except for :ref:`function <t_function>` arguments."
msgstr ""

#: ../../../LangRef.rst:2552
msgid "Aggregate Types"
msgstr ""

#: ../../../LangRef.rst:2554
msgid ""
"Aggregate Types are a subset of derived types that can contain multiple "
"member types. :ref:`Arrays <t_array>` and :ref:`structs <t_struct>` are "
"aggregate types. :ref:`Vectors <t_vector>` are not considered to be "
"aggregate types."
msgstr ""

#: ../../../LangRef.rst:2562
msgid "Array Type"
msgstr ""

#: ../../../LangRef.rst:2566
msgid ""
"The array type is a very simple derived type that arranges elements "
"sequentially in memory. The array type requires a size (number of elements) "
"and an underlying data type."
msgstr ""

#: ../../../LangRef.rst:2576
msgid ""
"The number of elements is a constant integer value; ``elementtype`` may be "
"any type with a size."
msgstr ""

#: ../../../LangRef.rst:2582
msgid "``[40 x i32]``"
msgstr ""

#: ../../../LangRef.rst:2582
msgid "Array of 40 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2584
msgid "``[41 x i32]``"
msgstr ""

#: ../../../LangRef.rst:2584
msgid "Array of 41 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2586
msgid "``[4 x i8]``"
msgstr ""

#: ../../../LangRef.rst:2586
msgid "Array of 4 8-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2589
msgid "Here are some examples of multidimensional arrays:"
msgstr ""

#: ../../../LangRef.rst:2592
msgid "``[3 x [4 x i32]]``"
msgstr ""

#: ../../../LangRef.rst:2592
msgid "3x4 array of 32-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2594
msgid "``[12 x [10 x float]]``"
msgstr ""

#: ../../../LangRef.rst:2594
msgid "12x10 array of single precision floating point values."
msgstr ""

#: ../../../LangRef.rst:2596
msgid "``[2 x [3 x [4 x i16]]]``"
msgstr ""

#: ../../../LangRef.rst:2596
msgid "2x3x4 array of 16-bit integer values."
msgstr ""

#: ../../../LangRef.rst:2599
msgid ""
"There is no restriction on indexing beyond the end of the array implied by a "
"static type (though there are restrictions on indexing beyond the bounds of "
"an allocated object in some cases). This means that single-dimension "
"'variable sized array' addressing can be implemented in LLVM with a zero "
"length array type. An implementation of 'pascal style arrays' in LLVM could "
"use the type \"``{ i32, [0 x float]}``\", for example."
msgstr ""

#: ../../../LangRef.rst:2610
msgid "Structure Type"
msgstr ""

#: ../../../LangRef.rst:2614
msgid ""
"The structure type is used to represent a collection of data members "
"together in memory. The elements of a structure may be any type that has a "
"size."
msgstr ""

#: ../../../LangRef.rst:2618
msgid ""
"Structures in memory are accessed using '``load``' and '``store``' by "
"getting a pointer to a field with the '``getelementptr``' instruction. "
"Structures in registers are accessed using the '``extractvalue``' and "
"'``insertvalue``' instructions."
msgstr ""

#: ../../../LangRef.rst:2623
msgid ""
"Structures may optionally be \"packed\" structures, which indicate that the "
"alignment of the struct is one byte, and that there is no padding between "
"the elements. In non-packed structs, padding between field types is inserted "
"as defined by the DataLayout string in the module, which is required to "
"match what the underlying code generator expects."
msgstr ""

#: ../../../LangRef.rst:2629
msgid ""
"Structures can either be \"literal\" or \"identified\". A literal structure "
"is defined inline with other types (e.g. ``{i32, i32}*``) whereas identified "
"types are always defined at the top level with a name. Literal types are "
"uniqued by their contents and can never be recursive or opaque since there "
"is no way to write one. Identified types can be recursive, can be opaqued, "
"and are never uniqued."
msgstr ""

#: ../../../LangRef.rst:2646
msgid "``{ i32, i32, i32 }``"
msgstr ""

#: ../../../LangRef.rst:2646
msgid "A triple of three ``i32`` values"
msgstr ""

#: ../../../LangRef.rst:2648
msgid "``{ float, i32 (i32) * }``"
msgstr ""

#: ../../../LangRef.rst:2648
msgid ""
"A pair, where the first element is a ``float`` and the second element is a :"
"ref:`pointer <t_pointer>` to a :ref:`function <t_function>` that takes an "
"``i32``, returning an ``i32``."
msgstr ""

#: ../../../LangRef.rst:2650
msgid "``<{ i8, i32 }>``"
msgstr ""

#: ../../../LangRef.rst:2650
msgid "A packed struct known to be 5 bytes in size."
msgstr ""

#: ../../../LangRef.rst:2656
msgid "Opaque Structure Types"
msgstr ""

#: ../../../LangRef.rst:2660
msgid ""
"Opaque structure types are used to represent named structure types that do "
"not have a body specified. This corresponds (for example) to the C notion of "
"a forward declared structure."
msgstr ""

#: ../../../LangRef.rst:2674
msgid "``opaque``"
msgstr ""

#: ../../../LangRef.rst:2674
msgid "An opaque type."
msgstr ""

#: ../../../LangRef.rst:2680
msgid "Constants"
msgstr ""

#: ../../../LangRef.rst:2682
msgid ""
"LLVM has several different basic types of constants. This section describes "
"them all and their syntax."
msgstr ""

#: ../../../LangRef.rst:2686
msgid "Simple Constants"
msgstr ""

#: ../../../LangRef.rst:2689
msgid "**Boolean constants**"
msgstr ""

#: ../../../LangRef.rst:2689
msgid ""
"The two strings '``true``' and '``false``' are both valid constants of the "
"``i1`` type."
msgstr ""

#: ../../../LangRef.rst:2693
msgid "**Integer constants**"
msgstr ""

#: ../../../LangRef.rst:2692
msgid ""
"Standard integers (such as '4') are constants of the :ref:`integer "
"<t_integer>` type. Negative numbers may be used with integer types."
msgstr ""

#: ../../../LangRef.rst:2701
msgid "**Floating point constants**"
msgstr ""

#: ../../../LangRef.rst:2696
msgid ""
"Floating point constants use standard decimal notation (e.g. 123.421), "
"exponential notation (e.g. 1.23421e+2), or a more precise hexadecimal "
"notation (see below). The assembler requires the exact decimal value of a "
"floating-point constant. For example, the assembler accepts 1.25 but rejects "
"1.3 because 1.3 is a repeating decimal in binary. Floating point constants "
"must have a :ref:`floating point <t_floating>` type."
msgstr ""

#: ../../../LangRef.rst:2704
msgid "**Null pointer constants**"
msgstr ""

#: ../../../LangRef.rst:2704
msgid ""
"The identifier '``null``' is recognized as a null pointer constant and must "
"be of :ref:`pointer type <t_pointer>`."
msgstr ""

#: ../../../LangRef.rst:2708
msgid "**Token constants**"
msgstr ""

#: ../../../LangRef.rst:2707
msgid ""
"The identifier '``none``' is recognized as an empty token constant and must "
"be of :ref:`token type <t_token>`."
msgstr ""

#: ../../../LangRef.rst:2710
msgid ""
"The one non-intuitive notation for constants is the hexadecimal form of "
"floating point constants. For example, the form '``double    "
"0x432ff973cafa8000``' is equivalent to (but harder to read than) '``double "
"4.5e+15``'. The only time hexadecimal floating point constants are required "
"(and the only time that they are generated by the disassembler) is when a "
"floating point constant must be emitted but it cannot be represented as a "
"decimal floating point number in a reasonable number of digits. For example, "
"NaN's, infinities, and other special values are represented in their IEEE "
"hexadecimal format so that assembly and disassembly do not cause any bits to "
"change in the constants."
msgstr ""

#: ../../../LangRef.rst:2721
msgid ""
"When using the hexadecimal form, constants of types half, float, and double "
"are represented using the 16-digit form shown above (which matches the "
"IEEE754 representation for double); half and float values must, however, be "
"exactly representable as IEEE 754 half and single precision, respectively. "
"Hexadecimal format is always used for long double, and there are three forms "
"of long double. The 80-bit format used by x86 is represented as ``0xK`` "
"followed by 20 hexadecimal digits. The 128-bit format used by PowerPC (two "
"adjacent doubles) is represented by ``0xM`` followed by 32 hexadecimal "
"digits. The IEEE 128-bit format is represented by ``0xL`` followed by 32 "
"hexadecimal digits. Long doubles will only work if they match the long "
"double format on your target. The IEEE 16-bit format (half precision) is "
"represented by ``0xH`` followed by 4 hexadecimal digits. All hexadecimal "
"formats are big-endian (sign bit at the left)."
msgstr ""

#: ../../../LangRef.rst:2736
msgid "There are no constants of type x86_mmx."
msgstr ""

#: ../../../LangRef.rst:2741
msgid "Complex Constants"
msgstr ""

#: ../../../LangRef.rst:2743
msgid ""
"Complex constants are a (potentially recursive) combination of simple "
"constants and smaller complex constants."
msgstr ""

#: ../../../LangRef.rst:2752
msgid "**Structure constants**"
msgstr ""

#: ../../../LangRef.rst:2747
msgid ""
"Structure constants are represented with notation similar to structure type "
"definitions (a comma separated list of elements, surrounded by braces (``{}"
"``)). For example: \"``{ i32 4, float 17.0, i32* @G }``\", where \"``@G``\" "
"is declared as \"``@G = external global i32``\". Structure constants must "
"have :ref:`structure type <t_struct>`, and the number and types of elements "
"must match those specified by the type."
msgstr ""

#: ../../../LangRef.rst:2761
msgid "**Array constants**"
msgstr ""

#: ../../../LangRef.rst:2755
msgid ""
"Array constants are represented with notation similar to array type "
"definitions (a comma separated list of elements, surrounded by square "
"brackets (``[]``)). For example: \"``[ i32 42, i32 11, i32 74 ]``\". Array "
"constants must have :ref:`array type <t_array>`, and the number and types of "
"elements must match those specified by the type. As a special case, "
"character array constants may also be represented as a double-quoted string "
"using the ``c`` prefix. For example: \"``c\"Hello World\\0A\\00\"``\"."
msgstr ""

#: ../../../LangRef.rst:2768
msgid "**Vector constants**"
msgstr ""

#: ../../../LangRef.rst:2764
msgid ""
"Vector constants are represented with notation similar to vector type "
"definitions (a comma separated list of elements, surrounded by less-than/"
"greater-than's (``<>``)). For example: \"``< i32 42, i32 11, i32 74, i32 100 "
">``\". Vector constants must have :ref:`vector type <t_vector>`, and the "
"number and types of elements must match those specified by the type."
msgstr ""

#: ../../../LangRef.rst:2774
msgid "**Zero initialization**"
msgstr ""

#: ../../../LangRef.rst:2771
msgid ""
"The string '``zeroinitializer``' can be used to zero initialize a value to "
"zero of *any* type, including scalar and :ref:`aggregate <t_aggregate>` "
"types. This is often used to avoid having to print large zero initializers "
"(e.g. for large arrays) and is always exactly equivalent to using explicit "
"zero initializers."
msgstr ""

#: ../../../LangRef.rst:2782
msgid "**Metadata node**"
msgstr ""

#: ../../../LangRef.rst:2777
msgid ""
"A metadata node is a constant tuple without types. For example: \"``!{!0, !{!"
"2, !0}, !\"test\"}``\". Metadata can reference constant values, for example: "
"\"``!{!0, i32 0, i8* @global, i64 (i64)* @function, !\"str\"}``\". Unlike "
"other typed constants that are meant to be interpreted as part of the "
"instruction stream, metadata is a place to attach additional information "
"such as debug info."
msgstr ""

#: ../../../LangRef.rst:2785
msgid "Global Variable and Function Addresses"
msgstr ""

#: ../../../LangRef.rst:2787
msgid ""
"The addresses of :ref:`global variables <globalvars>` and :ref:`functions "
"<functionstructure>` are always implicitly valid (link-time) constants. "
"These constants are explicitly referenced when the :ref:`identifier for the "
"global <identifiers>` is used and always have :ref:`pointer <t_pointer>` "
"type. For example, the following is a legal LLVM file:"
msgstr ""

#: ../../../LangRef.rst:2803
msgid "Undefined Values"
msgstr ""

#: ../../../LangRef.rst:2805
msgid ""
"The string '``undef``' can be used anywhere a constant is expected, and "
"indicates that the user of the value may receive an unspecified bit-pattern. "
"Undefined values may be of any type (other than '``label``' or '``void``') "
"and be used anywhere a constant is permitted."
msgstr ""

#: ../../../LangRef.rst:2810
msgid ""
"Undefined values are useful because they indicate to the compiler that the "
"program is well defined no matter what value is used. This gives the "
"compiler more freedom to optimize. Here are some examples of (potentially "
"surprising) transformations that are valid (in pseudo IR):"
msgstr ""

#: ../../../LangRef.rst:2825
msgid ""
"This is safe because all of the output bits are affected by the undef bits. "
"Any output bit can have a zero or one depending on the input bits."
msgstr ""

#: ../../../LangRef.rst:2842
msgid ""
"These logical operations have bits that are not always affected by the "
"input. For example, if ``%X`` has a zero bit, then the output of the "
"'``and``' operation will always be a zero for that bit, no matter what the "
"corresponding bit from the '``undef``' is. As such, it is unsafe to optimize "
"or assume that the result of the '``and``' is '``undef``'. However, it is "
"safe to assume that all bits of the '``undef``' could be 0, and optimize the "
"'``and``' to 0. Likewise, it is safe to assume that all the bits of the "
"'``undef``' operand to the '``or``' could be set, allowing the '``or``' to "
"be folded to -1."
msgstr ""

#: ../../../LangRef.rst:2866
msgid ""
"This set of examples shows that undefined '``select``' (and conditional "
"branch) conditions can go *either way*, but they have to come from one of "
"the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were both "
"known to have a clear low bit, then ``%A`` would have to have a cleared low "
"bit. However, in the ``%C`` example, the optimizer is allowed to assume that "
"the '``undef``' operand could be the same as ``%Y``, allowing the whole "
"'``select``' to be eliminated."
msgstr ""

#: ../../../LangRef.rst:2893
msgid ""
"This example points out that two '``undef``' operands are not necessarily "
"the same. This can be surprising to people (and also matches C semantics) "
"where they assume that \"``X^X``\" is always zero, even if ``X`` is "
"undefined. This isn't true for a number of reasons, but the short answer is "
"that an '``undef``' \"variable\" can arbitrarily change its value over its "
"\"live range\". This is true because the variable doesn't actually *have a "
"live range*. Instead, the value is logically read from arbitrary registers "
"that happen to be around when needed, so the value is not necessarily "
"consistent over time. In fact, ``%A`` and ``%C`` need to have the same "
"semantics or the core LLVM \"replace all uses with\" concept would not hold."
msgstr ""

#: ../../../LangRef.rst:2913
msgid ""
"These examples show the crucial difference between an *undefined value* and "
"*undefined behavior*. An undefined value (like '``undef``') is allowed to "
"have an arbitrary bit-pattern. This means that the ``%A`` operation can be "
"constant folded to '``undef``', because the '``undef``' could be an SNaN, "
"and ``fdiv`` is not (currently) defined on SNaN's. However, in the second "
"example, we can make a more aggressive assumption: because the ``undef`` is "
"allowed to be an arbitrary value, we are allowed to assume that it could be "
"zero. Since a divide by zero has *undefined behavior*, we are allowed to "
"assume that the operation does not execute at all. This allows us to delete "
"the divide and all code after it. Because the undefined operation \"can't "
"happen\", the optimizer can assume that it occurs in dead code."
msgstr ""

#: ../../../LangRef.rst:2934
msgid ""
"These examples reiterate the ``fdiv`` example: a store *of* an undefined "
"value can be assumed to not have any effect; we can assume that the value is "
"overwritten with bits that happen to match what was already there. However, "
"a store *to* an undefined location could clobber arbitrary memory, "
"therefore, it has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:2943
msgid "Poison Values"
msgstr ""

#: ../../../LangRef.rst:2945
msgid ""
"Poison values are similar to :ref:`undef values <undefvalues>`, however they "
"also represent the fact that an instruction or constant expression that "
"cannot evoke side effects has nevertheless detected a condition that results "
"in undefined behavior."
msgstr ""

#: ../../../LangRef.rst:2950
msgid ""
"There is currently no way of representing a poison value in the IR; they "
"only exist when produced by operations such as :ref:`add <i_add>` with the "
"``nsw`` flag."
msgstr ""

#: ../../../LangRef.rst:2954
msgid "Poison value behavior is defined in terms of value *dependence*:"
msgstr ""

#: ../../../LangRef.rst:2956
msgid "Values other than :ref:`phi <i_phi>` nodes depend on their operands."
msgstr ""

#: ../../../LangRef.rst:2957
msgid ""
":ref:`Phi <i_phi>` nodes depend on the operand corresponding to their "
"dynamic predecessor basic block."
msgstr ""

#: ../../../LangRef.rst:2959
msgid ""
"Function arguments depend on the corresponding actual argument values in the "
"dynamic callers of their functions."
msgstr ""

#: ../../../LangRef.rst:2961
msgid ""
":ref:`Call <i_call>` instructions depend on the :ref:`ret <i_ret>` "
"instructions that dynamically transfer control back to them."
msgstr ""

#: ../../../LangRef.rst:2963
msgid ""
":ref:`Invoke <i_invoke>` instructions depend on the :ref:`ret <i_ret>`, :ref:"
"`resume <i_resume>`, or exception-throwing call instructions that "
"dynamically transfer control back to them."
msgstr ""

#: ../../../LangRef.rst:2966
msgid ""
"Non-volatile loads and stores depend on the most recent stores to all of the "
"referenced memory addresses, following the order in the IR (including loads "
"and stores implied by intrinsics such as :ref:`@llvm.memcpy <int_memcpy>`.)"
msgstr ""

#: ../../../LangRef.rst:2970
msgid ""
"An instruction with externally visible side effects depends on the most "
"recent preceding instruction with externally visible side effects, following "
"the order in the IR. (This includes :ref:`volatile operations <volatile>`.)"
msgstr ""

#: ../../../LangRef.rst:2974
msgid ""
"An instruction *control-depends* on a :ref:`terminator instruction "
"<terminators>` if the terminator instruction has multiple successors and the "
"instruction is always executed when control transfers to one of the "
"successors, and may not be executed when control is transferred to another."
msgstr ""

#: ../../../LangRef.rst:2979
msgid ""
"Additionally, an instruction also *control-depends* on a terminator "
"instruction if the set of instructions it otherwise depends on would be "
"different if the terminator had transferred control to a different successor."
msgstr ""

#: ../../../LangRef.rst:2983
msgid "Dependence is transitive."
msgstr ""

#: ../../../LangRef.rst:2985
msgid ""
"Poison values have the same behavior as :ref:`undef values <undefvalues>`, "
"with the additional effect that any instruction that has a *dependence* on a "
"poison value has undefined behavior."
msgstr ""

#: ../../../LangRef.rst:2989
msgid "Here are some examples:"
msgstr ""

#: ../../../LangRef.rst:3045
msgid "Addresses of Basic Blocks"
msgstr ""

#: ../../../LangRef.rst:3047
msgid "``blockaddress(@function, %block)``"
msgstr ""

#: ../../../LangRef.rst:3049
msgid ""
"The '``blockaddress``' constant computes the address of the specified basic "
"block in the specified function, and always has an ``i8*`` type. Taking the "
"address of the entry block is illegal."
msgstr ""

#: ../../../LangRef.rst:3053
msgid ""
"This value only has defined behavior when used as an operand to the ':ref:"
"`indirectbr <i_indirectbr>`' instruction, or for comparisons against null. "
"Pointer equality tests between labels addresses results in undefined "
"behavior --- though, again, comparison against null is ok, and no label is "
"equal to the null pointer. This may be passed around as an opaque pointer "
"sized value as long as the bits are not inspected. This allows ``ptrtoint`` "
"and arithmetic to be performed on these values so long as the original value "
"is reconstituted before the ``indirectbr`` instruction."
msgstr ""

#: ../../../LangRef.rst:3063
msgid ""
"Finally, some targets may provide defined semantics when using the value as "
"the operand to an inline assembly, but that is target specific."
msgstr ""

#: ../../../LangRef.rst:3069
msgid "Constant Expressions"
msgstr ""

#: ../../../LangRef.rst:3071
msgid ""
"Constant expressions are used to allow expressions involving other constants "
"to be used as constants. Constant expressions may be of any :ref:`first "
"class <t_firstclass>` type and may involve any LLVM operation that does not "
"have side effects (e.g. load and call are not supported). The following is "
"the syntax for constant expressions:"
msgstr ""

#: ../../../LangRef.rst:3078
msgid "``trunc (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3078
msgid ""
"Truncate a constant to another type. The bit size of CST must be larger than "
"the bit size of TYPE. Both types must be integers."
msgstr ""

#: ../../../LangRef.rst:3081
msgid "``zext (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3081
msgid ""
"Zero extend a constant to another type. The bit size of CST must be smaller "
"than the bit size of TYPE. Both types must be integers."
msgstr ""

#: ../../../LangRef.rst:3084
msgid "``sext (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3084
msgid ""
"Sign extend a constant to another type. The bit size of CST must be smaller "
"than the bit size of TYPE. Both types must be integers."
msgstr ""

#: ../../../LangRef.rst:3088
msgid "``fptrunc (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3087
msgid ""
"Truncate a floating point constant to another floating point type. The size "
"of CST must be larger than the size of TYPE. Both types must be floating "
"point."
msgstr ""

#: ../../../LangRef.rst:3092
msgid "``fpext (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3091
msgid ""
"Floating point extend a constant to another type. The size of CST must be "
"smaller or equal to the size of TYPE. Both types must be floating point."
msgstr ""

#: ../../../LangRef.rst:3098
msgid "``fptoui (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3095
msgid ""
"Convert a floating point constant to the corresponding unsigned integer "
"constant. TYPE must be a scalar or vector integer type. CST must be of "
"scalar or vector floating point type. Both CST and TYPE must be scalars, or "
"vectors of the same number of elements. If the value won't fit in the "
"integer type, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:3104
msgid "``fptosi (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3101
msgid ""
"Convert a floating point constant to the corresponding signed integer "
"constant. TYPE must be a scalar or vector integer type. CST must be of "
"scalar or vector floating point type. Both CST and TYPE must be scalars, or "
"vectors of the same number of elements. If the value won't fit in the "
"integer type, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:3110
msgid "``uitofp (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3107
msgid ""
"Convert an unsigned integer constant to the corresponding floating point "
"constant. TYPE must be a scalar or vector floating point type. CST must be "
"of scalar or vector integer type. Both CST and TYPE must be scalars, or "
"vectors of the same number of elements. If the value won't fit in the "
"floating point type, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:3116
msgid "``sitofp (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3113
msgid ""
"Convert a signed integer constant to the corresponding floating point "
"constant. TYPE must be a scalar or vector floating point type. CST must be "
"of scalar or vector integer type. Both CST and TYPE must be scalars, or "
"vectors of the same number of elements. If the value won't fit in the "
"floating point type, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:3121
msgid "``ptrtoint (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3119
msgid ""
"Convert a pointer typed constant to the corresponding integer constant. "
"``TYPE`` must be an integer type. ``CST`` must be of pointer type. The "
"``CST`` value is zero extended, truncated, or unchanged to make it fit in "
"``TYPE``."
msgstr ""

#: ../../../LangRef.rst:3126
msgid "``inttoptr (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3124
msgid ""
"Convert an integer constant to a pointer constant. TYPE must be a pointer "
"type. CST must be of integer type. The CST value is zero extended, "
"truncated, or unchanged to make it fit in a pointer size. This one is "
"*really* dangerous!"
msgstr ""

#: ../../../LangRef.rst:3130
msgid "``bitcast (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3129
msgid ""
"Convert a constant, CST, to another TYPE. The constraints of the operands "
"are the same as those for the :ref:`bitcast instruction <i_bitcast>`."
msgstr ""

#: ../../../LangRef.rst:3134
msgid "``addrspacecast (CST to TYPE)``"
msgstr ""

#: ../../../LangRef.rst:3133
msgid ""
"Convert a constant pointer or constant vector of pointer, CST, to another "
"TYPE in a different address space. The constraints of the operands are the "
"same as those for the :ref:`addrspacecast instruction <i_addrspacecast>`."
msgstr ""

#: ../../../LangRef.rst:3139
msgid ""
"``getelementptr (TY, CSTPTR, IDX0, IDX1, ...)``, ``getelementptr inbounds "
"(TY, CSTPTR, IDX0, IDX1, ...)``"
msgstr ""

#: ../../../LangRef.rst:3137
msgid ""
"Perform the :ref:`getelementptr operation <i_getelementptr>` on constants. "
"As with the :ref:`getelementptr <i_getelementptr>` instruction, the index "
"list may have zero or more indexes, which are required to make sense for the "
"type of \"pointer to TY\"."
msgstr ""

#: ../../../LangRef.rst:3141
msgid "``select (COND, VAL1, VAL2)``"
msgstr ""

#: ../../../LangRef.rst:3142
msgid "Perform the :ref:`select operation <i_select>` on constants."
msgstr ""

#: ../../../LangRef.rst:3143
msgid "``icmp COND (VAL1, VAL2)``"
msgstr ""

#: ../../../LangRef.rst:3144
msgid "Performs the :ref:`icmp operation <i_icmp>` on constants."
msgstr ""

#: ../../../LangRef.rst:3145
msgid "``fcmp COND (VAL1, VAL2)``"
msgstr ""

#: ../../../LangRef.rst:3146
msgid "Performs the :ref:`fcmp operation <i_fcmp>` on constants."
msgstr ""

#: ../../../LangRef.rst:3148
msgid "``extractelement (VAL, IDX)``"
msgstr ""

#: ../../../LangRef.rst:3148
msgid ""
"Perform the :ref:`extractelement operation <i_extractelement>` on constants."
msgstr ""

#: ../../../LangRef.rst:3151
msgid "``insertelement (VAL, ELT, IDX)``"
msgstr ""

#: ../../../LangRef.rst:3151
msgid ""
"Perform the :ref:`insertelement operation <i_insertelement>` on constants."
msgstr ""

#: ../../../LangRef.rst:3154
msgid "``shufflevector (VEC1, VEC2, IDXMASK)``"
msgstr ""

#: ../../../LangRef.rst:3154
msgid ""
"Perform the :ref:`shufflevector operation <i_shufflevector>` on constants."
msgstr ""

#: ../../../LangRef.rst:3159
msgid "``extractvalue (VAL, IDX0, IDX1, ...)``"
msgstr ""

#: ../../../LangRef.rst:3157
msgid ""
"Perform the :ref:`extractvalue operation <i_extractvalue>` on constants. The "
"index list is interpreted in a similar manner as indices in a ':ref:"
"`getelementptr <i_getelementptr>`' operation. At least one index value must "
"be specified."
msgstr ""

#: ../../../LangRef.rst:3164
msgid "``insertvalue (VAL, ELT, IDX0, IDX1, ...)``"
msgstr ""

#: ../../../LangRef.rst:3162
msgid ""
"Perform the :ref:`insertvalue operation <i_insertvalue>` on constants. The "
"index list is interpreted in a similar manner as indices in a ':ref:"
"`getelementptr <i_getelementptr>`' operation. At least one index value must "
"be specified."
msgstr ""

#: ../../../LangRef.rst:3171
msgid "``OPCODE (LHS, RHS)``"
msgstr ""

#: ../../../LangRef.rst:3167
msgid ""
"Perform the specified operation of the LHS and RHS constants. OPCODE may be "
"any of the :ref:`binary <binaryops>` or :ref:`bitwise binary <bitwiseops>` "
"operations. The constraints on operands are the same as those for the "
"corresponding instruction (e.g. no bitwise operations on floating point "
"values are allowed)."
msgstr ""

#: ../../../LangRef.rst:3174
msgid "Other Values"
msgstr ""

#: ../../../LangRef.rst:3179
msgid "Inline Assembler Expressions"
msgstr ""

#: ../../../LangRef.rst:3181
msgid ""
"LLVM supports inline assembler expressions (as opposed to :ref:`Module-Level "
"Inline Assembly <moduleasm>`) through the use of a special value. This value "
"represents the inline assembler as a template string (containing the "
"instructions to emit), a list of operand constraints (stored as a string), a "
"flag that indicates whether or not the inline asm expression has side "
"effects, and a flag indicating whether the function containing the asm needs "
"to align its stack conservatively."
msgstr ""

#: ../../../LangRef.rst:3189
msgid ""
"The template string supports argument substitution of the operands using "
"\"``$``\" followed by a number, to indicate substitution of the given "
"register/memory location, as specified by the constraint string. \"``${NUM:"
"MODIFIER}``\" may also be used, where ``MODIFIER`` is a target-specific "
"annotation for how to print the operand (See :ref:`inline-asm-modifiers`)."
msgstr ""

#: ../../../LangRef.rst:3195
msgid ""
"A literal \"``$``\" may be included by using \"``$$``\" in the template. To "
"include other special characters into the output, the usual \"``\\XX``\" "
"escapes may be used, just as in other strings. Note that after template "
"substitution, the resulting assembly string is parsed by LLVM's integrated "
"assembler unless it is disabled -- even when emitting a ``.s`` file -- and "
"thus must contain assembly syntax known to LLVM."
msgstr ""

#: ../../../LangRef.rst:3202
msgid ""
"LLVM's support for inline asm is modeled closely on the requirements of "
"Clang's GCC-compatible inline-asm support. Thus, the feature-set and the "
"constraint and modifier codes listed here are similar or identical to those "
"in GCC's inline asm support. However, to be clear, the syntax of the "
"template and constraint strings described here is *not* the same as the "
"syntax accepted by GCC and Clang, and, while most constraint letters are "
"passed through as-is by Clang, some get translated to other codes when "
"converting from the C source to the LLVM assembly."
msgstr ""

#: ../../../LangRef.rst:3211
msgid "An example inline assembler expression is:"
msgstr ""

#: ../../../LangRef.rst:3217
msgid ""
"Inline assembler expressions may **only** be used as the callee operand of "
"a :ref:`call <i_call>` or an :ref:`invoke <i_invoke>` instruction. Thus, "
"typically we have:"
msgstr ""

#: ../../../LangRef.rst:3225
msgid ""
"Inline asms with side effects not visible in the constraint list must be "
"marked as having side effects. This is done through the use of the "
"'``sideeffect``' keyword, like so:"
msgstr ""

#: ../../../LangRef.rst:3233
msgid ""
"In some cases inline asms will contain code that will not work unless the "
"stack is aligned in some way, such as calls or SSE instructions on x86, yet "
"will not contain code that does that alignment within the asm. The compiler "
"should make conservative assumptions about what the asm might contain and "
"should generate its usual stack alignment code in the prologue if the "
"'``alignstack``' keyword is present:"
msgstr ""

#: ../../../LangRef.rst:3244
msgid ""
"Inline asms also support using non-standard assembly dialects. The assumed "
"dialect is ATT. When the '``inteldialect``' keyword is present, the inline "
"asm is using the Intel dialect. Currently, ATT and Intel are the only "
"supported dialects. An example is:"
msgstr ""

#: ../../../LangRef.rst:3253
msgid ""
"If multiple keywords appear the '``sideeffect``' keyword must come first, "
"the '``alignstack``' keyword second and the '``inteldialect``' keyword last."
msgstr ""

#: ../../../LangRef.rst:3258
msgid "Inline Asm Constraint String"
msgstr ""

#: ../../../LangRef.rst:3260
msgid ""
"The constraint list is a comma-separated string, each element containing one "
"or more constraint codes."
msgstr ""

#: ../../../LangRef.rst:3263
msgid ""
"For each element in the constraint list an appropriate register or memory "
"operand will be chosen, and it will be made available to assembly template "
"string expansion as ``$0`` for the first constraint in the list, ``$1`` for "
"the second, etc."
msgstr ""

#: ../../../LangRef.rst:3268
msgid ""
"There are three different types of constraints, which are distinguished by a "
"prefix symbol in front of the constraint code: Output, Input, and Clobber. "
"The constraints must always be given in that order: outputs first, then "
"inputs, then clobbers. They cannot be intermingled."
msgstr ""

#: ../../../LangRef.rst:3273
msgid "There are also three different categories of constraint codes:"
msgstr ""

#: ../../../LangRef.rst:3275
msgid ""
"Register constraint. This is either a register class, or a fixed physical "
"register. This kind of constraint will allocate a register, and if "
"necessary, bitcast the argument or result to the appropriate type."
msgstr ""

#: ../../../LangRef.rst:3278
msgid ""
"Memory constraint. This kind of constraint is for use with an instruction "
"taking a memory operand. Different constraints allow for different "
"addressing modes used by the target."
msgstr ""

#: ../../../LangRef.rst:3281
msgid ""
"Immediate value constraint. This kind of constraint is for an integer or "
"other immediate value which can be rendered directly into an instruction. "
"The various target-specific constraints allow the selection of a value in "
"the proper range for the instruction you wish to use it with."
msgstr ""

#: ../../../LangRef.rst:3287
msgid "Output constraints"
msgstr ""

#: ../../../LangRef.rst:3289
msgid ""
"Output constraints are specified by an \"``=``\" prefix (e.g. \"``=r``\"). "
"This indicates that the assembly will write to this operand, and the operand "
"will then be made available as a return value of the ``asm`` expression. "
"Output constraints do not consume an argument from the call instruction. "
"(Except, see below about indirect outputs)."
msgstr ""

#: ../../../LangRef.rst:3295
msgid ""
"Normally, it is expected that no output locations are written to by the "
"assembly expression until *all* of the inputs have been read. As such, LLVM "
"may assign the same register to an output and an input. If this is not safe "
"(e.g. if the assembly contains two instructions, where the first writes to "
"one output, and the second reads an input and writes to a second output), "
"then the \"``&``\" modifier must be used (e.g. \"``=&r``\") to specify that "
"the output is an \"early-clobber\" output. Marking an output as \"early-"
"clobber\" ensures that LLVM will not use the same register for any inputs "
"(other than an input tied to this output)."
msgstr ""

#: ../../../LangRef.rst:3306
msgid "Input constraints"
msgstr ""

#: ../../../LangRef.rst:3308
msgid ""
"Input constraints do not have a prefix -- just the constraint codes. Each "
"input constraint will consume one argument from the call instruction. It is "
"not permitted for the asm to write to any input register or memory location "
"(unless that input is tied to an output). Note also that multiple inputs may "
"all be assigned to the same register, if LLVM can determine that they "
"necessarily all contain the same value."
msgstr ""

#: ../../../LangRef.rst:3315
msgid ""
"Instead of providing a Constraint Code, input constraints may also \"tie\" "
"themselves to an output constraint, by providing an integer as the "
"constraint string. Tied inputs still consume an argument from the call "
"instruction, and take up a position in the asm template numbering as is "
"usual -- they will simply be constrained to always use the same register as "
"the output they've been tied to. For example, a constraint string of "
"\"``=r,0``\" says to assign a register for output, and use that register as "
"an input as well (it being the 0'th constraint)."
msgstr ""

#: ../../../LangRef.rst:3324
msgid ""
"It is permitted to tie an input to an \"early-clobber\" output. In that "
"case, no *other* input may share the same register as the input tied to the "
"early-clobber (even when the other input has the same value)."
msgstr ""

#: ../../../LangRef.rst:3328
msgid ""
"You may only tie an input to an output which has a register constraint, not "
"a memory constraint. Only a single input may be tied to an output."
msgstr ""

#: ../../../LangRef.rst:3331
msgid ""
"There is also an \"interesting\" feature which deserves a bit of "
"explanation: if a register class constraint allocates a register which is "
"too small for the value type operand provided as input, the input value will "
"be split into multiple registers, and all of them passed to the inline asm."
msgstr ""

#: ../../../LangRef.rst:3336
msgid "However, this feature is often not as useful as you might think."
msgstr ""

#: ../../../LangRef.rst:3338
msgid ""
"Firstly, the registers are *not* guaranteed to be consecutive. So, on those "
"architectures that have instructions which operate on multiple consecutive "
"instructions, this is not an appropriate way to support them. (e.g. the 32-"
"bit SparcV8 has a 64-bit load, which instruction takes a single 32-bit "
"register. The hardware then loads into both the named register, and the next "
"register. This feature of inline asm would not be useful to support that.)"
msgstr ""

#: ../../../LangRef.rst:3345
msgid ""
"A few of the targets provide a template string modifier allowing explicit "
"access to the second register of a two-register operand (e.g. MIPS ``L``, "
"``M``, and ``D``). On such an architecture, you can actually access the "
"second allocated register (yet, still, not any subsequent ones). But, in "
"that case, you're still probably better off simply splitting the value into "
"two separate operands, for clarity. (e.g. see the description of the ``A`` "
"constraint on X86, which, despite existing only for use with this feature, "
"is not really a good idea to use)"
msgstr ""

#: ../../../LangRef.rst:3355
msgid "Indirect inputs and outputs"
msgstr ""

#: ../../../LangRef.rst:3357
msgid ""
"Indirect output or input constraints can be specified by the \"``*``\" "
"modifier (which goes after the \"``=``\" in case of an output). This "
"indicates that the asm will write to or read from the contents of an "
"*address* provided as an input argument. (Note that in this way, indirect "
"outputs act more like an *input* than an output: just like an input, they "
"consume an argument of the call expression, rather than producing a return "
"value. An indirect output constraint is an \"output\" only in that the asm "
"is expected to write to the contents of the input memory location, instead "
"of just read from it)."
msgstr ""

#: ../../../LangRef.rst:3366
msgid ""
"This is most typically used for memory constraint, e.g. \"``=*m``\", to pass "
"the address of a variable as a value."
msgstr ""

#: ../../../LangRef.rst:3369
msgid ""
"It is also possible to use an indirect *register* constraint, but only on "
"output (e.g. \"``=*r``\"). This will cause LLVM to allocate a register for "
"an output value normally, and then, separately emit a store to the address "
"provided as input, after the provided inline asm. (It's not clear what value "
"this functionality provides, compared to writing the store explicitly after "
"the asm statement, and it can only produce worse code, since it bypasses "
"many optimization passes. I would recommend not using it.)"
msgstr ""

#: ../../../LangRef.rst:3379
msgid "Clobber constraints"
msgstr ""

#: ../../../LangRef.rst:3381
msgid ""
"A clobber constraint is indicated by a \"``~``\" prefix. A clobber does not "
"consume an input operand, nor generate an output. Clobbers cannot use any of "
"the general constraint code letters -- they may use only explicit register "
"constraints, e.g. \"``~{eax}``\". The one exception is that a clobber string "
"of \"``~{memory}``\" indicates that the assembly writes to arbitrary "
"undeclared memory locations -- not only the memory pointed to by a declared "
"indirect output."
msgstr ""

#: ../../../LangRef.rst:3389
msgid ""
"Note that clobbering named registers that are also present in output "
"constraints is not legal."
msgstr ""

#: ../../../LangRef.rst:3394
msgid "Constraint Codes"
msgstr ""

#: ../../../LangRef.rst:3395
msgid "After a potential prefix comes constraint code, or codes."
msgstr ""

#: ../../../LangRef.rst:3397
msgid ""
"A Constraint Code is either a single letter (e.g. \"``r``\"), a \"``^``\" "
"character followed by two letters (e.g. \"``^wc``\"), or \"``{``\" register-"
"name \"``}``\" (e.g. \"``{eax}``\")."
msgstr ""

#: ../../../LangRef.rst:3401
msgid ""
"The one and two letter constraint codes are typically chosen to be the same "
"as GCC's constraint codes."
msgstr ""

#: ../../../LangRef.rst:3404
msgid ""
"A single constraint may include one or more than constraint code in it, "
"leaving it up to LLVM to choose which one to use. This is included mainly "
"for compatibility with the translation of GCC inline asm coming from clang."
msgstr ""

#: ../../../LangRef.rst:3408
msgid ""
"There are two ways to specify alternatives, and either or both may be used "
"in an inline asm constraint list:"
msgstr ""

#: ../../../LangRef.rst:3411
msgid ""
"Append the codes to each other, making a constraint code set. E.g. "
"\"``im``\" or \"``{eax}m``\". This means \"choose any of the options in the "
"set\". The choice of constraint is made independently for each constraint in "
"the constraint list."
msgstr ""

#: ../../../LangRef.rst:3416
msgid ""
"Use \"``|``\" between constraint code sets, creating alternatives. Every "
"constraint in the constraint list must have the same number of alternative "
"sets. With this syntax, the same alternative in *all* of the items in the "
"constraint list will be chosen together."
msgstr ""

#: ../../../LangRef.rst:3421
msgid ""
"Putting those together, you might have a two operand constraint string like "
"``\"rm|r,ri|rm\"``. This indicates that if operand 0 is ``r`` or ``m``, then "
"operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand "
"1 may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type "
"m."
msgstr ""

#: ../../../LangRef.rst:3426
msgid ""
"However, the use of either of the alternatives features is *NOT* "
"recommended, as LLVM is not able to make an intelligent choice about which "
"one to use. (At the point it currently needs to choose, not enough "
"information is available to do so in a smart way.) Thus, it simply tries to "
"make a choice that's most likely to compile, not one that will be optimal "
"performance. (e.g., given \"``rm``\", it'll always choose to use memory, not "
"registers). And, if given multiple registers, or multiple register classes, "
"it will simply choose the first one. (In fact, it doesn't currently even "
"ensure explicitly specified physical registers are unique, so specifying "
"multiple physical registers as alternatives, like ``{r11}{r12},{r11}{r12}``, "
"will assign r11 to both operands, not at all what was intended.)"
msgstr ""

#: ../../../LangRef.rst:3439
msgid "Supported Constraint Code List"
msgstr ""

#: ../../../LangRef.rst:3441
msgid ""
"The constraint codes are, in general, expected to behave the same way they "
"do in GCC. LLVM's support is often implemented on an 'as-needed' basis, to "
"support C inline asm code which was supported by GCC. A mismatch in behavior "
"between LLVM and GCC likely indicates a bug in LLVM."
msgstr ""

#: ../../../LangRef.rst:3446
msgid "Some constraint codes are typically supported by all targets:"
msgstr ""

#: ../../../LangRef.rst:3448
msgid "``r``: A register in the target's general purpose register class."
msgstr ""

#: ../../../LangRef.rst:3449
msgid ""
"``m``: A memory address operand. It is target-specific what addressing modes "
"are supported, typical examples are register, or register + register offset, "
"or register + immediate offset (of some target-specific size)."
msgstr ""

#: ../../../LangRef.rst:3452
msgid ""
"``i``: An integer constant (of target-specific width). Allows either a "
"simple immediate, or a relocatable value."
msgstr ""

#: ../../../LangRef.rst:3454
msgid "``n``: An integer constant -- *not* including relocatable values."
msgstr ""

#: ../../../LangRef.rst:3455
msgid "``s``: An integer constant, but allowing *only* relocatable values."
msgstr ""

#: ../../../LangRef.rst:3456
msgid ""
"``X``: Allows an operand of any kind, no constraint whatsoever. Typically "
"useful to pass a label for an asm branch or call."
msgstr ""

#: ../../../LangRef.rst:3462
msgid "``{register-name}``: Requires exactly the named physical register."
msgstr ""

#: ../../../LangRef.rst:3464
msgid "Other constraints are target-specific:"
msgstr ""

#: ../../../LangRef.rst:3466 ../../../LangRef.rst:3715
msgid "AArch64:"
msgstr ""

#: ../../../LangRef.rst:3468
msgid ""
"``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate."
msgstr ""

#: ../../../LangRef.rst:3469
msgid ""
"``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction, i."
"e. 0 to 4095 with optional shift by 12."
msgstr ""

#: ../../../LangRef.rst:3471
msgid ""
"``J``: An immediate integer that, when negated, is valid for an ``ADD`` or "
"``SUB`` instruction, i.e. -1 to -4095 with optional left shift by 12."
msgstr ""

#: ../../../LangRef.rst:3473
msgid ""
"``K``: An immediate integer that is valid for the 'bitmask immediate 32' of "
"a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 32-bit "
"register."
msgstr ""

#: ../../../LangRef.rst:3475
msgid ""
"``L``: An immediate integer that is valid for the 'bitmask immediate 64' of "
"a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 64-bit "
"register."
msgstr ""

#: ../../../LangRef.rst:3477
msgid ""
"``M``: An immediate integer for use with the ``MOV`` assembly alias on a 32-"
"bit register. This is a superset of ``K``: in addition to the bitmask "
"immediate, also allows immediate integers which can be loaded with a single "
"``MOVZ`` or ``MOVL`` instruction."
msgstr ""

#: ../../../LangRef.rst:3481
msgid ""
"``N``: An immediate integer for use with the ``MOV`` assembly alias on a 64-"
"bit register. This is a superset of ``L``."
msgstr ""

#: ../../../LangRef.rst:3483
msgid ""
"``Q``: Memory address operand must be in a single register (no offsets). "
"(However, LLVM currently does this for the ``m`` constraint as well.)"
msgstr ""

#: ../../../LangRef.rst:3486
msgid "``r``: A 32 or 64-bit integer register (W* or X*)."
msgstr ""

#: ../../../LangRef.rst:3487
msgid "``w``: A 32, 64, or 128-bit floating-point/SIMD register."
msgstr ""

#: ../../../LangRef.rst:3488
msgid ""
"``x``: A lower 128-bit floating-point/SIMD register (``V0`` to ``V15``)."
msgstr ""

#: ../../../LangRef.rst:3490 ../../../LangRef.rst:3724
msgid "AMDGPU:"
msgstr ""

#: ../../../LangRef.rst:3492 ../../../LangRef.rst:3607
msgid "``r``: A 32 or 64-bit integer register."
msgstr ""

#: ../../../LangRef.rst:3493
msgid "``[0-9]v``: The 32-bit VGPR register, number 0-9."
msgstr ""

#: ../../../LangRef.rst:3494
msgid "``[0-9]s``: The 32-bit SGPR register, number 0-9."
msgstr ""

#: ../../../LangRef.rst:3497
msgid "All ARM modes:"
msgstr ""

#: ../../../LangRef.rst:3499
msgid ""
"``Q``, ``Um``, ``Un``, ``Uq``, ``Us``, ``Ut``, ``Uv``, ``Uy``: Memory "
"address operand. Treated the same as operand ``m``, at the moment."
msgstr ""

#: ../../../LangRef.rst:3502
msgid "ARM and ARM's Thumb2 mode:"
msgstr ""

#: ../../../LangRef.rst:3504
msgid "``j``: An immediate integer between 0 and 65535 (valid for ``MOVW``)"
msgstr ""

#: ../../../LangRef.rst:3505
msgid "``I``: An immediate integer valid for a data-processing instruction."
msgstr ""

#: ../../../LangRef.rst:3506
msgid "``J``: An immediate integer between -4095 and 4095."
msgstr ""

#: ../../../LangRef.rst:3507
msgid ""
"``K``: An immediate integer whose bitwise inverse is valid for a data-"
"processing instruction. (Can be used with template modifier \"``B``\" to "
"print the inverted value)."
msgstr ""

#: ../../../LangRef.rst:3510
msgid ""
"``L``: An immediate integer whose negation is valid for a data-processing "
"instruction. (Can be used with template modifier \"``n``\" to print the "
"negated value)."
msgstr ""

#: ../../../LangRef.rst:3513
msgid "``M``: A power of two or a integer between 0 and 32."
msgstr ""

#: ../../../LangRef.rst:3514
msgid "``N``: Invalid immediate constraint."
msgstr ""

#: ../../../LangRef.rst:3515
msgid "``O``: Invalid immediate constraint."
msgstr ""

#: ../../../LangRef.rst:3516
msgid "``r``: A general-purpose 32-bit integer register (``r0-r15``)."
msgstr ""

#: ../../../LangRef.rst:3517
msgid ""
"``l``: In Thumb2 mode, low 32-bit GPR registers (``r0-r7``). In ARM mode, "
"same as ``r``."
msgstr ""

#: ../../../LangRef.rst:3519
msgid ""
"``h``: In Thumb2 mode, a high 32-bit GPR register (``r8-r15``). In ARM mode, "
"invalid."
msgstr ""

#: ../../../LangRef.rst:3521 ../../../LangRef.rst:3541
msgid ""
"``w``: A 32, 64, or 128-bit floating-point/SIMD register: ``s0-s31``, ``d0-"
"d31``, or ``q0-q15``."
msgstr ""

#: ../../../LangRef.rst:3523 ../../../LangRef.rst:3543
msgid ""
"``x``: A 32, 64, or 128-bit floating-point/SIMD register: ``s0-s15``, ``d0-"
"d7``, or ``q0-q3``."
msgstr ""

#: ../../../LangRef.rst:3525 ../../../LangRef.rst:3545
msgid ""
"``t``: A floating-point/SIMD register, only supports 32-bit values: ``s0-"
"s31``."
msgstr ""

#: ../../../LangRef.rst:3528
msgid "ARM's Thumb1 mode:"
msgstr ""

#: ../../../LangRef.rst:3530
msgid "``I``: An immediate integer between 0 and 255."
msgstr ""

#: ../../../LangRef.rst:3531
msgid "``J``: An immediate integer between -255 and -1."
msgstr ""

#: ../../../LangRef.rst:3532
msgid ""
"``K``: An immediate integer between 0 and 255, with optional left-shift by "
"some amount."
msgstr ""

#: ../../../LangRef.rst:3534
msgid "``L``: An immediate integer between -7 and 7."
msgstr ""

#: ../../../LangRef.rst:3535
msgid ""
"``M``: An immediate integer which is a multiple of 4 between 0 and 1020."
msgstr ""

#: ../../../LangRef.rst:3536
msgid "``N``: An immediate integer between 0 and 31."
msgstr ""

#: ../../../LangRef.rst:3537
msgid ""
"``O``: An immediate integer which is a multiple of 4 between -508 and 508."
msgstr ""

#: ../../../LangRef.rst:3538
msgid "``r``: A low 32-bit GPR register (``r0-r7``)."
msgstr ""

#: ../../../LangRef.rst:3539
msgid "``l``: A low 32-bit GPR register (``r0-r7``)."
msgstr ""

#: ../../../LangRef.rst:3540
msgid "``h``: A high GPR register (``r0-r7``)."
msgstr ""

#: ../../../LangRef.rst:3549 ../../../LangRef.rst:3757
msgid "Hexagon:"
msgstr ""

#: ../../../LangRef.rst:3551
msgid ""
"``o``, ``v``: A memory address operand, treated the same as constraint "
"``m``, at the moment."
msgstr ""

#: ../../../LangRef.rst:3553
msgid "``r``: A 32 or 64-bit register."
msgstr ""

#: ../../../LangRef.rst:3555 ../../../LangRef.rst:3768
msgid "MSP430:"
msgstr ""

#: ../../../LangRef.rst:3557
msgid "``r``: An 8 or 16-bit register."
msgstr ""

#: ../../../LangRef.rst:3559 ../../../LangRef.rst:3772
msgid "MIPS:"
msgstr ""

#: ../../../LangRef.rst:3561 ../../../LangRef.rst:3596
msgid "``I``: An immediate signed 16-bit integer."
msgstr ""

#: ../../../LangRef.rst:3562
msgid "``J``: An immediate integer zero."
msgstr ""

#: ../../../LangRef.rst:3563 ../../../LangRef.rst:3598
msgid "``K``: An immediate unsigned 16-bit integer."
msgstr ""

#: ../../../LangRef.rst:3564
msgid "``L``: An immediate 32-bit integer, where the lower 16 bits are 0."
msgstr ""

#: ../../../LangRef.rst:3565
msgid "``N``: An immediate integer between -65535 and -1."
msgstr ""

#: ../../../LangRef.rst:3566
msgid "``O``: An immediate signed 15-bit integer."
msgstr ""

#: ../../../LangRef.rst:3567
msgid "``P``: An immediate integer between 1 and 65535."
msgstr ""

#: ../../../LangRef.rst:3568
msgid ""
"``m``: A memory address operand. In MIPS-SE mode, allows a base address "
"register plus 16-bit immediate offset. In MIPS mode, just a base register."
msgstr ""

#: ../../../LangRef.rst:3570
msgid ""
"``R``: A memory address operand. In MIPS-SE mode, allows a base address "
"register plus a 9-bit signed offset. In MIPS mode, the same as constraint "
"``m``."
msgstr ""

#: ../../../LangRef.rst:3573
msgid ""
"``ZC``: A memory address operand, suitable for use in a ``pref``, ``ll``, or "
"``sc`` instruction on the given subtarget (details vary)."
msgstr ""

#: ../../../LangRef.rst:3575
msgid "``r``, ``d``,  ``y``: A 32 or 64-bit GPR register."
msgstr ""

#: ../../../LangRef.rst:3576
msgid ""
"``f``: A 32 or 64-bit FPU register (``F0-F31``), or a 128-bit MSA register "
"(``W0-W31``). In the case of MSA registers, it is recommended to use the "
"``w`` argument modifier for compatibility with GCC."
msgstr ""

#: ../../../LangRef.rst:3579
msgid ""
"``c``: A 32-bit or 64-bit GPR register suitable for indirect jump (always "
"``25``)."
msgstr ""

#: ../../../LangRef.rst:3581
msgid "``l``: The ``lo`` register, 32 or 64-bit."
msgstr ""

#: ../../../LangRef.rst:3582
msgid "``x``: Invalid."
msgstr ""

#: ../../../LangRef.rst:3584 ../../../LangRef.rst:3797
msgid "NVPTX:"
msgstr ""

#: ../../../LangRef.rst:3586
msgid "``b``: A 1-bit integer register."
msgstr ""

#: ../../../LangRef.rst:3587
msgid "``c`` or ``h``: A 16-bit integer register."
msgstr ""

#: ../../../LangRef.rst:3588 ../../../LangRef.rst:3629
#: ../../../LangRef.rst:3690
msgid "``r``: A 32-bit integer register."
msgstr ""

#: ../../../LangRef.rst:3589
msgid "``l`` or ``N``: A 64-bit integer register."
msgstr ""

#: ../../../LangRef.rst:3590
msgid "``f``: A 32-bit float register."
msgstr ""

#: ../../../LangRef.rst:3591
msgid "``d``: A 64-bit float register."
msgstr ""

#: ../../../LangRef.rst:3594 ../../../LangRef.rst:3801
msgid "PowerPC:"
msgstr ""

#: ../../../LangRef.rst:3597
msgid "``J``: An immediate unsigned 16-bit integer, shifted left 16 bits."
msgstr ""

#: ../../../LangRef.rst:3599
msgid "``L``: An immediate signed 16-bit integer, shifted left 16 bits."
msgstr ""

#: ../../../LangRef.rst:3600
msgid "``M``: An immediate integer greater than 31."
msgstr ""

#: ../../../LangRef.rst:3601
msgid "``N``: An immediate integer that is an exact power of 2."
msgstr ""

#: ../../../LangRef.rst:3602
msgid "``O``: The immediate integer constant 0."
msgstr ""

#: ../../../LangRef.rst:3603
msgid ""
"``P``: An immediate integer constant whose negation is a signed 16-bit "
"constant."
msgstr ""

#: ../../../LangRef.rst:3605
msgid ""
"``es``, ``o``, ``Q``, ``Z``, ``Zy``: A memory address operand, currently "
"treated the same as ``m``."
msgstr ""

#: ../../../LangRef.rst:3608
msgid ""
"``b``: A 32 or 64-bit integer register, excluding ``R0`` (that is: ``R1-"
"R31``)."
msgstr ""

#: ../../../LangRef.rst:3610
msgid ""
"``f``: A 32 or 64-bit float register (``F0-F31``), or when QPX is enabled, a "
"128 or 256-bit QPX register (``Q0-Q31``; aliases the ``F`` registers)."
msgstr ""

#: ../../../LangRef.rst:3612
msgid ""
"``v``: For ``4 x f32`` or ``4 x f64`` types, when QPX is enabled, a 128 or "
"256-bit QPX register (``Q0-Q31``), otherwise a 128-bit altivec vector "
"register (``V0-V31``)."
msgstr ""

#: ../../../LangRef.rst:3619
msgid "``y``: Condition register (``CR0-CR7``)."
msgstr ""

#: ../../../LangRef.rst:3620
msgid "``wc``: An individual CR bit in a CR register."
msgstr ""

#: ../../../LangRef.rst:3621
msgid ""
"``wa``, ``wd``, ``wf``: Any 128-bit VSX vector register, from the full VSX "
"register set (overlapping both the floating-point and vector register files)."
msgstr ""

#: ../../../LangRef.rst:3623
msgid ""
"``ws``: A 32 or 64-bit floating point register, from the full VSX register "
"set."
msgstr ""

#: ../../../LangRef.rst:3626 ../../../LangRef.rst:3819
msgid "Sparc:"
msgstr ""

#: ../../../LangRef.rst:3628
msgid "``I``: An immediate 13-bit signed integer."
msgstr ""

#: ../../../LangRef.rst:3631 ../../../LangRef.rst:3823
msgid "SystemZ:"
msgstr ""

#: ../../../LangRef.rst:3633
msgid "``I``: An immediate unsigned 8-bit integer."
msgstr ""

#: ../../../LangRef.rst:3634
msgid "``J``: An immediate unsigned 12-bit integer."
msgstr ""

#: ../../../LangRef.rst:3635
msgid "``K``: An immediate signed 16-bit integer."
msgstr ""

#: ../../../LangRef.rst:3636
msgid "``L``: An immediate signed 20-bit integer."
msgstr ""

#: ../../../LangRef.rst:3637
msgid "``M``: An immediate integer 0x7fffffff."
msgstr ""

#: ../../../LangRef.rst:3638
msgid ""
"``Q``: A memory address operand with a base address and a 12-bit immediate "
"unsigned displacement."
msgstr ""

#: ../../../LangRef.rst:3640
msgid ""
"``R``: A memory address operand with a base address, a 12-bit immediate "
"unsigned displacement, and an index register."
msgstr ""

#: ../../../LangRef.rst:3642
msgid ""
"``S``: A memory address operand with a base address and a 20-bit immediate "
"signed displacement."
msgstr ""

#: ../../../LangRef.rst:3644
msgid ""
"``T``: A memory address operand with a base address, a 20-bit immediate "
"signed displacement, and an index register."
msgstr ""

#: ../../../LangRef.rst:3646
msgid "``r`` or ``d``: A 32, 64, or 128-bit integer register."
msgstr ""

#: ../../../LangRef.rst:3647
msgid ""
"``a``: A 32, 64, or 128-bit integer address register (excludes R0, which in "
"an address context evaluates as zero)."
msgstr ""

#: ../../../LangRef.rst:3649
msgid ""
"``h``: A 32-bit value in the high part of a 64bit data register (LLVM-"
"specific)"
msgstr ""

#: ../../../LangRef.rst:3651
msgid "``f``: A 32, 64, or 128-bit floating point register."
msgstr ""

#: ../../../LangRef.rst:3653 ../../../LangRef.rst:3828
msgid "X86:"
msgstr ""

#: ../../../LangRef.rst:3655
msgid "``I``: An immediate integer between 0 and 31."
msgstr ""

#: ../../../LangRef.rst:3656
msgid "``J``: An immediate integer between 0 and 64."
msgstr ""

#: ../../../LangRef.rst:3657
msgid "``K``: An immediate signed 8-bit integer."
msgstr ""

#: ../../../LangRef.rst:3658
msgid ""
"``L``: An immediate integer, 0xff or 0xffff or (in 64-bit mode only) "
"0xffffffff."
msgstr ""

#: ../../../LangRef.rst:3660
msgid "``M``: An immediate integer between 0 and 3."
msgstr ""

#: ../../../LangRef.rst:3661
msgid "``N``: An immediate unsigned 8-bit integer."
msgstr ""

#: ../../../LangRef.rst:3662
msgid "``O``: An immediate integer between 0 and 127."
msgstr ""

#: ../../../LangRef.rst:3663
msgid "``e``: An immediate 32-bit signed integer."
msgstr ""

#: ../../../LangRef.rst:3664
msgid "``Z``: An immediate 32-bit unsigned integer."
msgstr ""

#: ../../../LangRef.rst:3665
msgid "``o``, ``v``: Treated the same as ``m``, at the moment."
msgstr ""

#: ../../../LangRef.rst:3666
msgid ""
"``q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit "
"``l`` integer register. On X86-32, this is the ``a``, ``b``, ``c``, and "
"``d`` registers, and on X86-64, it is all of the integer registers."
msgstr ""

#: ../../../LangRef.rst:3669
msgid ""
"``Q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit "
"``h`` integer register. This is the ``a``, ``b``, ``c``, and ``d`` registers."
msgstr ""

#: ../../../LangRef.rst:3671
msgid "``r`` or ``l``: An 8, 16, 32, or 64-bit integer register."
msgstr ""

#: ../../../LangRef.rst:3672
msgid ""
"``R``: An 8, 16, 32, or 64-bit \"legacy\" integer register -- one which has "
"existed since i386, and can be accessed without the REX prefix."
msgstr ""

#: ../../../LangRef.rst:3674
msgid "``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register."
msgstr ""

#: ../../../LangRef.rst:3675
msgid "``y``: A 64-bit MMX register, if MMX is enabled."
msgstr ""

#: ../../../LangRef.rst:3676
msgid ""
"``x``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector "
"operand in a SSE register. If AVX is also enabled, can also be a 256-bit "
"vector operand in an AVX register. If AVX-512 is also enabled, can also be a "
"512-bit vector operand in an AVX512 register, Otherwise, an error."
msgstr ""

#: ../../../LangRef.rst:3680
msgid "``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error."
msgstr ""

#: ../../../LangRef.rst:3681
msgid ""
"``A``: Special case: allocates EAX first, then EDX, for a single operand (in "
"32-bit mode, a 64-bit integer operand will get split into two registers). It "
"is not recommended to use this constraint, as in 64-bit mode, the 64-bit "
"operand will get allocated only to RAX -- if two 32-bit operands are needed, "
"you're better off splitting it yourself, before passing it to the asm "
"statement."
msgstr ""

#: ../../../LangRef.rst:3688 ../../../LangRef.rst:3851
msgid "XCore:"
msgstr ""

#: ../../../LangRef.rst:3696
msgid "Asm template argument modifiers"
msgstr ""

#: ../../../LangRef.rst:3698
msgid ""
"In the asm template string, modifiers can be used on the operand reference, "
"like \"``${0:n}``\"."
msgstr ""

#: ../../../LangRef.rst:3701
msgid ""
"The modifiers are, in general, expected to behave the same way they do in "
"GCC. LLVM's support is often implemented on an 'as-needed' basis, to support "
"C inline asm code which was supported by GCC. A mismatch in behavior between "
"LLVM and GCC likely indicates a bug in LLVM."
msgstr ""

#: ../../../LangRef.rst:3706
msgid "Target-independent:"
msgstr ""

#: ../../../LangRef.rst:3708
msgid ""
"``c``: Print an immediate integer constant unadorned, without the target-"
"specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../../LangRef.rst:3710
msgid ""
"``n``: Negate and print immediate integer constant unadorned, without the "
"target-specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../../LangRef.rst:3712
msgid ""
"``l``: Print as an unadorned label, without the target-specific label "
"punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../../LangRef.rst:3717
msgid ""
"``w``: Print a GPR register with a ``w*`` name instead of ``x*`` name. E.g., "
"instead of ``x30``, print ``w30``."
msgstr ""

#: ../../../LangRef.rst:3719
msgid ""
"``x``: Print a GPR register with a ``x*`` name. (this is the default, "
"anyhow)."
msgstr ""

#: ../../../LangRef.rst:3720
msgid ""
"``b``, ``h``, ``s``, ``d``, ``q``: Print a floating-point/SIMD register with "
"a ``b*``, ``h*``, ``s*``, ``d*``, or ``q*`` name, rather than the default of "
"``v*``."
msgstr ""

#: ../../../LangRef.rst:3726 ../../../LangRef.rst:3799
#: ../../../LangRef.rst:3821
msgid "``r``: No effect."
msgstr ""

#: ../../../LangRef.rst:3728
msgid "ARM:"
msgstr ""

#: ../../../LangRef.rst:3730
msgid ""
"``a``: Print an operand as an address (with ``[`` and ``]`` surrounding a "
"register)."
msgstr ""

#: ../../../LangRef.rst:3732
msgid "``P``: No effect."
msgstr ""

#: ../../../LangRef.rst:3733
msgid "``q``: No effect."
msgstr ""

#: ../../../LangRef.rst:3734
msgid ""
"``y``: Print a VFP single-precision register as an indexed double (e.g. "
"print as ``d4[1]`` instead of ``s9``)"
msgstr ""

#: ../../../LangRef.rst:3736
msgid ""
"``B``: Bitwise invert and print an immediate integer constant without ``#`` "
"prefix."
msgstr ""

#: ../../../LangRef.rst:3738
msgid "``L``: Print the low 16-bits of an immediate integer constant."
msgstr ""

#: ../../../LangRef.rst:3739
msgid ""
"``M``: Print as a register set suitable for ldm/stm. Also prints *all* "
"register operands subsequent to the specified one (!), so use carefully."
msgstr ""

#: ../../../LangRef.rst:3741
msgid ""
"``Q``: Print the low-order register of a register-pair, or the low-order "
"register of a two-register operand."
msgstr ""

#: ../../../LangRef.rst:3743
msgid ""
"``R``: Print the high-order register of a register-pair, or the high-order "
"register of a two-register operand."
msgstr ""

#: ../../../LangRef.rst:3745
msgid ""
"``H``: Print the second register of a register-pair. (On a big-endian "
"system, ``H`` is equivalent to ``Q``, and on little-endian system, ``H`` is "
"equivalent to ``R``.)"
msgstr ""

#: ../../../LangRef.rst:3752
msgid "``e``: Print the low doubleword register of a NEON quad register."
msgstr ""

#: ../../../LangRef.rst:3753
msgid "``f``: Print the high doubleword register of a NEON quad register."
msgstr ""

#: ../../../LangRef.rst:3754
msgid ""
"``m``: Print the base register of a memory operand without the ``[`` and "
"``]`` adornment."
msgstr ""

#: ../../../LangRef.rst:3759 ../../../LangRef.rst:3803
msgid ""
"``L``: Print the second register of a two-register operand. Requires that it "
"has been allocated consecutively to the first."
msgstr ""

#: ../../../LangRef.rst:3765 ../../../LangRef.rst:3809
msgid ""
"``I``: Print the letter 'i' if the operand is an integer constant, otherwise "
"nothing. Used to print 'addi' vs 'add' instructions."
msgstr ""

#: ../../../LangRef.rst:3770 ../../../LangRef.rst:3853
msgid "No additional modifiers."
msgstr ""

#: ../../../LangRef.rst:3774
msgid "``X``: Print an immediate integer as hexadecimal"
msgstr ""

#: ../../../LangRef.rst:3775
msgid "``x``: Print the low 16 bits of an immediate integer as hexadecimal."
msgstr ""

#: ../../../LangRef.rst:3776
msgid "``d``: Print an immediate integer as decimal."
msgstr ""

#: ../../../LangRef.rst:3777
msgid "``m``: Subtract one and print an immediate integer as decimal."
msgstr ""

#: ../../../LangRef.rst:3778
msgid "``z``: Print $0 if an immediate zero, otherwise print normally."
msgstr ""

#: ../../../LangRef.rst:3779
msgid ""
"``L``: Print the low-order register of a two-register operand, or prints the "
"address of the low-order word of a double-word memory operand."
msgstr ""

#: ../../../LangRef.rst:3784
msgid ""
"``M``: Print the high-order register of a two-register operand, or prints "
"the address of the high-order word of a double-word memory operand."
msgstr ""

#: ../../../LangRef.rst:3789
msgid ""
"``D``: Print the second register of a two-register operand, or prints the "
"second word of a double-word memory operand. (On a big-endian system, ``D`` "
"is equivalent to ``L``, and on little-endian system, ``D`` is equivalent to "
"``M``.)"
msgstr ""

#: ../../../LangRef.rst:3793
msgid ""
"``w``: No effect. Provided for compatibility with GCC which requires this "
"modifier in order to print MSA registers (``W0-W31``) with the ``f`` "
"constraint."
msgstr ""

#: ../../../LangRef.rst:3811
msgid ""
"``y``: For a memory operand, prints formatter for a two-register X-form "
"instruction. (Currently always prints ``r0,OPERAND``)."
msgstr ""

#: ../../../LangRef.rst:3813
msgid ""
"``U``: Prints 'u' if the memory operand is an update form, and nothing "
"otherwise. (NOTE: LLVM does not support update form, so this will currently "
"always print nothing)"
msgstr ""

#: ../../../LangRef.rst:3816
msgid ""
"``X``: Prints 'x' if the memory operand is an indexed form. (NOTE: LLVM does "
"not support indexed form, so this will currently always print nothing)"
msgstr ""

#: ../../../LangRef.rst:3825
msgid ""
"SystemZ implements only ``n``, and does *not* support any of the other "
"target-independent modifiers."
msgstr ""

#: ../../../LangRef.rst:3830
msgid ""
"``c``: Print an unadorned integer or symbol name. (The latter is target-"
"specific behavior for this typically target-independent modifier)."
msgstr ""

#: ../../../LangRef.rst:3832
msgid "``A``: Print a register name with a '``*``' before it."
msgstr ""

#: ../../../LangRef.rst:3833
msgid ""
"``b``: Print an 8-bit register name (e.g. ``al``); do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:3835
msgid ""
"``h``: Print the upper 8-bit register name (e.g. ``ah``); do nothing on a "
"memory operand."
msgstr ""

#: ../../../LangRef.rst:3837
msgid ""
"``w``: Print the 16-bit register name (e.g. ``ax``); do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:3839
msgid ""
"``k``: Print the 32-bit register name (e.g. ``eax``); do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:3841
msgid ""
"``q``: Print the 64-bit register name (e.g. ``rax``), if 64-bit registers "
"are available, otherwise the 32-bit register name; do nothing on a memory "
"operand."
msgstr ""

#: ../../../LangRef.rst:3843
msgid ""
"``n``: Negate and print an unadorned integer, or, for operands other than an "
"immediate integer (e.g. a relocatable symbol expression), print a '-' before "
"the operand. (The behavior for relocatable symbol expressions is a target-"
"specific behavior for this typically target-independent modifier)"
msgstr ""

#: ../../../LangRef.rst:3847
msgid "``H``: Print a memory reference with additional offset +8."
msgstr ""

#: ../../../LangRef.rst:3848
msgid ""
"``P``: Print a memory reference or operand for use as the argument of a call "
"instruction. (E.g. omit ``(rip)``, even though it's PC-relative.)"
msgstr ""

#: ../../../LangRef.rst:3857
msgid "Inline Asm Metadata"
msgstr ""

#: ../../../LangRef.rst:3859
msgid ""
"The call instructions that wrap inline asm nodes may have a \"``!srcloc``\" "
"MDNode attached to it that contains a list of constant integers. If present, "
"the code generator will use the integer as the location cookie value when "
"report errors through the ``LLVMContext`` error reporting mechanisms. This "
"allows a front-end to correlate backend errors that occur with inline asm "
"back to the source code that produced it. For example:"
msgstr ""

#: ../../../LangRef.rst:3873
msgid ""
"It is up to the front-end to make sense of the magic numbers it places in "
"the IR. If the MDNode contains multiple constants, the code generator will "
"use the one that corresponds to the line of the asm that the error occurs on."
msgstr ""

#: ../../../LangRef.rst:3881
msgid "Metadata"
msgstr ""

#: ../../../LangRef.rst:3883
msgid ""
"LLVM IR allows metadata to be attached to instructions in the program that "
"can convey extra information about the code to the optimizers and code "
"generator. One example application of metadata is source-level debug "
"information. There are two metadata primitives: strings and nodes."
msgstr ""

#: ../../../LangRef.rst:3888
msgid ""
"Metadata does not have a type, and is not a value. If referenced from a "
"``call`` instruction, it uses the ``metadata`` type."
msgstr ""

#: ../../../LangRef.rst:3891
msgid "All metadata are identified in syntax by a exclamation point ('``!``')."
msgstr ""

#: ../../../LangRef.rst:3896
msgid "Metadata Nodes and Metadata Strings"
msgstr ""

#: ../../../LangRef.rst:3898
msgid ""
"A metadata string is a string surrounded by double quotes. It can contain "
"any character by escaping non-printable characters with \"``\\xx``\" where "
"\"``xx``\" is the two digit hex code. For example: \"``!\"test\\00\"``\"."
msgstr ""

#: ../../../LangRef.rst:3903
msgid ""
"Metadata nodes are represented with notation similar to structure constants "
"(a comma separated list of elements, surrounded by braces and preceded by an "
"exclamation point). Metadata nodes can have any values as their operand. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:3912
msgid ""
"Metadata nodes that aren't uniqued use the ``distinct`` keyword. For example:"
msgstr ""

#: ../../../LangRef.rst:3918
msgid ""
"``distinct`` nodes are useful when nodes shouldn't be merged based on their "
"content. They can also occur when transformations cause uniquing collisions "
"when metadata operands change."
msgstr ""

#: ../../../LangRef.rst:3922
msgid ""
"A :ref:`named metadata <namedmetadatastructure>` is a collection of metadata "
"nodes, which can be looked up in the module symbol table. For example:"
msgstr ""

#: ../../../LangRef.rst:3930
msgid ""
"Metadata can be used as function arguments. Here ``llvm.dbg.value`` function "
"is using two metadata arguments:"
msgstr ""

#: ../../../LangRef.rst:3937
msgid ""
"Metadata can be attached to an instruction. Here metadata ``!21`` is "
"attached to the ``add`` instruction using the ``!dbg`` identifier:"
msgstr ""

#: ../../../LangRef.rst:3944
msgid ""
"Metadata can also be attached to a function definition. Here metadata ``!"
"22`` is attached to the ``foo`` function using the ``!dbg`` identifier:"
msgstr ""

#: ../../../LangRef.rst:3953
msgid ""
"More information about specific metadata nodes recognized by the optimizers "
"and code generator is found below."
msgstr ""

#: ../../../LangRef.rst:3959
msgid "Specialized Metadata Nodes"
msgstr ""

#: ../../../LangRef.rst:3961
msgid ""
"Specialized metadata nodes are custom data structures in metadata (as "
"opposed to generic tuples). Their fields are labelled, and can be specified "
"in any order."
msgstr ""

#: ../../../LangRef.rst:3965
msgid ""
"These aren't inherently debug info centric, but currently all the "
"specialized metadata nodes are related to debug info."
msgstr ""

#: ../../../LangRef.rst:3971
msgid "DICompileUnit"
msgstr ""

#: ../../../LangRef.rst:3973
msgid ""
"``DICompileUnit`` nodes represent a compile unit. The ``enums:``, "
"``retainedTypes:``, ``subprograms:``, ``globals:``, ``imports:`` and "
"``macros:`` fields are tuples containing the debug info to be emitted along "
"with the compile unit, regardless of code optimizations (some nodes are only "
"emitted if there are references to them from instructions)."
msgstr ""

#: ../../../LangRef.rst:3987
msgid ""
"Compile unit descriptors provide the root scope for objects declared in a "
"specific compilation unit. File descriptors are defined using this scope. "
"These descriptors are collected by a named metadata ``!llvm.dbg.cu``. They "
"keep track of subprograms, global variables, type information, and imported "
"entities (declarations and namespaces)."
msgstr ""

#: ../../../LangRef.rst:3996
msgid "DIFile"
msgstr ""

#: ../../../LangRef.rst:3998
msgid ""
"``DIFile`` nodes represent files. The ``filename:`` can include slashes."
msgstr ""

#: ../../../LangRef.rst:4006
msgid ""
"Files are sometimes used in ``scope:`` fields, and are the only valid target "
"for ``file:`` fields. Valid values for ``checksumkind:`` field are: "
"{CSK_None, CSK_MD5, CSK_SHA1}"
msgstr ""

#: ../../../LangRef.rst:4013
msgid "DIBasicType"
msgstr ""

#: ../../../LangRef.rst:4015
msgid ""
"``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` "
"and ``float``. ``tag:`` defaults to ``DW_TAG_base_type``."
msgstr ""

#: ../../../LangRef.rst:4024
msgid ""
"The ``encoding:`` describes the details of the type. Usually it's one of the "
"following:"
msgstr ""

#: ../../../LangRef.rst:4040
msgid "DISubroutineType"
msgstr ""

#: ../../../LangRef.rst:4042
msgid ""
"``DISubroutineType`` nodes represent subroutine types. Their ``types:`` "
"field refers to a tuple; the first operand is the return type, while the "
"rest are the types of the formal arguments in order. If the first operand is "
"``null``, that represents a function with no return value (such as ``void "
"foo() {}`` in C++)."
msgstr ""

#: ../../../LangRef.rst:4056
msgid "DIDerivedType"
msgstr ""

#: ../../../LangRef.rst:4058
msgid ""
"``DIDerivedType`` nodes represent types derived from other types, such as "
"qualified types."
msgstr ""

#: ../../../LangRef.rst:4068 ../../../LangRef.rst:4132
msgid "The following ``tag:`` values are valid:"
msgstr ""

#: ../../../LangRef.rst:4086
msgid ""
"``DW_TAG_member`` is used to define a member of a :ref:`composite type "
"<DICompositeType>`. The type of the member is the ``baseType:``. The "
"``offset:`` is the member's bit offset.  If the composite type has an ODR "
"``identifier:`` and does not set ``flags: DIFwdDecl``, then the member is "
"uniqued based only on its ``name:`` and ``scope:``."
msgstr ""

#: ../../../LangRef.rst:4092
msgid ""
"``DW_TAG_inheritance`` and ``DW_TAG_friend`` are used in the ``elements:`` "
"field of :ref:`composite types <DICompositeType>` to describe parents and "
"friends."
msgstr ""

#: ../../../LangRef.rst:4096
msgid "``DW_TAG_typedef`` is used to provide a name for the ``baseType:``."
msgstr ""

#: ../../../LangRef.rst:4098
msgid ""
"``DW_TAG_pointer_type``, ``DW_TAG_reference_type``, ``DW_TAG_const_type``, "
"``DW_TAG_volatile_type``, ``DW_TAG_restrict_type`` and "
"``DW_TAG_atomic_type`` are used to qualify the ``baseType:``."
msgstr ""

#: ../../../LangRef.rst:4102
msgid "Note that the ``void *`` type is expressed as a type derived from NULL."
msgstr ""

#: ../../../LangRef.rst:4107
msgid "DICompositeType"
msgstr ""

#: ../../../LangRef.rst:4109
msgid ""
"``DICompositeType`` nodes represent types composed of other types, like "
"structures and unions. ``elements:`` points to a tuple of the composed types."
msgstr ""

#: ../../../LangRef.rst:4112
msgid ""
"If the source language supports ODR, the ``identifier:`` field gives the "
"unique identifier used for type merging between modules.  When specified, :"
"ref:`subprogram declarations <DISubprogramDeclaration>` and :ref:`member "
"derived types <DIDerivedTypeMember>` that reference the ODR-type in their "
"``scope:`` change uniquing rules."
msgstr ""

#: ../../../LangRef.rst:4118
msgid ""
"For a given ``identifier:``, there should only be a single composite type "
"that does not have  ``flags: DIFlagFwdDecl`` set.  LLVM tools that link "
"modules together will unique such definitions at parse time via the "
"``identifier:`` field, even if the nodes are ``distinct``."
msgstr ""

#: ../../../LangRef.rst:4142
msgid ""
"For ``DW_TAG_array_type``, the ``elements:`` should be :ref:`subrange "
"descriptors <DISubrange>`, each representing the range of subscripts at that "
"level of indexing. The ``DIFlagVector`` flag to ``flags:`` indicates that an "
"array type is a native packed vector."
msgstr ""

#: ../../../LangRef.rst:4147
msgid ""
"For ``DW_TAG_enumeration_type``, the ``elements:`` should be :ref:"
"`enumerator descriptors <DIEnumerator>`, each representing the definition of "
"an enumeration value for the set. All enumeration type descriptors are "
"collected in the ``enums:`` field of the :ref:`compile unit <DICompileUnit>`."
msgstr ""

#: ../../../LangRef.rst:4152
msgid ""
"For ``DW_TAG_structure_type``, ``DW_TAG_class_type``, and "
"``DW_TAG_union_type``, the ``elements:`` should be :ref:`derived types "
"<DIDerivedType>` with ``tag: DW_TAG_member``, ``tag: DW_TAG_inheritance``, "
"or ``tag: DW_TAG_friend``; or :ref:`subprograms <DISubprogram>` with "
"``isDefinition: false``."
msgstr ""

#: ../../../LangRef.rst:4161
msgid "DISubrange"
msgstr ""

#: ../../../LangRef.rst:4163
msgid ""
"``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants of :"
"ref:`DICompositeType`. ``count: -1`` indicates an empty array."
msgstr ""

#: ../../../LangRef.rst:4175
msgid "DIEnumerator"
msgstr ""

#: ../../../LangRef.rst:4177
msgid ""
"``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type`` "
"variants of :ref:`DICompositeType`."
msgstr ""

#: ../../../LangRef.rst:4187
msgid "DITemplateTypeParameter"
msgstr ""

#: ../../../LangRef.rst:4189
msgid ""
"``DITemplateTypeParameter`` nodes represent type parameters to generic "
"source language constructs. They are used (optionally) in :ref:"
"`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` fields."
msgstr ""

#: ../../../LangRef.rst:4198
msgid "DITemplateValueParameter"
msgstr ""

#: ../../../LangRef.rst:4200
msgid ""
"``DITemplateValueParameter`` nodes represent value parameters to generic "
"source language constructs. ``tag:`` defaults to "
"``DW_TAG_template_value_parameter``, but if specified can also be set to "
"``DW_TAG_GNU_template_template_param`` or "
"``DW_TAG_GNU_template_param_pack``. They are used (optionally) in :ref:"
"`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` fields."
msgstr ""

#: ../../../LangRef.rst:4211
msgid "DINamespace"
msgstr ""

#: ../../../LangRef.rst:4213
msgid "``DINamespace`` nodes represent namespaces in the source language."
msgstr ""

#: ../../../LangRef.rst:4220
msgid "DIGlobalVariable"
msgstr ""

#: ../../../LangRef.rst:4222
msgid ""
"``DIGlobalVariable`` nodes represent global variables in the source language."
msgstr ""

#: ../../../LangRef.rst:4231
msgid ""
"All global variables should be referenced by the `globals:` field of a :ref:"
"`compile unit <DICompileUnit>`."
msgstr ""

#: ../../../LangRef.rst:4237
msgid "DISubprogram"
msgstr ""

#: ../../../LangRef.rst:4239
msgid ""
"``DISubprogram`` nodes represent functions from the source language. A "
"``DISubprogram`` may be attached to a function definition using ``!dbg`` "
"metadata. The ``variables:`` field points at :ref:`variables "
"<DILocalVariable>` that must be retained, even if their IR counterparts are "
"optimized out of the IR. The ``type:`` field must point at an :ref:"
"`DISubroutineType`."
msgstr ""

#: ../../../LangRef.rst:4247
msgid ""
"When ``isDefinition: false``, subprograms describe a declaration in the type "
"tree as opposed to a definition of a function.  If the scope is a composite "
"type with an ODR ``identifier:`` and that does not set ``flags: DIFwdDecl``, "
"then the subprogram declaration is uniqued based only on its ``linkageName:"
"`` and ``scope:``."
msgstr ""

#: ../../../LangRef.rst:4271
msgid "DILexicalBlock"
msgstr ""

#: ../../../LangRef.rst:4273
msgid ""
"``DILexicalBlock`` nodes describe nested blocks within a :ref:`subprogram "
"<DISubprogram>`. The line number and column numbers are used to distinguish "
"two lexical blocks at same depth. They are valid targets for ``scope:`` "
"fields."
msgstr ""

#: ../../../LangRef.rst:4282
msgid ""
"Usually lexical blocks are ``distinct`` to prevent node merging based on "
"operands."
msgstr ""

#: ../../../LangRef.rst:4288
msgid "DILexicalBlockFile"
msgstr ""

#: ../../../LangRef.rst:4290
msgid ""
"``DILexicalBlockFile`` nodes are used to discriminate between sections of a :"
"ref:`lexical block <DILexicalBlock>`. The ``file:`` field can be changed to "
"indicate textual inclusion, or the ``discriminator:`` field can be used to "
"discriminate between control flow within a single block in the source "
"language."
msgstr ""

#: ../../../LangRef.rst:4304
msgid "DILocation"
msgstr ""

#: ../../../LangRef.rst:4306
msgid ""
"``DILocation`` nodes represent source debug locations. The ``scope:`` field "
"is mandatory, and points at an :ref:`DILexicalBlockFile`, an :ref:"
"`DILexicalBlock`, or an :ref:`DISubprogram`."
msgstr ""

#: ../../../LangRef.rst:4317
msgid "DILocalVariable"
msgstr ""

#: ../../../LangRef.rst:4319
msgid ""
"``DILocalVariable`` nodes represent local variables in the source language. "
"If the ``arg:`` field is set to non-zero, then this variable is a subprogram "
"parameter, and it will be included in the ``variables:`` field of its :ref:"
"`DISubprogram`."
msgstr ""

#: ../../../LangRef.rst:4333
msgid "DIExpression"
msgstr ""

#: ../../../LangRef.rst:4335
msgid ""
"``DIExpression`` nodes represent DWARF expression sequences. They are used "
"in :ref:`debug intrinsics<dbg_intrinsics>` (such as ``llvm.dbg.declare``) to "
"describe how the referenced LLVM variable relates to the source language "
"variable."
msgstr ""

#: ../../../LangRef.rst:4340
msgid "The current supported vocabulary is limited:"
msgstr ""

#: ../../../LangRef.rst:4342
msgid "``DW_OP_deref`` dereferences the working expression."
msgstr ""

#: ../../../LangRef.rst:4343
msgid "``DW_OP_plus, 93`` adds ``93`` to the working expression."
msgstr ""

#: ../../../LangRef.rst:4344
msgid ""
"``DW_OP_bit_piece, 16, 8`` specifies the offset and size (``16`` and ``8`` "
"here, respectively) of the variable piece from the working expression."
msgstr ""

#: ../../../LangRef.rst:4355
msgid "DIObjCProperty"
msgstr ""

#: ../../../LangRef.rst:4357
msgid "``DIObjCProperty`` nodes represent Objective-C property nodes."
msgstr ""

#: ../../../LangRef.rst:4365
msgid "DIImportedEntity"
msgstr ""

#: ../../../LangRef.rst:4367
msgid ""
"``DIImportedEntity`` nodes represent entities (such as modules) imported "
"into a compile unit."
msgstr ""

#: ../../../LangRef.rst:4376
msgid "DIMacro"
msgstr ""

#: ../../../LangRef.rst:4378
msgid ""
"``DIMacro`` nodes represent definition or undefinition of a macro "
"identifiers. The ``name:`` field is the macro identifier, followed by macro "
"parameters when defining a function-like macro, and the ``value`` field is "
"the token-string used to expand the macro identifier."
msgstr ""

#: ../../../LangRef.rst:4390
msgid "DIMacroFile"
msgstr ""

#: ../../../LangRef.rst:4392
msgid ""
"``DIMacroFile`` nodes represent inclusion of source files. The ``nodes:`` "
"field is a list of ``DIMacro`` and ``DIMacroFile`` nodes that appear in the "
"included source file."
msgstr ""

#: ../../../LangRef.rst:4402
msgid "'``tbaa``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4404
msgid ""
"In LLVM IR, memory does not have types, so LLVM's own type system is not "
"suitable for doing TBAA. Instead, metadata is added to the IR to describe a "
"type system of a higher level language. This can be used to implement "
"typical C/C++ TBAA, but it can also be used to implement custom alias "
"analysis behavior for other languages."
msgstr ""

#: ../../../LangRef.rst:4410
msgid ""
"The current metadata format is very simple. TBAA metadata nodes have up to "
"three fields, e.g.:"
msgstr ""

#: ../../../LangRef.rst:4420
msgid ""
"The first field is an identity field. It can be any value, usually a "
"metadata string, which uniquely identifies the type. The most important name "
"in the tree is the name of the root node. Two trees with different root node "
"names are entirely disjoint, even if they have leaves with common names."
msgstr ""

#: ../../../LangRef.rst:4426
msgid ""
"The second field identifies the type's parent node in the tree, or is null "
"or omitted for a root node. A type is considered to alias all of its "
"descendants and all of its ancestors in the tree. Also, a type is considered "
"to alias all types in other trees, so that bitcode produced from multiple "
"front-ends is handled conservatively."
msgstr ""

#: ../../../LangRef.rst:4432
msgid ""
"If the third field is present, it's an integer which if equal to 1 indicates "
"that the type is \"constant\" (meaning ``pointsToConstantMemory`` should "
"return true; see `other useful AliasAnalysis methods <AliasAnalysis."
"html#OtherItfs>`_)."
msgstr ""

#: ../../../LangRef.rst:4438
msgid "'``tbaa.struct``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4440
msgid ""
"The :ref:`llvm.memcpy <int_memcpy>` is often used to implement aggregate "
"assignment operations in C and similar languages, however it is defined to "
"copy a contiguous region of memory, which is more than strictly necessary "
"for aggregate types which contain holes due to padding. Also, it doesn't "
"contain any TBAA information about the fields of the aggregate."
msgstr ""

#: ../../../LangRef.rst:4447
msgid ""
"``!tbaa.struct`` metadata can describe which memory subregions in a memcpy "
"are padding and what the TBAA tags of the struct are."
msgstr ""

#: ../../../LangRef.rst:4450
msgid ""
"The current metadata format is very simple. ``!tbaa.struct`` metadata nodes "
"are a list of operands which are in conceptual groups of three. For each "
"group of three, the first operand gives the byte offset of a field in bytes, "
"the second gives its size in bytes, and the third gives its tbaa tag. e.g.:"
msgstr ""

#: ../../../LangRef.rst:4460
msgid ""
"This describes a struct with two fields. The first is at offset 0 bytes with "
"size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes and has "
"size 4 bytes and has tbaa tag !2."
msgstr ""

#: ../../../LangRef.rst:4464
msgid ""
"Note that the fields need not be contiguous. In this example, there is a 4 "
"byte gap between the two fields. This gap represents padding which does not "
"carry useful data and need not be preserved."
msgstr ""

#: ../../../LangRef.rst:4469
msgid "'``noalias``' and '``alias.scope``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4471
msgid ""
"``noalias`` and ``alias.scope`` metadata provide the ability to specify "
"generic noalias memory-access sets. This means that some collection of "
"memory access instructions (loads, stores, memory-accessing calls, etc.) "
"that carry ``noalias`` metadata can specifically be specified not to alias "
"with some other collection of memory access instructions that carry ``alias."
"scope`` metadata. Each type of metadata specifies a list of scopes where "
"each scope has an id and a domain."
msgstr ""

#: ../../../LangRef.rst:4479
msgid ""
"When evaluating an aliasing query, if for some domain, the set of scopes "
"with that domain in one instruction's ``alias.scope`` list is a subset of "
"(or equal to) the set of scopes for that domain in another instruction's "
"``noalias`` list, then the two memory accesses are assumed not to alias."
msgstr ""

#: ../../../LangRef.rst:4485
msgid ""
"Because scopes in one domain don't affect scopes in other domains, separate "
"domains can be used to compose multiple independent noalias sets.  This is "
"used for example during inlining.  As the noalias function parameters are "
"turned into noalias scope metadata, a new domain is used every time the "
"function is inlined."
msgstr ""

#: ../../../LangRef.rst:4491
msgid ""
"The metadata identifying each domain is itself a list containing one or two "
"entries. The first entry is the name of the domain. Note that if the name is "
"a string then it can be combined across functions and translation units. A "
"self-reference can be used to create globally unique domain names. A "
"descriptive string may optionally be provided as a second list entry."
msgstr ""

#: ../../../LangRef.rst:4497
msgid ""
"The metadata identifying each scope is also itself a list containing two or "
"three entries. The first entry is the name of the scope. Note that if the "
"name is a string then it can be combined across functions and translation "
"units. A self-reference can be used to create globally unique scope names. A "
"metadata reference to the scope's domain is the second entry. A descriptive "
"string may optionally be provided as a third list entry."
msgstr ""

#: ../../../LangRef.rst:4504
msgid "For example,"
msgstr ""

#: ../../../LangRef.rst:4538
msgid "'``fpmath``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4540
msgid ""
"``fpmath`` metadata may be attached to any instruction of floating point "
"type. It can be used to express the maximum acceptable error in the result "
"of that instruction, in ULPs, thus potentially allowing the compiler to use "
"a more efficient but less accurate method of computing it. ULP is defined as "
"follows:"
msgstr ""

#: ../../../LangRef.rst:4546
msgid ""
"If ``x`` is a real number that lies between two finite consecutive floating-"
"point numbers ``a`` and ``b``, without being equal to one of them, then "
"``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the distance between the two "
"non-equal finite floating-point numbers nearest ``x``. Moreover, "
"``ulp(NaN)`` is ``NaN``."
msgstr ""

#: ../../../LangRef.rst:4552
msgid ""
"The metadata node shall consist of a single positive float type number "
"representing the maximum relative error, for example:"
msgstr ""

#: ../../../LangRef.rst:4562
msgid "'``range``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4564
msgid ""
"``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` "
"of integer types. It expresses the possible ranges the loaded value or the "
"value returned by the called function at this call site is in. The ranges "
"are represented with a flattened list of integers. The loaded value or the "
"value returned is known to be in the union of the ranges defined by each "
"consecutive pair. Each pair has the following properties:"
msgstr ""

#: ../../../LangRef.rst:4571
msgid "The type must match the type loaded by the instruction."
msgstr ""

#: ../../../LangRef.rst:4572
msgid "The pair ``a,b`` represents the range ``[a,b)``."
msgstr ""

#: ../../../LangRef.rst:4573
msgid "Both ``a`` and ``b`` are constants."
msgstr ""

#: ../../../LangRef.rst:4574
msgid "The range is allowed to wrap."
msgstr ""

#: ../../../LangRef.rst:4575
msgid ""
"The range should not represent the full or empty set. That is, ``a!=b``."
msgstr ""

#: ../../../LangRef.rst:4578
msgid ""
"In addition, the pairs must be in signed order of the lower bound and they "
"must be non-contiguous."
msgstr ""

#: ../../../LangRef.rst:4597
msgid "'``absolute_symbol``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4599
msgid ""
"``absolute_symbol`` metadata may be attached to a global variable "
"declaration. It marks the declaration as a reference to an absolute symbol, "
"which causes the backend to use absolute relocations for the symbol even in "
"position independent code, and expresses the possible ranges that the global "
"variable's *address* (not its value) is in, in the same format as ``range`` "
"metadata."
msgstr ""

#: ../../../LangRef.rst:4606 ../../../LangRef.rst:5361
#: ../../../LangRef.rst:5406 ../../../LangRef.rst:5464
#: ../../../LangRef.rst:5525 ../../../LangRef.rst:5621
#: ../../../LangRef.rst:5663 ../../../LangRef.rst:5716
#: ../../../LangRef.rst:5767 ../../../LangRef.rst:5817
#: ../../../LangRef.rst:5907 ../../../LangRef.rst:5946
#: ../../../LangRef.rst:5998 ../../../LangRef.rst:6041
#: ../../../LangRef.rst:6095 ../../../LangRef.rst:6134
#: ../../../LangRef.rst:6178 ../../../LangRef.rst:6224
#: ../../../LangRef.rst:6263 ../../../LangRef.rst:6305
#: ../../../LangRef.rst:6360 ../../../LangRef.rst:6400
#: ../../../LangRef.rst:6460 ../../../LangRef.rst:6509
#: ../../../LangRef.rst:6560 ../../../LangRef.rst:6612
#: ../../../LangRef.rst:6661 ../../../LangRef.rst:6711
#: ../../../LangRef.rst:6764 ../../../LangRef.rst:6806
#: ../../../LangRef.rst:6854 ../../../LangRef.rst:6913
#: ../../../LangRef.rst:6956 ../../../LangRef.rst:7023
#: ../../../LangRef.rst:7242 ../../../LangRef.rst:7299
#: ../../../LangRef.rst:7373 ../../../LangRef.rst:7459
#: ../../../LangRef.rst:7610 ../../../LangRef.rst:7719
#: ../../../LangRef.rst:7760 ../../../LangRef.rst:7801
#: ../../../LangRef.rst:7843 ../../../LangRef.rst:7883
#: ../../../LangRef.rst:7924 ../../../LangRef.rst:7966
#: ../../../LangRef.rst:8008 ../../../LangRef.rst:8049
#: ../../../LangRef.rst:8094 ../../../LangRef.rst:8138
#: ../../../LangRef.rst:8190 ../../../LangRef.rst:8236
#: ../../../LangRef.rst:8329 ../../../LangRef.rst:8443
#: ../../../LangRef.rst:8497 ../../../LangRef.rst:8547
#: ../../../LangRef.rst:8663 ../../../LangRef.rst:8729
#: ../../../LangRef.rst:8806 ../../../LangRef.rst:8879
#: ../../../LangRef.rst:8949
msgid "Example:"
msgstr ""

#: ../../../LangRef.rst:4616
msgid "'``unpredictable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4618
msgid ""
"``unpredictable`` metadata may be attached to any branch or switch "
"instruction. It can be used to express the unpredictability of control flow. "
"Similar to the llvm.expect intrinsic, it may be used to alter optimizations "
"related to compare and branch instructions. The metadata is treated as a "
"boolean value; if it exists, it signals that the branch or switch that it is "
"attached to is completely unpredictable."
msgstr ""

#: ../../../LangRef.rst:4626
msgid "'``llvm.loop``'"
msgstr ""

#: ../../../LangRef.rst:4628
msgid ""
"It is sometimes useful to attach information to loop constructs. Currently, "
"loop metadata is implemented as metadata attached to the branch instruction "
"in the loop latch block. This type of metadata refer to a metadata node that "
"is guaranteed to be separate for each loop. The loop identifier metadata is "
"specified with the name ``llvm.loop``."
msgstr ""

#: ../../../LangRef.rst:4634
msgid ""
"The loop identifier metadata is implemented using a metadata that refers to "
"itself to avoid merging it with any other identifier metadata, e.g., during "
"module linkage or function inlining. That is, each loop should refer to "
"their own identification metadata even if they reside in separate functions. "
"The following example contains loop identifier metadata for two separate "
"loop constructs:"
msgstr ""

#: ../../../LangRef.rst:4646
msgid ""
"The loop identifier metadata can be used to specify additional per-loop "
"metadata. Any operands after the first operand can be treated as user-"
"defined metadata. For example the ``llvm.loop.unroll.count`` suggests an "
"unroll factor to the loop unroller:"
msgstr ""

#: ../../../LangRef.rst:4659
msgid "'``llvm.loop.vectorize``' and '``llvm.loop.interleave``'"
msgstr ""

#: ../../../LangRef.rst:4661
msgid ""
"Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` "
"are used to control per-loop vectorization and interleaving parameters such "
"as vectorization width and interleave count. These metadata should be used "
"in conjunction with ``llvm.loop`` loop identification metadata. The ``llvm."
"loop.vectorize`` and ``llvm.loop.interleave`` metadata are only optimization "
"hints and the optimizer will only interleave and vectorize loops if it "
"believes it is safe to do so. The ``llvm.mem.parallel_loop_access`` metadata "
"which contains information about loop-carried memory dependencies can be "
"helpful in determining the safety of these transformations."
msgstr ""

#: ../../../LangRef.rst:4672
msgid "'``llvm.loop.interleave.count``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4674
msgid ""
"This metadata suggests an interleave count to the loop interleaver. The "
"first operand is the string ``llvm.loop.interleave.count`` and the second "
"operand is an integer specifying the interleave count. For example:"
msgstr ""

#: ../../../LangRef.rst:4683
msgid ""
"Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving "
"multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to "
"0 then the interleave count will be determined automatically."
msgstr ""

#: ../../../LangRef.rst:4688
msgid "'``llvm.loop.vectorize.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4690
msgid ""
"This metadata selectively enables or disables vectorization for the loop. "
"The first operand is the string ``llvm.loop.vectorize.enable`` and the "
"second operand is a bit. If the bit operand value is 1 vectorization is "
"enabled. A value of 0 disables vectorization:"
msgstr ""

#: ../../../LangRef.rst:4701
msgid "'``llvm.loop.vectorize.width``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4703
msgid ""
"This metadata sets the target width of the vectorizer. The first operand is "
"the string ``llvm.loop.vectorize.width`` and the second operand is an "
"integer specifying the width. For example:"
msgstr ""

#: ../../../LangRef.rst:4711
msgid ""
"Note that setting ``llvm.loop.vectorize.width`` to 1 disables vectorization "
"of the loop. If ``llvm.loop.vectorize.width`` is set to 0 or if the loop "
"does not have this metadata the width will be determined automatically."
msgstr ""

#: ../../../LangRef.rst:4717
msgid "'``llvm.loop.unroll``'"
msgstr ""

#: ../../../LangRef.rst:4719
msgid ""
"Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling optimization "
"hints such as the unroll factor. ``llvm.loop.unroll`` metadata should be "
"used in conjunction with ``llvm.loop`` loop identification metadata. The "
"``llvm.loop.unroll`` metadata are only optimization hints and the unrolling "
"will only be performed if the optimizer believes it is safe to do so."
msgstr ""

#: ../../../LangRef.rst:4727
msgid "'``llvm.loop.unroll.count``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4729
msgid ""
"This metadata suggests an unroll factor to the loop unroller. The first "
"operand is the string ``llvm.loop.unroll.count`` and the second operand is a "
"positive integer specifying the unroll factor. For example:"
msgstr ""

#: ../../../LangRef.rst:4738
msgid ""
"If the trip count of the loop is less than the unroll count the loop will be "
"partially unrolled."
msgstr ""

#: ../../../LangRef.rst:4742
msgid "'``llvm.loop.unroll.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4744
msgid ""
"This metadata disables loop unrolling. The metadata has a single operand "
"which is the string ``llvm.loop.unroll.disable``. For example:"
msgstr ""

#: ../../../LangRef.rst:4752
msgid "'``llvm.loop.unroll.runtime.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4754
msgid ""
"This metadata disables runtime loop unrolling. The metadata has a single "
"operand which is the string ``llvm.loop.unroll.runtime.disable``. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:4762
msgid "'``llvm.loop.unroll.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4764
msgid ""
"This metadata suggests that the loop should be fully unrolled if the trip "
"count is known at compile time and partially unrolled if the trip count is "
"not known at compile time. The metadata has a single operand which is the "
"string ``llvm.loop.unroll.enable``.  For example:"
msgstr ""

#: ../../../LangRef.rst:4774
msgid "'``llvm.loop.unroll.full``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4776
msgid ""
"This metadata suggests that the loop should be unrolled fully. The metadata "
"has a single operand which is the string ``llvm.loop.unroll.full``. For "
"example:"
msgstr ""

#: ../../../LangRef.rst:4785
msgid "'``llvm.loop.licm_versioning.disable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4787
msgid ""
"This metadata indicates that the loop should not be versioned for the "
"purpose of enabling loop-invariant code motion (LICM). The metadata has a "
"single operand which is the string ``llvm.loop.licm_versioning.disable``. "
"For example:"
msgstr ""

#: ../../../LangRef.rst:4796
msgid "'``llvm.loop.distribute.enable``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4798
msgid ""
"Loop distribution allows splitting a loop into multiple loops.  Currently, "
"this is only performed if the entire loop cannot be vectorized due to unsafe "
"memory dependencies.  The transformation will atempt to isolate the unsafe "
"dependencies into their own loop."
msgstr ""

#: ../../../LangRef.rst:4803
msgid ""
"This metadata can be used to selectively enable or disable distribution of "
"the loop.  The first operand is the string ``llvm.loop.distribute.enable`` "
"and the second operand is a bit. If the bit operand value is 1 distribution "
"is enabled. A value of 0 disables distribution:"
msgstr ""

#: ../../../LangRef.rst:4813
msgid ""
"This metadata should be used in conjunction with ``llvm.loop`` loop "
"identification metadata."
msgstr ""

#: ../../../LangRef.rst:4817
msgid "'``llvm.mem``'"
msgstr ""

#: ../../../LangRef.rst:4819
msgid ""
"Metadata types used to annotate memory accesses with information helpful for "
"optimizations are prefixed with ``llvm.mem``."
msgstr ""

#: ../../../LangRef.rst:4823
msgid "'``llvm.mem.parallel_loop_access``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4825
msgid ""
"The ``llvm.mem.parallel_loop_access`` metadata refers to a loop identifier, "
"or metadata containing a list of loop identifiers for nested loops. The "
"metadata is attached to memory accessing instructions and denotes that no "
"loop carried memory dependence exist between it and other instructions "
"denoted with the same loop identifier. The metadata on memory reads also "
"implies that if conversion (i.e. speculative execution within a loop "
"iteration) is safe."
msgstr ""

#: ../../../LangRef.rst:4832
msgid ""
"Precisely, given two instructions ``m1`` and ``m2`` that both have the "
"``llvm.mem.parallel_loop_access`` metadata, with ``L1`` and ``L2`` being the "
"set of loops associated with that metadata, respectively, then there is no "
"loop carried dependence between ``m1`` and ``m2`` for loops in both ``L1`` "
"and ``L2``."
msgstr ""

#: ../../../LangRef.rst:4838
msgid ""
"As a special case, if all memory accessing instructions in a loop have "
"``llvm.mem.parallel_loop_access`` metadata that refers to that loop, then "
"the loop has no loop carried memory dependences and is considered to be a "
"parallel loop."
msgstr ""

#: ../../../LangRef.rst:4843
msgid ""
"Note that if not all memory access instructions have such metadata referring "
"to the loop, then the loop is considered not being trivially parallel. "
"Additional memory dependence analysis is required to make that "
"determination. As a fail safe mechanism, this causes loops that were "
"originally parallel to be considered sequential (if optimization passes that "
"are unaware of the parallel semantics insert new memory instructions into "
"the loop body)."
msgstr ""

#: ../../../LangRef.rst:4850
msgid ""
"Example of a loop that is considered parallel due to its correct use of both "
"``llvm.loop`` and ``llvm.mem.parallel_loop_access`` metadata types that "
"refer to the same loop identifier metadata."
msgstr ""

#: ../../../LangRef.rst:4868
msgid ""
"It is also possible to have nested parallel loops. In that case the memory "
"accesses refer to a list of loop identifier metadata nodes instead of the "
"loop identifier metadata node directly:"
msgstr ""

#: ../../../LangRef.rst:4901
msgid "'``invariant.group``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4903
msgid ""
"The ``invariant.group`` metadata may be attached to ``load``/``store`` "
"instructions. The existence of the ``invariant.group`` metadata on the "
"instruction tells the optimizer that every ``load`` and ``store`` to the "
"same pointer operand within the same invariant group can be assumed to load "
"or store the same value (but see the ``llvm.invariant.group.barrier`` "
"intrinsic which affects when two pointers are considered the same). Pointers "
"returned by bitcast or getelementptr with only zero indices are considered "
"the same."
msgstr ""

#: ../../../LangRef.rst:4944
msgid "'``type``' Metadata"
msgstr ""

#: ../../../LangRef.rst:4946
msgid "See :doc:`TypeMetadata`."
msgstr ""

#: ../../../LangRef.rst:4950
msgid "Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:4952
msgid ""
"Information about the module as a whole is difficult to convey to LLVM's "
"subsystems. The LLVM IR isn't sufficient to transmit this information. The "
"``llvm.module.flags`` named metadata exists in order to facilitate this. "
"These flags are in the form of key / value pairs --- much like a dictionary "
"--- making it easy for any subsystem who cares about a flag to look it up."
msgstr ""

#: ../../../LangRef.rst:4959
msgid ""
"The ``llvm.module.flags`` metadata contains a list of metadata triplets. "
"Each triplet has the following form:"
msgstr ""

#: ../../../LangRef.rst:4962
msgid ""
"The first element is a *behavior* flag, which specifies the behavior when "
"two (or more) modules are merged together, and it encounters two (or more) "
"metadata with the same ID. The supported behaviors are described below."
msgstr ""

#: ../../../LangRef.rst:4966
msgid ""
"The second element is a metadata string that is a unique ID for the "
"metadata. Each module may only have one flag entry for each unique ID (not "
"including entries with the **Require** behavior)."
msgstr ""

#: ../../../LangRef.rst:4969
msgid "The third element is the value of the flag."
msgstr ""

#: ../../../LangRef.rst:4971
msgid ""
"When two (or more) modules are merged together, the resulting ``llvm.module."
"flags`` metadata is the union of the modules' flags. That is, for each "
"unique metadata ID string, there will be exactly one entry in the merged "
"modules ``llvm.module.flags`` metadata table, and the value for that entry "
"will be determined by the merge behavior flag, as described below. The only "
"exception is that entries with the *Require* behavior are always preserved."
msgstr ""

#: ../../../LangRef.rst:4978
msgid "The following behaviors are supported:"
msgstr ""

#: ../../../LangRef.rst:4984 ../../../LangRef.rst:5081
#: ../../../LangRef.rst:5166
msgid "Value"
msgstr ""

#: ../../../LangRef.rst:4985
msgid "Behavior"
msgstr ""

#: ../../../LangRef.rst:4987 ../../../LangRef.rst:6604
#: ../../../LangRef.rst:6606 ../../../LangRef.rst:6608
#: ../../../LangRef.rst:6653 ../../../LangRef.rst:6655
#: ../../../LangRef.rst:6657 ../../../LangRef.rst:6703
#: ../../../LangRef.rst:6705 ../../../LangRef.rst:6707
msgid "1"
msgstr ""

#: ../../../LangRef.rst:4990
msgid "**Error**"
msgstr ""

#: ../../../LangRef.rst:4989
msgid ""
"Emits an error if two values disagree, otherwise the resulting value is that "
"of the operands."
msgstr ""

#: ../../../LangRef.rst:4992
msgid "2"
msgstr ""

#: ../../../LangRef.rst:4995
msgid "**Warning**"
msgstr ""

#: ../../../LangRef.rst:4994
msgid ""
"Emits a warning if two values disagree. The result value will be the operand "
"for the flag from the first module being linked."
msgstr ""

#: ../../../LangRef.rst:4997
msgid "3"
msgstr ""

#: ../../../LangRef.rst:5005
msgid "**Require**"
msgstr ""

#: ../../../LangRef.rst:4999
msgid ""
"Adds a requirement that another module flag be present and have a specified "
"value after linking is performed. The value must be a metadata pair, where "
"the first element of the pair is the ID of the module flag to be restricted, "
"and the second element of the pair is the value the module flag should be "
"restricted to. This behavior can be used to restrict the allowable results "
"(via triggering of an error) of linking IDs with the **Override** behavior."
msgstr ""

#: ../../../LangRef.rst:5007
msgid "4"
msgstr ""

#: ../../../LangRef.rst:5011
msgid "**Override**"
msgstr ""

#: ../../../LangRef.rst:5009
msgid ""
"Uses the specified value, regardless of the behavior or value of the other "
"module. If both modules specify **Override**, but the values differ, an "
"error will be emitted."
msgstr ""

#: ../../../LangRef.rst:5013
msgid "5"
msgstr ""

#: ../../../LangRef.rst:5015
msgid "**Append**"
msgstr ""

#: ../../../LangRef.rst:5015
msgid "Appends the two values, which are required to be metadata nodes."
msgstr ""

#: ../../../LangRef.rst:5017
msgid "6"
msgstr ""

#: ../../../LangRef.rst:5020
msgid "**AppendUnique**"
msgstr ""

#: ../../../LangRef.rst:5019
msgid ""
"Appends the two values, which are required to be metadata nodes. However, "
"duplicate entries in the second list are dropped during the append operation."
msgstr ""

#: ../../../LangRef.rst:5023
msgid ""
"It is an error for a particular unique flag ID to have multiple behaviors, "
"except in the case of **Require** (which adds restrictions on another "
"metadata value) or **Override**."
msgstr ""

#: ../../../LangRef.rst:5027
msgid "An example of module flags:"
msgstr ""

#: ../../../LangRef.rst:5041
msgid ""
"Metadata ``!0`` has the ID ``!\"foo\"`` and the value '1'. The behavior if "
"two or more ``!\"foo\"`` flags are seen is to emit an error if their values "
"are not equal."
msgstr ""

#: ../../../LangRef.rst:5045
msgid ""
"Metadata ``!1`` has the ID ``!\"bar\"`` and the value '37'. The behavior if "
"two or more ``!\"bar\"`` flags are seen is to use the value '37'."
msgstr ""

#: ../../../LangRef.rst:5049
msgid ""
"Metadata ``!2`` has the ID ``!\"qux\"`` and the value '42'. The behavior if "
"two or more ``!\"qux\"`` flags are seen is to emit a warning if their values "
"are not equal."
msgstr ""

#: ../../../LangRef.rst:5053
msgid "Metadata ``!3`` has the ID ``!\"qux\"`` and the value:"
msgstr ""

#: ../../../LangRef.rst:5059
msgid ""
"The behavior is to emit an error if the ``llvm.module.flags`` does not "
"contain a flag with the ID ``!\"foo\"`` that has the value '1' after linking "
"is performed."
msgstr ""

#: ../../../LangRef.rst:5064
msgid "Objective-C Garbage Collection Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:5066
msgid ""
"On the Mach-O platform, Objective-C stores metadata about garbage collection "
"in a special section called \"image info\". The metadata consists of a "
"version number and a bitmask specifying what types of garbage collection are "
"supported (if any) by the file. If two or more modules are linked together "
"their garbage collection metadata needs to be merged rather than appended "
"together."
msgstr ""

#: ../../../LangRef.rst:5073
msgid ""
"The Objective-C garbage collection module flags metadata consists of the "
"following key-value pairs:"
msgstr ""

#: ../../../LangRef.rst:5080 ../../../LangRef.rst:5165
msgid "Key"
msgstr ""

#: ../../../LangRef.rst:5083
msgid "``Objective-C Version``"
msgstr ""

#: ../../../LangRef.rst:5084
msgid ""
"**[Required]** --- The Objective-C ABI version. Valid values are 1 and 2."
msgstr ""

#: ../../../LangRef.rst:5086
msgid "``Objective-C Image Info Version``"
msgstr ""

#: ../../../LangRef.rst:5087
msgid ""
"**[Required]** --- The version of the image info section. Currently always 0."
msgstr ""

#: ../../../LangRef.rst:5090
msgid "``Objective-C Image Info Section``"
msgstr ""

#: ../../../LangRef.rst:5091
msgid ""
"**[Required]** --- The section to place the metadata. Valid values are "
"``\"__OBJC, __image_info, regular\"`` for Objective-C ABI version 1, and "
"``\"__DATA,__objc_imageinfo, regular, no_dead_strip\"`` for Objective-C ABI "
"version 2."
msgstr ""

#: ../../../LangRef.rst:5096
msgid "``Objective-C Garbage Collection``"
msgstr ""

#: ../../../LangRef.rst:5097
msgid ""
"**[Required]** --- Specifies whether garbage collection is supported or not. "
"Valid values are 0, for no garbage collection, and 2, for garbage collection "
"supported."
msgstr ""

#: ../../../LangRef.rst:5101
msgid "``Objective-C GC Only``"
msgstr ""

#: ../../../LangRef.rst:5102
msgid ""
"**[Optional]** --- Specifies that only garbage collection is supported. If "
"present, its value must be 6. This flag requires that the ``Objective-C "
"Garbage Collection`` flag have the value 2."
msgstr ""

#: ../../../LangRef.rst:5106
msgid "Some important flag interactions:"
msgstr ""

#: ../../../LangRef.rst:5108
msgid ""
"If a module with ``Objective-C Garbage Collection`` set to 0 is merged with "
"a module with ``Objective-C Garbage Collection`` set to 2, then the "
"resulting module has the ``Objective-C Garbage Collection`` flag set to 0."
msgstr ""

#: ../../../LangRef.rst:5112
msgid ""
"A module with ``Objective-C Garbage Collection`` set to 0 cannot be merged "
"with a module with ``Objective-C GC Only`` set to 6."
msgstr ""

#: ../../../LangRef.rst:5116
msgid "Automatic Linker Flags Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:5118
msgid ""
"Some targets support embedding flags to the linker inside individual object "
"files. Typically this is used in conjunction with language extensions which "
"allow source files to explicitly declare the libraries they depend on, and "
"have these automatically be transmitted to the linker via object files."
msgstr ""

#: ../../../LangRef.rst:5123
msgid ""
"These flags are encoded in the IR using metadata in the module flags "
"section, using the ``Linker Options`` key. The merge behavior for this flag "
"is required to be ``AppendUnique``, and the value for the key is expected to "
"be a metadata node which should be a list of other metadata nodes, each of "
"which should be a list of metadata strings defining linker options."
msgstr ""

#: ../../../LangRef.rst:5129
msgid ""
"For example, the following metadata section specifies two separate sets of "
"linker options, presumably to link against ``libz`` and the ``Cocoa`` "
"framework::"
msgstr ""

#: ../../../LangRef.rst:5139
msgid ""
"The metadata encoding as lists of lists of options, as opposed to a "
"collapsed list of options, is chosen so that the IR encoding can use "
"multiple option strings to specify e.g., a single library, while still "
"having that specifier be preserved as an atomic element that can be "
"recognized by a target specific assembly writer or object file emitter."
msgstr ""

#: ../../../LangRef.rst:5145
msgid ""
"Each individual option is required to be either a valid option for the "
"target's linker, or an option that is reserved by the target specific "
"assembly writer or object file emitter. No other aspect of these options is "
"defined by the IR."
msgstr ""

#: ../../../LangRef.rst:5150
msgid "C type width Module Flags Metadata"
msgstr ""

#: ../../../LangRef.rst:5152
msgid ""
"The ARM backend emits a section into each generated object file describing "
"the options that it was compiled with (in a compiler-independent way) to "
"prevent linking incompatible objects, and to allow automatic library "
"selection. Some of these options are not visible at the IR level, namely "
"wchar_t width and enum width."
msgstr ""

#: ../../../LangRef.rst:5158
msgid ""
"To pass this information to the backend, these options are encoded in module "
"flags metadata, using the following key-value pairs:"
msgstr ""

#: ../../../LangRef.rst:5168
msgid "short_wchar"
msgstr ""

#: ../../../LangRef.rst:5169
msgid "0 --- sizeof(wchar_t) == 4"
msgstr ""

#: ../../../LangRef.rst:5170
msgid "1 --- sizeof(wchar_t) == 2"
msgstr ""

#: ../../../LangRef.rst:5172
msgid "short_enum"
msgstr ""

#: ../../../LangRef.rst:5173
msgid "0 --- Enums are at least as large as an ``int``."
msgstr ""

#: ../../../LangRef.rst:5174
msgid ""
"1 --- Enums are stored in the smallest integer type which can represent all "
"of its values."
msgstr ""

#: ../../../LangRef.rst:5177
msgid ""
"For example, the following metadata section specifies that the module was "
"compiled with a ``wchar_t`` width of 4 bytes, and the underlying type of an "
"enum is the smallest type which can represent all of its values::"
msgstr ""

#: ../../../LangRef.rst:5188
msgid "Intrinsic Global Variables"
msgstr ""

#: ../../../LangRef.rst:5190
msgid ""
"LLVM has a number of \"magic\" global variables that contain data that "
"affect code generation or other IR semantics. These are documented here. All "
"globals of this sort should have a section specified as \"``llvm."
"metadata``\". This section and all globals that start with \"``llvm.``\" are "
"reserved for use by LLVM."
msgstr ""

#: ../../../LangRef.rst:5199
msgid "The '``llvm.used``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:5201
msgid ""
"The ``@llvm.used`` global is an array which has :ref:`appending linkage "
"<linkage_appending>`. This array contains a list of pointers to named global "
"variables, functions and aliases which may optionally have a pointer cast "
"formed of bitcast or getelementptr. For example, a legal use of it is:"
msgstr ""

#: ../../../LangRef.rst:5217
msgid ""
"If a symbol appears in the ``@llvm.used`` list, then the compiler, "
"assembler, and linker are required to treat the symbol as if there is a "
"reference to the symbol that it cannot see (which is why they have to be "
"named). For example, if a variable has internal linkage and no references "
"other than that from the ``@llvm.used`` list, it cannot be deleted. This is "
"commonly used to represent references from inline asms and other things the "
"compiler cannot \"see\", and corresponds to \"``attribute((used))``\" in GNU "
"C."
msgstr ""

#: ../../../LangRef.rst:5225
msgid ""
"On some targets, the code generator must emit a directive to the assembler "
"or object file to prevent the assembler and linker from molesting the symbol."
msgstr ""

#: ../../../LangRef.rst:5232
msgid "The '``llvm.compiler.used``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:5234
msgid ""
"The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used`` "
"directive, except that it only prevents the compiler from touching the "
"symbol. On targets that support it, this allows an intelligent linker to "
"optimize references to the symbol without being impeded as it would be by "
"``@llvm.used``."
msgstr ""

#: ../../../LangRef.rst:5240
msgid ""
"This is a rare construct that should only be used in rare circumstances, and "
"should not be exposed to source languages."
msgstr ""

#: ../../../LangRef.rst:5246
msgid "The '``llvm.global_ctors``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:5253
msgid ""
"The ``@llvm.global_ctors`` array contains a list of constructor functions, "
"priorities, and an optional associated global or function. The functions "
"referenced by this array will be called in ascending order of priority (i.e. "
"lowest first) when the module is loaded. The order of functions with the "
"same priority is not defined."
msgstr ""

#: ../../../LangRef.rst:5259
msgid ""
"If the third field is present, non-null, and points to a global variable or "
"function, the initializer function will only run if the associated data from "
"the current module is not discarded."
msgstr ""

#: ../../../LangRef.rst:5266
msgid "The '``llvm.global_dtors``' Global Variable"
msgstr ""

#: ../../../LangRef.rst:5273
msgid ""
"The ``@llvm.global_dtors`` array contains a list of destructor functions, "
"priorities, and an optional associated global or function. The functions "
"referenced by this array will be called in descending order of priority (i."
"e. highest first) when the module is unloaded. The order of functions with "
"the same priority is not defined."
msgstr ""

#: ../../../LangRef.rst:5279
msgid ""
"If the third field is present, non-null, and points to a global variable or "
"function, the destructor function will only run if the associated data from "
"the current module is not discarded."
msgstr ""

#: ../../../LangRef.rst:5284
msgid "Instruction Reference"
msgstr ""

#: ../../../LangRef.rst:5286
msgid ""
"The LLVM instruction set consists of several different classifications of "
"instructions: :ref:`terminator instructions <terminators>`, :ref:`binary "
"instructions <binaryops>`, :ref:`bitwise binary instructions <bitwiseops>`, :"
"ref:`memory instructions <memoryops>`, and :ref:`other instructions "
"<otherops>`."
msgstr ""

#: ../../../LangRef.rst:5295
msgid "Terminator Instructions"
msgstr ""

#: ../../../LangRef.rst:5297
msgid ""
"As mentioned :ref:`previously <functionstructure>`, every basic block in a "
"program ends with a \"Terminator\" instruction, which indicates which block "
"should be executed after the current block is finished. These terminator "
"instructions typically yield a '``void``' value: they produce control flow, "
"not values (the one exception being the ':ref:`invoke <i_invoke>`' "
"instruction)."
msgstr ""

#: ../../../LangRef.rst:5304
msgid ""
"The terminator instructions are: ':ref:`ret <i_ret>`', ':ref:`br <i_br>`', ':"
"ref:`switch <i_switch>`', ':ref:`indirectbr <i_indirectbr>`', ':ref:`invoke "
"<i_invoke>`', ':ref:`resume <i_resume>`', ':ref:`catchswitch "
"<i_catchswitch>`', ':ref:`catchret <i_catchret>`', ':ref:`cleanupret "
"<i_cleanupret>`', and ':ref:`unreachable <i_unreachable>`'."
msgstr ""

#: ../../../LangRef.rst:5315
msgid "'``ret``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5318 ../../../LangRef.rst:5375
#: ../../../LangRef.rst:5424 ../../../LangRef.rst:5486
#: ../../../LangRef.rst:5537 ../../../LangRef.rst:5636
#: ../../../LangRef.rst:5675 ../../../LangRef.rst:5731
#: ../../../LangRef.rst:5779 ../../../LangRef.rst:5830
#: ../../../LangRef.rst:5868 ../../../LangRef.rst:5919
#: ../../../LangRef.rst:5956 ../../../LangRef.rst:6011
#: ../../../LangRef.rst:6052 ../../../LangRef.rst:6107
#: ../../../LangRef.rst:6144 ../../../LangRef.rst:6188
#: ../../../LangRef.rst:6236 ../../../LangRef.rst:6273
#: ../../../LangRef.rst:6315 ../../../LangRef.rst:6372
#: ../../../LangRef.rst:6421 ../../../LangRef.rst:6474
#: ../../../LangRef.rst:6524 ../../../LangRef.rst:6575
#: ../../../LangRef.rst:6624 ../../../LangRef.rst:6673
#: ../../../LangRef.rst:6736 ../../../LangRef.rst:6776
#: ../../../LangRef.rst:6818 ../../../LangRef.rst:6879
#: ../../../LangRef.rst:6925 ../../../LangRef.rst:6980
#: ../../../LangRef.rst:7038 ../../../LangRef.rst:7167
#: ../../../LangRef.rst:7256 ../../../LangRef.rst:7312
#: ../../../LangRef.rst:7398 ../../../LangRef.rst:7471
#: ../../../LangRef.rst:7690 ../../../LangRef.rst:7732
#: ../../../LangRef.rst:7772 ../../../LangRef.rst:7813
#: ../../../LangRef.rst:7854 ../../../LangRef.rst:7894
#: ../../../LangRef.rst:7936 ../../../LangRef.rst:7978
#: ../../../LangRef.rst:8019 ../../../LangRef.rst:8062
#: ../../../LangRef.rst:8108 ../../../LangRef.rst:8153
#: ../../../LangRef.rst:8205 ../../../LangRef.rst:8258
#: ../../../LangRef.rst:8346 ../../../LangRef.rst:8458
#: ../../../LangRef.rst:8512 ../../../LangRef.rst:8559
#: ../../../LangRef.rst:8692 ../../../LangRef.rst:8743
#: ../../../LangRef.rst:8827 ../../../LangRef.rst:8895
#: ../../../LangRef.rst:9060 ../../../LangRef.rst:9092
#: ../../../LangRef.rst:9125 ../../../LangRef.rst:9184
#: ../../../LangRef.rst:9219 ../../../LangRef.rst:9255
#: ../../../LangRef.rst:9295 ../../../LangRef.rst:9333
#: ../../../LangRef.rst:9359 ../../../LangRef.rst:9396
#: ../../../LangRef.rst:9449 ../../../LangRef.rst:9493
#: ../../../LangRef.rst:9525 ../../../LangRef.rst:9551
#: ../../../LangRef.rst:9591 ../../../LangRef.rst:9628
#: ../../../LangRef.rst:9661 ../../../LangRef.rst:9692
#: ../../../LangRef.rst:9725 ../../../LangRef.rst:9769
#: ../../../LangRef.rst:9800 ../../../LangRef.rst:9849
#: ../../../LangRef.rst:9886 ../../../LangRef.rst:9939
#: ../../../LangRef.rst:9994 ../../../LangRef.rst:10045
#: ../../../LangRef.rst:10085 ../../../LangRef.rst:10123
#: ../../../LangRef.rst:10159 ../../../LangRef.rst:10195
#: ../../../LangRef.rst:10232 ../../../LangRef.rst:10267
#: ../../../LangRef.rst:10302 ../../../LangRef.rst:10337
#: ../../../LangRef.rst:10372 ../../../LangRef.rst:10407
#: ../../../LangRef.rst:10443 ../../../LangRef.rst:10479
#: ../../../LangRef.rst:10521 ../../../LangRef.rst:10562
#: ../../../LangRef.rst:10598 ../../../LangRef.rst:10633
#: ../../../LangRef.rst:10668 ../../../LangRef.rst:10704
#: ../../../LangRef.rst:10741 ../../../LangRef.rst:10777
#: ../../../LangRef.rst:10819 ../../../LangRef.rst:10847
#: ../../../LangRef.rst:10882 ../../../LangRef.rst:10920
#: ../../../LangRef.rst:10967 ../../../LangRef.rst:11040
#: ../../../LangRef.rst:11090 ../../../LangRef.rst:11139
#: ../../../LangRef.rst:11189 ../../../LangRef.rst:11239
#: ../../../LangRef.rst:11289 ../../../LangRef.rst:11342
#: ../../../LangRef.rst:11411 ../../../LangRef.rst:11478
#: ../../../LangRef.rst:11518 ../../../LangRef.rst:11606
#: ../../../LangRef.rst:11652 ../../../LangRef.rst:11693
#: ../../../LangRef.rst:11738 ../../../LangRef.rst:11788
#: ../../../LangRef.rst:11842 ../../../LangRef.rst:11900
#: ../../../LangRef.rst:11933 ../../../LangRef.rst:11964
#: ../../../LangRef.rst:11995 ../../../LangRef.rst:12025
#: ../../../LangRef.rst:12061 ../../../LangRef.rst:12091
#: ../../../LangRef.rst:12131 ../../../LangRef.rst:12169
#: ../../../LangRef.rst:12196 ../../../LangRef.rst:12223
#: ../../../LangRef.rst:12259 ../../../LangRef.rst:12294
#: ../../../LangRef.rst:12332 ../../../LangRef.rst:12367
#: ../../../LangRef.rst:12409 ../../../LangRef.rst:12432
#: ../../../LangRef.rst:12486 ../../../LangRef.rst:12515
#: ../../../LangRef.rst:12590 ../../../LangRef.rst:12639
#: ../../../LangRef.rst:12679
msgid "Syntax:"
msgstr ""

#: ../../../LangRef.rst:5326 ../../../LangRef.rst:5383
#: ../../../LangRef.rst:5431 ../../../LangRef.rst:5493
#: ../../../LangRef.rst:5545 ../../../LangRef.rst:5643
#: ../../../LangRef.rst:5683 ../../../LangRef.rst:5738
#: ../../../LangRef.rst:5787 ../../../LangRef.rst:5837
#: ../../../LangRef.rst:5878 ../../../LangRef.rst:5926
#: ../../../LangRef.rst:5966 ../../../LangRef.rst:6018
#: ../../../LangRef.rst:6062 ../../../LangRef.rst:6114
#: ../../../LangRef.rst:6152 ../../../LangRef.rst:6196
#: ../../../LangRef.rst:6243 ../../../LangRef.rst:6280
#: ../../../LangRef.rst:6322 ../../../LangRef.rst:6379
#: ../../../LangRef.rst:6431 ../../../LangRef.rst:6482
#: ../../../LangRef.rst:6532 ../../../LangRef.rst:6582
#: ../../../LangRef.rst:6631 ../../../LangRef.rst:6680
#: ../../../LangRef.rst:6743 ../../../LangRef.rst:6783
#: ../../../LangRef.rst:6825 ../../../LangRef.rst:6886
#: ../../../LangRef.rst:6932 ../../../LangRef.rst:6987
#: ../../../LangRef.rst:7049 ../../../LangRef.rst:7175
#: ../../../LangRef.rst:7263 ../../../LangRef.rst:7319
#: ../../../LangRef.rst:7405 ../../../LangRef.rst:7480
#: ../../../LangRef.rst:7697 ../../../LangRef.rst:7739
#: ../../../LangRef.rst:7779 ../../../LangRef.rst:7820
#: ../../../LangRef.rst:7861 ../../../LangRef.rst:7901
#: ../../../LangRef.rst:7943 ../../../LangRef.rst:7985
#: ../../../LangRef.rst:8026 ../../../LangRef.rst:8069
#: ../../../LangRef.rst:8115 ../../../LangRef.rst:8160
#: ../../../LangRef.rst:8212 ../../../LangRef.rst:8265
#: ../../../LangRef.rst:8353 ../../../LangRef.rst:8465
#: ../../../LangRef.rst:8521 ../../../LangRef.rst:8567
#: ../../../LangRef.rst:8699 ../../../LangRef.rst:8754
#: ../../../LangRef.rst:8834 ../../../LangRef.rst:8902
#: ../../../LangRef.rst:9067 ../../../LangRef.rst:9099
#: ../../../LangRef.rst:9132 ../../../LangRef.rst:9191
#: ../../../LangRef.rst:9226 ../../../LangRef.rst:9262
#: ../../../LangRef.rst:9302 ../../../LangRef.rst:9340
#: ../../../LangRef.rst:9366 ../../../LangRef.rst:9404
#: ../../../LangRef.rst:9460 ../../../LangRef.rst:9500
#: ../../../LangRef.rst:9532 ../../../LangRef.rst:9559
#: ../../../LangRef.rst:9598 ../../../LangRef.rst:9635
#: ../../../LangRef.rst:9668 ../../../LangRef.rst:9699
#: ../../../LangRef.rst:9733 ../../../LangRef.rst:9778
#: ../../../LangRef.rst:9809 ../../../LangRef.rst:9856
#: ../../../LangRef.rst:9900 ../../../LangRef.rst:9953
#: ../../../LangRef.rst:10008 ../../../LangRef.rst:10060
#: ../../../LangRef.rst:10100 ../../../LangRef.rst:10138
#: ../../../LangRef.rst:10174 ../../../LangRef.rst:10210
#: ../../../LangRef.rst:10247 ../../../LangRef.rst:10282
#: ../../../LangRef.rst:10317 ../../../LangRef.rst:10352
#: ../../../LangRef.rst:10387 ../../../LangRef.rst:10422
#: ../../../LangRef.rst:10458 ../../../LangRef.rst:10494
#: ../../../LangRef.rst:10536 ../../../LangRef.rst:10577
#: ../../../LangRef.rst:10613 ../../../LangRef.rst:10648
#: ../../../LangRef.rst:10683 ../../../LangRef.rst:10719
#: ../../../LangRef.rst:10756 ../../../LangRef.rst:10792
#: ../../../LangRef.rst:10831 ../../../LangRef.rst:10859
#: ../../../LangRef.rst:10898 ../../../LangRef.rst:10936
#: ../../../LangRef.rst:10983 ../../../LangRef.rst:11052
#: ../../../LangRef.rst:11102 ../../../LangRef.rst:11151
#: ../../../LangRef.rst:11201 ../../../LangRef.rst:11251
#: ../../../LangRef.rst:11301 ../../../LangRef.rst:11350
#: ../../../LangRef.rst:11419 ../../../LangRef.rst:11486
#: ../../../LangRef.rst:11526 ../../../LangRef.rst:11613
#: ../../../LangRef.rst:11659 ../../../LangRef.rst:11706
#: ../../../LangRef.rst:11751 ../../../LangRef.rst:11798
#: ../../../LangRef.rst:11852 ../../../LangRef.rst:11907
#: ../../../LangRef.rst:11940 ../../../LangRef.rst:11972
#: ../../../LangRef.rst:12003 ../../../LangRef.rst:12032
#: ../../../LangRef.rst:12068 ../../../LangRef.rst:12107
#: ../../../LangRef.rst:12145 ../../../LangRef.rst:12176
#: ../../../LangRef.rst:12203 ../../../LangRef.rst:12230
#: ../../../LangRef.rst:12266 ../../../LangRef.rst:12302
#: ../../../LangRef.rst:12344 ../../../LangRef.rst:12374
#: ../../../LangRef.rst:12423 ../../../LangRef.rst:12448
#: ../../../LangRef.rst:12493 ../../../LangRef.rst:12522
#: ../../../LangRef.rst:12597 ../../../LangRef.rst:12646
#: ../../../LangRef.rst:12691
msgid "Overview:"
msgstr ""

#: ../../../LangRef.rst:5328
msgid ""
"The '``ret``' instruction is used to return control flow (and optionally a "
"value) from a function back to the caller."
msgstr ""

#: ../../../LangRef.rst:5331
msgid ""
"There are two forms of the '``ret``' instruction: one that returns a value "
"and then causes control flow, and one that just causes control flow to occur."
msgstr ""

#: ../../../LangRef.rst:5336 ../../../LangRef.rst:5391
#: ../../../LangRef.rst:5439 ../../../LangRef.rst:5501
#: ../../../LangRef.rst:5567 ../../../LangRef.rst:5649
#: ../../../LangRef.rst:5690 ../../../LangRef.rst:5745
#: ../../../LangRef.rst:5794 ../../../LangRef.rst:5883
#: ../../../LangRef.rst:5931 ../../../LangRef.rst:5974
#: ../../../LangRef.rst:6026 ../../../LangRef.rst:6067
#: ../../../LangRef.rst:6119 ../../../LangRef.rst:6157
#: ../../../LangRef.rst:6201 ../../../LangRef.rst:6248
#: ../../../LangRef.rst:6286 ../../../LangRef.rst:6330
#: ../../../LangRef.rst:6385 ../../../LangRef.rst:6437
#: ../../../LangRef.rst:6488 ../../../LangRef.rst:6539
#: ../../../LangRef.rst:6588 ../../../LangRef.rst:6637
#: ../../../LangRef.rst:6687 ../../../LangRef.rst:6749
#: ../../../LangRef.rst:6789 ../../../LangRef.rst:6832
#: ../../../LangRef.rst:6892 ../../../LangRef.rst:6938
#: ../../../LangRef.rst:6995 ../../../LangRef.rst:7054
#: ../../../LangRef.rst:7180 ../../../LangRef.rst:7269
#: ../../../LangRef.rst:7326 ../../../LangRef.rst:7410
#: ../../../LangRef.rst:7488 ../../../LangRef.rst:7702
#: ../../../LangRef.rst:7744 ../../../LangRef.rst:7784
#: ../../../LangRef.rst:7825 ../../../LangRef.rst:7867
#: ../../../LangRef.rst:7907 ../../../LangRef.rst:7949
#: ../../../LangRef.rst:7991 ../../../LangRef.rst:8032
#: ../../../LangRef.rst:8075 ../../../LangRef.rst:8121
#: ../../../LangRef.rst:8166 ../../../LangRef.rst:8218
#: ../../../LangRef.rst:8272 ../../../LangRef.rst:8366
#: ../../../LangRef.rst:8471 ../../../LangRef.rst:8527
#: ../../../LangRef.rst:8572 ../../../LangRef.rst:8706
#: ../../../LangRef.rst:8764 ../../../LangRef.rst:8842
#: ../../../LangRef.rst:8918 ../../../LangRef.rst:9073
#: ../../../LangRef.rst:9105 ../../../LangRef.rst:9138
#: ../../../LangRef.rst:9197 ../../../LangRef.rst:9233
#: ../../../LangRef.rst:9269 ../../../LangRef.rst:9309
#: ../../../LangRef.rst:9372 ../../../LangRef.rst:9412
#: ../../../LangRef.rst:9606 ../../../LangRef.rst:9647
#: ../../../LangRef.rst:9741 ../../../LangRef.rst:9785
#: ../../../LangRef.rst:9817 ../../../LangRef.rst:9910
#: ../../../LangRef.rst:9965 ../../../LangRef.rst:10018
#: ../../../LangRef.rst:10070 ../../../LangRef.rst:10108
#: ../../../LangRef.rst:10143 ../../../LangRef.rst:10179
#: ../../../LangRef.rst:10216 ../../../LangRef.rst:10252
#: ../../../LangRef.rst:10287 ../../../LangRef.rst:10322
#: ../../../LangRef.rst:10357 ../../../LangRef.rst:10392
#: ../../../LangRef.rst:10428 ../../../LangRef.rst:10464
#: ../../../LangRef.rst:10501 ../../../LangRef.rst:10543
#: ../../../LangRef.rst:10583 ../../../LangRef.rst:10618
#: ../../../LangRef.rst:10653 ../../../LangRef.rst:10689
#: ../../../LangRef.rst:10726 ../../../LangRef.rst:10762
#: ../../../LangRef.rst:10798 ../../../LangRef.rst:10904
#: ../../../LangRef.rst:10942 ../../../LangRef.rst:10989
#: ../../../LangRef.rst:11059 ../../../LangRef.rst:11109
#: ../../../LangRef.rst:11158 ../../../LangRef.rst:11208
#: ../../../LangRef.rst:11258 ../../../LangRef.rst:11308
#: ../../../LangRef.rst:11428 ../../../LangRef.rst:11492
#: ../../../LangRef.rst:11533 ../../../LangRef.rst:11619
#: ../../../LangRef.rst:11665 ../../../LangRef.rst:11712
#: ../../../LangRef.rst:11756 ../../../LangRef.rst:11804
#: ../../../LangRef.rst:11857 ../../../LangRef.rst:11913
#: ../../../LangRef.rst:11946 ../../../LangRef.rst:11978
#: ../../../LangRef.rst:12009 ../../../LangRef.rst:12040
#: ../../../LangRef.rst:12073 ../../../LangRef.rst:12112
#: ../../../LangRef.rst:12150 ../../../LangRef.rst:12181
#: ../../../LangRef.rst:12208 ../../../LangRef.rst:12237
#: ../../../LangRef.rst:12275 ../../../LangRef.rst:12312
#: ../../../LangRef.rst:12350 ../../../LangRef.rst:12381
#: ../../../LangRef.rst:12417 ../../../LangRef.rst:12440
#: ../../../LangRef.rst:12501 ../../../LangRef.rst:12537
#: ../../../LangRef.rst:12700
msgid "Arguments:"
msgstr ""

#: ../../../LangRef.rst:5338
msgid ""
"The '``ret``' instruction optionally accepts a single argument, the return "
"value. The type of the return value must be a ':ref:`first class "
"<t_firstclass>`' type."
msgstr ""

#: ../../../LangRef.rst:5342
msgid ""
"A function is not :ref:`well formed <wellformed>` if it it has a non-void "
"return type and contains a '``ret``' instruction with no return value or a "
"return value with a type that does not match its type, or if it has a void "
"return type and contains a '``ret``' instruction with a return value."
msgstr ""

#: ../../../LangRef.rst:5349 ../../../LangRef.rst:5398
#: ../../../LangRef.rst:5447 ../../../LangRef.rst:5512
#: ../../../LangRef.rst:5603 ../../../LangRef.rst:5656
#: ../../../LangRef.rst:5705 ../../../LangRef.rst:5753
#: ../../../LangRef.rst:5809 ../../../LangRef.rst:5845
#: ../../../LangRef.rst:5890 ../../../LangRef.rst:5938
#: ../../../LangRef.rst:5981 ../../../LangRef.rst:6033
#: ../../../LangRef.rst:6074 ../../../LangRef.rst:6126
#: ../../../LangRef.rst:6164 ../../../LangRef.rst:6208
#: ../../../LangRef.rst:6255 ../../../LangRef.rst:6293
#: ../../../LangRef.rst:6337 ../../../LangRef.rst:6392
#: ../../../LangRef.rst:6444 ../../../LangRef.rst:6495
#: ../../../LangRef.rst:6546 ../../../LangRef.rst:6595
#: ../../../LangRef.rst:6644 ../../../LangRef.rst:6694
#: ../../../LangRef.rst:6757 ../../../LangRef.rst:6798
#: ../../../LangRef.rst:6844 ../../../LangRef.rst:6907
#: ../../../LangRef.rst:6949 ../../../LangRef.rst:7010
#: ../../../LangRef.rst:7142 ../../../LangRef.rst:7230
#: ../../../LangRef.rst:7276 ../../../LangRef.rst:7354
#: ../../../LangRef.rst:7437 ../../../LangRef.rst:7545
#: ../../../LangRef.rst:7711 ../../../LangRef.rst:7752
#: ../../../LangRef.rst:7792 ../../../LangRef.rst:7833
#: ../../../LangRef.rst:7874 ../../../LangRef.rst:7916
#: ../../../LangRef.rst:7958 ../../../LangRef.rst:8000
#: ../../../LangRef.rst:8041 ../../../LangRef.rst:8083
#: ../../../LangRef.rst:8128 ../../../LangRef.rst:8178
#: ../../../LangRef.rst:8225 ../../../LangRef.rst:8294
#: ../../../LangRef.rst:8397 ../../../LangRef.rst:8490
#: ../../../LangRef.rst:8534 ../../../LangRef.rst:8654
#: ../../../LangRef.rst:8714 ../../../LangRef.rst:8778
#: ../../../LangRef.rst:8859 ../../../LangRef.rst:8924
#: ../../../LangRef.rst:9078 ../../../LangRef.rst:9110
#: ../../../LangRef.rst:9144 ../../../LangRef.rst:9205
#: ../../../LangRef.rst:9241 ../../../LangRef.rst:9277
#: ../../../LangRef.rst:9317 ../../../LangRef.rst:9347
#: ../../../LangRef.rst:9380 ../../../LangRef.rst:9432
#: ../../../LangRef.rst:9468 ../../../LangRef.rst:9509
#: ../../../LangRef.rst:9541 ../../../LangRef.rst:9570
#: ../../../LangRef.rst:9617 ../../../LangRef.rst:9652
#: ../../../LangRef.rst:9678 ../../../LangRef.rst:9707
#: ../../../LangRef.rst:9757 ../../../LangRef.rst:9792
#: ../../../LangRef.rst:9837 ../../../LangRef.rst:9862
#: ../../../LangRef.rst:9927 ../../../LangRef.rst:9982
#: ../../../LangRef.rst:10034 ../../../LangRef.rst:10076
#: ../../../LangRef.rst:10114 ../../../LangRef.rst:10149
#: ../../../LangRef.rst:10185 ../../../LangRef.rst:10222
#: ../../../LangRef.rst:10258 ../../../LangRef.rst:10293
#: ../../../LangRef.rst:10328 ../../../LangRef.rst:10363
#: ../../../LangRef.rst:10398 ../../../LangRef.rst:10434
#: ../../../LangRef.rst:10470 ../../../LangRef.rst:10507
#: ../../../LangRef.rst:10549 ../../../LangRef.rst:10589
#: ../../../LangRef.rst:10624 ../../../LangRef.rst:10659
#: ../../../LangRef.rst:10695 ../../../LangRef.rst:10732
#: ../../../LangRef.rst:10768 ../../../LangRef.rst:10804
#: ../../../LangRef.rst:10838 ../../../LangRef.rst:10867
#: ../../../LangRef.rst:10911 ../../../LangRef.rst:10955
#: ../../../LangRef.rst:11002 ../../../LangRef.rst:11068
#: ../../../LangRef.rst:11118 ../../../LangRef.rst:11167
#: ../../../LangRef.rst:11217 ../../../LangRef.rst:11267
#: ../../../LangRef.rst:11317 ../../../LangRef.rst:11434
#: ../../../LangRef.rst:11498 ../../../LangRef.rst:11539
#: ../../../LangRef.rst:11631 ../../../LangRef.rst:11672
#: ../../../LangRef.rst:11718 ../../../LangRef.rst:11762
#: ../../../LangRef.rst:11810 ../../../LangRef.rst:11863
#: ../../../LangRef.rst:11920 ../../../LangRef.rst:11953
#: ../../../LangRef.rst:11985 ../../../LangRef.rst:12017
#: ../../../LangRef.rst:12046 ../../../LangRef.rst:12080
#: ../../../LangRef.rst:12120 ../../../LangRef.rst:12158
#: ../../../LangRef.rst:12186 ../../../LangRef.rst:12213
#: ../../../LangRef.rst:12245 ../../../LangRef.rst:12280
#: ../../../LangRef.rst:12321 ../../../LangRef.rst:12357
#: ../../../LangRef.rst:12386 ../../../LangRef.rst:12506
#: ../../../LangRef.rst:12543 ../../../LangRef.rst:12716
msgid "Semantics:"
msgstr ""

#: ../../../LangRef.rst:5351
msgid ""
"When the '``ret``' instruction is executed, control flow returns back to the "
"calling function's context. If the caller is a \":ref:`call <i_call>`\" "
"instruction, execution continues at the instruction after the call. If the "
"caller was an \":ref:`invoke <i_invoke>`\" instruction, execution continues "
"at the beginning of the \"normal\" destination block. If the instruction "
"returns a value, that value shall set the call or invoke instruction's "
"return value."
msgstr ""

#: ../../../LangRef.rst:5372
msgid "'``br``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5385
msgid ""
"The '``br``' instruction is used to cause control flow to transfer to a "
"different basic block in the current function. There are two forms of this "
"instruction, corresponding to a conditional branch and an unconditional "
"branch."
msgstr ""

#: ../../../LangRef.rst:5393
msgid ""
"The conditional branch form of the '``br``' instruction takes a single "
"'``i1``' value and two '``label``' values. The unconditional form of the "
"'``br``' instruction takes a single '``label``' value as a target."
msgstr ""

#: ../../../LangRef.rst:5400
msgid ""
"Upon execution of a conditional '``br``' instruction, the '``i1``' argument "
"is evaluated. If the value is ``true``, control flows to the '``iftrue``' "
"``label`` argument. If \"cond\" is ``false``, control flows to the "
"'``iffalse``' ``label`` argument."
msgstr ""

#: ../../../LangRef.rst:5421
msgid "'``switch``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5433
msgid ""
"The '``switch``' instruction is used to transfer control flow to one of "
"several different places. It is a generalization of the '``br``' "
"instruction, allowing a branch to occur to one of many possible destinations."
msgstr ""

#: ../../../LangRef.rst:5441
msgid ""
"The '``switch``' instruction uses three parameters: an integer comparison "
"value '``value``', a default '``label``' destination, and an array of pairs "
"of comparison value constants and '``label``'s. The table is not allowed to "
"contain duplicate constant entries."
msgstr ""

#: ../../../LangRef.rst:5449
msgid ""
"The ``switch`` instruction specifies a table of values and destinations. "
"When the '``switch``' instruction is executed, this table is searched for "
"the given value. If the value is found, control flow is transferred to the "
"corresponding destination; otherwise, control flow is transferred to the "
"default destination."
msgstr ""

#: ../../../LangRef.rst:5456 ../../../LangRef.rst:5520
msgid "Implementation:"
msgstr ""

#: ../../../LangRef.rst:5458
msgid ""
"Depending on properties of the target machine and the particular ``switch`` "
"instruction, this instruction may be code generated in different ways. For "
"example, it could be generated as a series of chained conditional branches "
"or with a lookup table."
msgstr ""

#: ../../../LangRef.rst:5483
msgid "'``indirectbr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5495
msgid ""
"The '``indirectbr``' instruction implements an indirect branch to a label "
"within the current function, whose address is specified by \"``address``\". "
"Address must be derived from a :ref:`blockaddress <blockaddress>` constant."
msgstr ""

#: ../../../LangRef.rst:5503
msgid ""
"The '``address``' argument is the address of the label to jump to. The rest "
"of the arguments indicate the full set of possible destinations that the "
"address may point to. Blocks are allowed to occur multiple times in the "
"destination list, though this isn't particularly useful."
msgstr ""

#: ../../../LangRef.rst:5508
msgid ""
"This destination list is required so that dataflow analysis has an accurate "
"understanding of the CFG."
msgstr ""

#: ../../../LangRef.rst:5514
msgid ""
"Control transfers to the block specified in the address argument. All "
"possible destination blocks must be listed in the label list, otherwise this "
"instruction has undefined behavior. This implies that jumps to labels "
"defined in other functions have undefined behavior as well."
msgstr ""

#: ../../../LangRef.rst:5522
msgid "This is typically implemented with a jump through a register."
msgstr ""

#: ../../../LangRef.rst:5534
msgid "'``invoke``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5547
msgid ""
"The '``invoke``' instruction causes control to transfer to a specified "
"function, with the possibility of control flow transfer to either the "
"'``normal``' label or the '``exception``' label. If the callee function "
"returns with the \"``ret``\" instruction, control flow will return to the "
"\"normal\" label. If the callee (or any indirect callees) returns via the \":"
"ref:`resume <i_resume>`\" instruction or other exception handling mechanism, "
"control is interrupted and continued at the dynamically nearest "
"\"exception\" label."
msgstr ""

#: ../../../LangRef.rst:5556
msgid ""
"The '``exception``' label is a `landing pad <ExceptionHandling."
"html#overview>`_ for the exception. As such, '``exception``' label is "
"required to have the \":ref:`landingpad <i_landingpad>`\" instruction, which "
"contains the information about the behavior of the program after unwinding "
"happens, as its first non-PHI instruction. The restrictions on the "
"\"``landingpad``\" instruction's tightly couples it to the \"``invoke``\" "
"instruction, so that the important information contained within the "
"\"``landingpad``\" instruction can't be lost through normal code motion."
msgstr ""

#: ../../../LangRef.rst:5569 ../../../LangRef.rst:8574
msgid "This instruction requires several arguments:"
msgstr ""

#: ../../../LangRef.rst:5571
msgid ""
"The optional \"cconv\" marker indicates which :ref:`calling convention "
"<callingconv>` the call should use. If none is specified, the call defaults "
"to using C calling conventions."
msgstr ""

#: ../../../LangRef.rst:5574 ../../../LangRef.rst:8630
msgid ""
"The optional :ref:`Parameter Attributes <paramattrs>` list for return "
"values. Only '``zeroext``', '``signext``', and '``inreg``' attributes are "
"valid here."
msgstr ""

#: ../../../LangRef.rst:5577 ../../../LangRef.rst:8633
msgid ""
"'``ty``': the type of the call instruction itself which is also the type of "
"the return value. Functions that return no value are marked ``void``."
msgstr ""

#: ../../../LangRef.rst:5580
msgid ""
"'``fnty``': shall be the signature of the function being invoked. The "
"argument types must match the types implied by this signature. This type can "
"be omitted if the function is not varargs."
msgstr ""

#: ../../../LangRef.rst:5583
msgid ""
"'``fnptrval``': An LLVM value containing a pointer to a function to be "
"invoked. In most cases, this is a direct function invocation, but indirect "
"``invoke``'s are just as possible, calling an arbitrary pointer to function "
"value."
msgstr ""

#: ../../../LangRef.rst:5587 ../../../LangRef.rst:8643
msgid ""
"'``function args``': argument list whose types match the function signature "
"argument types and parameter attributes. All arguments must be of :ref:"
"`first class <t_firstclass>` type. If the function signature indicates the "
"function accepts a variable number of arguments, the extra arguments can be "
"specified."
msgstr ""

#: ../../../LangRef.rst:5592
msgid ""
"'``normal label``': the label reached when the called function executes a "
"'``ret``' instruction."
msgstr ""

#: ../../../LangRef.rst:5594
msgid ""
"'``exception label``': the label reached when a callee returns via the :ref:"
"`resume <i_resume>` instruction or other exception handling mechanism."
msgstr ""

#: ../../../LangRef.rst:5597
msgid ""
"The optional :ref:`function attributes <fnattrs>` list. Only '``noreturn``', "
"'``nounwind``', '``readonly``' and '``readnone``' attributes are valid here."
msgstr ""

#: ../../../LangRef.rst:5600 ../../../LangRef.rst:8651
msgid "The optional :ref:`operand bundles <opbundles>` list."
msgstr ""

#: ../../../LangRef.rst:5605
msgid ""
"This instruction is designed to operate as a standard '``call``' instruction "
"in most regards. The primary difference is that it establishes an "
"association with a label, which is used by the runtime library to unwind the "
"stack."
msgstr ""

#: ../../../LangRef.rst:5610
msgid ""
"This instruction is used in languages with destructors to ensure that proper "
"cleanup is performed in the case of either a ``longjmp`` or a thrown "
"exception. Additionally, this is important for implementation of '``catch``' "
"clauses in high-level languages that support them."
msgstr ""

#: ../../../LangRef.rst:5615
msgid ""
"For the purposes of the SSA form, the definition of the value returned by "
"the '``invoke``' instruction is deemed to occur on the edge from the current "
"block to the \"normal\" label. If the callee unwinds then no return value is "
"available."
msgstr ""

#: ../../../LangRef.rst:5633
msgid "'``resume``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5645
msgid ""
"The '``resume``' instruction is a terminator instruction that has no "
"successors."
msgstr ""

#: ../../../LangRef.rst:5651
msgid ""
"The '``resume``' instruction requires one argument, which must have the same "
"type as the result of any '``landingpad``' instruction in the same function."
msgstr ""

#: ../../../LangRef.rst:5658
msgid ""
"The '``resume``' instruction resumes propagation of an existing (in-flight) "
"exception whose unwinding was interrupted with a :ref:`landingpad "
"<i_landingpad>` instruction."
msgstr ""

#: ../../../LangRef.rst:5672
msgid "'``catchswitch``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5685
msgid ""
"The '``catchswitch``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to describe the set of possible "
"catch handlers that may be executed by the :ref:`EH personality routine "
"<personalityfn>`."
msgstr ""

#: ../../../LangRef.rst:5692
msgid ""
"The ``parent`` argument is the token of the funclet that contains the "
"``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet, "
"this operand may be the token ``none``."
msgstr ""

#: ../../../LangRef.rst:5696
msgid ""
"The ``default`` argument is the label of another basic block beginning with "
"either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind "
"destination must be a legal target with respect to the ``parent`` links, as "
"described in the `exception handling documentation\\ <ExceptionHandling."
"html#wineh-constraints>`_."
msgstr ""

#: ../../../LangRef.rst:5701
msgid ""
"The ``handlers`` are a nonempty list of successor blocks that each begin "
"with a :ref:`catchpad <i_catchpad>` instruction."
msgstr ""

#: ../../../LangRef.rst:5707
msgid ""
"Executing this instruction transfers control to one of the successors in "
"``handlers``, if appropriate, or continues to unwind via the unwind label if "
"present."
msgstr ""

#: ../../../LangRef.rst:5711
msgid ""
"The ``catchswitch`` is both a terminator and a \"pad\" instruction, meaning "
"that it must be both the first non-phi instruction and last instruction in "
"the basic block. Therefore, it must be the only non-phi instruction in the "
"block."
msgstr ""

#: ../../../LangRef.rst:5728
msgid "'``catchret``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5740
msgid ""
"The '``catchret``' instruction is a terminator instruction that has a single "
"successor."
msgstr ""

#: ../../../LangRef.rst:5747
msgid ""
"The first argument to a '``catchret``' indicates which ``catchpad`` it "
"exits.  It must be a :ref:`catchpad <i_catchpad>`. The second argument to a "
"'``catchret``' specifies where control will transfer to next."
msgstr ""

#: ../../../LangRef.rst:5755
msgid ""
"The '``catchret``' instruction ends an existing (in-flight) exception whose "
"unwinding was interrupted with a :ref:`catchpad <i_catchpad>` instruction.  "
"The :ref:`personality function <personalityfn>` gets a chance to execute "
"arbitrary code to, for example, destroy the active exception.  Control then "
"transfers to ``normal``."
msgstr ""

#: ../../../LangRef.rst:5761
msgid ""
"The ``token`` argument must be a token produced by a ``catchpad`` "
"instruction. If the specified ``catchpad`` is not the most-recently-entered "
"not-yet-exited funclet pad (as described in the `EH documentation\\ "
"<ExceptionHandling.html#wineh-constraints>`_), the ``catchret``'s behavior "
"is undefined."
msgstr ""

#: ../../../LangRef.rst:5776
msgid "'``cleanupret``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5789
msgid ""
"The '``cleanupret``' instruction is a terminator instruction that has an "
"optional successor."
msgstr ""

#: ../../../LangRef.rst:5796
msgid ""
"The '``cleanupret``' instruction requires one argument, which indicates "
"which ``cleanuppad`` it exits, and must be a :ref:`cleanuppad "
"<i_cleanuppad>`. If the specified ``cleanuppad`` is not the most-recently-"
"entered not-yet-exited funclet pad (as described in the `EH documentation\\ "
"<ExceptionHandling.html#wineh-constraints>`_), the ``cleanupret``'s behavior "
"is undefined."
msgstr ""

#: ../../../LangRef.rst:5802
msgid ""
"The '``cleanupret``' instruction also has an optional successor, "
"``continue``, which must be the label of another basic block beginning with "
"either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind "
"destination must be a legal target with respect to the ``parent`` links, as "
"described in the `exception handling documentation\\ <ExceptionHandling."
"html#wineh-constraints>`_."
msgstr ""

#: ../../../LangRef.rst:5811
msgid ""
"The '``cleanupret``' instruction indicates to the :ref:`personality function "
"<personalityfn>` that one :ref:`cleanuppad <i_cleanuppad>` it transferred "
"control to has ended. It transfers control to ``continue`` or unwinds out of "
"the function."
msgstr ""

#: ../../../LangRef.rst:5827
msgid "'``unreachable``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5839
msgid ""
"The '``unreachable``' instruction has no defined semantics. This instruction "
"is used to inform the optimizer that a particular portion of the code is not "
"reachable. This can be used to indicate that the code after a no-return "
"function cannot be reached, and other facts."
msgstr ""

#: ../../../LangRef.rst:5847
msgid "The '``unreachable``' instruction has no defined semantics."
msgstr ""

#: ../../../LangRef.rst:5852
msgid "Binary Operations"
msgstr ""

#: ../../../LangRef.rst:5854
msgid ""
"Binary operators are used to do most of the computation in a program. They "
"require two operands of the same type, execute an operation on them, and "
"produce a single value. The operands might represent multiple data, as is "
"the case with the :ref:`vector <t_vector>` data type. The result value has "
"the same type as its operands."
msgstr ""

#: ../../../LangRef.rst:5860
msgid "There are several different binary operators:"
msgstr ""

#: ../../../LangRef.rst:5865
msgid "'``add``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5880
msgid "The '``add``' instruction returns the sum of its two operands."
msgstr ""

#: ../../../LangRef.rst:5885
msgid ""
"The two arguments to the '``add``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:5892
msgid "The value produced is the integer sum of the two operands."
msgstr ""

#: ../../../LangRef.rst:5894
msgid ""
"If the sum has unsigned overflow, the result returned is the mathematical "
"result modulo 2\\ :sup:`n`\\ , where n is the bit width of the result."
msgstr ""

#: ../../../LangRef.rst:5898 ../../../LangRef.rst:5989
msgid ""
"Because LLVM integers use a two's complement representation, this "
"instruction is appropriate for both signed and unsigned integers."
msgstr ""

#: ../../../LangRef.rst:5901
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", "
"respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result "
"value of the ``add`` is a :ref:`poison value <poisonvalues>` if unsigned and/"
"or signed overflow, respectively, occurs."
msgstr ""

#: ../../../LangRef.rst:5916
msgid "'``fadd``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5928
msgid "The '``fadd``' instruction returns the sum of its two operands."
msgstr ""

#: ../../../LangRef.rst:5933
msgid ""
"The two arguments to the '``fadd``' instruction must be :ref:`floating point "
"<t_floating>` or :ref:`vector <t_vector>` of floating point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:5940
msgid ""
"The value produced is the floating point sum of the two operands. This "
"instruction can also take any number of :ref:`fast-math flags <fastmath>`, "
"which are optimization hints to enable otherwise unsafe floating point "
"optimizations:"
msgstr ""

#: ../../../LangRef.rst:5953
msgid "'``sub``' Instruction"
msgstr ""

#: ../../../LangRef.rst:5968
msgid "The '``sub``' instruction returns the difference of its two operands."
msgstr ""

#: ../../../LangRef.rst:5970
msgid ""
"Note that the '``sub``' instruction is used to represent the '``neg``' "
"instruction present in most other intermediate representations."
msgstr ""

#: ../../../LangRef.rst:5976
msgid ""
"The two arguments to the '``sub``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:5983
msgid "The value produced is the integer difference of the two operands."
msgstr ""

#: ../../../LangRef.rst:5985
msgid ""
"If the difference has unsigned overflow, the result returned is the "
"mathematical result modulo 2\\ :sup:`n`\\ , where n is the bit width of the "
"result."
msgstr ""

#: ../../../LangRef.rst:5992
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", "
"respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result "
"value of the ``sub`` is a :ref:`poison value <poisonvalues>` if unsigned and/"
"or signed overflow, respectively, occurs."
msgstr ""

#: ../../../LangRef.rst:6008
msgid "'``fsub``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6020
msgid "The '``fsub``' instruction returns the difference of its two operands."
msgstr ""

#: ../../../LangRef.rst:6022
msgid ""
"Note that the '``fsub``' instruction is used to represent the '``fneg``' "
"instruction present in most other intermediate representations."
msgstr ""

#: ../../../LangRef.rst:6028
msgid ""
"The two arguments to the '``fsub``' instruction must be :ref:`floating point "
"<t_floating>` or :ref:`vector <t_vector>` of floating point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:6035
msgid ""
"The value produced is the floating point difference of the two operands. "
"This instruction can also take any number of :ref:`fast-math flags "
"<fastmath>`, which are optimization hints to enable otherwise unsafe "
"floating point optimizations:"
msgstr ""

#: ../../../LangRef.rst:6049
msgid "'``mul``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6064
msgid "The '``mul``' instruction returns the product of its two operands."
msgstr ""

#: ../../../LangRef.rst:6069
msgid ""
"The two arguments to the '``mul``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6076
msgid "The value produced is the integer product of the two operands."
msgstr ""

#: ../../../LangRef.rst:6078
msgid ""
"If the result of the multiplication has unsigned overflow, the result "
"returned is the mathematical result modulo 2\\ :sup:`n`\\ , where n is the "
"bit width of the result."
msgstr ""

#: ../../../LangRef.rst:6082
msgid ""
"Because LLVM integers use a two's complement representation, and the result "
"is the same width as the operands, this instruction returns the correct "
"result for both signed and unsigned integers. If a full product (e.g. "
"``i32`` * ``i32`` -> ``i64``) is needed, the operands should be sign-"
"extended or zero-extended as appropriate to the width of the full product."
msgstr ""

#: ../../../LangRef.rst:6089
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", "
"respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result "
"value of the ``mul`` is a :ref:`poison value <poisonvalues>` if unsigned and/"
"or signed overflow, respectively, occurs."
msgstr ""

#: ../../../LangRef.rst:6104
msgid "'``fmul``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6116
msgid "The '``fmul``' instruction returns the product of its two operands."
msgstr ""

#: ../../../LangRef.rst:6121
msgid ""
"The two arguments to the '``fmul``' instruction must be :ref:`floating point "
"<t_floating>` or :ref:`vector <t_vector>` of floating point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:6128
msgid ""
"The value produced is the floating point product of the two operands. This "
"instruction can also take any number of :ref:`fast-math flags <fastmath>`, "
"which are optimization hints to enable otherwise unsafe floating point "
"optimizations:"
msgstr ""

#: ../../../LangRef.rst:6141
msgid "'``udiv``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6154
msgid "The '``udiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../../LangRef.rst:6159
msgid ""
"The two arguments to the '``udiv``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6166
msgid ""
"The value produced is the unsigned integer quotient of the two operands."
msgstr ""

#: ../../../LangRef.rst:6168
msgid ""
"Note that unsigned integer division and signed integer division are distinct "
"operations; for signed integer division, use '``sdiv``'."
msgstr ""

#: ../../../LangRef.rst:6171
msgid "Division by zero leads to undefined behavior."
msgstr ""

#: ../../../LangRef.rst:6173
msgid ""
"If the ``exact`` keyword is present, the result value of the ``udiv`` is a :"
"ref:`poison value <poisonvalues>` if %op1 is not a multiple of %op2 (as "
"such, \"((a udiv exact b) mul b) == a\")."
msgstr ""

#: ../../../LangRef.rst:6185
msgid "'``sdiv``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6198
msgid "The '``sdiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../../LangRef.rst:6203
msgid ""
"The two arguments to the '``sdiv``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6210
msgid ""
"The value produced is the signed integer quotient of the two operands "
"rounded towards zero."
msgstr ""

#: ../../../LangRef.rst:6213
msgid ""
"Note that signed integer division and unsigned integer division are distinct "
"operations; for unsigned integer division, use '``udiv``'."
msgstr ""

#: ../../../LangRef.rst:6216
msgid ""
"Division by zero leads to undefined behavior. Overflow also leads to "
"undefined behavior; this is a rare case, but can occur, for example, by "
"doing a 32-bit division of -2147483648 by -1."
msgstr ""

#: ../../../LangRef.rst:6220
msgid ""
"If the ``exact`` keyword is present, the result value of the ``sdiv`` is a :"
"ref:`poison value <poisonvalues>` if the result would be rounded."
msgstr ""

#: ../../../LangRef.rst:6233
msgid "'``fdiv``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6245
msgid "The '``fdiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../../LangRef.rst:6250
msgid ""
"The two arguments to the '``fdiv``' instruction must be :ref:`floating point "
"<t_floating>` or :ref:`vector <t_vector>` of floating point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:6257
msgid ""
"The value produced is the floating point quotient of the two operands. This "
"instruction can also take any number of :ref:`fast-math flags <fastmath>`, "
"which are optimization hints to enable otherwise unsafe floating point "
"optimizations:"
msgstr ""

#: ../../../LangRef.rst:6270
msgid "'``urem``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6282
msgid ""
"The '``urem``' instruction returns the remainder from the unsigned division "
"of its two arguments."
msgstr ""

#: ../../../LangRef.rst:6288
msgid ""
"The two arguments to the '``urem``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6295
msgid ""
"This instruction returns the unsigned integer *remainder* of a division. "
"This instruction always performs an unsigned division to get the remainder."
msgstr ""

#: ../../../LangRef.rst:6299
msgid ""
"Note that unsigned integer remainder and signed integer remainder are "
"distinct operations; for signed integer remainder, use '``srem``'."
msgstr ""

#: ../../../LangRef.rst:6302
msgid "Taking the remainder of a division by zero leads to undefined behavior."
msgstr ""

#: ../../../LangRef.rst:6312
msgid "'``srem``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6324
msgid ""
"The '``srem``' instruction returns the remainder from the signed division of "
"its two operands. This instruction can also take :ref:`vector <t_vector>` "
"versions of the values in which case the elements must be integers."
msgstr ""

#: ../../../LangRef.rst:6332
msgid ""
"The two arguments to the '``srem``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6339
msgid ""
"This instruction returns the *remainder* of a division (where the result is "
"either zero or has the same sign as the dividend, ``op1``), not the *modulo* "
"operator (where the result is either zero or has the same sign as the "
"divisor, ``op2``) of a value. For more information about the difference, see "
"`The Math Forum <http://mathforum.org/dr.math/problems/anne.4.28.99.html>`_. "
"For a table of how this is implemented in various languages, please see "
"`Wikipedia: modulo operation <http://en.wikipedia.org/wiki/"
"Modulo_operation>`_."
msgstr ""

#: ../../../LangRef.rst:6349
msgid ""
"Note that signed integer remainder and unsigned integer remainder are "
"distinct operations; for unsigned integer remainder, use '``urem``'."
msgstr ""

#: ../../../LangRef.rst:6352
msgid ""
"Taking the remainder of a division by zero leads to undefined behavior. "
"Overflow also leads to undefined behavior; this is a rare case, but can "
"occur, for example, by taking the remainder of a 32-bit division of "
"-2147483648 by -1. (The remainder doesn't actually overflow, but this rule "
"lets srem be implemented using instructions that return both the result of "
"the division and the remainder.)"
msgstr ""

#: ../../../LangRef.rst:6369
msgid "'``frem``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6381
msgid ""
"The '``frem``' instruction returns the remainder from the division of its "
"two operands."
msgstr ""

#: ../../../LangRef.rst:6387
msgid ""
"The two arguments to the '``frem``' instruction must be :ref:`floating point "
"<t_floating>` or :ref:`vector <t_vector>` of floating point values. Both "
"arguments must have identical types."
msgstr ""

#: ../../../LangRef.rst:6394
msgid ""
"This instruction returns the *remainder* of a division. The remainder has "
"the same sign as the dividend. This instruction can also take any number of :"
"ref:`fast-math flags <fastmath>`, which are optimization hints to enable "
"otherwise unsafe floating point optimizations:"
msgstr ""

#: ../../../LangRef.rst:6409
msgid "Bitwise Binary Operations"
msgstr ""

#: ../../../LangRef.rst:6411
msgid ""
"Bitwise binary operators are used to do various forms of bit-twiddling in a "
"program. They are generally very efficient instructions and can commonly be "
"strength reduced from other instructions. They require two operands of the "
"same type, execute an operation on them, and produce a single value. The "
"resulting value is the same type as its operands."
msgstr ""

#: ../../../LangRef.rst:6418
msgid "'``shl``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6433
msgid ""
"The '``shl``' instruction returns the first operand shifted to the left a "
"specified number of bits."
msgstr ""

#: ../../../LangRef.rst:6439
msgid ""
"Both arguments to the '``shl``' instruction must be the same :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is "
"treated as an unsigned value."
msgstr ""

#: ../../../LangRef.rst:6446
msgid ""
"The value produced is ``op1`` \\* 2\\ :sup:`op2` mod 2\\ :sup:`n`, where "
"``n`` is the width of the result. If ``op2`` is (statically or dynamically) "
"equal to or larger than the number of bits in ``op1``, the result is "
"undefined. If the arguments are vectors, each vector element of ``op1`` is "
"shifted by the corresponding shift amount in ``op2``."
msgstr ""

#: ../../../LangRef.rst:6453
msgid ""
"If the ``nuw`` keyword is present, then the shift produces a :ref:`poison "
"value <poisonvalues>` if it shifts out any non-zero bits. If the ``nsw`` "
"keyword is present, then the shift produces a :ref:`poison value "
"<poisonvalues>` if it shifts out any bits that disagree with the resultant "
"sign bit."
msgstr ""

#: ../../../LangRef.rst:6471
msgid "'``lshr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6484
msgid ""
"The '``lshr``' instruction (logical shift right) returns the first operand "
"shifted to the right a specified number of bits with zero fill."
msgstr ""

#: ../../../LangRef.rst:6490
msgid ""
"Both arguments to the '``lshr``' instruction must be the same :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is "
"treated as an unsigned value."
msgstr ""

#: ../../../LangRef.rst:6497
msgid ""
"This instruction always performs a logical shift right operation. The most "
"significant bits of the result will be filled with zero bits after the "
"shift. If ``op2`` is (statically or dynamically) equal to or larger than the "
"number of bits in ``op1``, the result is undefined. If the arguments are "
"vectors, each vector element of ``op1`` is shifted by the corresponding "
"shift amount in ``op2``."
msgstr ""

#: ../../../LangRef.rst:6504
msgid ""
"If the ``exact`` keyword is present, the result value of the ``lshr`` is a :"
"ref:`poison value <poisonvalues>` if any of the bits shifted out are non-"
"zero."
msgstr ""

#: ../../../LangRef.rst:6521
msgid "'``ashr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6534
msgid ""
"The '``ashr``' instruction (arithmetic shift right) returns the first "
"operand shifted to the right a specified number of bits with sign extension."
msgstr ""

#: ../../../LangRef.rst:6541
msgid ""
"Both arguments to the '``ashr``' instruction must be the same :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is "
"treated as an unsigned value."
msgstr ""

#: ../../../LangRef.rst:6548
msgid ""
"This instruction always performs an arithmetic shift right operation, The "
"most significant bits of the result will be filled with the sign bit of "
"``op1``. If ``op2`` is (statically or dynamically) equal to or larger than "
"the number of bits in ``op1``, the result is undefined. If the arguments are "
"vectors, each vector element of ``op1`` is shifted by the corresponding "
"shift amount in ``op2``."
msgstr ""

#: ../../../LangRef.rst:6555
msgid ""
"If the ``exact`` keyword is present, the result value of the ``ashr`` is a :"
"ref:`poison value <poisonvalues>` if any of the bits shifted out are non-"
"zero."
msgstr ""

#: ../../../LangRef.rst:6572
msgid "'``and``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6584
msgid ""
"The '``and``' instruction returns the bitwise logical and of its two "
"operands."
msgstr ""

#: ../../../LangRef.rst:6590
msgid ""
"The two arguments to the '``and``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6597
msgid "The truth table used for the '``and``' instruction is:"
msgstr ""

#: ../../../LangRef.rst:6600 ../../../LangRef.rst:6649
#: ../../../LangRef.rst:6699
msgid "In0"
msgstr ""

#: ../../../LangRef.rst:6600 ../../../LangRef.rst:6649
#: ../../../LangRef.rst:6699
msgid "In1"
msgstr ""

#: ../../../LangRef.rst:6600 ../../../LangRef.rst:6649
#: ../../../LangRef.rst:6699
msgid "Out"
msgstr ""

#: ../../../LangRef.rst:6602 ../../../LangRef.rst:6604
#: ../../../LangRef.rst:6606 ../../../LangRef.rst:6651
#: ../../../LangRef.rst:6653 ../../../LangRef.rst:6655
#: ../../../LangRef.rst:6701 ../../../LangRef.rst:6703
#: ../../../LangRef.rst:6705 ../../../LangRef.rst:6707
msgid "0"
msgstr ""

#: ../../../LangRef.rst:6621
msgid "'``or``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6633
msgid ""
"The '``or``' instruction returns the bitwise logical inclusive or of its two "
"operands."
msgstr ""

#: ../../../LangRef.rst:6639
msgid ""
"The two arguments to the '``or``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6646
msgid "The truth table used for the '``or``' instruction is:"
msgstr ""

#: ../../../LangRef.rst:6670
msgid "'``xor``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6682
msgid ""
"The '``xor``' instruction returns the bitwise logical exclusive or of its "
"two operands. The ``xor`` is used to implement the \"one's complement\" "
"operation, which is the \"~\" operator in C."
msgstr ""

#: ../../../LangRef.rst:6689
msgid ""
"The two arguments to the '``xor``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments "
"must have identical types."
msgstr ""

#: ../../../LangRef.rst:6696
msgid "The truth table used for the '``xor``' instruction is:"
msgstr ""

#: ../../../LangRef.rst:6721
msgid "Vector Operations"
msgstr ""

#: ../../../LangRef.rst:6723
msgid ""
"LLVM supports several instructions to represent vector operations in a "
"target-independent manner. These instructions cover the element-access and "
"vector-specific operations needed to process vectors effectively. While LLVM "
"does directly support these vector operations, many sophisticated algorithms "
"will want to use target-specific intrinsics to take full advantage of a "
"specific target."
msgstr ""

#: ../../../LangRef.rst:6733
msgid "'``extractelement``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6745
msgid ""
"The '``extractelement``' instruction extracts a single scalar element from a "
"vector at a specified index."
msgstr ""

#: ../../../LangRef.rst:6751
msgid ""
"The first operand of an '``extractelement``' instruction is a value of :ref:"
"`vector <t_vector>` type. The second operand is an index indicating the "
"position from which to extract the element. The index may be a variable of "
"any integer type."
msgstr ""

#: ../../../LangRef.rst:6759
msgid ""
"The result is a scalar of the same type as the element type of ``val``. Its "
"value is the value at position ``idx`` of ``val``. If ``idx`` exceeds the "
"length of ``val``, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:6773
msgid "'``insertelement``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6785
msgid ""
"The '``insertelement``' instruction inserts a scalar element into a vector "
"at a specified index."
msgstr ""

#: ../../../LangRef.rst:6791
msgid ""
"The first operand of an '``insertelement``' instruction is a value of :ref:"
"`vector <t_vector>` type. The second operand is a scalar value whose type "
"must equal the element type of the first operand. The third operand is an "
"index indicating the position at which to insert the value. The index may be "
"a variable of any integer type."
msgstr ""

#: ../../../LangRef.rst:6800
msgid ""
"The result is a vector of the same type as ``val``. Its element values are "
"those of ``val`` except at position ``idx``, where it gets the value "
"``elt``. If ``idx`` exceeds the length of ``val``, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:6815
msgid "'``shufflevector``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6827
msgid ""
"The '``shufflevector``' instruction constructs a permutation of elements "
"from two input vectors, returning a vector with the same element type as the "
"input and length that is the same as the shuffle mask."
msgstr ""

#: ../../../LangRef.rst:6834
msgid ""
"The first two operands of a '``shufflevector``' instruction are vectors with "
"the same type. The third argument is a shuffle mask whose element type is "
"always 'i32'. The result of the instruction is a vector whose length is the "
"same as the shuffle mask and whose element type is the same as the element "
"type of the first two operands."
msgstr ""

#: ../../../LangRef.rst:6840
msgid ""
"The shuffle mask operand is required to be a constant vector with either "
"constant integer or undef values."
msgstr ""

#: ../../../LangRef.rst:6846
msgid ""
"The elements of the two input vectors are numbered from left to right across "
"both of the vectors. The shuffle mask operand specifies, for each element of "
"the result vector, which element of the two input vectors the result element "
"gets. The element selector may be undef (meaning \"don't care\") and the "
"second operand may be undef if performing a shuffle from only one vector."
msgstr ""

#: ../../../LangRef.rst:6868
msgid "Aggregate Operations"
msgstr ""

#: ../../../LangRef.rst:6870
msgid ""
"LLVM supports several instructions for working with :ref:`aggregate "
"<t_aggregate>` values."
msgstr ""

#: ../../../LangRef.rst:6876
msgid "'``extractvalue``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6888
msgid ""
"The '``extractvalue``' instruction extracts the value of a member field from "
"an :ref:`aggregate <t_aggregate>` value."
msgstr ""

#: ../../../LangRef.rst:6894
msgid ""
"The first operand of an '``extractvalue``' instruction is a value of :ref:"
"`struct <t_struct>` or :ref:`array <t_array>` type. The other operands are "
"constant indices to specify which value to extract in a similar manner as "
"indices in a '``getelementptr``' instruction."
msgstr ""

#: ../../../LangRef.rst:6899
msgid "The major differences to ``getelementptr`` indexing are:"
msgstr ""

#: ../../../LangRef.rst:6901
msgid ""
"Since the value being indexed is not a pointer, the first index is omitted "
"and assumed to be zero."
msgstr ""

#: ../../../LangRef.rst:6903
msgid "At least one index must be specified."
msgstr ""

#: ../../../LangRef.rst:6904
msgid "Not only struct indices but also array indices must be in bounds."
msgstr ""

#: ../../../LangRef.rst:6909
msgid ""
"The result is the value at the position in the aggregate specified by the "
"index operands."
msgstr ""

#: ../../../LangRef.rst:6922
msgid "'``insertvalue``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6934
msgid ""
"The '``insertvalue``' instruction inserts a value into a member field in an :"
"ref:`aggregate <t_aggregate>` value."
msgstr ""

#: ../../../LangRef.rst:6940
msgid ""
"The first operand of an '``insertvalue``' instruction is a value of :ref:"
"`struct <t_struct>` or :ref:`array <t_array>` type. The second operand is a "
"first-class value to insert. The following operands are constant indices "
"indicating the position at which to insert the value in a similar manner as "
"indices in a '``extractvalue``' instruction. The value to insert must have "
"the same type as the value identified by the indices."
msgstr ""

#: ../../../LangRef.rst:6951
msgid ""
"The result is an aggregate of the same type as ``val``. Its value is that of "
"``val`` except that the value at the position specified by the indices is "
"that of ``elt``."
msgstr ""

#: ../../../LangRef.rst:6967
msgid "Memory Access and Addressing Operations"
msgstr ""

#: ../../../LangRef.rst:6969
msgid ""
"A key design point of an SSA-based representation is how it represents "
"memory. In LLVM, no memory locations are in SSA form, which makes things "
"very simple. This section describes how to read, write, and allocate memory "
"in LLVM."
msgstr ""

#: ../../../LangRef.rst:6977
msgid "'``alloca``' Instruction"
msgstr ""

#: ../../../LangRef.rst:6989
msgid ""
"The '``alloca``' instruction allocates memory on the stack frame of the "
"currently executing function, to be automatically released when this "
"function returns to its caller. The object is always allocated in the "
"generic address space (address space zero)."
msgstr ""

#: ../../../LangRef.rst:6997
msgid ""
"The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements`` bytes "
"of memory on the runtime stack, returning a pointer of the appropriate type "
"to the program. If \"NumElements\" is specified, it is the number of "
"elements allocated, otherwise \"NumElements\" is defaulted to be one. If a "
"constant alignment is specified, the value result of the allocation is "
"guaranteed to be aligned to at least that boundary. The alignment may not be "
"greater than ``1 << 29``. If not specified, or if zero, the target can "
"choose to align the allocation on any convenient boundary compatible with "
"the type."
msgstr ""

#: ../../../LangRef.rst:7007
msgid "'``type``' may be any sized type."
msgstr ""

#: ../../../LangRef.rst:7012
msgid ""
"Memory is allocated; a pointer is returned. The operation is undefined if "
"there is insufficient stack space for the allocation. '``alloca``'d memory "
"is automatically released when the function returns. The '``alloca``' "
"instruction is commonly used to represent automatic variables that must have "
"an address available. When the function returns (either with the ``ret`` or "
"``resume`` instructions), the memory is reclaimed. Allocating zero bytes is "
"legal, but the result is undefined. The order in which memory is allocated "
"(ie., which way the stack grows) is not specified."
msgstr ""

#: ../../../LangRef.rst:7035
msgid "'``load``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7051
msgid "The '``load``' instruction is used to read from memory."
msgstr ""

#: ../../../LangRef.rst:7056
msgid ""
"The argument to the ``load`` instruction specifies the memory address from "
"which to load. The type specified must be a :ref:`first class "
"<t_firstclass>` type of known size (i.e. not containing an :ref:`opaque "
"structural type <t_opaque>`). If the ``load`` is marked as ``volatile``, "
"then the optimizer is not allowed to modify the number or order of execution "
"of this ``load`` with other :ref:`volatile operations <volatile>`."
msgstr ""

#: ../../../LangRef.rst:7063
msgid ""
"If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering "
"<ordering>` and optional ``singlethread`` argument. The ``release`` and "
"``acq_rel`` orderings are not valid on ``load`` instructions. Atomic loads "
"produce :ref:`defined <memmodel>` results when they may see multiple atomic "
"stores. The type of the pointee must be an integer, pointer, or floating-"
"point type whose bit width is a power of two greater than or equal to eight "
"and less than or equal to a target-specific size limit.  ``align`` must be "
"explicitly specified on atomic loads, and the load has undefined behavior if "
"the alignment is not set to a value which is at least the size in bytes of "
"the pointee. ``!nontemporal`` does not have any defined semantics for atomic "
"loads."
msgstr ""

#: ../../../LangRef.rst:7074
msgid ""
"The optional constant ``align`` argument specifies the alignment of the "
"operation (that is, the alignment of the memory address). A value of 0 or an "
"omitted ``align`` argument means that the operation has the ABI alignment "
"for the target. It is the responsibility of the code emitter to ensure that "
"the alignment information is correct. Overestimating the alignment results "
"in undefined behavior. Underestimating the alignment may produce less "
"efficient code. An alignment of 1 is always safe. The maximum possible "
"alignment is ``1 << 29``. An alignment value higher than the size of the "
"loaded type implies memory up to the alignment value bytes can be safely "
"loaded without trapping in the default address space. Access of the high "
"bytes can interfere with debugging tools, so should not be accessed if the "
"function has the ``sanitize_thread`` or ``sanitize_address`` attributes."
msgstr ""

#: ../../../LangRef.rst:7088 ../../../LangRef.rst:7218
msgid ""
"The optional ``!nontemporal`` metadata must reference a single metadata name "
"``<index>`` corresponding to a metadata node with one ``i32`` entry of value "
"1. The existence of the ``!nontemporal`` metadata on the instruction tells "
"the optimizer and code generator that this load is not expected to be reused "
"in the cache. The code generator may select special instructions to save "
"cache bandwidth, such as the ``MOVNT`` instruction on x86."
msgstr ""

#: ../../../LangRef.rst:7096
msgid ""
"The optional ``!invariant.load`` metadata must reference a single metadata "
"name ``<index>`` corresponding to a metadata node with no entries. If a load "
"instruction tagged with the ``!invariant.load`` metadata is executed, the "
"optimizer may assume the memory location referenced by the load contains the "
"same value at all points in the program where the memory location is known "
"to be dereferenceable."
msgstr ""

#: ../../../LangRef.rst:7104
msgid ""
"The optional ``!invariant.group`` metadata must reference a single metadata "
"name"
msgstr ""

#: ../../../LangRef.rst:7104
msgid ""
"``<index>`` corresponding to a metadata node. See ``invariant.group`` "
"metadata."
msgstr ""

#: ../../../LangRef.rst:7106
msgid ""
"The optional ``!nonnull`` metadata must reference a single metadata name "
"``<index>`` corresponding to a metadata node with no entries. The existence "
"of the ``!nonnull`` metadata on the instruction tells the optimizer that the "
"value loaded is known to never be null. This is analogous to the ``nonnull`` "
"attribute on parameters and return values. This metadata can only be applied "
"to loads of a pointer type."
msgstr ""

#: ../../../LangRef.rst:7114
msgid ""
"The optional ``!dereferenceable`` metadata must reference a single metadata "
"name ``<deref_bytes_node>`` corresponding to a metadata node with one "
"``i64`` entry. The existence of the ``!dereferenceable`` metadata on the "
"instruction tells the optimizer that the value loaded is known to be "
"dereferenceable. The number of bytes known to be dereferenceable is "
"specified by the integer value in the metadata node. This is analogous to "
"the ''dereferenceable'' attribute on parameters and return values. This "
"metadata can only be applied to loads of a pointer type."
msgstr ""

#: ../../../LangRef.rst:7123
msgid ""
"The optional ``!dereferenceable_or_null`` metadata must reference a single "
"metadata name ``<deref_bytes_node>`` corresponding to a metadata node with "
"one ``i64`` entry. The existence of the ``!dereferenceable_or_null`` "
"metadata on the instruction tells the optimizer that the value loaded is "
"known to be either dereferenceable or null. The number of bytes known to be "
"dereferenceable is specified by the integer value in the metadata node. This "
"is analogous to the ''dereferenceable_or_null'' attribute on parameters and "
"return values. This metadata can only be applied to loads of a pointer type."
msgstr ""

#: ../../../LangRef.rst:7133
msgid ""
"The optional ``!align`` metadata must reference a single metadata name "
"``<align_node>`` corresponding to a metadata node with one ``i64`` entry. "
"The existence of the ``!align`` metadata on the instruction tells the "
"optimizer that the value loaded is known to be aligned to a boundary "
"specified by the integer value in the metadata node. The alignment must be a "
"power of 2. This is analogous to the ''align'' attribute on parameters and "
"return values. This metadata can only be applied to loads of a pointer type."
msgstr ""

#: ../../../LangRef.rst:7144
msgid ""
"The location of memory pointed to is loaded. If the value being loaded is of "
"scalar type then the number of bytes read does not exceed the minimum number "
"of bytes needed to hold all bits of the type. For example, loading an "
"``i24`` reads at most three bytes. When loading a value of a type like "
"``i20`` with a size that is not an integral number of bytes, the result is "
"undefined if the value was not originally written using a store of the same "
"type."
msgstr ""

#: ../../../LangRef.rst:7164
msgid "'``store``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7177
msgid "The '``store``' instruction is used to write to memory."
msgstr ""

#: ../../../LangRef.rst:7182
msgid ""
"There are two arguments to the ``store`` instruction: a value to store and "
"an address at which to store it. The type of the ``<pointer>`` operand must "
"be a pointer to the :ref:`first class <t_firstclass>` type of the "
"``<value>`` operand. If the ``store`` is marked as ``volatile``, then the "
"optimizer is not allowed to modify the number or order of execution of this "
"``store`` with other :ref:`volatile operations <volatile>`.  Only values of :"
"ref:`first class <t_firstclass>` types of known size (i.e. not containing "
"an :ref:`opaque structural type <t_opaque>`) can be stored."
msgstr ""

#: ../../../LangRef.rst:7191
msgid ""
"If the ``store`` is marked as ``atomic``, it takes an extra :ref:`ordering "
"<ordering>` and optional ``singlethread`` argument. The ``acquire`` and "
"``acq_rel`` orderings aren't valid on ``store`` instructions. Atomic loads "
"produce :ref:`defined <memmodel>` results when they may see multiple atomic "
"stores. The type of the pointee must be an integer, pointer, or floating-"
"point type whose bit width is a power of two greater than or equal to eight "
"and less than or equal to a target-specific size limit.  ``align`` must be "
"explicitly specified on atomic stores, and the store has undefined behavior "
"if the alignment is not set to a value which is at least the size in bytes "
"of the pointee. ``!nontemporal`` does not have any defined semantics for "
"atomic stores."
msgstr ""

#: ../../../LangRef.rst:7202
msgid ""
"The optional constant ``align`` argument specifies the alignment of the "
"operation (that is, the alignment of the memory address). A value of 0 or an "
"omitted ``align`` argument means that the operation has the ABI alignment "
"for the target. It is the responsibility of the code emitter to ensure that "
"the alignment information is correct. Overestimating the alignment results "
"in undefined behavior. Underestimating the alignment may produce less "
"efficient code. An alignment of 1 is always safe. The maximum possible "
"alignment is ``1 << 29``. An alignment value higher than the size of the "
"stored type implies memory up to the alignment value bytes can be stored to "
"without trapping in the default address space. Storing to the higher bytes "
"however may result in data races if another thread can access the same "
"address. Introducing a data race is not allowed. Storing to the extra bytes "
"is not allowed even in situations where a data race is known to not exist if "
"the function has the ``sanitize_address`` attribute."
msgstr ""

#: ../../../LangRef.rst:7226
msgid ""
"The optional ``!invariant.group`` metadata must reference a single metadata "
"name ``<index>``. See ``invariant.group`` metadata."
msgstr ""

#: ../../../LangRef.rst:7232
msgid ""
"The contents of memory are updated to contain ``<value>`` at the location "
"specified by the ``<pointer>`` operand. If ``<value>`` is of scalar type "
"then the number of bytes written does not exceed the minimum number of bytes "
"needed to hold all bits of the type. For example, storing an ``i24`` writes "
"at most three bytes. When writing a value of a type like ``i20`` with a size "
"that is not an integral number of bytes, it is unspecified what happens to "
"the extra bits that do not belong to the type, but they will typically be "
"overwritten."
msgstr ""

#: ../../../LangRef.rst:7253
msgid "'``fence``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7265
msgid ""
"The '``fence``' instruction is used to introduce happens-before edges "
"between operations."
msgstr ""

#: ../../../LangRef.rst:7271
msgid ""
"'``fence``' instructions take an :ref:`ordering <ordering>` argument which "
"defines what *synchronizes-with* edges they add. They can only be given "
"``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings."
msgstr ""

#: ../../../LangRef.rst:7278
msgid ""
"A fence A which has (at least) ``release`` ordering semantics *synchronizes "
"with* a fence B with (at least) ``acquire`` ordering semantics if and only "
"if there exist atomic operations X and Y, both operating on some atomic "
"object M, such that A is sequenced before X, X modifies M (either directly "
"or through some side effect of a sequence headed by X), Y is sequenced "
"before B, and Y observes M. This provides a *happens-before* dependency "
"between A and B. Rather than an explicit ``fence``, one (but not both) of "
"the atomic operations X or Y might provide a ``release`` or ``acquire`` "
"(resp.) ordering constraint and still *synchronize-with* the explicit "
"``fence`` and establish the *happens-before* edge."
msgstr ""

#: ../../../LangRef.rst:7290
msgid ""
"A ``fence`` which has ``seq_cst`` ordering, in addition to having both "
"``acquire`` and ``release`` semantics specified above, participates in the "
"global program order of other ``seq_cst`` operations and/or fences."
msgstr ""

#: ../../../LangRef.rst:7294
msgid ""
"The optional \":ref:`singlethread <singlethread>`\" argument specifies that "
"the fence only synchronizes with other fences in the same thread. (This is "
"useful for interacting with signal handlers.)"
msgstr ""

#: ../../../LangRef.rst:7309
msgid "'``cmpxchg``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7321
msgid ""
"The '``cmpxchg``' instruction is used to atomically modify memory. It loads "
"a value in memory and compares it to a given value. If they are equal, it "
"tries to store a new value into the memory."
msgstr ""

#: ../../../LangRef.rst:7328
msgid ""
"There are three arguments to the '``cmpxchg``' instruction: an address to "
"operate on, a value to compare to the value currently be at that address, "
"and a new value to place at that address if the compared values are equal. "
"The type of '<cmp>' must be an integer or pointer type whose bit width is a "
"power of two greater than or equal to eight and less than or equal to a "
"target-specific size limit. '<cmp>' and '<new>' must have the same type, and "
"the type of '<pointer>' must be a pointer to that type. If the ``cmpxchg`` "
"is marked as ``volatile``, then the optimizer is not allowed to modify the "
"number or order of execution of this ``cmpxchg`` with other :ref:`volatile "
"operations <volatile>`."
msgstr ""

#: ../../../LangRef.rst:7339
msgid ""
"The success and failure :ref:`ordering <ordering>` arguments specify how "
"this ``cmpxchg`` synchronizes with other atomic operations. Both ordering "
"parameters must be at least ``monotonic``, the ordering constraint on "
"failure must be no stronger than that on success, and the failure ordering "
"cannot be either ``release`` or ``acq_rel``."
msgstr ""

#: ../../../LangRef.rst:7345
msgid ""
"The optional \"``singlethread``\" argument declares that the ``cmpxchg`` is "
"only atomic with respect to code (usually signal handlers) running in the "
"same thread as the ``cmpxchg``. Otherwise the cmpxchg is atomic with respect "
"to all other code in the system."
msgstr ""

#: ../../../LangRef.rst:7350
msgid ""
"The pointer passed into cmpxchg must have alignment greater than or equal to "
"the size in memory of the operand."
msgstr ""

#: ../../../LangRef.rst:7356
msgid ""
"The contents of memory at the location specified by the '``<pointer>``' "
"operand is read and compared to '``<cmp>``'; if the read value is the equal, "
"the '``<new>``' is written. The original value at the location is returned, "
"together with a flag indicating success (true) or failure (false)."
msgstr ""

#: ../../../LangRef.rst:7361
msgid ""
"If the cmpxchg operation is marked as ``weak`` then a spurious failure is "
"permitted: the operation may not write ``<new>`` even if the comparison "
"matched."
msgstr ""

#: ../../../LangRef.rst:7365
msgid ""
"If the cmpxchg operation is strong (the default), the i1 value is 1 if and "
"only if the value loaded equals ``cmp``."
msgstr ""

#: ../../../LangRef.rst:7368
msgid ""
"A successful ``cmpxchg`` is a read-modify-write instruction for the purpose "
"of identifying release sequences. A failed ``cmpxchg`` is equivalent to an "
"atomic load with an ordering parameter determined the second ordering "
"parameter."
msgstr ""

#: ../../../LangRef.rst:7395
msgid "'``atomicrmw``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7407
msgid "The '``atomicrmw``' instruction is used to atomically modify memory."
msgstr ""

#: ../../../LangRef.rst:7412
msgid ""
"There are three arguments to the '``atomicrmw``' instruction: an operation "
"to apply, an address whose value to modify, an argument to the operation. "
"The operation must be one of the following keywords:"
msgstr ""

#: ../../../LangRef.rst:7416
msgid "xchg"
msgstr ""

#: ../../../LangRef.rst:7417
msgid "add"
msgstr ""

#: ../../../LangRef.rst:7418
msgid "sub"
msgstr ""

#: ../../../LangRef.rst:7419
msgid "and"
msgstr ""

#: ../../../LangRef.rst:7420
msgid "nand"
msgstr ""

#: ../../../LangRef.rst:7421
msgid "or"
msgstr ""

#: ../../../LangRef.rst:7422
msgid "xor"
msgstr ""

#: ../../../LangRef.rst:7423
msgid "max"
msgstr ""

#: ../../../LangRef.rst:7424
msgid "min"
msgstr ""

#: ../../../LangRef.rst:7425
msgid "umax"
msgstr ""

#: ../../../LangRef.rst:7426
msgid "umin"
msgstr ""

#: ../../../LangRef.rst:7428
msgid ""
"The type of '<value>' must be an integer type whose bit width is a power of "
"two greater than or equal to eight and less than or equal to a target-"
"specific size limit. The type of the '``<pointer>``' operand must be a "
"pointer to that type. If the ``atomicrmw`` is marked as ``volatile``, then "
"the optimizer is not allowed to modify the number or order of execution of "
"this ``atomicrmw`` with other :ref:`volatile operations <volatile>`."
msgstr ""

#: ../../../LangRef.rst:7439
msgid ""
"The contents of memory at the location specified by the '``<pointer>``' "
"operand are atomically read, modified, and written back. The original value "
"at the location is returned. The modification is specified by the operation "
"argument:"
msgstr ""

#: ../../../LangRef.rst:7444
msgid "xchg: ``*ptr = val``"
msgstr ""

#: ../../../LangRef.rst:7445
msgid "add: ``*ptr = *ptr + val``"
msgstr ""

#: ../../../LangRef.rst:7446
msgid "sub: ``*ptr = *ptr - val``"
msgstr ""

#: ../../../LangRef.rst:7447
msgid "and: ``*ptr = *ptr & val``"
msgstr ""

#: ../../../LangRef.rst:7448
msgid "nand: ``*ptr = ~(*ptr & val)``"
msgstr ""

#: ../../../LangRef.rst:7449
msgid "or: ``*ptr = *ptr | val``"
msgstr ""

#: ../../../LangRef.rst:7450
msgid "xor: ``*ptr = *ptr ^ val``"
msgstr ""

#: ../../../LangRef.rst:7451
msgid "max: ``*ptr = *ptr > val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../../LangRef.rst:7452
msgid "min: ``*ptr = *ptr < val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../../LangRef.rst:7453
msgid "umax: ``*ptr = *ptr > val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../../LangRef.rst:7455
msgid "umin: ``*ptr = *ptr < val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../../LangRef.rst:7468
msgid "'``getelementptr``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7482
msgid ""
"The '``getelementptr``' instruction is used to get the address of a "
"subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs "
"address calculation only and does not access memory. The instruction can "
"also be used to calculate a vector of such addresses."
msgstr ""

#: ../../../LangRef.rst:7490
msgid ""
"The first argument is always a type used as the basis for the calculations. "
"The second argument is always a pointer or a vector of pointers, and is the "
"base address to start from. The remaining arguments are indices that "
"indicate which of the elements of the aggregate object are indexed. The "
"interpretation of each index is dependent on the type being indexed into. "
"The first index always indexes the pointer value given as the first "
"argument, the second index indexes a value of the type pointed to (not "
"necessarily the value directly pointed to, since the first index can be non-"
"zero), etc. The first type indexed into must be a pointer value, subsequent "
"types can be arrays, vectors, and structs. Note that subsequent types being "
"indexed into can never be pointers, since that would require loading the "
"pointer before continuing calculation."
msgstr ""

#: ../../../LangRef.rst:7503
msgid ""
"The type of each index argument depends on the type it is indexing into. "
"When indexing into a (optionally packed) structure, only ``i32`` integer "
"**constants** are allowed (when using a vector of indices they must all be "
"the **same** ``i32`` integer constant). When indexing into an array, pointer "
"or vector, integers of any width are allowed, and they are not required to "
"be constant. These integers are treated as signed values where relevant."
msgstr ""

#: ../../../LangRef.rst:7511
msgid ""
"For example, let's consider a C code fragment and how it gets compiled to "
"LLVM:"
msgstr ""

#: ../../../LangRef.rst:7531
msgid "The LLVM code generated by Clang is:"
msgstr ""

#: ../../../LangRef.rst:7547
msgid ""
"In the example above, the first index is indexing into the '``%struct.ST*``' "
"type, which is a pointer, yielding a '``%struct.ST``' = '``{ i32, double, "
"%struct.RT }``' type, a structure. The second index indexes into the third "
"element of the structure, yielding a '``%struct.RT``' = '``{ i8 , [10 x [20 "
"x i32]], i8 }``' type, another structure. The third index indexes into the "
"second element of the structure, yielding a '``[10 x [20 x i32]]``' type, an "
"array. The two dimensions of the array are subscripted into, yielding an "
"'``i32``' type. The '``getelementptr``' instruction returns a pointer to "
"this element, thus computing a value of '``i32*``' type."
msgstr ""

#: ../../../LangRef.rst:7558
msgid ""
"Note that it is perfectly legal to index partially through a structure, "
"returning a pointer to an inner element. Because of this, the LLVM code for "
"the given testcase is equivalent to:"
msgstr ""

#: ../../../LangRef.rst:7573
msgid ""
"If the ``inbounds`` keyword is present, the result value of the "
"``getelementptr`` is a :ref:`poison value <poisonvalues>` if the base "
"pointer is not an *in bounds* address of an allocated object, or if any of "
"the addresses that would be formed by successive addition of the offsets "
"implied by the indices to the base address with infinitely precise signed "
"arithmetic are not an *in bounds* address of that allocated object. The *in "
"bounds* addresses for an allocated object are all the addresses that point "
"into the object, plus the address one byte past the end. In cases where the "
"base is a vector of pointers the ``inbounds`` keyword applies to each of the "
"computations element-wise."
msgstr ""

#: ../../../LangRef.rst:7584
msgid ""
"If the ``inbounds`` keyword is not present, the offsets are added to the "
"base address with silently-wrapping two's complement arithmetic. If the "
"offsets have a different width from the pointer, they are sign-extended or "
"truncated to the width of the pointer. The result value of the "
"``getelementptr`` may be outside the object pointed to by the base pointer. "
"The result value may not necessarily be used to access memory though, even "
"if it happens to point into allocated storage. See the :ref:`Pointer "
"Aliasing Rules <pointeraliasing>` section for more information."
msgstr ""

#: ../../../LangRef.rst:7594
msgid ""
"If the ``inrange`` keyword is present before any index, loading from or "
"storing to any pointer derived from the ``getelementptr`` has undefined "
"behavior if the load or store would access memory outside of the bounds of "
"the element selected by the index marked as ``inrange``. The result of a "
"pointer comparison or ``ptrtoint`` (including ``ptrtoint``-like operations "
"involving memory) involving a pointer derived from a ``getelementptr`` with "
"the ``inrange`` keyword is undefined, with the exception of comparisons in "
"the case where both operands are in the range of the element selected by the "
"``inrange`` keyword, inclusive of the address one past the end of that "
"element. Note that the ``inrange`` keyword is currently only allowed in "
"constant ``getelementptr`` expressions."
msgstr ""

#: ../../../LangRef.rst:7606
msgid ""
"The getelementptr instruction is often confusing. For some more insight into "
"how it works, see :doc:`the getelementptr FAQ <GetElementPtr>`."
msgstr ""

#: ../../../LangRef.rst:7624
msgid "Vector of pointers:"
msgstr ""

#: ../../../LangRef.rst:7626
msgid ""
"The ``getelementptr`` returns a vector of pointers, instead of a single "
"address, when one or more of its arguments is a vector. In such cases, all "
"vector arguments should have the same number of elements, and every scalar "
"argument will be effectively broadcast into a vector during address "
"calculation."
msgstr ""

#: ../../../LangRef.rst:7647
msgid "The two following instructions are equivalent:"
msgstr ""

#: ../../../LangRef.rst:7660
msgid ""
"Let's look at the C code, where the vector version of ``getelementptr`` "
"makes sense:"
msgstr ""

#: ../../../LangRef.rst:7680
msgid "Conversion Operations"
msgstr ""

#: ../../../LangRef.rst:7682
msgid ""
"The instructions in this category are the conversion instructions (casting) "
"which all take a single operand and a type. They perform various bit "
"conversions on the operand."
msgstr ""

#: ../../../LangRef.rst:7687
msgid "'``trunc .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7699
msgid "The '``trunc``' instruction truncates its operand to the type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7704
msgid ""
"The '``trunc``' instruction takes a value to trunc, and a type to trunc it "
"to. Both types must be of :ref:`integer <t_integer>` types, or vectors of "
"the same number of integers. The bit size of the ``value`` must be larger "
"than the bit size of the destination type, ``ty2``. Equal sized types are "
"not allowed."
msgstr ""

#: ../../../LangRef.rst:7713
msgid ""
"The '``trunc``' instruction truncates the high order bits in ``value`` and "
"converts the remaining bits to ``ty2``. Since the source size must be larger "
"than the destination size, ``trunc`` cannot be a *no-op cast*. It will "
"always truncate bits."
msgstr ""

#: ../../../LangRef.rst:7729
msgid "'``zext .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7741
msgid "The '``zext``' instruction zero extends its operand to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7746
msgid ""
"The '``zext``' instruction takes a value to cast, and a type to cast it to. "
"Both types must be of :ref:`integer <t_integer>` types, or vectors of the "
"same number of integers. The bit size of the ``value`` must be smaller than "
"the bit size of the destination type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7754
msgid ""
"The ``zext`` fills the high order bits of the ``value`` with zero bits until "
"it reaches the size of the destination type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7757
msgid "When zero extending from i1, the result will always be either 0 or 1."
msgstr ""

#: ../../../LangRef.rst:7769
msgid "'``sext .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7781
msgid "The '``sext``' sign extends ``value`` to the type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7786
msgid ""
"The '``sext``' instruction takes a value to cast, and a type to cast it to. "
"Both types must be of :ref:`integer <t_integer>` types, or vectors of the "
"same number of integers. The bit size of the ``value`` must be smaller than "
"the bit size of the destination type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7794
msgid ""
"The '``sext``' instruction performs a sign extension by copying the sign bit "
"(highest order bit) of the ``value`` until it reaches the bit size of the "
"type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7798
msgid "When sign extending from i1, the extension always results in -1 or 0."
msgstr ""

#: ../../../LangRef.rst:7810
msgid "'``fptrunc .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7822
msgid "The '``fptrunc``' instruction truncates ``value`` to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7827
msgid ""
"The '``fptrunc``' instruction takes a :ref:`floating point <t_floating>` "
"value to cast and a :ref:`floating point <t_floating>` type to cast it to. "
"The size of ``value`` must be larger than the size of ``ty2``. This implies "
"that ``fptrunc`` cannot be used to make a *no-op cast*."
msgstr ""

#: ../../../LangRef.rst:7835
msgid ""
"The '``fptrunc``' instruction casts a ``value`` from a larger :ref:`floating "
"point <t_floating>` type to a smaller :ref:`floating point <t_floating>` "
"type. If the value cannot fit (i.e. overflows) within the destination type, "
"``ty2``, then the results are undefined. If the cast produces an inexact "
"result, how rounding is performed (e.g. truncation, also known as round to "
"zero) is undefined."
msgstr ""

#: ../../../LangRef.rst:7851
msgid "'``fpext .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7863
msgid ""
"The '``fpext``' extends a floating point ``value`` to a larger floating "
"point value."
msgstr ""

#: ../../../LangRef.rst:7869
msgid ""
"The '``fpext``' instruction takes a :ref:`floating point <t_floating>` "
"``value`` to cast, and a :ref:`floating point <t_floating>` type to cast it "
"to. The source type must be smaller than the destination type."
msgstr ""

#: ../../../LangRef.rst:7876
msgid ""
"The '``fpext``' instruction extends the ``value`` from a smaller :ref:"
"`floating point <t_floating>` type to a larger :ref:`floating point "
"<t_floating>` type. The ``fpext`` cannot be used to make a *no-op cast* "
"because it always changes bits. Use ``bitcast`` to make a *no-op cast* for a "
"floating point cast."
msgstr ""

#: ../../../LangRef.rst:7891
msgid "'``fptoui .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7903
msgid ""
"The '``fptoui``' converts a floating point ``value`` to its unsigned integer "
"equivalent of type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7909
msgid ""
"The '``fptoui``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`floating point <t_floating>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`integer <t_integer>` type. If ``ty`` is a "
"vector floating point type, ``ty2`` must be a vector integer type with the "
"same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:7918
msgid ""
"The '``fptoui``' instruction converts its :ref:`floating point <t_floating>` "
"operand into the nearest (rounding towards zero) unsigned integer value. If "
"the value cannot fit in ``ty2``, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:7933
msgid "'``fptosi .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7945
msgid ""
"The '``fptosi``' instruction converts :ref:`floating point <t_floating>` "
"``value`` to type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:7951
msgid ""
"The '``fptosi``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`floating point <t_floating>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`integer <t_integer>` type. If ``ty`` is a "
"vector floating point type, ``ty2`` must be a vector integer type with the "
"same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:7960
msgid ""
"The '``fptosi``' instruction converts its :ref:`floating point <t_floating>` "
"operand into the nearest (rounding towards zero) signed integer value. If "
"the value cannot fit in ``ty2``, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:7975
msgid "'``uitofp .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:7987
msgid ""
"The '``uitofp``' instruction regards ``value`` as an unsigned integer and "
"converts that value to the ``ty2`` type."
msgstr ""

#: ../../../LangRef.rst:7993
msgid ""
"The '``uitofp``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`integer <t_integer>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`floating point <t_floating>` type. If ``ty`` "
"is a vector integer type, ``ty2`` must be a vector floating point type with "
"the same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:8002
msgid ""
"The '``uitofp``' instruction interprets its operand as an unsigned integer "
"quantity and converts it to the corresponding floating point value. If the "
"value cannot fit in the floating point value, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:8016
msgid "'``sitofp .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8028
msgid ""
"The '``sitofp``' instruction regards ``value`` as a signed integer and "
"converts that value to the ``ty2`` type."
msgstr ""

#: ../../../LangRef.rst:8034
msgid ""
"The '``sitofp``' instruction takes a value to cast, which must be a scalar "
"or vector :ref:`integer <t_integer>` value, and a type to cast it to "
"``ty2``, which must be an :ref:`floating point <t_floating>` type. If ``ty`` "
"is a vector integer type, ``ty2`` must be a vector floating point type with "
"the same number of elements as ``ty``"
msgstr ""

#: ../../../LangRef.rst:8043
msgid ""
"The '``sitofp``' instruction interprets its operand as a signed integer "
"quantity and converts it to the corresponding floating point value. If the "
"value cannot fit in the floating point value, the results are undefined."
msgstr ""

#: ../../../LangRef.rst:8059
msgid "'``ptrtoint .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8071
msgid ""
"The '``ptrtoint``' instruction converts the pointer or a vector of pointers "
"``value`` to the integer (or vector of integers) type ``ty2``."
msgstr ""

#: ../../../LangRef.rst:8077
msgid ""
"The '``ptrtoint``' instruction takes a ``value`` to cast, which must be a "
"value of type :ref:`pointer <t_pointer>` or a vector of pointers, and a type "
"to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` or a "
"vector of integers type."
msgstr ""

#: ../../../LangRef.rst:8085
msgid ""
"The '``ptrtoint``' instruction converts ``value`` to integer type ``ty2`` by "
"interpreting the pointer value as an integer and either truncating or zero "
"extending that value to the size of the integer type. If ``value`` is "
"smaller than ``ty2`` then a zero extension is done. If ``value`` is larger "
"than ``ty2`` then a truncation is done. If they are the same size, then "
"nothing is done (*no-op cast*) other than a type change."
msgstr ""

#: ../../../LangRef.rst:8105
msgid "'``inttoptr .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8117
msgid ""
"The '``inttoptr``' instruction converts an integer ``value`` to a pointer "
"type, ``ty2``."
msgstr ""

#: ../../../LangRef.rst:8123
msgid ""
"The '``inttoptr``' instruction takes an :ref:`integer <t_integer>` value to "
"cast, and a type to cast it to, which must be a :ref:`pointer <t_pointer>` "
"type."
msgstr ""

#: ../../../LangRef.rst:8130
msgid ""
"The '``inttoptr``' instruction converts ``value`` to type ``ty2`` by "
"applying either a zero extension or a truncation depending on the size of "
"the integer ``value``. If ``value`` is larger than the size of a pointer "
"then a truncation is done. If ``value`` is smaller than the size of a "
"pointer then a zero extension is done. If they are the same size, nothing is "
"done (*no-op cast*)."
msgstr ""

#: ../../../LangRef.rst:8150
msgid "'``bitcast .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8162
msgid ""
"The '``bitcast``' instruction converts ``value`` to type ``ty2`` without "
"changing any bits."
msgstr ""

#: ../../../LangRef.rst:8168
msgid ""
"The '``bitcast``' instruction takes a value to cast, which must be a non-"
"aggregate first class value, and a type to cast it to, which must also be a "
"non-aggregate :ref:`first class <t_firstclass>` type. The bit sizes of "
"``value`` and the destination type, ``ty2``, must be identical. If the "
"source type is a pointer, the destination type must also be a pointer of the "
"same size. This instruction supports bitwise conversion of vectors to "
"integers and to vectors of other types (as long as they have the same size)."
msgstr ""

#: ../../../LangRef.rst:8180
msgid ""
"The '``bitcast``' instruction converts ``value`` to type ``ty2``. It is "
"always a *no-op cast* because no bits change with this conversion. The "
"conversion is done as if the ``value`` had been stored to memory and read "
"back as type ``ty2``. Pointer (or vector of pointers) types may only be "
"converted to other pointer (or vector of pointers) types with the same "
"address space through this instruction. To convert pointers to other types, "
"use the :ref:`inttoptr <i_inttoptr>` or :ref:`ptrtoint <i_ptrtoint>` "
"instructions first."
msgstr ""

#: ../../../LangRef.rst:8202
msgid "'``addrspacecast .. to``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8214
msgid ""
"The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in "
"address space ``n`` to type ``pty2`` in address space ``m``."
msgstr ""

#: ../../../LangRef.rst:8220
msgid ""
"The '``addrspacecast``' instruction takes a pointer or vector of pointer "
"value to cast and a pointer type to cast it to, which must have a different "
"address space."
msgstr ""

#: ../../../LangRef.rst:8227
msgid ""
"The '``addrspacecast``' instruction converts the pointer value ``ptrval`` to "
"type ``pty2``. It can be a *no-op cast* or a complex value modification, "
"depending on the target and the address space pair. Pointer conversions "
"within the same address space must be performed with the ``bitcast`` "
"instruction. Note that if the address space conversion is legal then both "
"result and operand refer to the same memory location."
msgstr ""

#: ../../../LangRef.rst:8247
msgid "Other Operations"
msgstr ""

#: ../../../LangRef.rst:8249
msgid ""
"The instructions in this category are the \"miscellaneous\" instructions, "
"which defy better classification."
msgstr ""

#: ../../../LangRef.rst:8255
msgid "'``icmp``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8267
msgid ""
"The '``icmp``' instruction returns a boolean value or a vector of boolean "
"values based on comparison of its two integer, integer vector, pointer, or "
"pointer vector operands."
msgstr ""

#: ../../../LangRef.rst:8274
msgid ""
"The '``icmp``' instruction takes three operands. The first operand is the "
"condition code indicating the kind of comparison to perform. It is not a "
"value, just a keyword. The possible condition codes are:"
msgstr ""

#: ../../../LangRef.rst:8278
msgid "``eq``: equal"
msgstr ""

#: ../../../LangRef.rst:8279
msgid "``ne``: not equal"
msgstr ""

#: ../../../LangRef.rst:8280
msgid "``ugt``: unsigned greater than"
msgstr ""

#: ../../../LangRef.rst:8281
msgid "``uge``: unsigned greater or equal"
msgstr ""

#: ../../../LangRef.rst:8282
msgid "``ult``: unsigned less than"
msgstr ""

#: ../../../LangRef.rst:8283
msgid "``ule``: unsigned less or equal"
msgstr ""

#: ../../../LangRef.rst:8284
msgid "``sgt``: signed greater than"
msgstr ""

#: ../../../LangRef.rst:8285
msgid "``sge``: signed greater or equal"
msgstr ""

#: ../../../LangRef.rst:8286
msgid "``slt``: signed less than"
msgstr ""

#: ../../../LangRef.rst:8287
msgid "``sle``: signed less or equal"
msgstr ""

#: ../../../LangRef.rst:8289
msgid ""
"The remaining two arguments must be :ref:`integer <t_integer>` or :ref:"
"`pointer <t_pointer>` or integer :ref:`vector <t_vector>` typed. They must "
"also be identical types."
msgstr ""

#: ../../../LangRef.rst:8296
msgid ""
"The '``icmp``' compares ``op1`` and ``op2`` according to the condition code "
"given as ``cond``. The comparison performed always yields either an :ref:`i1 "
"<t_integer>` or vector of ``i1`` result, as follows:"
msgstr ""

#: ../../../LangRef.rst:8300
msgid ""
"``eq``: yields ``true`` if the operands are equal, ``false`` otherwise. No "
"sign interpretation is necessary or performed."
msgstr ""

#: ../../../LangRef.rst:8302
msgid ""
"``ne``: yields ``true`` if the operands are unequal, ``false`` otherwise. No "
"sign interpretation is necessary or performed."
msgstr ""

#: ../../../LangRef.rst:8304
msgid ""
"``ugt``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:8306
msgid ""
"``uge``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8308
msgid ""
"``ult``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is less than ``op2``."
msgstr ""

#: ../../../LangRef.rst:8310
msgid ""
"``ule``: interprets the operands as unsigned values and yields ``true`` if "
"``op1`` is less than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8312
msgid ""
"``sgt``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:8314
msgid ""
"``sge``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8316
msgid ""
"``slt``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is less than ``op2``."
msgstr ""

#: ../../../LangRef.rst:8318
msgid ""
"``sle``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is less than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8321
msgid ""
"If the operands are :ref:`pointer <t_pointer>` typed, the pointer values are "
"compared as if they were integers."
msgstr ""

#: ../../../LangRef.rst:8324
msgid ""
"If the operands are integer vectors, then they are compared element by "
"element. The result is an ``i1`` vector with the same number of elements as "
"the values being compared. Otherwise, the result is an ``i1``."
msgstr ""

#: ../../../LangRef.rst:8343
msgid "'``fcmp``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8355
msgid ""
"The '``fcmp``' instruction returns a boolean value or vector of boolean "
"values based on comparison of its operands."
msgstr ""

#: ../../../LangRef.rst:8358
msgid ""
"If the operands are floating point scalars, then the result type is a "
"boolean (:ref:`i1 <t_integer>`)."
msgstr ""

#: ../../../LangRef.rst:8361
msgid ""
"If the operands are floating point vectors, then the result type is a vector "
"of boolean with the same number of elements as the operands being compared."
msgstr ""

#: ../../../LangRef.rst:8368
msgid ""
"The '``fcmp``' instruction takes three operands. The first operand is the "
"condition code indicating the kind of comparison to perform. It is not a "
"value, just a keyword. The possible condition codes are:"
msgstr ""

#: ../../../LangRef.rst:8372
msgid "``false``: no comparison, always returns false"
msgstr ""

#: ../../../LangRef.rst:8373
msgid "``oeq``: ordered and equal"
msgstr ""

#: ../../../LangRef.rst:8374
msgid "``ogt``: ordered and greater than"
msgstr ""

#: ../../../LangRef.rst:8375
msgid "``oge``: ordered and greater than or equal"
msgstr ""

#: ../../../LangRef.rst:8376
msgid "``olt``: ordered and less than"
msgstr ""

#: ../../../LangRef.rst:8377
msgid "``ole``: ordered and less than or equal"
msgstr ""

#: ../../../LangRef.rst:8378
msgid "``one``: ordered and not equal"
msgstr ""

#: ../../../LangRef.rst:8379
msgid "``ord``: ordered (no nans)"
msgstr ""

#: ../../../LangRef.rst:8380
msgid "``ueq``: unordered or equal"
msgstr ""

#: ../../../LangRef.rst:8381
msgid "``ugt``: unordered or greater than"
msgstr ""

#: ../../../LangRef.rst:8382
msgid "``uge``: unordered or greater than or equal"
msgstr ""

#: ../../../LangRef.rst:8383
msgid "``ult``: unordered or less than"
msgstr ""

#: ../../../LangRef.rst:8384
msgid "``ule``: unordered or less than or equal"
msgstr ""

#: ../../../LangRef.rst:8385
msgid "``une``: unordered or not equal"
msgstr ""

#: ../../../LangRef.rst:8386
msgid "``uno``: unordered (either nans)"
msgstr ""

#: ../../../LangRef.rst:8387
msgid "``true``: no comparison, always returns true"
msgstr ""

#: ../../../LangRef.rst:8389
msgid ""
"*Ordered* means that neither operand is a QNAN while *unordered* means that "
"either operand may be a QNAN."
msgstr ""

#: ../../../LangRef.rst:8392
msgid ""
"Each of ``val1`` and ``val2`` arguments must be either a :ref:`floating "
"point <t_floating>` type or a :ref:`vector <t_vector>` of floating point "
"type. They must have identical types."
msgstr ""

#: ../../../LangRef.rst:8399
msgid ""
"The '``fcmp``' instruction compares ``op1`` and ``op2`` according to the "
"condition code given as ``cond``. If the operands are vectors, then the "
"vectors are compared element by element. Each comparison performed always "
"yields an :ref:`i1 <t_integer>` result, as follows:"
msgstr ""

#: ../../../LangRef.rst:8404
msgid "``false``: always yields ``false``, regardless of operands."
msgstr ""

#: ../../../LangRef.rst:8405
msgid ""
"``oeq``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8407
msgid ""
"``ogt``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"greater than ``op2``."
msgstr ""

#: ../../../LangRef.rst:8409
msgid ""
"``oge``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"greater than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8411
msgid ""
"``olt``: yields ``true`` if both operands are not a QNAN and ``op1`` is less "
"than ``op2``."
msgstr ""

#: ../../../LangRef.rst:8413
msgid ""
"``ole``: yields ``true`` if both operands are not a QNAN and ``op1`` is less "
"than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8415
msgid ""
"``one``: yields ``true`` if both operands are not a QNAN and ``op1`` is not "
"equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8417
msgid "``ord``: yields ``true`` if both operands are not a QNAN."
msgstr ""

#: ../../../LangRef.rst:8418
msgid ""
"``ueq``: yields ``true`` if either operand is a QNAN or ``op1`` is equal to "
"``op2``."
msgstr ""

#: ../../../LangRef.rst:8420
msgid ""
"``ugt``: yields ``true`` if either operand is a QNAN or ``op1`` is greater "
"than ``op2``."
msgstr ""

#: ../../../LangRef.rst:8422
msgid ""
"``uge``: yields ``true`` if either operand is a QNAN or ``op1`` is greater "
"than or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8424
msgid ""
"``ult``: yields ``true`` if either operand is a QNAN or ``op1`` is less than "
"``op2``."
msgstr ""

#: ../../../LangRef.rst:8426
msgid ""
"``ule``: yields ``true`` if either operand is a QNAN or ``op1`` is less than "
"or equal to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8428
msgid ""
"``une``: yields ``true`` if either operand is a QNAN or ``op1`` is not equal "
"to ``op2``."
msgstr ""

#: ../../../LangRef.rst:8430
msgid "``uno``: yields ``true`` if either operand is a QNAN."
msgstr ""

#: ../../../LangRef.rst:8431
msgid "``true``: always yields ``true``, regardless of operands."
msgstr ""

#: ../../../LangRef.rst:8433
msgid ""
"The ``fcmp`` instruction can also optionally take any number of :ref:`fast-"
"math flags <fastmath>`, which are optimization hints to enable otherwise "
"unsafe floating point optimizations."
msgstr ""

#: ../../../LangRef.rst:8437
msgid ""
"Any set of fast-math flags are legal on an ``fcmp`` instruction, but the "
"only flags that have any effect on its semantics are those that allow "
"assumptions to be made about the values of input arguments; namely ``nnan``, "
"``ninf``, and ``nsz``. See :ref:`fastmath` for more information."
msgstr ""

#: ../../../LangRef.rst:8455
msgid "'``phi``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8467
msgid ""
"The '``phi``' instruction is used to implement the φ node in the SSA graph "
"representing the function."
msgstr ""

#: ../../../LangRef.rst:8473
msgid ""
"The type of the incoming values is specified with the first type field. "
"After this, the '``phi``' instruction takes a list of pairs as arguments, "
"with one pair for each predecessor basic block of the current block. Only "
"values of :ref:`first class <t_firstclass>` type may be used as the value "
"arguments to the PHI node. Only labels may be used as the label arguments."
msgstr ""

#: ../../../LangRef.rst:8480
msgid ""
"There must be no non-phi instructions between the start of a basic block and "
"the PHI instructions: i.e. PHI instructions must be first in a basic block."
msgstr ""

#: ../../../LangRef.rst:8484
msgid ""
"For the purposes of the SSA form, the use of each incoming value is deemed "
"to occur on the edge from the corresponding predecessor block to the current "
"block (but after any definition of an '``invoke``' instruction's return "
"value on the same edge)."
msgstr ""

#: ../../../LangRef.rst:8492
msgid ""
"At runtime, the '``phi``' instruction logically takes on the value specified "
"by the pair corresponding to the predecessor basic block that executed just "
"prior to the current block."
msgstr ""

#: ../../../LangRef.rst:8509
msgid "'``select``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8523
msgid ""
"The '``select``' instruction is used to choose one value based on a "
"condition, without IR-level branching."
msgstr ""

#: ../../../LangRef.rst:8529
msgid ""
"The '``select``' instruction requires an 'i1' value or a vector of 'i1' "
"values indicating the condition, and two values of the same :ref:`first "
"class <t_firstclass>` type."
msgstr ""

#: ../../../LangRef.rst:8536
msgid ""
"If the condition is an i1 and it evaluates to 1, the instruction returns the "
"first value argument; otherwise, it returns the second value argument."
msgstr ""

#: ../../../LangRef.rst:8540
msgid ""
"If the condition is a vector of i1, then the value arguments must be vectors "
"of the same size, and the selection is done element by element."
msgstr ""

#: ../../../LangRef.rst:8543
msgid ""
"If the condition is an i1 and the value arguments are vectors of the same "
"size, then an entire vector is selected."
msgstr ""

#: ../../../LangRef.rst:8556
msgid "'``call``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8569
msgid "The '``call``' instruction represents a simple function call."
msgstr ""

#: ../../../LangRef.rst:8576
msgid ""
"The optional ``tail`` and ``musttail`` markers indicate that the optimizers "
"should perform tail call optimization. The ``tail`` marker is a hint that "
"`can be ignored <CodeGenerator.html#sibcallopt>`_. The ``musttail`` marker "
"means that the call must be tail call optimized in order for the program to "
"be correct. The ``musttail`` marker provides these guarantees:"
msgstr ""

#: ../../../LangRef.rst:8582
msgid ""
"The call will not cause unbounded stack growth if it is part of a recursive "
"cycle in the call graph."
msgstr ""

#: ../../../LangRef.rst:8584
msgid ""
"Arguments with the :ref:`inalloca <attr_inalloca>` attribute are forwarded "
"in place."
msgstr ""

#: ../../../LangRef.rst:8587
msgid ""
"Both markers imply that the callee does not access allocas or varargs from "
"the caller. Calls marked ``musttail`` must obey the following additional "
"rules:"
msgstr ""

#: ../../../LangRef.rst:8591
msgid ""
"The call must immediately precede a :ref:`ret <i_ret>` instruction, or a "
"pointer bitcast followed by a ret instruction."
msgstr ""

#: ../../../LangRef.rst:8593
msgid ""
"The ret instruction must return the (possibly bitcasted) value produced by "
"the call or void."
msgstr ""

#: ../../../LangRef.rst:8595
msgid ""
"The caller and callee prototypes must match. Pointer types of parameters or "
"return types may differ in pointee type, but not in address space."
msgstr ""

#: ../../../LangRef.rst:8598
msgid "The calling conventions of the caller and callee must match."
msgstr ""

#: ../../../LangRef.rst:8599
msgid ""
"All ABI-impacting function attributes, such as sret, byval, inreg, returned, "
"and inalloca, must match."
msgstr ""

#: ../../../LangRef.rst:8601
msgid ""
"The callee must be varargs iff the caller is varargs. Bitcasting a non-"
"varargs function to the appropriate varargs type is legal so long as the non-"
"varargs prefixes obey the other rules."
msgstr ""

#: ../../../LangRef.rst:8605
msgid ""
"Tail call optimization for calls marked ``tail`` is guaranteed to occur if "
"the following conditions are met:"
msgstr ""

#: ../../../LangRef.rst:8608
msgid "Caller and callee both have the calling convention ``fastcc``."
msgstr ""

#: ../../../LangRef.rst:8609
msgid ""
"The call is in tail position (ret immediately follows call and ret uses "
"value of call or is void)."
msgstr ""

#: ../../../LangRef.rst:8611
msgid ""
"Option ``-tailcallopt`` is enabled, or ``llvm::GuaranteedTailCallOpt`` is "
"``true``."
msgstr ""

#: ../../../LangRef.rst:8613
msgid ""
"`Platform-specific constraints are met. <CodeGenerator.html#tailcallopt>`_"
msgstr ""

#: ../../../LangRef.rst:8616
msgid ""
"The optional ``notail`` marker indicates that the optimizers should not add "
"``tail`` or ``musttail`` markers to the call. It is used to prevent tail "
"call optimization from being performed on the call."
msgstr ""

#: ../../../LangRef.rst:8620
msgid ""
"The optional ``fast-math flags`` marker indicates that the call has one or "
"more :ref:`fast-math flags <fastmath>`, which are optimization hints to "
"enable otherwise unsafe floating-point optimizations. Fast-math flags are "
"only valid for calls that return a floating-point scalar or vector type."
msgstr ""

#: ../../../LangRef.rst:8625
msgid ""
"The optional \"cconv\" marker indicates which :ref:`calling convention "
"<callingconv>` the call should use. If none is specified, the call defaults "
"to using C calling conventions. The calling convention of the call must "
"match the calling convention of the target function, or else the behavior is "
"undefined."
msgstr ""

#: ../../../LangRef.rst:8636
msgid ""
"'``fnty``': shall be the signature of the function being called. The "
"argument types must match the types implied by this signature. This type can "
"be omitted if the function is not varargs."
msgstr ""

#: ../../../LangRef.rst:8639
msgid ""
"'``fnptrval``': An LLVM value containing a pointer to a function to be "
"called. In most cases, this is a direct function call, but indirect "
"``call``'s are just as possible, calling an arbitrary pointer to function "
"value."
msgstr ""

#: ../../../LangRef.rst:8648
msgid ""
"The optional :ref:`function attributes <fnattrs>` list. Only '``noreturn``', "
"'``nounwind``', '``readonly``' , '``readnone``', and '``convergent``' "
"attributes are valid here."
msgstr ""

#: ../../../LangRef.rst:8656
msgid ""
"The '``call``' instruction is used to cause control flow to transfer to a "
"specified function, with its incoming arguments bound to the specified "
"values. Upon a '``ret``' instruction in the called function, control flow "
"continues with the instruction after the function call, and the return value "
"of the function is bound to the result argument."
msgstr ""

#: ../../../LangRef.rst:8680
msgid ""
"llvm treats calls to some functions with names and arguments that match the "
"standard C99 library as being the C99 library functions, and may perform "
"optimizations or generate code for them under that assumption. This is "
"something we'd like to change in the future to provide better support for "
"freestanding environments and non-C-based languages."
msgstr ""

#: ../../../LangRef.rst:8689
msgid "'``va_arg``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8701
msgid ""
"The '``va_arg``' instruction is used to access arguments passed through the "
"\"variable argument\" area of a function call. It is used to implement the "
"``va_arg`` macro in C."
msgstr ""

#: ../../../LangRef.rst:8708
msgid ""
"This instruction takes a ``va_list*`` value and the type of the argument. It "
"returns a value of the specified argument type and increments the "
"``va_list`` to point to the next argument. The actual type of ``va_list`` is "
"target specific."
msgstr ""

#: ../../../LangRef.rst:8716
msgid ""
"The '``va_arg``' instruction loads an argument of the specified type from "
"the specified ``va_list`` and causes the ``va_list`` to point to the next "
"argument. For more information, see the variable argument handling :ref:"
"`Intrinsic Functions <int_varargs>`."
msgstr ""

#: ../../../LangRef.rst:8721
msgid ""
"It is legal for this instruction to be called in a function which does not "
"take a variable number of arguments, for example, the ``vfprintf`` function."
msgstr ""

#: ../../../LangRef.rst:8725
msgid ""
"``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic function "
"<intrinsics>` because it takes a type as an argument."
msgstr ""

#: ../../../LangRef.rst:8731
msgid "See the :ref:`variable argument processing <int_varargs>` section."
msgstr ""

#: ../../../LangRef.rst:8733
msgid ""
"Note that the code generator does not yet fully support va\\_arg on many "
"targets. Also, it does not currently support va\\_arg with aggregate types "
"on any target."
msgstr ""

#: ../../../LangRef.rst:8740
msgid "'``landingpad``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8756
msgid ""
"The '``landingpad``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to specify that a basic block is "
"a landing pad --- one where the exception lands, and corresponds to the code "
"found in the ``catch`` portion of a ``try``/``catch`` sequence. It defines "
"values supplied by the :ref:`personality function <personalityfn>` upon re-"
"entry to the function. The ``resultval`` has the type ``resultty``."
msgstr ""

#: ../../../LangRef.rst:8766
msgid ""
"The optional ``cleanup`` flag indicates that the landing pad block is a "
"cleanup."
msgstr ""

#: ../../../LangRef.rst:8769
msgid ""
"A ``clause`` begins with the clause type --- ``catch`` or ``filter`` --- and "
"contains the global variable representing the \"type\" that may be caught or "
"filtered respectively. Unlike the ``catch`` clause, the ``filter`` clause "
"takes an array constant as its argument. Use \"``[0 x i8**] undef``\" for a "
"filter which cannot throw. The '``landingpad``' instruction must contain *at "
"least* one ``clause`` or the ``cleanup`` flag."
msgstr ""

#: ../../../LangRef.rst:8780
msgid ""
"The '``landingpad``' instruction defines the values which are set by the :"
"ref:`personality function <personalityfn>` upon re-entry to the function, "
"and therefore the \"result type\" of the ``landingpad`` instruction. As with "
"calling conventions, how the personality function results are represented in "
"LLVM IR is target specific."
msgstr ""

#: ../../../LangRef.rst:8786
msgid ""
"The clauses are applied in order from top to bottom. If two ``landingpad`` "
"instructions are merged together through inlining, the clauses from the "
"calling function are appended to the list of clauses. When the call stack is "
"being unwound due to an exception being thrown, the exception is compared "
"against each ``clause`` in turn. If it doesn't match any of the clauses, and "
"the ``cleanup`` flag is not set, then unwinding continues further up the "
"call stack."
msgstr ""

#: ../../../LangRef.rst:8794
msgid "The ``landingpad`` instruction has several restrictions:"
msgstr ""

#: ../../../LangRef.rst:8796
msgid ""
"A landing pad block is a basic block which is the unwind destination of an "
"'``invoke``' instruction."
msgstr ""

#: ../../../LangRef.rst:8798
msgid ""
"A landing pad block must have a '``landingpad``' instruction as its first "
"non-PHI instruction."
msgstr ""

#: ../../../LangRef.rst:8800
msgid ""
"There can be only one '``landingpad``' instruction within the landing pad "
"block."
msgstr ""

#: ../../../LangRef.rst:8802
msgid ""
"A basic block that is not a landing pad block may not include a "
"'``landingpad``' instruction."
msgstr ""

#: ../../../LangRef.rst:8824
msgid "'``catchpad``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8836
msgid ""
"The '``catchpad``' instruction is used by `LLVM's exception handling system "
"<ExceptionHandling.html#overview>`_ to specify that a basic block begins a "
"catch handler --- one where a personality routine attempts to transfer "
"control to catch an exception."
msgstr ""

#: ../../../LangRef.rst:8844
msgid ""
"The ``catchswitch`` operand must always be a token produced by a :ref:"
"`catchswitch <i_catchswitch>` instruction in a predecessor block. This "
"ensures that each ``catchpad`` has exactly one predecessor block, and it "
"always terminates in a ``catchswitch``."
msgstr ""

#: ../../../LangRef.rst:8849
msgid ""
"The ``args`` correspond to whatever information the personality routine "
"requires to know if this is an appropriate handler for the exception. "
"Control will transfer to the ``catchpad`` if this is the first appropriate "
"handler for the exception."
msgstr ""

#: ../../../LangRef.rst:8854
msgid ""
"The ``resultval`` has the type :ref:`token <t_token>` and is used to match "
"the ``catchpad`` to corresponding :ref:`catchrets <i_catchret>` and other "
"nested EH pads."
msgstr ""

#: ../../../LangRef.rst:8861
msgid ""
"When the call stack is being unwound due to an exception being thrown, the "
"exception is compared against the ``args``. If it doesn't match, control "
"will not reach the ``catchpad`` instruction.  The representation of ``args`` "
"is entirely target and personality function-specific."
msgstr ""

#: ../../../LangRef.rst:8866
msgid ""
"Like the :ref:`landingpad <i_landingpad>` instruction, the ``catchpad`` "
"instruction must be the first non-phi of its parent basic block."
msgstr ""

#: ../../../LangRef.rst:8869
msgid ""
"The meaning of the tokens produced and consumed by ``catchpad`` and other "
"\"pad\" instructions is described in the `Windows exception handling "
"documentation\\ <ExceptionHandling.html#wineh>`_."
msgstr ""

#: ../../../LangRef.rst:8873
msgid ""
"When a ``catchpad`` has been \"entered\" but not yet \"exited\" (as "
"described in the `EH documentation\\ <ExceptionHandling.html#wineh-"
"constraints>`_), it is undefined behavior to execute a :ref:`call <i_call>` "
"or :ref:`invoke <i_invoke>` that does not carry an appropriate :ref:"
"`\"funclet\" bundle <ob_funclet>`."
msgstr ""

#: ../../../LangRef.rst:8892
msgid "'``cleanuppad``' Instruction"
msgstr ""

#: ../../../LangRef.rst:8904
msgid ""
"The '``cleanuppad``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to specify that a basic block is "
"a cleanup block --- one where a personality routine attempts to transfer "
"control to run cleanup actions. The ``args`` correspond to whatever "
"additional information the :ref:`personality function <personalityfn>` "
"requires to execute the cleanup. The ``resultval`` has the type :ref:`token "
"<t_token>` and is used to match the ``cleanuppad`` to corresponding :ref:"
"`cleanuprets <i_cleanupret>`. The ``parent`` argument is the token of the "
"funclet that contains the ``cleanuppad`` instruction. If the ``cleanuppad`` "
"is not inside a funclet, this operand may be the token ``none``."
msgstr ""

#: ../../../LangRef.rst:8920
msgid ""
"The instruction takes a list of arbitrary values which are interpreted by "
"the :ref:`personality function <personalityfn>`."
msgstr ""

#: ../../../LangRef.rst:8926
msgid ""
"When the call stack is being unwound due to an exception being thrown, the :"
"ref:`personality function <personalityfn>` transfers control to the "
"``cleanuppad`` with the aid of the personality-specific arguments. As with "
"calling conventions, how the personality function results are represented in "
"LLVM IR is target specific."
msgstr ""

#: ../../../LangRef.rst:8932
msgid "The ``cleanuppad`` instruction has several restrictions:"
msgstr ""

#: ../../../LangRef.rst:8934
msgid ""
"A cleanup block is a basic block which is the unwind destination of an "
"exceptional instruction."
msgstr ""

#: ../../../LangRef.rst:8936
msgid ""
"A cleanup block must have a '``cleanuppad``' instruction as its first non-"
"PHI instruction."
msgstr ""

#: ../../../LangRef.rst:8938
msgid ""
"There can be only one '``cleanuppad``' instruction within the cleanup block."
msgstr ""

#: ../../../LangRef.rst:8940
msgid ""
"A basic block that is not a cleanup block may not include a '``cleanuppad``' "
"instruction."
msgstr ""

#: ../../../LangRef.rst:8943
msgid ""
"When a ``cleanuppad`` has been \"entered\" but not yet \"exited\" (as "
"described in the `EH documentation\\ <ExceptionHandling.html#wineh-"
"constraints>`_), it is undefined behavior to execute a :ref:`call <i_call>` "
"or :ref:`invoke <i_invoke>` that does not carry an appropriate :ref:"
"`\"funclet\" bundle <ob_funclet>`."
msgstr ""

#: ../../../LangRef.rst:8958
msgid "Intrinsic Functions"
msgstr ""

#: ../../../LangRef.rst:8960
msgid ""
"LLVM supports the notion of an \"intrinsic function\". These functions have "
"well known names and semantics and are required to follow certain "
"restrictions. Overall, these intrinsics represent an extension mechanism for "
"the LLVM language that does not require changing all of the transformations "
"in LLVM when adding to the language (or the bitcode reader/writer, the "
"parser, etc...)."
msgstr ""

#: ../../../LangRef.rst:8967
msgid ""
"Intrinsic function names must all start with an \"``llvm.``\" prefix. This "
"prefix is reserved in LLVM for intrinsic names; thus, function names may not "
"begin with this prefix. Intrinsic functions must always be external "
"functions: you cannot define the body of intrinsic functions. Intrinsic "
"functions may only be used in call or invoke instructions: it is illegal to "
"take the address of an intrinsic function. Additionally, because intrinsic "
"functions are part of the LLVM language, it is required if any are added "
"that they be documented here."
msgstr ""

#: ../../../LangRef.rst:8976
msgid ""
"Some intrinsic functions can be overloaded, i.e., the intrinsic represents a "
"family of functions that perform the same operation but on different data "
"types. Because LLVM can represent over 8 million different integer types, "
"overloading is used commonly to allow an intrinsic function to operate on "
"any integer type. One or more of the argument types or the result type can "
"be overloaded to accept any integer type. Argument types may also be defined "
"as exactly matching a previous argument's type or the result type. This "
"allows an intrinsic function which accepts multiple arguments, but needs all "
"of them to be of the same type, to only be overloaded with respect to a "
"single argument or the result."
msgstr ""

#: ../../../LangRef.rst:8988
msgid ""
"Overloaded intrinsics will have the names of its overloaded argument types "
"encoded into its function name, each preceded by a period. Only those types "
"which are overloaded result in a name suffix. Arguments whose type is "
"matched against another type do not. For example, the ``llvm.ctpop`` "
"function can take an integer of any width and returns an integer of exactly "
"the same integer width. This leads to a family of functions such as ``i8 "
"@llvm.ctpop.i8(i8 %val)`` and ``i29 @llvm.ctpop.i29(i29 %val)``. Only one "
"type, the return type, is overloaded, and only one type suffix is required. "
"Because the argument's type is matched against the return type, it does not "
"require its own name suffix."
msgstr ""

#: ../../../LangRef.rst:9000
msgid ""
"To learn how to add an intrinsic function, please see the `Extending LLVM "
"Guide <ExtendingLLVM.html>`_."
msgstr ""

#: ../../../LangRef.rst:9006
msgid "Variable Argument Handling Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9008
msgid ""
"Variable argument support is defined in LLVM with the :ref:`va_arg "
"<i_va_arg>` instruction and these three intrinsic functions. These functions "
"are related to the similarly named macros defined in the ``<stdarg.h>`` "
"header file."
msgstr ""

#: ../../../LangRef.rst:9013
msgid ""
"All of these functions operate on arguments that use a target-specific value "
"type \"``va_list``\". The LLVM assembly language reference manual does not "
"define what this type is, so all transformations should be prepared to "
"handle these functions regardless of the type used."
msgstr ""

#: ../../../LangRef.rst:9018
msgid ""
"This example shows how the :ref:`va_arg <i_va_arg>` instruction and the "
"variable argument handling intrinsic functions are used."
msgstr ""

#: ../../../LangRef.rst:9057
msgid "'``llvm.va_start``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9069
msgid ""
"The '``llvm.va_start``' intrinsic initializes ``*<arglist>`` for subsequent "
"use by ``va_arg``."
msgstr ""

#: ../../../LangRef.rst:9075
msgid "The argument is a pointer to a ``va_list`` element to initialize."
msgstr ""

#: ../../../LangRef.rst:9080
msgid ""
"The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro "
"available in C. In a target-dependent way, it initializes the ``va_list`` "
"element to which the argument points, so that the next call to ``va_arg`` "
"will produce the first variable argument passed to the function. Unlike the "
"C ``va_start`` macro, this intrinsic does not need to know the last argument "
"of the function as the compiler can figure that out."
msgstr ""

#: ../../../LangRef.rst:9089
msgid "'``llvm.va_end``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9101
msgid ""
"The '``llvm.va_end``' intrinsic destroys ``*<arglist>``, which has been "
"initialized previously with ``llvm.va_start`` or ``llvm.va_copy``."
msgstr ""

#: ../../../LangRef.rst:9107
msgid "The argument is a pointer to a ``va_list`` to destroy."
msgstr ""

#: ../../../LangRef.rst:9112
msgid ""
"The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro "
"available in C. In a target-dependent way, it destroys the ``va_list`` "
"element to which the argument points. Calls to :ref:`llvm.va_start "
"<int_va_start>` and :ref:`llvm.va_copy <int_va_copy>` must be matched "
"exactly with calls to ``llvm.va_end``."
msgstr ""

#: ../../../LangRef.rst:9122
msgid "'``llvm.va_copy``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9134
msgid ""
"The '``llvm.va_copy``' intrinsic copies the current argument position from "
"the source argument list to the destination argument list."
msgstr ""

#: ../../../LangRef.rst:9140
msgid ""
"The first argument is a pointer to a ``va_list`` element to initialize. The "
"second argument is a pointer to a ``va_list`` element to copy from."
msgstr ""

#: ../../../LangRef.rst:9146
msgid ""
"The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro "
"available in C. In a target-dependent way, it copies the source ``va_list`` "
"element into the destination ``va_list`` element. This intrinsic is "
"necessary because the `` llvm.va_start`` intrinsic may be arbitrarily "
"complex and require, for example, memory allocation."
msgstr ""

#: ../../../LangRef.rst:9153
msgid "Accurate Garbage Collection Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9155
msgid ""
"LLVM's support for `Accurate Garbage Collection <GarbageCollection.html>`_ "
"(GC) requires the frontend to generate code containing appropriate intrinsic "
"calls and select an appropriate GC strategy which knows how to lower these "
"intrinsics in a manner which is appropriate for the target collector."
msgstr ""

#: ../../../LangRef.rst:9160
msgid ""
"These intrinsics allow identification of :ref:`GC roots on the stack "
"<int_gcroot>`, as well as garbage collector implementations that require :"
"ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. Frontends "
"for type-safe garbage collected languages should generate these intrinsics "
"to make use of the LLVM garbage collectors. For more details, see `Garbage "
"Collection with LLVM <GarbageCollection.html>`_."
msgstr ""

#: ../../../LangRef.rst:9168
msgid "Experimental Statepoint Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9170
msgid ""
"LLVM provides an second experimental set of intrinsics for describing "
"garbage collection safepoints in compiled code. These intrinsics are an "
"alternative to the ``llvm.gcroot`` intrinsics, but are compatible with the "
"ones for :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. "
"The differences in approach are covered in the `Garbage Collection with LLVM "
"<GarbageCollection.html>`_ documentation. The intrinsics themselves are "
"described in :doc:`Statepoints`."
msgstr ""

#: ../../../LangRef.rst:9181
msgid "'``llvm.gcroot``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9193
msgid ""
"The '``llvm.gcroot``' intrinsic declares the existence of a GC root to the "
"code generator, and allows some metadata to be associated with it."
msgstr ""

#: ../../../LangRef.rst:9199
msgid ""
"The first argument specifies the address of a stack object that contains the "
"root pointer. The second pointer (which must be either a constant or a "
"global value address) contains the meta-data to be associated with the root."
msgstr ""

#: ../../../LangRef.rst:9207
msgid ""
"At runtime, a call to this intrinsic stores a null pointer into the "
"\"ptrloc\" location. At compile-time, the code generator generates "
"information to allow the runtime to find the pointer at GC safe points. The "
"'``llvm.gcroot``' intrinsic may only be used in a function which :ref:"
"`specifies a GC algorithm <gc>`."
msgstr ""

#: ../../../LangRef.rst:9216
msgid "'``llvm.gcread``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9228
msgid ""
"The '``llvm.gcread``' intrinsic identifies reads of references from heap "
"locations, allowing garbage collector implementations that require read "
"barriers."
msgstr ""

#: ../../../LangRef.rst:9235
msgid ""
"The second argument is the address to read from, which should be an address "
"allocated from the garbage collector. The first object is a pointer to the "
"start of the referenced object, if needed by the language runtime (otherwise "
"null)."
msgstr ""

#: ../../../LangRef.rst:9243
msgid ""
"The '``llvm.gcread``' intrinsic has the same semantics as a load "
"instruction, but may be replaced with substantially more complex code by the "
"garbage collector runtime, as needed. The '``llvm.gcread``' intrinsic may "
"only be used in a function which :ref:`specifies a GC algorithm <gc>`."
msgstr ""

#: ../../../LangRef.rst:9252
msgid "'``llvm.gcwrite``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9264
msgid ""
"The '``llvm.gcwrite``' intrinsic identifies writes of references to heap "
"locations, allowing garbage collector implementations that require write "
"barriers (such as generational or reference counting collectors)."
msgstr ""

#: ../../../LangRef.rst:9271
msgid ""
"The first argument is the reference to store, the second is the start of the "
"object to store it to, and the third is the address of the field of Obj to "
"store to. If the runtime does not require a pointer to the object, Obj may "
"be null."
msgstr ""

#: ../../../LangRef.rst:9279
msgid ""
"The '``llvm.gcwrite``' intrinsic has the same semantics as a store "
"instruction, but may be replaced with substantially more complex code by the "
"garbage collector runtime, as needed. The '``llvm.gcwrite``' intrinsic may "
"only be used in a function which :ref:`specifies a GC algorithm <gc>`."
msgstr ""

#: ../../../LangRef.rst:9286
msgid "Code Generator Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9288
msgid ""
"These intrinsics are provided by LLVM to expose special features that may "
"only be implemented with code generator support."
msgstr ""

#: ../../../LangRef.rst:9292
msgid "'``llvm.returnaddress``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9304
msgid ""
"The '``llvm.returnaddress``' intrinsic attempts to compute a target-specific "
"value indicating the return address of the current function or one of its "
"callers."
msgstr ""

#: ../../../LangRef.rst:9311
msgid ""
"The argument to this intrinsic indicates which function to return the "
"address for. Zero indicates the calling function, one indicates its caller, "
"etc. The argument is **required** to be a constant integer value."
msgstr ""

#: ../../../LangRef.rst:9319
msgid ""
"The '``llvm.returnaddress``' intrinsic either returns a pointer indicating "
"the return address of the specified call frame, or zero if it cannot be "
"identified. The value returned by this intrinsic is likely to be incorrect "
"or 0 for arguments other than zero, so it should only be used for debugging "
"purposes."
msgstr ""

#: ../../../LangRef.rst:9325 ../../../LangRef.rst:9349
#: ../../../LangRef.rst:9388
msgid ""
"Note that calling this intrinsic does not prevent function inlining or other "
"aggressive transformations, so the value returned may not be that of the "
"obvious source-language caller."
msgstr ""

#: ../../../LangRef.rst:9330
msgid "'``llvm.addressofreturnaddress``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9342
msgid ""
"The '``llvm.addressofreturnaddress``' intrinsic returns a target-specific "
"pointer to the place in the stack frame where the return address of the "
"current function is stored."
msgstr ""

#: ../../../LangRef.rst:9353
msgid "This intrinsic is only implemented for x86."
msgstr ""

#: ../../../LangRef.rst:9356
msgid "'``llvm.frameaddress``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9368
msgid ""
"The '``llvm.frameaddress``' intrinsic attempts to return the target-specific "
"frame pointer value for the specified stack frame."
msgstr ""

#: ../../../LangRef.rst:9374
msgid ""
"The argument to this intrinsic indicates which function to return the frame "
"pointer for. Zero indicates the calling function, one indicates its caller, "
"etc. The argument is **required** to be a constant integer value."
msgstr ""

#: ../../../LangRef.rst:9382
msgid ""
"The '``llvm.frameaddress``' intrinsic either returns a pointer indicating "
"the frame address of the specified call frame, or zero if it cannot be "
"identified. The value returned by this intrinsic is likely to be incorrect "
"or 0 for arguments other than zero, so it should only be used for debugging "
"purposes."
msgstr ""

#: ../../../LangRef.rst:9393
msgid "'``llvm.localescape``' and '``llvm.localrecover``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9406
msgid ""
"The '``llvm.localescape``' intrinsic escapes offsets of a collection of "
"static allocas, and the '``llvm.localrecover``' intrinsic applies those "
"offsets to a live frame pointer to recover the address of the allocation. "
"The offset is computed during frame layout of the caller of ``llvm."
"localescape``."
msgstr ""

#: ../../../LangRef.rst:9414
msgid ""
"All arguments to '``llvm.localescape``' must be pointers to static allocas "
"or casts of static allocas. Each function can only call '``llvm."
"localescape``' once, and it can only do so from the entry block."
msgstr ""

#: ../../../LangRef.rst:9418
msgid ""
"The ``func`` argument to '``llvm.localrecover``' must be a constant "
"bitcasted pointer to a function defined in the current module. The code "
"generator cannot determine the frame allocation offset of functions defined "
"in other modules."
msgstr ""

#: ../../../LangRef.rst:9423
msgid ""
"The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a "
"call frame that is currently live. The return value of '``llvm."
"localaddress``' is one way to produce such a value, but various runtimes "
"also expose a suitable pointer in platform-specific ways."
msgstr ""

#: ../../../LangRef.rst:9428
msgid ""
"The ``idx`` argument to '``llvm.localrecover``' indicates which alloca "
"passed to '``llvm.localescape``' to recover. It is zero-indexed."
msgstr ""

#: ../../../LangRef.rst:9434
msgid ""
"These intrinsics allow a group of functions to share access to a set of "
"local stack allocations of a one parent function. The parent function may "
"call the '``llvm.localescape``' intrinsic once from the function entry "
"block, and the child functions can use '``llvm.localrecover``' to access the "
"escaped allocas. The '``llvm.localescape``' intrinsic blocks inlining, as "
"inlining changes where the escaped allocas are allocated, which would break "
"attempts to use '``llvm.localrecover``'."
msgstr ""

#: ../../../LangRef.rst:9446
msgid "'``llvm.read_register``' and '``llvm.write_register``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9462
msgid ""
"The '``llvm.read_register``' and '``llvm.write_register``' intrinsics "
"provides access to the named register. The register must be valid on the "
"architecture being compiled to. The type needs to be compatible with the "
"register being read."
msgstr ""

#: ../../../LangRef.rst:9470
msgid ""
"The '``llvm.read_register``' intrinsic returns the current value of the "
"register, where possible. The '``llvm.write_register``' intrinsic sets the "
"current value of the register, where possible."
msgstr ""

#: ../../../LangRef.rst:9474
msgid ""
"This is useful to implement named register global variables that need to "
"always be mapped to a specific register, as is common practice on bare-metal "
"programs including OS kernels."
msgstr ""

#: ../../../LangRef.rst:9478
msgid ""
"The compiler doesn't check for register availability or use of the used "
"register in surrounding code, including inline assembly. Because of that, "
"allocatable registers are not supported."
msgstr ""

#: ../../../LangRef.rst:9482
msgid ""
"Warning: So far it only works with the stack pointer on selected "
"architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of work "
"is needed to support other registers and even more so, allocatable registers."
msgstr ""

#: ../../../LangRef.rst:9490
msgid "'``llvm.stacksave``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9502
msgid ""
"The '``llvm.stacksave``' intrinsic is used to remember the current state of "
"the function stack, for use with :ref:`llvm.stackrestore "
"<int_stackrestore>`. This is useful for implementing language features like "
"scoped automatic variable sized arrays in C99."
msgstr ""

#: ../../../LangRef.rst:9511
msgid ""
"This intrinsic returns a opaque pointer value that can be passed to :ref:"
"`llvm.stackrestore <int_stackrestore>`. When an ``llvm.stackrestore`` "
"intrinsic is executed with a value saved from ``llvm.stacksave``, it "
"effectively restores the state of the stack to the state it was in when the "
"``llvm.stacksave`` intrinsic executed. In practice, this pops any :ref:"
"`alloca <i_alloca>` blocks from the stack that were allocated after the "
"``llvm.stacksave`` was executed."
msgstr ""

#: ../../../LangRef.rst:9522
msgid "'``llvm.stackrestore``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9534
msgid ""
"The '``llvm.stackrestore``' intrinsic is used to restore the state of the "
"function stack to the state it was in when the corresponding :ref:`llvm."
"stacksave <int_stacksave>` intrinsic executed. This is useful for "
"implementing language features like scoped automatic variable sized arrays "
"in C99."
msgstr ""

#: ../../../LangRef.rst:9543
msgid "See the description for :ref:`llvm.stacksave <int_stacksave>`."
msgstr ""

#: ../../../LangRef.rst:9548
msgid "'``llvm.get.dynamic.area.offset``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9561
msgid ""
"The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to get the "
"offset from native stack pointer to the address of the most recent dynamic "
"alloca on the caller's stack. These intrinsics are intendend for use in "
"combination with :ref:`llvm.stacksave <int_stacksave>` to get a pointer to "
"the most recent dynamic alloca. This is useful, for example, for "
"AddressSanitizer's stack unpoisoning routines."
msgstr ""

#: ../../../LangRef.rst:9572
msgid ""
"These intrinsics return a non-negative integer value that can be used to get "
"the address of the most recent dynamic alloca, allocated by :ref:`alloca "
"<i_alloca>` on the caller's stack. In particular, for targets where stack "
"grows downwards, adding this offset to the native stack pointer would get "
"the address of the most recent dynamic alloca. For targets where stack grows "
"upwards, the situation is a bit more complicated, because subtracting this "
"value from stack pointer would get the address one past the end of the most "
"recent dynamic alloca."
msgstr ""

#: ../../../LangRef.rst:9580
msgid ""
"Although for most targets `llvm.get.dynamic.area.offset "
"<int_get_dynamic_area_offset>` returns just a zero, for others, such as "
"PowerPC and PowerPC64, it returns a compile-time-known constant value."
msgstr ""

#: ../../../LangRef.rst:9584
msgid ""
"The return value type of :ref:`llvm.get.dynamic.area.offset "
"<int_get_dynamic_area_offset>` must match the target's generic address "
"space's (address space 0) pointer type."
msgstr ""

#: ../../../LangRef.rst:9588
msgid "'``llvm.prefetch``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9600
msgid ""
"The '``llvm.prefetch``' intrinsic is a hint to the code generator to insert "
"a prefetch instruction if supported; otherwise, it is a noop. Prefetches "
"have no effect on the behavior of the program but can change its performance "
"characteristics."
msgstr ""

#: ../../../LangRef.rst:9608
msgid ""
"``address`` is the address to be prefetched, ``rw`` is the specifier "
"determining if the fetch should be for a read (0) or write (1), and "
"``locality`` is a temporal locality specifier ranging from (0) - no "
"locality, to (3) - extremely local keep in cache. The ``cache type`` "
"specifies whether the prefetch is performed on the data (1) or instruction "
"(0) cache. The ``rw``, ``locality`` and ``cache type`` arguments must be "
"constant integers."
msgstr ""

#: ../../../LangRef.rst:9619
msgid ""
"This intrinsic does not modify the behavior of the program. In particular, "
"prefetches cannot trap and do not produce a value. On targets that support "
"this intrinsic, the prefetch can provide hints to the processor cache for "
"better performance."
msgstr ""

#: ../../../LangRef.rst:9625
msgid "'``llvm.pcmarker``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9637
msgid ""
"The '``llvm.pcmarker``' intrinsic is a method to export a Program Counter "
"(PC) in a region of code to simulators and other tools. The method is target "
"specific, but it is expected that the marker will use exported symbols to "
"transmit the PC of the marker. The marker makes no guarantees that it will "
"remain with any specific instruction after optimizations. It is possible "
"that the presence of a marker will inhibit optimizations. The intended use "
"is to be inserted after optimizations to allow correlations of simulation "
"runs."
msgstr ""

#: ../../../LangRef.rst:9649
msgid "``id`` is a numerical id identifying the marker."
msgstr ""

#: ../../../LangRef.rst:9654
msgid ""
"This intrinsic does not modify the behavior of the program. Backends that do "
"not support this intrinsic may ignore it."
msgstr ""

#: ../../../LangRef.rst:9658
msgid "'``llvm.readcyclecounter``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9670
msgid ""
"The '``llvm.readcyclecounter``' intrinsic provides access to the cycle "
"counter register (or similar low latency, high accuracy clocks) on those "
"targets that support it. On X86, it should map to RDTSC. On Alpha, it should "
"map to RPCC. As the backing counters overflow quickly (on the order of 9 "
"seconds on alpha), this should only be used for small timings."
msgstr ""

#: ../../../LangRef.rst:9680
msgid ""
"When directly supported, reading the cycle counter should not modify any "
"memory. Implementations are allowed to either return a application specific "
"value or a system wide value. On backends without support, this is lowered "
"to a constant 0."
msgstr ""

#: ../../../LangRef.rst:9685
msgid ""
"Note that runtime support may be conditional on the privilege-level code is "
"running at and the host platform."
msgstr ""

#: ../../../LangRef.rst:9689
msgid "'``llvm.clear_cache``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9701
msgid ""
"The '``llvm.clear_cache``' intrinsic ensures visibility of modifications in "
"the specified range to the execution unit of the processor. On targets with "
"non-unified instruction and data cache, the implementation flushes the "
"instruction cache."
msgstr ""

#: ../../../LangRef.rst:9709
msgid ""
"On platforms with coherent instruction and data caches (e.g. x86), this "
"intrinsic is a nop. On platforms with non-coherent instruction and data "
"cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate "
"instructions or a system call, if cache flushing requires special privileges."
msgstr ""

#: ../../../LangRef.rst:9715
msgid ""
"The default behavior is to emit a call to ``__clear_cache`` from the run "
"time library."
msgstr ""

#: ../../../LangRef.rst:9718
msgid ""
"This instrinsic does *not* empty the instruction pipeline. Modifications of "
"the current function are outside the scope of the intrinsic."
msgstr ""

#: ../../../LangRef.rst:9722
msgid "'``llvm.instrprof_increment``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9735
msgid ""
"The '``llvm.instrprof_increment``' intrinsic can be emitted by a frontend "
"for use with instrumentation based profiling. These will be lowered by the "
"``-instrprof`` pass to generate execution counts of a program at runtime."
msgstr ""

#: ../../../LangRef.rst:9743
msgid ""
"The first argument is a pointer to a global variable containing the name of "
"the entity being instrumented. This should generally be the (mangled) "
"function name for a set of counters."
msgstr ""

#: ../../../LangRef.rst:9747
msgid ""
"The second argument is a hash value that can be used by the consumer of the "
"profile data to detect changes to the instrumented source, and the third is "
"the number of counters associated with ``name``. It is an error if ``hash`` "
"or ``num-counters`` differ between two instances of ``instrprof_increment`` "
"that refer to the same name."
msgstr ""

#: ../../../LangRef.rst:9753
msgid ""
"The last argument refers to which of the counters for ``name`` should be "
"incremented. It should be a value between 0 and ``num-counters``."
msgstr ""

#: ../../../LangRef.rst:9759
msgid ""
"This intrinsic represents an increment of a profiling counter. It will cause "
"the ``-instrprof`` pass to generate the appropriate data structures and the "
"code to increment the appropriate value, in a format that can be written out "
"by a compiler runtime and consumed via the ``llvm-profdata`` tool."
msgstr ""

#: ../../../LangRef.rst:9766
msgid "'``llvm.instrprof_increment_step``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9780
msgid ""
"The '``llvm.instrprof_increment_step``' intrinsic is an extension to the "
"'``llvm.instrprof_increment``' intrinsic with an additional fifth argument "
"to specify the step of the increment."
msgstr ""

#: ../../../LangRef.rst:9786
msgid ""
"The first four arguments are the same as '``llvm.instrprof_increment``' "
"instrinsic."
msgstr ""

#: ../../../LangRef.rst:9789
msgid ""
"The last argument specifies the value of the increment of the counter "
"variable."
msgstr ""

#: ../../../LangRef.rst:9793
msgid "See description of '``llvm.instrprof_increment``' instrinsic."
msgstr ""

#: ../../../LangRef.rst:9797
msgid "'``llvm.instrprof_value_profile``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9811
msgid ""
"The '``llvm.instrprof_value_profile``' intrinsic can be emitted by a "
"frontend for use with instrumentation based profiling. This will be lowered "
"by the ``-instrprof`` pass to find out the target values, instrumented "
"expressions take in a program at runtime."
msgstr ""

#: ../../../LangRef.rst:9819
msgid ""
"The first argument is a pointer to a global variable containing the name of "
"the entity being instrumented. ``name`` should generally be the (mangled) "
"function name for a set of counters."
msgstr ""

#: ../../../LangRef.rst:9823
msgid ""
"The second argument is a hash value that can be used by the consumer of the "
"profile data to detect changes to the instrumented source. It is an error if "
"``hash`` differs between two instances of ``llvm.instrprof_*`` that refer to "
"the same name."
msgstr ""

#: ../../../LangRef.rst:9828
msgid ""
"The third argument is the value of the expression being profiled. The "
"profiled expression's value should be representable as an unsigned 64-bit "
"value. The fourth argument represents the kind of value profiling that is "
"being done. The supported value profiling kinds are enumerated through the "
"``InstrProfValueKind`` type declared in the ``<include/llvm/ProfileData/"
"InstrProf.h>`` header file. The last argument is the index of the "
"instrumented expression within ``name``. It should be >= 0."
msgstr ""

#: ../../../LangRef.rst:9839
msgid ""
"This intrinsic represents the point where a call to a runtime routine should "
"be inserted for value profiling of target expressions. ``-instrprof`` pass "
"will generate the appropriate data structures and replace the ``llvm."
"instrprof_value_profile`` intrinsic with the call to the profile runtime "
"library with proper arguments."
msgstr ""

#: ../../../LangRef.rst:9846
msgid "'``llvm.thread.pointer``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9858
msgid ""
"The '``llvm.thread.pointer``' intrinsic returns the value of the thread "
"pointer."
msgstr ""

#: ../../../LangRef.rst:9864
msgid ""
"The '``llvm.thread.pointer``' intrinsic returns a pointer to the TLS area "
"for the current thread.  The exact semantics of this value are target "
"specific: it may point to the start of TLS area, to the end, or somewhere in "
"the middle.  Depending on the target, this intrinsic may read a register, "
"call a helper function, read from an alternate memory space, or perform "
"other operations necessary to locate the TLS area.  Not all targets support "
"this intrinsic."
msgstr ""

#: ../../../LangRef.rst:9873
msgid "Standard C Library Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9875
msgid ""
"LLVM provides intrinsics for a few important standard C library functions. "
"These intrinsics allow source-language front-ends to pass information about "
"the alignment of the pointer arguments to the code generator, providing "
"opportunity for more efficient code generation."
msgstr ""

#: ../../../LangRef.rst:9883
msgid "'``llvm.memcpy``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9888
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memcpy`` on any integer "
"bit width and for different address spaces. Not all targets support all bit "
"widths however."
msgstr ""

#: ../../../LangRef.rst:9902
msgid ""
"The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source "
"location to the destination location."
msgstr ""

#: ../../../LangRef.rst:9905
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memcpy.*`` "
"intrinsics do not return a value, takes extra alignment/isvolatile arguments "
"and the pointers can be in specified address spaces."
msgstr ""

#: ../../../LangRef.rst:9912 ../../../LangRef.rst:9967
msgid ""
"The first argument is a pointer to the destination, the second is a pointer "
"to the source. The third argument is an integer argument specifying the "
"number of bytes to copy, the fourth argument is the alignment of the source "
"and destination locations, and the fifth is a boolean indicating a volatile "
"access."
msgstr ""

#: ../../../LangRef.rst:9918
msgid ""
"If the call to this intrinsic has an alignment value that is not 0 or 1, "
"then the caller guarantees that both the source and destination pointers are "
"aligned to that boundary."
msgstr ""

#: ../../../LangRef.rst:9922
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is a :"
"ref:`volatile operation <volatile>`. The detailed access behavior is not "
"very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:9929
msgid ""
"The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source "
"location to the destination location, which are not allowed to overlap. It "
"copies \"len\" bytes of memory over. If the argument is known to be aligned "
"to some boundary, this can be specified as the fourth argument, otherwise it "
"should be set to 0 or 1 (both meaning no alignment)."
msgstr ""

#: ../../../LangRef.rst:9936
msgid "'``llvm.memmove``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:9941
msgid ""
"This is an overloaded intrinsic. You can use llvm.memmove on any integer bit "
"width and for different address space. Not all targets support all bit "
"widths however."
msgstr ""

#: ../../../LangRef.rst:9955
msgid ""
"The '``llvm.memmove.*``' intrinsics move a block of memory from the source "
"location to the destination location. It is similar to the '``llvm.memcpy``' "
"intrinsic but allows the two memory locations to overlap."
msgstr ""

#: ../../../LangRef.rst:9960
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memmove.*`` "
"intrinsics do not return a value, takes extra alignment/isvolatile arguments "
"and the pointers can be in specified address spaces."
msgstr ""

#: ../../../LangRef.rst:9973
msgid ""
"If the call to this intrinsic has an alignment value that is not 0 or 1, "
"then the caller guarantees that the source and destination pointers are "
"aligned to that boundary."
msgstr ""

#: ../../../LangRef.rst:9977
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memmove`` call is a :"
"ref:`volatile operation <volatile>`. The detailed access behavior is not "
"very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:9984
msgid ""
"The '``llvm.memmove.*``' intrinsics copy a block of memory from the source "
"location to the destination location, which may overlap. It copies \"len\" "
"bytes of memory over. If the argument is known to be aligned to some "
"boundary, this can be specified as the fourth argument, otherwise it should "
"be set to 0 or 1 (both meaning no alignment)."
msgstr ""

#: ../../../LangRef.rst:9991
msgid "'``llvm.memset.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:9996
msgid ""
"This is an overloaded intrinsic. You can use llvm.memset on any integer bit "
"width and for different address spaces. However, not all targets support all "
"bit widths."
msgstr ""

#: ../../../LangRef.rst:10010
msgid ""
"The '``llvm.memset.*``' intrinsics fill a block of memory with a particular "
"byte value."
msgstr ""

#: ../../../LangRef.rst:10013
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memset`` intrinsic "
"does not return a value and takes extra alignment/volatile arguments. Also, "
"the destination can be in an arbitrary address space."
msgstr ""

#: ../../../LangRef.rst:10020
msgid ""
"The first argument is a pointer to the destination to fill, the second is "
"the byte value with which to fill it, the third argument is an integer "
"argument specifying the number of bytes to fill, and the fourth argument is "
"the known alignment of the destination location."
msgstr ""

#: ../../../LangRef.rst:10025
msgid ""
"If the call to this intrinsic has an alignment value that is not 0 or 1, "
"then the caller guarantees that the destination pointer is aligned to that "
"boundary."
msgstr ""

#: ../../../LangRef.rst:10029
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memset`` call is a :"
"ref:`volatile operation <volatile>`. The detailed access behavior is not "
"very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../../LangRef.rst:10036
msgid ""
"The '``llvm.memset.*``' intrinsics fill \"len\" bytes of memory starting at "
"the destination location. If the argument is known to be aligned to some "
"boundary, this can be specified as the fourth argument, otherwise it should "
"be set to 0 or 1 (both meaning no alignment)."
msgstr ""

#: ../../../LangRef.rst:10042
msgid "'``llvm.sqrt.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10047
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sqrt`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10062
msgid ""
"The '``llvm.sqrt``' intrinsics return the sqrt of the specified operand, "
"returning the same value as the libm '``sqrt``' functions would. Unlike "
"``sqrt`` in libm, however, ``llvm.sqrt`` has undefined behavior for negative "
"numbers other than -0.0 (which allows for better optimization, because there "
"is no need to worry about errno being set). ``llvm.sqrt(-0.0)`` is defined "
"to return -0.0 like IEEE sqrt."
msgstr ""

#: ../../../LangRef.rst:10072 ../../../LangRef.rst:10145
#: ../../../LangRef.rst:10181 ../../../LangRef.rst:10254
#: ../../../LangRef.rst:10289 ../../../LangRef.rst:10324
#: ../../../LangRef.rst:10359 ../../../LangRef.rst:10394
#: ../../../LangRef.rst:10430 ../../../LangRef.rst:10466
#: ../../../LangRef.rst:10620 ../../../LangRef.rst:10655
#: ../../../LangRef.rst:10691 ../../../LangRef.rst:10728
#: ../../../LangRef.rst:10764 ../../../LangRef.rst:10800
msgid ""
"The argument and return value are floating point numbers of the same type."
msgstr ""

#: ../../../LangRef.rst:10078
msgid ""
"This function returns the sqrt of the specified operand if it is a "
"nonnegative floating point number."
msgstr ""

#: ../../../LangRef.rst:10082
msgid "'``llvm.powi.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10087
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.powi`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10102
msgid ""
"The '``llvm.powi.*``' intrinsics return the first operand raised to the "
"specified (positive or negative) power. The order of evaluation of "
"multiplications is not defined. When a vector of floating point type is "
"used, the second argument remains a scalar integer value."
msgstr ""

#: ../../../LangRef.rst:10110
msgid ""
"The second argument is an integer power, and the first is a value to raise "
"to that power."
msgstr ""

#: ../../../LangRef.rst:10116
msgid ""
"This function returns the first value raised to the second power with an "
"unspecified sequence of rounding operations."
msgstr ""

#: ../../../LangRef.rst:10120
msgid "'``llvm.sin.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10125
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sin`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10140
msgid "The '``llvm.sin.*``' intrinsics return the sine of the operand."
msgstr ""

#: ../../../LangRef.rst:10151
msgid ""
"This function returns the sine of the specified operand, returning the same "
"values as the libm ``sin`` functions would, and handles error conditions in "
"the same way."
msgstr ""

#: ../../../LangRef.rst:10156
msgid "'``llvm.cos.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10161
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.cos`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10176
msgid "The '``llvm.cos.*``' intrinsics return the cosine of the operand."
msgstr ""

#: ../../../LangRef.rst:10187
msgid ""
"This function returns the cosine of the specified operand, returning the "
"same values as the libm ``cos`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10192
msgid "'``llvm.pow.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10197
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.pow`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10212
msgid ""
"The '``llvm.pow.*``' intrinsics return the first operand raised to the "
"specified (positive or negative) power."
msgstr ""

#: ../../../LangRef.rst:10218
msgid ""
"The second argument is a floating point power, and the first is a value to "
"raise to that power."
msgstr ""

#: ../../../LangRef.rst:10224
msgid ""
"This function returns the first value raised to the second power, returning "
"the same values as the libm ``pow`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10229
msgid "'``llvm.exp.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10234
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.exp`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10249
msgid "The '``llvm.exp.*``' intrinsics perform the exp function."
msgstr ""

#: ../../../LangRef.rst:10260
msgid ""
"This function returns the same values as the libm ``exp`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10264
msgid "'``llvm.exp2.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10269
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.exp2`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10284
msgid "The '``llvm.exp2.*``' intrinsics perform the exp2 function."
msgstr ""

#: ../../../LangRef.rst:10295
msgid ""
"This function returns the same values as the libm ``exp2`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10299
msgid "'``llvm.log.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10304
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10319
msgid "The '``llvm.log.*``' intrinsics perform the log function."
msgstr ""

#: ../../../LangRef.rst:10330
msgid ""
"This function returns the same values as the libm ``log`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10334
msgid "'``llvm.log10.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10339
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log10`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10354
msgid "The '``llvm.log10.*``' intrinsics perform the log10 function."
msgstr ""

#: ../../../LangRef.rst:10365
msgid ""
"This function returns the same values as the libm ``log10`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10369
msgid "'``llvm.log2.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10374
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log2`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10389
msgid "The '``llvm.log2.*``' intrinsics perform the log2 function."
msgstr ""

#: ../../../LangRef.rst:10400
msgid ""
"This function returns the same values as the libm ``log2`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10404
msgid "'``llvm.fma.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10409
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fma`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10424
msgid ""
"The '``llvm.fma.*``' intrinsics perform the fused multiply-add operation."
msgstr ""

#: ../../../LangRef.rst:10436
msgid ""
"This function returns the same values as the libm ``fma`` functions would, "
"and does not set errno."
msgstr ""

#: ../../../LangRef.rst:10440
msgid "'``llvm.fabs.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10445
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fabs`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10460
msgid ""
"The '``llvm.fabs.*``' intrinsics return the absolute value of the operand."
msgstr ""

#: ../../../LangRef.rst:10472
msgid ""
"This function returns the same values as the libm ``fabs`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10476
msgid "'``llvm.minnum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10481
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.minnum`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10496
msgid ""
"The '``llvm.minnum.*``' intrinsics return the minimum of the two arguments."
msgstr ""

#: ../../../LangRef.rst:10503 ../../../LangRef.rst:10545
#: ../../../LangRef.rst:10585
msgid ""
"The arguments and return value are floating point numbers of the same type."
msgstr ""

#: ../../../LangRef.rst:10509
msgid ""
"Follows the IEEE-754 semantics for minNum, which also match for libm's fmin."
msgstr ""

#: ../../../LangRef.rst:10512
msgid ""
"If either operand is a NaN, returns the other non-NaN operand. Returns NaN "
"only if both operands are NaN. If the operands compare equal, returns a "
"value that compares equal to both operands. This means that fmin(+/-0.0, "
"+/-0.0) could return either -0.0 or 0.0."
msgstr ""

#: ../../../LangRef.rst:10518
msgid "'``llvm.maxnum.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10523
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.maxnum`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10538
msgid ""
"The '``llvm.maxnum.*``' intrinsics return the maximum of the two arguments."
msgstr ""

#: ../../../LangRef.rst:10550
msgid ""
"Follows the IEEE-754 semantics for maxNum, which also match for libm's fmax."
msgstr ""

#: ../../../LangRef.rst:10553
msgid ""
"If either operand is a NaN, returns the other non-NaN operand. Returns NaN "
"only if both operands are NaN. If the operands compare equal, returns a "
"value that compares equal to both operands. This means that fmax(+/-0.0, "
"+/-0.0) could return either -0.0 or 0.0."
msgstr ""

#: ../../../LangRef.rst:10559
msgid "'``llvm.copysign.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10564
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.copysign`` on any "
"floating point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:10579
msgid ""
"The '``llvm.copysign.*``' intrinsics return a value with the magnitude of "
"the first operand and the sign of the second operand."
msgstr ""

#: ../../../LangRef.rst:10591
msgid ""
"This function returns the same values as the libm ``copysign`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10595
msgid "'``llvm.floor.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10600
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.floor`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10615
msgid "The '``llvm.floor.*``' intrinsics return the floor of the operand."
msgstr ""

#: ../../../LangRef.rst:10626
msgid ""
"This function returns the same values as the libm ``floor`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10630
msgid "'``llvm.ceil.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10635
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ceil`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10650
msgid "The '``llvm.ceil.*``' intrinsics return the ceiling of the operand."
msgstr ""

#: ../../../LangRef.rst:10661
msgid ""
"This function returns the same values as the libm ``ceil`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10665
msgid "'``llvm.trunc.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10670
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.trunc`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10685
msgid ""
"The '``llvm.trunc.*``' intrinsics returns the operand rounded to the nearest "
"integer not larger in magnitude than the operand."
msgstr ""

#: ../../../LangRef.rst:10697
msgid ""
"This function returns the same values as the libm ``trunc`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10701
msgid "'``llvm.rint.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10706
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.rint`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10721
msgid ""
"The '``llvm.rint.*``' intrinsics returns the operand rounded to the nearest "
"integer. It may raise an inexact floating-point exception if the operand "
"isn't an integer."
msgstr ""

#: ../../../LangRef.rst:10734
msgid ""
"This function returns the same values as the libm ``rint`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10738
msgid "'``llvm.nearbyint.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10743
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.nearbyint`` on any "
"floating point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../../LangRef.rst:10758
msgid ""
"The '``llvm.nearbyint.*``' intrinsics returns the operand rounded to the "
"nearest integer."
msgstr ""

#: ../../../LangRef.rst:10770
msgid ""
"This function returns the same values as the libm ``nearbyint`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10774
msgid "'``llvm.round.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10779
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.round`` on any floating "
"point or vector of floating point type. Not all targets support all types "
"however."
msgstr ""

#: ../../../LangRef.rst:10794
msgid ""
"The '``llvm.round.*``' intrinsics returns the operand rounded to the nearest "
"integer."
msgstr ""

#: ../../../LangRef.rst:10806
msgid ""
"This function returns the same values as the libm ``round`` functions would, "
"and handles error conditions in the same way."
msgstr ""

#: ../../../LangRef.rst:10810
msgid "Bit Manipulation Intrinsics"
msgstr ""

#: ../../../LangRef.rst:10812
msgid ""
"LLVM provides intrinsics for a few important bit manipulation operations. "
"These allow efficient code generation for some algorithms."
msgstr ""

#: ../../../LangRef.rst:10816
msgid "'``llvm.bitreverse.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:10821
msgid ""
"This is an overloaded intrinsic function. You can use bitreverse on any "
"integer type."
msgstr ""

#: ../../../LangRef.rst:10833
msgid ""
"The '``llvm.bitreverse``' family of intrinsics is used to reverse the "
"bitpattern of an integer value; for example ``0b10110110`` becomes "
"``0b01101101``."
msgstr ""

#: ../../../LangRef.rst:10840
msgid ""
"The ``llvm.bitreverse.iN`` intrinsic returns an iN value that has bit ``M`` "
"in the input moved to bit ``N-M`` in the output."
msgstr ""

#: ../../../LangRef.rst:10844
msgid "'``llvm.bswap.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:10849
msgid ""
"This is an overloaded intrinsic function. You can use bswap on any integer "
"type that is an even number of bytes (i.e. BitWidth % 16 == 0)."
msgstr ""

#: ../../../LangRef.rst:10861
msgid ""
"The '``llvm.bswap``' family of intrinsics is used to byte swap integer "
"values with an even number of bytes (positive multiple of 16 bits). These "
"are useful for performing operations on data that is not in the target's "
"native byte order."
msgstr ""

#: ../../../LangRef.rst:10869
msgid ""
"The ``llvm.bswap.i16`` intrinsic returns an i16 value that has the high and "
"low byte of the input i16 swapped. Similarly, the ``llvm.bswap.i32`` "
"intrinsic returns an i32 value that has the four bytes of the input i32 "
"swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the "
"returned i32 will have its bytes in 3, 2, 1, 0 order. The ``llvm.bswap."
"i48``, ``llvm.bswap.i64`` and other intrinsics extend this concept to "
"additional even-byte lengths (6 bytes, 8 bytes and more, respectively)."
msgstr ""

#: ../../../LangRef.rst:10879
msgid "'``llvm.ctpop.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10884
msgid ""
"This is an overloaded intrinsic. You can use llvm.ctpop on any integer bit "
"width, or on any vector with integer elements. Not all targets support all "
"bit widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:10900
msgid ""
"The '``llvm.ctpop``' family of intrinsics counts the number of bits set in a "
"value."
msgstr ""

#: ../../../LangRef.rst:10906
msgid ""
"The only argument is the value to be counted. The argument may be of any "
"integer type, or a vector with integer elements. The return type must match "
"the argument type."
msgstr ""

#: ../../../LangRef.rst:10913
msgid ""
"The '``llvm.ctpop``' intrinsic counts the 1's in a variable, or within each "
"element of a vector."
msgstr ""

#: ../../../LangRef.rst:10917
msgid "'``llvm.ctlz.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10922
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any integer "
"bit width, or any vector whose elements are integers. Not all targets "
"support all bit widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:10938
msgid ""
"The '``llvm.ctlz``' family of intrinsic functions counts the number of "
"leading zeros in a variable."
msgstr ""

#: ../../../LangRef.rst:10944 ../../../LangRef.rst:10991
msgid ""
"The first argument is the value to be counted. This argument may be of any "
"integer type, or a vector with integer element type. The return type must "
"match the first argument type."
msgstr ""

#: ../../../LangRef.rst:10948 ../../../LangRef.rst:10995
msgid ""
"The second argument must be a constant and is a flag to indicate whether the "
"intrinsic should ensure that a zero as the first argument produces a defined "
"result. Historically some architectures did not provide a defined result for "
"zero values as efficiently, and many algorithms are now predicated on "
"avoiding zero-value inputs."
msgstr ""

#: ../../../LangRef.rst:10957
msgid ""
"The '``llvm.ctlz``' intrinsic counts the leading (most significant) zeros in "
"a variable, or within each element of the vector. If ``src == 0`` then the "
"result is the size in bits of the type of ``src`` if ``is_zero_undef == 0`` "
"and ``undef`` otherwise. For example, ``llvm.ctlz(i32 2) = 30``."
msgstr ""

#: ../../../LangRef.rst:10964
msgid "'``llvm.cttz.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:10969
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.cttz`` on any integer "
"bit width, or any vector of integer elements. Not all targets support all "
"bit widths or vector types, however."
msgstr ""

#: ../../../LangRef.rst:10985
msgid ""
"The '``llvm.cttz``' family of intrinsic functions counts the number of "
"trailing zeros."
msgstr ""

#: ../../../LangRef.rst:11004
msgid ""
"The '``llvm.cttz``' intrinsic counts the trailing (least significant) zeros "
"in a variable, or within each element of a vector. If ``src == 0`` then the "
"result is the size in bits of the type of ``src`` if ``is_zero_undef == 0`` "
"and ``undef`` otherwise. For example, ``llvm.cttz(2) = 1``."
msgstr ""

#: ../../../LangRef.rst:11013
msgid "Arithmetic with Overflow Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11015
msgid "LLVM provides intrinsics for fast arithmetic overflow checking."
msgstr ""

#: ../../../LangRef.rst:11017
msgid ""
"Each of these intrinsics returns a two-element struct. The first element of "
"this struct contains the result of the corresponding arithmetic operation "
"modulo 2\\ :sup:`n`\\ , where n is the bit width of the result. Therefore, "
"for example, the first element of the struct returned by ``llvm.sadd.with."
"overflow.i32`` is always the same as the result of a 32-bit ``add`` "
"instruction with the same operands, where the ``add`` is *not* modified by "
"an ``nsw`` or ``nuw`` flag."
msgstr ""

#: ../../../LangRef.rst:11025
msgid ""
"The second element of the result is an ``i1`` that is 1 if the arithmetic "
"operation overflowed and 0 otherwise. An operation overflows if, for any "
"values of its operands ``A`` and ``B`` and for any ``N`` larger than the "
"operands' width, ``ext(A op B) to iN`` is not equal to ``(ext(A) to iN) op "
"(ext(B) to iN)`` where ``ext`` is ``sext`` for signed overflow and ``zext`` "
"for unsigned overflow, and ``op`` is the underlying arithmetic operation."
msgstr ""

#: ../../../LangRef.rst:11033
msgid ""
"The behavior of these intrinsics is well-defined for all argument values."
msgstr ""

#: ../../../LangRef.rst:11037
msgid "'``llvm.sadd.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11042
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sadd.with.overflow`` on "
"any integer bit width."
msgstr ""

#: ../../../LangRef.rst:11054
msgid ""
"The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a "
"signed addition of the two arguments, and indicate whether an overflow "
"occurred during the signed summation."
msgstr ""

#: ../../../LangRef.rst:11061
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo signed addition."
msgstr ""

#: ../../../LangRef.rst:11070
msgid ""
"The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a "
"signed addition of the two variables. They return a structure --- the first "
"element of which is the signed summation, and the second element of which is "
"a bit specifying if the signed summation resulted in an overflow."
msgstr ""

#: ../../../LangRef.rst:11087
msgid "'``llvm.uadd.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11092
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.uadd.with.overflow`` on "
"any integer bit width."
msgstr ""

#: ../../../LangRef.rst:11104
msgid ""
"The '``llvm.uadd.with.overflow``' family of intrinsic functions perform an "
"unsigned addition of the two arguments, and indicate whether a carry "
"occurred during the unsigned summation."
msgstr ""

#: ../../../LangRef.rst:11111
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo unsigned addition."
msgstr ""

#: ../../../LangRef.rst:11120
msgid ""
"The '``llvm.uadd.with.overflow``' family of intrinsic functions perform an "
"unsigned addition of the two arguments. They return a structure --- the "
"first element of which is the sum, and the second element of which is a bit "
"specifying if the unsigned summation resulted in a carry."
msgstr ""

#: ../../../LangRef.rst:11136
msgid "'``llvm.ssub.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11141
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ssub.with.overflow`` on "
"any integer bit width."
msgstr ""

#: ../../../LangRef.rst:11153
msgid ""
"The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a "
"signed subtraction of the two arguments, and indicate whether an overflow "
"occurred during the signed subtraction."
msgstr ""

#: ../../../LangRef.rst:11160
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo signed subtraction."
msgstr ""

#: ../../../LangRef.rst:11169
msgid ""
"The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a "
"signed subtraction of the two arguments. They return a structure --- the "
"first element of which is the subtraction, and the second element of which "
"is a bit specifying if the signed subtraction resulted in an overflow."
msgstr ""

#: ../../../LangRef.rst:11186
msgid "'``llvm.usub.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11191
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.usub.with.overflow`` on "
"any integer bit width."
msgstr ""

#: ../../../LangRef.rst:11203
msgid ""
"The '``llvm.usub.with.overflow``' family of intrinsic functions perform an "
"unsigned subtraction of the two arguments, and indicate whether an overflow "
"occurred during the unsigned subtraction."
msgstr ""

#: ../../../LangRef.rst:11210
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo unsigned subtraction."
msgstr ""

#: ../../../LangRef.rst:11219
msgid ""
"The '``llvm.usub.with.overflow``' family of intrinsic functions perform an "
"unsigned subtraction of the two arguments. They return a structure --- the "
"first element of which is the subtraction, and the second element of which "
"is a bit specifying if the unsigned subtraction resulted in an overflow."
msgstr ""

#: ../../../LangRef.rst:11236
msgid "'``llvm.smul.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11241
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.smul.with.overflow`` on "
"any integer bit width."
msgstr ""

#: ../../../LangRef.rst:11253
msgid ""
"The '``llvm.smul.with.overflow``' family of intrinsic functions perform a "
"signed multiplication of the two arguments, and indicate whether an overflow "
"occurred during the signed multiplication."
msgstr ""

#: ../../../LangRef.rst:11260
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo signed multiplication."
msgstr ""

#: ../../../LangRef.rst:11269
msgid ""
"The '``llvm.smul.with.overflow``' family of intrinsic functions perform a "
"signed multiplication of the two arguments. They return a structure --- the "
"first element of which is the multiplication, and the second element of "
"which is a bit specifying if the signed multiplication resulted in an "
"overflow."
msgstr ""

#: ../../../LangRef.rst:11286
msgid "'``llvm.umul.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11291
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.umul.with.overflow`` on "
"any integer bit width."
msgstr ""

#: ../../../LangRef.rst:11303
msgid ""
"The '``llvm.umul.with.overflow``' family of intrinsic functions perform a "
"unsigned multiplication of the two arguments, and indicate whether an "
"overflow occurred during the unsigned multiplication."
msgstr ""

#: ../../../LangRef.rst:11310
msgid ""
"The arguments (%a and %b) and the first element of the result structure may "
"be of integer types of any bit width, but they must have the same bit width. "
"The second element of the result structure must be of type ``i1``. ``%a`` "
"and ``%b`` are the two values that will undergo unsigned multiplication."
msgstr ""

#: ../../../LangRef.rst:11319
msgid ""
"The '``llvm.umul.with.overflow``' family of intrinsic functions perform an "
"unsigned multiplication of the two arguments. They return a structure --- "
"the first element of which is the multiplication, and the second element of "
"which is a bit specifying if the unsigned multiplication resulted in an "
"overflow."
msgstr ""

#: ../../../LangRef.rst:11336
msgid "Specialised Arithmetic Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11339
msgid "'``llvm.canonicalize.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11352
msgid ""
"The '``llvm.canonicalize.*``' intrinsic returns the platform specific "
"canonical encoding of a floating point number. This canonicalization is "
"useful for implementing certain numeric primitives such as frexp. The "
"canonical encoding is defined by IEEE-754-2008 to be:"
msgstr ""

#: ../../../LangRef.rst:11363
msgid ""
"This operation can also be considered equivalent to the IEEE-754-2008 "
"conversion of a floating-point value to the same format. NaNs are handled "
"according to section 6.2."
msgstr ""

#: ../../../LangRef.rst:11367
msgid "Examples of non-canonical encodings:"
msgstr ""

#: ../../../LangRef.rst:11369
msgid ""
"x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are "
"converted to a canonical representation per hardware-specific protocol."
msgstr ""

#: ../../../LangRef.rst:11371
msgid ""
"Many normal decimal floating point numbers have non-canonical alternative "
"encodings."
msgstr ""

#: ../../../LangRef.rst:11373
msgid ""
"Some machines, like GPUs or ARMv7 NEON, do not support subnormal values. "
"These are treated as non-canonical encodings of zero and will be flushed to "
"a zero of the same sign by this operation."
msgstr ""

#: ../../../LangRef.rst:11377
msgid ""
"Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with "
"default exception handling must signal an invalid exception, and produce a "
"quiet NaN result."
msgstr ""

#: ../../../LangRef.rst:11381
msgid ""
"This function should always be implementable as multiplication by 1.0, "
"provided that the compiler does not constant fold the operation. Likewise, "
"division by 1.0 and ``llvm.minnum(x, x)`` are possible implementations. "
"Addition with -0.0 is also sufficient provided that the rounding mode is not "
"-Infinity."
msgstr ""

#: ../../../LangRef.rst:11386
msgid "``@llvm.canonicalize`` must preserve the equality relation. That is:"
msgstr ""

#: ../../../LangRef.rst:11388
msgid "``(@llvm.canonicalize(x) == x)`` is equivalent to ``(x == x)``"
msgstr ""

#: ../../../LangRef.rst:11389
msgid ""
"``(@llvm.canonicalize(x) == @llvm.canonicalize(y))`` is equivalent to to "
"``(x == y)``"
msgstr ""

#: ../../../LangRef.rst:11392
msgid ""
"Additionally, the sign of zero must be conserved: ``@llvm.canonicalize(-0.0) "
"= -0.0`` and ``@llvm.canonicalize(+0.0) = +0.0``"
msgstr ""

#: ../../../LangRef.rst:11395
msgid ""
"The payload bits of a NaN must be conserved, with two exceptions. First, "
"environments which use only a single canonical representation of NaN must "
"perform said canonicalization. Second, SNaNs must be quieted per the usual "
"methods."
msgstr ""

#: ../../../LangRef.rst:11400
msgid "The canonicalization operation may be optimized away if:"
msgstr ""

#: ../../../LangRef.rst:11402
msgid ""
"The input is known to be canonical. For example, it was produced by a "
"floating-point operation that is required by the standard to be canonical."
msgstr ""

#: ../../../LangRef.rst:11404
msgid ""
"The result is consumed only by (or fused with) other floating-point "
"operations. That is, the bits of the floating point value are not examined."
msgstr ""

#: ../../../LangRef.rst:11408
msgid "'``llvm.fmuladd.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11421
msgid ""
"The '``llvm.fmuladd.*``' intrinsic functions represent multiply-add "
"expressions that can be fused if the code generator determines that (a) the "
"target instruction set has support for a fused operation, and (b) that the "
"fused operation is more efficient than the equivalent, separate pair of mul "
"and add instructions."
msgstr ""

#: ../../../LangRef.rst:11430
msgid ""
"The '``llvm.fmuladd.*``' intrinsics each take three arguments: two "
"multiplicands, a and b, and an addend c."
msgstr ""

#: ../../../LangRef.rst:11436
msgid "The expression:"
msgstr ""

#: ../../../LangRef.rst:11442
msgid ""
"is equivalent to the expression a \\* b + c, except that rounding will not "
"be performed between the multiplication and addition steps if the code "
"generator fuses the operations. Fusion is not guaranteed, even if the target "
"platform supports it. If a fused multiply-add is required the corresponding "
"llvm.fma.\\* intrinsic function should be used instead. This never sets "
"errno, just as '``llvm.fma.*``'."
msgstr ""

#: ../../../LangRef.rst:11457
msgid "Half Precision Floating Point Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11459
msgid ""
"For most target platforms, half precision floating point is a storage-only "
"format. This means that it is a dense encoding (in memory) but does not "
"support computation in the format."
msgstr ""

#: ../../../LangRef.rst:11463
msgid ""
"This means that code must first load the half-precision floating point value "
"as an i16, then convert it to float with :ref:`llvm.convert.from.fp16 "
"<int_convert_from_fp16>`. Computation can then be performed on the float "
"value (including extending to double etc). To store the value back to "
"memory, it is first converted to float if needed, then converted to i16 "
"with :ref:`llvm.convert.to.fp16 <int_convert_to_fp16>`, then storing as an "
"i16 value."
msgstr ""

#: ../../../LangRef.rst:11475
msgid "'``llvm.convert.to.fp16``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11488
msgid ""
"The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from "
"a conventional floating point type to half precision floating point format."
msgstr ""

#: ../../../LangRef.rst:11494 ../../../LangRef.rst:11535
msgid ""
"The intrinsic function contains single argument - the value to be converted."
msgstr ""

#: ../../../LangRef.rst:11500
msgid ""
"The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from "
"a conventional floating point format to half precision floating point "
"format. The return value is an ``i16`` which contains the converted number."
msgstr ""

#: ../../../LangRef.rst:11515
msgid "'``llvm.convert.from.fp16``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11528
msgid ""
"The '``llvm.convert.from.fp16``' intrinsic function performs a conversion "
"from half precision floating point format to single precision floating point "
"format."
msgstr ""

#: ../../../LangRef.rst:11541
msgid ""
"The '``llvm.convert.from.fp16``' intrinsic function performs a conversion "
"from half single precision floating point format to single precision "
"floating point format. The input half-float value is represented by an "
"``i16`` value."
msgstr ""

#: ../../../LangRef.rst:11557
msgid "Debugger Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11559
msgid ""
"The LLVM debugger intrinsics (which all start with ``llvm.dbg.`` prefix), "
"are described in the `LLVM Source Level Debugging <SourceLevelDebugging."
"html#format_common_intrinsics>`_ document."
msgstr ""

#: ../../../LangRef.rst:11565
msgid "Exception Handling Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11567
msgid ""
"The LLVM exception handling intrinsics (which all start with ``llvm.eh.`` "
"prefix), are described in the `LLVM Exception Handling <ExceptionHandling."
"html#format_common_intrinsics>`_ document."
msgstr ""

#: ../../../LangRef.rst:11574
msgid "Trampoline Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11576
msgid ""
"These intrinsics make it possible to excise one parameter, marked with the :"
"ref:`nest <nest>` attribute, from a function. The result is a callable "
"function pointer lacking the nest parameter - the caller does not need to "
"provide a value for it. Instead, the value to use is stored in advance in a "
"\"trampoline\", a block of memory usually allocated on the stack, which also "
"contains code to splice the nest value into the argument list. This is used "
"to implement the GCC nested function address extension."
msgstr ""

#: ../../../LangRef.rst:11585
msgid ""
"For example, if the function is ``i32 f(i8* nest %c, i32 %x, i32 %y)`` then "
"the resulting function pointer has signature ``i32 (i32, i32)*``. It can be "
"created as follows:"
msgstr ""

#: ../../../LangRef.rst:11597
msgid ""
"The call ``%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to "
"``%val = call i32 %f(i8* %nval, i32 %x, i32 %y)``."
msgstr ""

#: ../../../LangRef.rst:11603
msgid "'``llvm.init.trampoline``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11615
msgid ""
"This fills the memory pointed to by ``tramp`` with executable code, turning "
"it into a trampoline."
msgstr ""

#: ../../../LangRef.rst:11621
msgid ""
"The ``llvm.init.trampoline`` intrinsic takes three arguments, all pointers. "
"The ``tramp`` argument must point to a sufficiently large and sufficiently "
"aligned block of memory; this memory is written to by the intrinsic. Note "
"that the size and the alignment are target-specific - LLVM currently "
"provides no portable way of determining them, so a front-end that generates "
"this intrinsic needs to have some target-specific knowledge. The ``func`` "
"argument must hold a function bitcast to an ``i8*``."
msgstr ""

#: ../../../LangRef.rst:11633
msgid ""
"The block of memory pointed to by ``tramp`` is filled with target dependent "
"code, turning it into a function. Then ``tramp`` needs to be passed to :ref:"
"`llvm.adjust.trampoline <int_at>` to get a pointer which can be :ref:"
"`bitcast (to a new function) and called <int_trampoline>`. The new "
"function's signature is the same as that of ``func`` with any arguments "
"marked with the ``nest`` attribute removed. At most one such ``nest`` "
"argument is allowed, and it must be of pointer type. Calling the new "
"function is equivalent to calling ``func`` with the same argument list, but "
"with ``nval`` used for the missing ``nest`` argument. If, after calling "
"``llvm.init.trampoline``, the memory pointed to by ``tramp`` is modified, "
"then the effect of any later call to the returned function pointer is "
"undefined."
msgstr ""

#: ../../../LangRef.rst:11649
msgid "'``llvm.adjust.trampoline``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11661
msgid ""
"This performs any required machine-specific adjustment to the address of a "
"trampoline (passed as ``tramp``)."
msgstr ""

#: ../../../LangRef.rst:11667
msgid ""
"``tramp`` must point to a block of memory which already has trampoline code "
"filled in by a previous call to :ref:`llvm.init.trampoline <int_it>`."
msgstr ""

#: ../../../LangRef.rst:11674
msgid ""
"On some architectures the address of the code to be executed needs to be "
"different than the address where the trampoline is actually stored. This "
"intrinsic returns the executable address corresponding to ``tramp`` after "
"performing the required machine specific adjustments. The pointer returned "
"can then be :ref:`bitcast and executed <int_trampoline>`."
msgstr ""

#: ../../../LangRef.rst:11683
msgid "Masked Vector Load and Store Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11685
msgid ""
"LLVM provides intrinsics for predicated vector load and store operations. "
"The predicate is specified by a mask operand, which holds one bit per vector "
"element, switching the associated vector lane on or off. The memory "
"addresses corresponding to the \"off\" lanes are not accessed. When all bits "
"of the mask are on, the intrinsic is identical to a regular vector load or "
"store. When all bits are off, no memory is accessed."
msgstr ""

#: ../../../LangRef.rst:11690
msgid "'``llvm.masked.load.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11694
msgid ""
"This is an overloaded intrinsic. The loaded data is a vector of any integer, "
"floating point or pointer data type."
msgstr ""

#: ../../../LangRef.rst:11708
msgid ""
"Reads a vector from memory according to the provided mask. The mask holds a "
"bit for each vector lane, and is used to prevent memory accesses to the "
"masked-off lanes. The masked-off lanes in the result vector are taken from "
"the corresponding lanes of the '``passthru``' operand."
msgstr ""

#: ../../../LangRef.rst:11714
msgid ""
"The first operand is the base pointer for the load. The second operand is "
"the alignment of the source location. It must be a constant integer value. "
"The third operand, mask, is a vector of boolean values with the same number "
"of elements as the return type. The fourth is a pass-through value that is "
"used to fill the masked-off lanes of the result. The return type, underlying "
"type of the base pointer and the type of the '``passthru``' operand are the "
"same vector types."
msgstr ""

#: ../../../LangRef.rst:11720
msgid ""
"The '``llvm.masked.load``' intrinsic is designed for conditional reading of "
"selected vector elements in a single IR operation. It is useful for targets "
"that support vector masked loads and allows vectorizing predicated basic "
"blocks on these targets. Other targets may support this intrinsic "
"differently, for example by lowering it into a sequence of branches that "
"guard scalar load operations. The result of this operation is equivalent to "
"a regular vector load instruction followed by a 'select' between the loaded "
"and the passthru values, predicated on the same mask. However, using this "
"intrinsic prevents exceptions on memory access to masked-off lanes."
msgstr ""

#: ../../../LangRef.rst:11735
msgid "'``llvm.masked.store.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11739
msgid ""
"This is an overloaded intrinsic. The data stored in memory is a vector of "
"any integer, floating point or pointer data type."
msgstr ""

#: ../../../LangRef.rst:11753
msgid ""
"Writes a vector to memory according to the provided mask. The mask holds a "
"bit for each vector lane, and is used to prevent memory accesses to the "
"masked-off lanes."
msgstr ""

#: ../../../LangRef.rst:11758
msgid ""
"The first operand is the vector value to be written to memory. The second "
"operand is the base pointer for the store, it has the same underlying type "
"as the value operand. The third operand is the alignment of the destination "
"location. The fourth operand, mask, is a vector of boolean values. The types "
"of the mask and the value operand must have the same number of vector "
"elements."
msgstr ""

#: ../../../LangRef.rst:11764
msgid ""
"The '``llvm.masked.store``' intrinsics is designed for conditional writing "
"of selected vector elements in a single IR operation. It is useful for "
"targets that support vector masked store and allows vectorizing predicated "
"basic blocks on these targets. Other targets may support this intrinsic "
"differently, for example by lowering it into a sequence of branches that "
"guard scalar store operations. The result of this operation is equivalent to "
"a load-modify-store sequence. However, using this intrinsic prevents "
"exceptions and data races on memory access to masked-off lanes."
msgstr ""

#: ../../../LangRef.rst:11778
msgid "Masked Vector Gather and Scatter Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11780
msgid ""
"LLVM provides intrinsics for vector gather and scatter operations. They are "
"similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except "
"they are designed for arbitrary memory accesses, rather than sequential "
"memory accesses. Gather and scatter also employ a mask operand, which holds "
"one bit per vector element, switching the associated vector lane on or off. "
"The memory addresses corresponding to the \"off\" lanes are not accessed. "
"When all bits are off, no memory is accessed."
msgstr ""

#: ../../../LangRef.rst:11785
msgid "'``llvm.masked.gather.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11789
msgid ""
"This is an overloaded intrinsic. The loaded data are multiple scalar values "
"of any integer, floating point or pointer data type gathered together into "
"one vector."
msgstr ""

#: ../../../LangRef.rst:11800
msgid ""
"Reads scalar values from arbitrary memory locations and gathers them into "
"one vector. The memory locations are provided in the vector of pointers "
"'``ptrs``'. The memory is accessed according to the provided mask. The mask "
"holds a bit for each vector lane, and is used to prevent memory accesses to "
"the masked-off lanes. The masked-off lanes in the result vector are taken "
"from the corresponding lanes of the '``passthru``' operand."
msgstr ""

#: ../../../LangRef.rst:11806
msgid ""
"The first operand is a vector of pointers which holds all memory addresses "
"to read. The second operand is an alignment of the source addresses. It must "
"be a constant integer value. The third operand, mask, is a vector of boolean "
"values with the same number of elements as the return type. The fourth is a "
"pass-through value that is used to fill the masked-off lanes of the result. "
"The return type, underlying type of the vector of pointers and the type of "
"the '``passthru``' operand are the same vector types."
msgstr ""

#: ../../../LangRef.rst:11812
msgid ""
"The '``llvm.masked.gather``' intrinsic is designed for conditional reading "
"of multiple scalar values from arbitrary memory locations in a single IR "
"operation. It is useful for targets that support vector masked gathers and "
"allows vectorizing basic blocks with data and control divergence. Other "
"targets may support this intrinsic differently, for example by lowering it "
"into a sequence of scalar load operations. The semantics of this operation "
"are equivalent to a sequence of conditional scalar loads with subsequent "
"gathering all loaded values into a single vector. The mask restricts memory "
"access to certain lanes and facilitates vectorization of predicated basic "
"blocks."
msgstr ""

#: ../../../LangRef.rst:11839
msgid "'``llvm.masked.scatter.*``' Intrinsics"
msgstr ""

#: ../../../LangRef.rst:11843
msgid ""
"This is an overloaded intrinsic. The data stored in memory is a vector of "
"any integer, floating point or pointer data type. Each vector element is "
"stored in an arbitrary memory address. Scatter with overlapping addresses is "
"guaranteed to be ordered from least-significant to most-significant element."
msgstr ""

#: ../../../LangRef.rst:11854
msgid ""
"Writes each element from the value vector to the corresponding memory "
"address. The memory addresses are represented as a vector of pointers. "
"Writing is done according to the provided mask. The mask holds a bit for "
"each vector lane, and is used to prevent memory accesses to the masked-off "
"lanes."
msgstr ""

#: ../../../LangRef.rst:11859
msgid ""
"The first operand is a vector value to be written to memory. The second "
"operand is a vector of pointers, pointing to where the value elements should "
"be stored. It has the same underlying type as the value operand. The third "
"operand is an alignment of the destination addresses. The fourth operand, "
"mask, is a vector of boolean values. The types of the mask and the value "
"operand must have the same number of vector elements."
msgstr ""

#: ../../../LangRef.rst:11865
msgid ""
"The '``llvm.masked.scatter``' intrinsics is designed for writing selected "
"vector elements to arbitrary memory addresses in a single IR operation. The "
"operation may be conditional, when not all bits in the mask are switched on. "
"It is useful for targets that support vector masked scatter and allows "
"vectorizing basic blocks with data and control divergence. Other targets may "
"support this intrinsic differently, for example by lowering it into a "
"sequence of branches that guard scalar store operations."
msgstr ""

#: ../../../LangRef.rst:11889
msgid "Memory Use Markers"
msgstr ""

#: ../../../LangRef.rst:11891
msgid ""
"This class of intrinsics provides information about the lifetime of memory "
"objects and ranges where variables are immutable."
msgstr ""

#: ../../../LangRef.rst:11897
msgid "'``llvm.lifetime.start``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11909
msgid ""
"The '``llvm.lifetime.start``' intrinsic specifies the start of a memory "
"object's lifetime."
msgstr ""

#: ../../../LangRef.rst:11915 ../../../LangRef.rst:11948
#: ../../../LangRef.rst:11980
msgid ""
"The first argument is a constant integer representing the size of the "
"object, or -1 if it is variable sized. The second argument is a pointer to "
"the object."
msgstr ""

#: ../../../LangRef.rst:11922
msgid ""
"This intrinsic indicates that before this point in the code, the value of "
"the memory pointed to by ``ptr`` is dead. This means that it is known to "
"never be used and has an undefined value. A load from the pointer that "
"precedes this intrinsic can be replaced with ``'undef'``."
msgstr ""

#: ../../../LangRef.rst:11930
msgid "'``llvm.lifetime.end``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11942
msgid ""
"The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's "
"lifetime."
msgstr ""

#: ../../../LangRef.rst:11955
msgid ""
"This intrinsic indicates that after this point in the code, the value of the "
"memory pointed to by ``ptr`` is dead. This means that it is known to never "
"be used and has an undefined value. Any stores into the memory object "
"following this intrinsic may be removed as dead."
msgstr ""

#: ../../../LangRef.rst:11961
msgid "'``llvm.invariant.start``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:11965 ../../../LangRef.rst:11996
msgid ""
"This is an overloaded intrinsic. The memory object can belong to any address "
"space."
msgstr ""

#: ../../../LangRef.rst:11974
msgid ""
"The '``llvm.invariant.start``' intrinsic specifies that the contents of a "
"memory object will not change."
msgstr ""

#: ../../../LangRef.rst:11987
msgid ""
"This intrinsic indicates that until an ``llvm.invariant.end`` that uses the "
"return value, the referenced memory location is constant and unchanging."
msgstr ""

#: ../../../LangRef.rst:11992
msgid "'``llvm.invariant.end``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12005
msgid ""
"The '``llvm.invariant.end``' intrinsic specifies that the contents of a "
"memory object are mutable."
msgstr ""

#: ../../../LangRef.rst:12011
msgid ""
"The first argument is the matching ``llvm.invariant.start`` intrinsic. The "
"second argument is a constant integer representing the size of the object, "
"or -1 if it is variable sized and the third argument is a pointer to the "
"object."
msgstr ""

#: ../../../LangRef.rst:12019
msgid "This intrinsic indicates that the memory is mutable again."
msgstr ""

#: ../../../LangRef.rst:12022
msgid "'``llvm.invariant.group.barrier``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12034
msgid ""
"The '``llvm.invariant.group.barrier``' intrinsic can be used when an "
"invariant established by invariant.group metadata no longer holds, to obtain "
"a new pointer value that does not carry the invariant information."
msgstr ""

#: ../../../LangRef.rst:12042
msgid ""
"The ``llvm.invariant.group.barrier`` takes only one argument, which is the "
"pointer to the memory for which the ``invariant.group`` no longer holds."
msgstr ""

#: ../../../LangRef.rst:12048
msgid ""
"Returns another pointer that aliases its argument but which is considered "
"different for the purposes of ``load``/``store`` ``invariant.group`` "
"metadata."
msgstr ""

#: ../../../LangRef.rst:12052
msgid "General Intrinsics"
msgstr ""

#: ../../../LangRef.rst:12054
msgid ""
"This class of intrinsics is designed to be generic and has no specific "
"purpose."
msgstr ""

#: ../../../LangRef.rst:12058
msgid "'``llvm.var.annotation``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12070
msgid "The '``llvm.var.annotation``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:12075
msgid ""
"The first argument is a pointer to a value, the second is a pointer to a "
"global string, the third is a pointer to a global string which is the source "
"file name, and the last argument is the line number."
msgstr ""

#: ../../../LangRef.rst:12082
msgid ""
"This intrinsic allows annotation of local variables with arbitrary strings. "
"This can be useful for special purpose optimizations that want to look for "
"these annotations. These have no other defined use; they are ignored by code "
"generation and optimization."
msgstr ""

#: ../../../LangRef.rst:12088
msgid "'``llvm.ptr.annotation.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12093
msgid ""
"This is an overloaded intrinsic. You can use '``llvm.ptr.annotation``' on a "
"pointer to an integer of any width. *NOTE* you must specify an address space "
"for the pointer. The identifier for the default address space is the integer "
"'``0``'."
msgstr ""

#: ../../../LangRef.rst:12109
msgid "The '``llvm.ptr.annotation``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:12114
msgid ""
"The first argument is a pointer to an integer value of arbitrary bitwidth "
"(result of some expression), the second is a pointer to a global string, the "
"third is a pointer to a global string which is the source file name, and the "
"last argument is the line number. It returns the value of the first argument."
msgstr ""

#: ../../../LangRef.rst:12122
msgid ""
"This intrinsic allows annotation of a pointer to an integer with arbitrary "
"strings. This can be useful for special purpose optimizations that want to "
"look for these annotations. These have no other defined use; they are "
"ignored by code generation and optimization."
msgstr ""

#: ../../../LangRef.rst:12128
msgid "'``llvm.annotation.*``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12133
msgid ""
"This is an overloaded intrinsic. You can use '``llvm.annotation``' on any "
"integer bit width."
msgstr ""

#: ../../../LangRef.rst:12147
msgid "The '``llvm.annotation``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:12152
msgid ""
"The first argument is an integer value (result of some expression), the "
"second is a pointer to a global string, the third is a pointer to a global "
"string which is the source file name, and the last argument is the line "
"number. It returns the value of the first argument."
msgstr ""

#: ../../../LangRef.rst:12160
msgid ""
"This intrinsic allows annotations to be put on arbitrary expressions with "
"arbitrary strings. This can be useful for special purpose optimizations that "
"want to look for these annotations. These have no other defined use; they "
"are ignored by code generation and optimization."
msgstr ""

#: ../../../LangRef.rst:12166
msgid "'``llvm.trap``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12178
msgid "The '``llvm.trap``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:12183 ../../../LangRef.rst:12210
#: ../../../LangRef.rst:12277 ../../../LangRef.rst:12503
msgid "None."
msgstr ""

#: ../../../LangRef.rst:12188
msgid ""
"This intrinsic is lowered to the target dependent trap instruction. If the "
"target does not have a trap instruction, this intrinsic will be lowered to a "
"call of the ``abort()`` function."
msgstr ""

#: ../../../LangRef.rst:12193
msgid "'``llvm.debugtrap``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12205
msgid "The '``llvm.debugtrap``' intrinsic."
msgstr ""

#: ../../../LangRef.rst:12215
msgid ""
"This intrinsic is lowered to code which is intended to cause an execution "
"trap with the intention of requesting the attention of a debugger."
msgstr ""

#: ../../../LangRef.rst:12220
msgid "'``llvm.stackprotector``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12232
msgid ""
"The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it onto "
"the stack at ``slot``. The stack slot is adjusted to ensure that it is "
"placed on the stack before local variables."
msgstr ""

#: ../../../LangRef.rst:12239
msgid ""
"The ``llvm.stackprotector`` intrinsic requires two pointer arguments. The "
"first argument is the value loaded from the stack guard "
"``@__stack_chk_guard``. The second variable is an ``alloca`` that has enough "
"space to hold the value of the guard."
msgstr ""

#: ../../../LangRef.rst:12247
msgid ""
"This intrinsic causes the prologue/epilogue inserter to force the position "
"of the ``AllocaInst`` stack slot to be before local variables on the stack. "
"This is to ensure that if a local variable on the stack is overwritten, it "
"will destroy the value of the guard. When the function exits, the guard on "
"the stack is checked against the original guard by ``llvm."
"stackprotectorcheck``. If they are different, then ``llvm."
"stackprotectorcheck`` causes the program to abort by calling the "
"``__stack_chk_fail()`` function."
msgstr ""

#: ../../../LangRef.rst:12256
msgid "'``llvm.stackguard``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12268
msgid "The ``llvm.stackguard`` intrinsic returns the system stack guard value."
msgstr ""

#: ../../../LangRef.rst:12270
msgid ""
"It should not be generated by frontends, since it is only for internal "
"usage. The reason why we create this intrinsic is that we still support IR "
"form Stack Protector in FastISel."
msgstr ""

#: ../../../LangRef.rst:12282
msgid ""
"On some platforms, the value returned by this intrinsic remains unchanged "
"between loads in the same thread. On other platforms, it returns the same "
"global variable value, if any, e.g. ``@__stack_chk_guard``."
msgstr ""

#: ../../../LangRef.rst:12286
msgid ""
"Currently some platforms have IR-level customized stack guard loading (e.g. "
"X86 Linux) that is not handled by ``llvm.stackguard()``, while they should "
"be in the future."
msgstr ""

#: ../../../LangRef.rst:12291
msgid "'``llvm.objectsize``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12304
msgid ""
"The ``llvm.objectsize`` intrinsic is designed to provide information to the "
"optimizers to determine at compile time whether a) an operation (like "
"memcpy) will overflow a buffer that corresponds to an object, or b) that a "
"runtime check for overflow isn't necessary. An object in this context means "
"an allocation of a specific class, structure, array, or other object."
msgstr ""

#: ../../../LangRef.rst:12314
msgid ""
"The ``llvm.objectsize`` intrinsic takes two arguments. The first argument is "
"a pointer to or into the ``object``. The second argument is a boolean and "
"determines whether ``llvm.objectsize`` returns 0 (if true) or -1 (if false) "
"when the object size is unknown. The second argument only accepts constants."
msgstr ""

#: ../../../LangRef.rst:12323
msgid ""
"The ``llvm.objectsize`` intrinsic is lowered to a constant representing the "
"size of the object concerned. If the size cannot be determined at compile "
"time, ``llvm.objectsize`` returns ``i32/i64 -1 or 0`` (depending on the "
"``min`` argument)."
msgstr ""

#: ../../../LangRef.rst:12329
msgid "'``llvm.expect``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12334
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.expect`` on any integer "
"bit width."
msgstr ""

#: ../../../LangRef.rst:12346
msgid ""
"The ``llvm.expect`` intrinsic provides information about expected (the most "
"probable) value of ``val``, which can be used by optimizers."
msgstr ""

#: ../../../LangRef.rst:12352
msgid ""
"The ``llvm.expect`` intrinsic takes two arguments. The first argument is a "
"value. The second argument is an expected value, this needs to be a constant "
"value, variables are not allowed."
msgstr ""

#: ../../../LangRef.rst:12359
msgid "This intrinsic is lowered to the ``val``."
msgstr ""

#: ../../../LangRef.rst:12364
msgid "'``llvm.assume``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12376
msgid ""
"The ``llvm.assume`` allows the optimizer to assume that the provided "
"condition is true. This information can then be used in simplifying other "
"parts of the code."
msgstr ""

#: ../../../LangRef.rst:12383
msgid "The condition which the optimizer may assume is always true."
msgstr ""

#: ../../../LangRef.rst:12388
msgid ""
"The intrinsic allows the optimizer to assume that the provided condition is "
"always true whenever the control flow reaches the intrinsic call. No code is "
"generated for this intrinsic, and instructions that contribute only to the "
"provided condition are not used for code generation. If the condition is "
"violated during execution, the behavior is undefined."
msgstr ""

#: ../../../LangRef.rst:12394
msgid ""
"Note that the optimizer might limit the transformations performed on values "
"used by the ``llvm.assume`` intrinsic in order to preserve the instructions "
"only used to form the intrinsic's input argument. This might prove "
"undesirable if the extra information provided by the ``llvm.assume`` "
"intrinsic does not cause sufficient overall improvement in code quality. For "
"this reason, ``llvm.assume`` should not be used to document basic "
"mathematical invariants that the optimizer can otherwise deduce or facts "
"that are of little use to the optimizer."
msgstr ""

#: ../../../LangRef.rst:12406
msgid "'``llvm.type.test``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12419
msgid ""
"The first argument is a pointer to be tested. The second argument is a "
"metadata object representing a :doc:`type identifier <TypeMetadata>`."
msgstr ""

#: ../../../LangRef.rst:12425
msgid ""
"The ``llvm.type.test`` intrinsic tests whether the given pointer is "
"associated with the given type identifier."
msgstr ""

#: ../../../LangRef.rst:12429
msgid "'``llvm.type.checked.load``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12442
msgid ""
"The first argument is a pointer from which to load a function pointer. The "
"second argument is the byte offset from which to load the function pointer. "
"The third argument is a metadata object representing a :doc:`type identifier "
"<TypeMetadata>`."
msgstr ""

#: ../../../LangRef.rst:12450
msgid ""
"The ``llvm.type.checked.load`` intrinsic safely loads a function pointer "
"from a virtual table pointer using type metadata. This intrinsic is used to "
"implement control flow integrity in conjunction with virtual call "
"optimization. The virtual call optimization pass will optimize away ``llvm."
"type.checked.load`` intrinsics associated with devirtualized calls, thereby "
"removing the type check in cases where it is not needed to enforce the "
"control flow integrity constraint."
msgstr ""

#: ../../../LangRef.rst:12458
msgid ""
"If the given pointer is associated with a type metadata identifier, this "
"function returns true as the second element of its return value. (Note that "
"the function may also return true if the given pointer is not associated "
"with a type metadata identifier.) If the function's return value's second "
"element is true, the following rules apply to the first element:"
msgstr ""

#: ../../../LangRef.rst:12464
msgid ""
"If the given pointer is associated with the given type metadata identifier, "
"it is the function pointer loaded from the given byte offset from the given "
"pointer."
msgstr ""

#: ../../../LangRef.rst:12468
msgid ""
"If the given pointer is not associated with the given type metadata "
"identifier, it is one of the following (the choice of which is unspecified):"
msgstr ""

#: ../../../LangRef.rst:12471
msgid ""
"The function pointer that would have been loaded from an arbitrarily chosen "
"(through an unspecified mechanism) pointer associated with the type metadata."
msgstr ""

#: ../../../LangRef.rst:12475
msgid ""
"If the function has a non-void return type, a pointer to a function that "
"returns an unspecified value without causing side effects."
msgstr ""

#: ../../../LangRef.rst:12478
msgid ""
"If the function's return value's second element is false, the value of the "
"first element is undefined."
msgstr ""

#: ../../../LangRef.rst:12483
msgid "'``llvm.donothing``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12495
msgid ""
"The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one of "
"only three intrinsics (besides ``llvm.experimental.patchpoint`` and ``llvm."
"experimental.gc.statepoint``) that can be called with an invoke instruction."
msgstr ""

#: ../../../LangRef.rst:12508
msgid ""
"This intrinsic does nothing, and it's removed by optimizers and ignored by "
"codegen."
msgstr ""

#: ../../../LangRef.rst:12512
msgid "'``llvm.experimental.deoptimize``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12524
msgid ""
"This intrinsic, together with :ref:`deoptimization operand bundles "
"<deopt_opbundles>`, allow frontends to express transfer of control and frame-"
"local state from the currently executing (typically more specialized, hence "
"faster) version of a function into another (typically more generic, hence "
"slower) version."
msgstr ""

#: ../../../LangRef.rst:12530
msgid ""
"In languages with a fully integrated managed runtime like Java and "
"JavaScript this intrinsic can be used to implement \"uncommon trap\" or "
"\"side exit\" like functionality.  In unmanaged languages like C and C++, "
"this intrinsic can be used to represent the slow paths of specialized "
"functions."
msgstr ""

#: ../../../LangRef.rst:12539
msgid ""
"The intrinsic takes an arbitrary number of arguments, whose meaning is "
"decided by the :ref:`lowering strategy<deoptimize_lowering>`."
msgstr ""

#: ../../../LangRef.rst:12545
msgid ""
"The ``@llvm.experimental.deoptimize`` intrinsic executes an attached "
"deoptimization continuation (denoted using a :ref:`deoptimization operand "
"bundle <deopt_opbundles>`) and returns the value returned by the "
"deoptimization continuation.  Defining the semantic properties of the "
"continuation itself is out of scope of the language reference -- as far as "
"LLVM is concerned, the deoptimization continuation can invoke arbitrary side "
"effects, including reading from and writing to the entire heap."
msgstr ""

#: ../../../LangRef.rst:12554
msgid ""
"Deoptimization continuations expressed using ``\"deopt\"`` operand bundles "
"always continue execution to the end of the physical frame containing them, "
"so all calls to ``@llvm.experimental.deoptimize`` must be in \"tail "
"position\":"
msgstr ""

#: ../../../LangRef.rst:12558
msgid "``@llvm.experimental.deoptimize`` cannot be invoked."
msgstr ""

#: ../../../LangRef.rst:12559
msgid "The call must immediately precede a :ref:`ret <i_ret>` instruction."
msgstr ""

#: ../../../LangRef.rst:12560
msgid ""
"The ``ret`` instruction must return the value produced by the ``@llvm."
"experimental.deoptimize`` call if there is one, or void."
msgstr ""

#: ../../../LangRef.rst:12563
msgid ""
"Note that the above restrictions imply that the return type for a call to "
"``@llvm.experimental.deoptimize`` will match the return type of its "
"immediate caller."
msgstr ""

#: ../../../LangRef.rst:12567
msgid ""
"The inliner composes the ``\"deopt\"`` continuations of the caller into the "
"``\"deopt\"`` continuations present in the inlinee, and also updates calls "
"to this intrinsic to return directly from the frame of the function it "
"inlined into."
msgstr ""

#: ../../../LangRef.rst:12571
msgid ""
"All declarations of ``@llvm.experimental.deoptimize`` must share the same "
"calling convention."
msgstr ""

#: ../../../LangRef.rst:12577 ../../../LangRef.rst:12735
msgid "Lowering:"
msgstr ""

#: ../../../LangRef.rst:12579
msgid ""
"Calls to ``@llvm.experimental.deoptimize`` are lowered to calls to the "
"symbol ``__llvm_deoptimize`` (it is the frontend's responsibility to ensure "
"that this symbol is defined).  The call arguments to ``@llvm.experimental."
"deoptimize`` are lowered as if they were formal arguments of the specified "
"types, and not as varargs."
msgstr ""

#: ../../../LangRef.rst:12587
msgid "'``llvm.experimental.guard``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12599
msgid ""
"This intrinsic, together with :ref:`deoptimization operand bundles "
"<deopt_opbundles>`, allows frontends to express guards or checks on "
"optimistic assumptions made during compilation.  The semantics of ``@llvm."
"experimental.guard`` is defined in terms of ``@llvm.experimental."
"deoptimize`` -- its body is defined to be equivalent to:"
msgstr ""

#: ../../../LangRef.rst:12621
msgid ""
"with the optional ``[, !make.implicit !{}]`` present if and only if it is "
"present on the call site.  For more details on ``!make.implicit``, see :doc:"
"`FaultMaps`."
msgstr ""

#: ../../../LangRef.rst:12625
msgid ""
"In words, ``@llvm.experimental.guard`` executes the attached ``\"deopt\"`` "
"continuation if (but **not** only if) its first argument is ``false``.  "
"Since the optimizer is allowed to replace the ``undef`` with an arbitrary "
"value, it can optimize guard to fail \"spuriously\", i.e. without the "
"original condition being false (hence the \"not only if\"); and this allows "
"for \"check widening\" type optimizations."
msgstr ""

#: ../../../LangRef.rst:12632
msgid "``@llvm.experimental.guard`` cannot be invoked."
msgstr ""

#: ../../../LangRef.rst:12636
msgid "'``llvm.load.relative``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12648
msgid ""
"This intrinsic loads a 32-bit value from the address ``%ptr + %offset``, "
"adds ``%ptr`` to that value and returns it. The constant folder specifically "
"recognizes the form of this intrinsic and the constant initializers it may "
"load from; if a loaded constant initializer is known to have the form ``i32 "
"trunc(x - %ptr)``, the intrinsic call is folded to ``x``."
msgstr ""

#: ../../../LangRef.rst:12654
msgid ""
"LLVM provides that the calculation of such a constant initializer will not "
"overflow at link time under the medium code model if ``x`` is an "
"``unnamed_addr`` function. However, it does not provide this guarantee for a "
"constant initializer folded into a function body. This intrinsic can be used "
"to avoid the possibility of overflows when loading from such a constant."
msgstr ""

#: ../../../LangRef.rst:12661
msgid "Stack Map Intrinsics"
msgstr ""

#: ../../../LangRef.rst:12663
msgid ""
"LLVM provides experimental intrinsics to support runtime patching mechanisms "
"commonly desired in dynamic language JITs. These intrinsics are described "
"in :doc:`StackMaps`."
msgstr ""

#: ../../../LangRef.rst:12668
msgid "Element Wise Atomic Memory Intrinsics"
msgstr ""

#: ../../../LangRef.rst:12670
msgid ""
"These intrinsics are similar to the standard library memory intrinsics "
"except that they perform memory transfer as a sequence of atomic memory "
"accesses."
msgstr ""

#: ../../../LangRef.rst:12676
msgid "'``llvm.memcpy.element.atomic``' Intrinsic"
msgstr ""

#: ../../../LangRef.rst:12681
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memcpy.element.atomic`` "
"on any integer bit width and for different address spaces. Not all targets "
"support all bit widths however."
msgstr ""

#: ../../../LangRef.rst:12693
msgid ""
"The '``llvm.memcpy.element.atomic.*``' intrinsic performs copy of a block of "
"memory from the source location to the destination location as a sequence of "
"unordered atomic memory accesses where each access is a multiple of "
"``element_size`` bytes wide and aligned at an element size boundary. For "
"example each element is accessed atomically in source and destination "
"buffers."
msgstr ""

#: ../../../LangRef.rst:12702
msgid ""
"The first argument is a pointer to the destination, the second is a pointer "
"to the source. The third argument is an integer argument specifying the "
"number of elements to copy, the fourth argument is size of the single "
"element in bytes."
msgstr ""

#: ../../../LangRef.rst:12707
msgid ""
"``element_size`` should be a power of two, greater than zero and less than a "
"target-specific atomic access size limit."
msgstr ""

#: ../../../LangRef.rst:12710
msgid ""
"For each of the input pointers ``align`` parameter attribute must be "
"specified. It must be a power of two and greater than or equal to the "
"``element_size``. Caller guarantees that both the source and destination "
"pointers are aligned to that boundary."
msgstr ""

#: ../../../LangRef.rst:12718
msgid ""
"The '``llvm.memcpy.element.atomic.*``' intrinsic copies '``num_elements`` * "
"``element_size``' bytes of memory from the source location to the "
"destination location. These locations are not allowed to overlap. Memory "
"copy is performed as a sequence of unordered atomic memory accesses where "
"each access is guaranteed to be a multiple of ``element_size`` bytes wide "
"and aligned at an element size boundary."
msgstr ""

#: ../../../LangRef.rst:12725
msgid ""
"The order of the copy is unspecified. The same value may be read from the "
"source buffer many times, but only one write is issued to the destination "
"buffer per element. It is well defined to have concurrent reads and writes "
"to both source and destination provided those reads and writes are at least "
"unordered atomic."
msgstr ""

#: ../../../LangRef.rst:12730
msgid ""
"This intrinsic does not provide any additional ordering guarantees over "
"those provided by a set of unordered loads from the source location and "
"stores to the destination."
msgstr ""

#: ../../../LangRef.rst:12737
msgid ""
"In the most general case call to the '``llvm.memcpy.element.atomic.*``' is "
"lowered to a call to the symbol ``__llvm_memcpy_element_atomic_*``. Where "
"'*' is replaced with an actual element size."
msgstr ""

#: ../../../LangRef.rst:12741
msgid ""
"Optimizer is allowed to inline memory copy when it's profitable to do so."
msgstr ""
