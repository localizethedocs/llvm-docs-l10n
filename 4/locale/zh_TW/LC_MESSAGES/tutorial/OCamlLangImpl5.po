# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/OCamlLangImpl5.rst:3
msgid "Kaleidoscope: Extending the Language: Control Flow"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:9
msgid "Chapter 5 Introduction"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:11
msgid ""
"Welcome to Chapter 5 of the \"`Implementing a language with LLVM <index."
"html>`_\" tutorial. Parts 1-4 described the implementation of the simple "
"Kaleidoscope language and included support for generating LLVM IR, followed "
"by optimizations and a JIT compiler. Unfortunately, as presented, "
"Kaleidoscope is mostly useless: it has no control flow other than call and "
"return. This means that you can't have conditional branches in the code, "
"significantly limiting its power. In this episode of \"build that "
"compiler\", we'll extend Kaleidoscope to have an if/then/else expression "
"plus a simple 'for' loop."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:22
msgid "If/Then/Else"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:24
msgid ""
"Extending Kaleidoscope to support if/then/else is quite straightforward. It "
"basically requires adding lexer support for this \"new\" concept to the "
"lexer, parser, AST, and LLVM code emitter. This example is nice, because it "
"shows how easy it is to \"grow\" a language over time, incrementally "
"extending it as new ideas are discovered."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:30
msgid ""
"Before we get going on \"how\" we add this extension, lets talk about "
"\"what\" we want. The basic idea is that we want to be able to write this "
"sort of thing:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:42
msgid ""
"In Kaleidoscope, every construct is an expression: there are no statements. "
"As such, the if/then/else expression needs to return a value like any other. "
"Since we're using a mostly functional form, we'll have it evaluate its "
"conditional, then return the 'then' or 'else' value based on how the "
"condition was resolved. This is very similar to the C \"?:\" expression."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:49
msgid ""
"The semantics of the if/then/else expression is that it evaluates the "
"condition to a boolean equality value: 0.0 is considered to be false and "
"everything else is considered to be true. If the condition is true, the "
"first subexpression is evaluated and returned, if the condition is false, "
"the second subexpression is evaluated and returned. Since Kaleidoscope "
"allows side-effects, this behavior is important to nail down."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:57
msgid ""
"Now that we know what we \"want\", lets break this down into its constituent "
"pieces."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:61
msgid "Lexer Extensions for If/Then/Else"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:63
msgid ""
"The lexer extensions are straightforward. First we add new variants for the "
"relevant tokens:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:71
msgid ""
"Once we have that, we recognize the new keywords in the lexer. This is "
"pretty simple stuff:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:88
msgid "AST Extensions for If/Then/Else"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:90
msgid "To represent the new expression we add a new AST variant for it:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:99
msgid "The AST variant just has pointers to the various subexpressions."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:102
msgid "Parser Extensions for If/Then/Else"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:104
msgid ""
"Now that we have the relevant tokens coming from the lexer and we have the "
"AST node to build, our parsing logic is relatively straightforward. First we "
"define a new parsing function:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:118
msgid "Next we hook it up as a primary expression:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:131
msgid "LLVM IR for If/Then/Else"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:133
msgid ""
"Now that we have it parsing and building the AST, the final piece is adding "
"LLVM code generation support. This is the most interesting part of the if/"
"then/else example, because this is where it starts to introduce new "
"concepts. All of the code above has been thoroughly described in previous "
"chapters."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:139
msgid ""
"To motivate the code we want to produce, lets take a look at a simple "
"example. Consider:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:148
msgid ""
"If you disable optimizations, the code you'll (soon) get from Kaleidoscope "
"looks like this:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:175
msgid ""
"To visualize the control flow graph, you can use a nifty feature of the LLVM "
"'`opt <http://llvm.org/cmds/opt.html>`_' tool. If you put this LLVM IR into "
"\"t.ll\" and run \"``llvm-as < t.ll | opt -analyze -view-cfg``\", `a window "
"will pop up <../ProgrammersManual.html#viewing-graphs-while-debugging-"
"code>`_ and you'll see this graph:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:185
msgid "Example CFG"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:187
msgid ""
"Another way to get this is to call \"``Llvm_analysis.view_function_cfg f``\" "
"or \"``Llvm_analysis.view_function_cfg_only f``\" (where ``f`` is a "
"\"``Function``\") either by inserting actual calls into the code and "
"recompiling or by calling these in the debugger. LLVM has many nice features "
"for visualizing various graphs."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:194
msgid ""
"Getting back to the generated code, it is fairly simple: the entry block "
"evaluates the conditional expression (\"x\" in our case here) and compares "
"the result to 0.0 with the \"``fcmp one``\" instruction ('one' is \"Ordered "
"and Not Equal\"). Based on the result of this expression, the code jumps to "
"either the \"then\" or \"else\" blocks, which contain the expressions for "
"the true/false cases."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:201
msgid ""
"Once the then/else blocks are finished executing, they both branch back to "
"the 'ifcont' block to execute the code that happens after the if/then/else. "
"In this case the only thing left to do is to return to the caller of the "
"function. The question then becomes: how does the code know which expression "
"to return?"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:207
msgid ""
"The answer to this question involves an important SSA operation: the `Phi "
"operation <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_. If "
"you're not familiar with SSA, `the wikipedia article <http://en.wikipedia."
"org/wiki/Static_single_assignment_form>`_ is a good introduction and there "
"are various other introductions to it available on your favorite search "
"engine. The short version is that \"execution\" of the Phi operation "
"requires \"remembering\" which block control came from. The Phi operation "
"takes on the value corresponding to the input control block. In this case, "
"if control comes in from the \"then\" block, it gets the value of "
"\"calltmp\". If control comes from the \"else\" block, it gets the value of "
"\"calltmp1\"."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:220
msgid ""
"At this point, you are probably starting to think \"Oh no! This means my "
"simple and elegant front-end will have to start generating SSA form in order "
"to use LLVM!\". Fortunately, this is not the case, and we strongly advise "
"*not* implementing an SSA construction algorithm in your front-end unless "
"there is an amazingly good reason to do so. In practice, there are two sorts "
"of values that float around in code written for your average imperative "
"programming language that might need Phi nodes:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:229
msgid "Code that involves user variables: ``x = 1; x = x + 1;``"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:230
msgid ""
"Values that are implicit in the structure of your AST, such as the Phi node "
"in this case."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:233
msgid ""
"In `Chapter 7 <OCamlLangImpl7.html>`_ of this tutorial (\"mutable "
"variables\"), we'll talk about #1 in depth. For now, just believe me that "
"you don't need SSA construction to handle this case. For #2, you have the "
"choice of using the techniques that we will describe for #1, or you can "
"insert Phi nodes directly, if convenient. In this case, it is really really "
"easy to generate the Phi node, so we choose to do it directly."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:240
msgid "Okay, enough of the motivation and overview, lets generate code!"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:243
msgid "Code Generation for If/Then/Else"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:245
msgid ""
"In order to generate code for this, we implement the ``Codegen`` method for "
"``IfExprAST``:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:259
msgid ""
"This code is straightforward and similar to what we saw before. We emit the "
"expression for the condition, then compare that value to zero to get a truth "
"value as a 1-bit (bool) value."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:273
msgid ""
"As opposed to the `C++ tutorial <LangImpl5.html>`_, we have to build our "
"basic blocks bottom up since we can't have dangling BasicBlocks. We start "
"off by saving a pointer to the first block (which might not be the entry "
"block), which we'll need to build a conditional branch later. We do this by "
"asking the ``builder`` for the current BasicBlock. The fourth line gets the "
"current Function object that is being built. It gets this by the "
"``start_bb`` for its \"parent\" (the function it is currently embedded into)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:282
msgid ""
"Once it has that, it creates one block. It is automatically appended into "
"the function's list of blocks."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:296
msgid ""
"We move the builder to start inserting into the \"then\" block. Strictly "
"speaking, this call moves the insertion point to be at the end of the "
"specified block. However, since the \"then\" block is empty, it also starts "
"out by inserting at the beginning of the block. :)"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:301
msgid ""
"Once the insertion point is set, we recursively codegen the \"then\" "
"expression from the AST."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:304
msgid ""
"The final line here is quite subtle, but is very important. The basic issue "
"is that when we create the Phi node in the merge block, we need to set up "
"the block/value pairs that indicate how the Phi will work. Importantly, the "
"Phi node expects to have an entry for each predecessor of the block in the "
"CFG. Why then, are we getting the current block when we just set it to "
"ThenBB 5 lines above? The problem is that the \"Then\" expression may "
"actually itself change the block that the Builder is emitting into if, for "
"example, it contains a nested \"if/then/else\" expression. Because calling "
"Codegen recursively could arbitrarily change the notion of the current "
"block, we are required to get an up-to-date value for code that will set up "
"the Phi node."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:327
msgid ""
"Code generation for the 'else' block is basically identical to codegen for "
"the 'then' block."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:338
msgid ""
"The first two lines here are now familiar: the first adds the \"merge\" "
"block to the Function object. The second changes the insertion point so that "
"newly created code will go into the \"merge\" block. Once that is done, we "
"need to create the PHI node and set up the block/value pairs for the PHI."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:350
msgid ""
"Once the blocks are created, we can emit the conditional branch that chooses "
"between them. Note that creating new blocks does not implicitly affect the "
"IRBuilder, so it is still inserting into the block that the condition went "
"into. This is why we needed to save the \"start\" block."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:367
msgid ""
"To finish off the blocks, we create an unconditional branch to the merge "
"block. One interesting (and very important) aspect of the LLVM IR is that it "
"`requires all basic blocks to be \"terminated\" <../LangRef."
"html#functionstructure>`_ with a `control flow instruction <../LangRef."
"html#terminators>`_ such as return or branch. This means that all control "
"flow, *including fall throughs* must be made explicit in the LLVM IR. If you "
"violate this rule, the verifier will emit an error."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:376
msgid ""
"Finally, the CodeGen function returns the phi node as the value computed by "
"the if/then/else expression. In our example above, this returned value will "
"feed into the code for the top-level function, which will create the return "
"instruction."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:381
msgid ""
"Overall, we now have the ability to execute conditional code in "
"Kaleidoscope. With this extension, Kaleidoscope is a fairly complete "
"language that can calculate a wide variety of numeric functions. Next up "
"we'll add another useful expression that is familiar from non-functional "
"languages..."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:388
msgid "'for' Loop Expression"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:390
msgid ""
"Now that we know how to add basic control flow constructs to the language, "
"we have the tools to add more powerful things. Lets add something more "
"aggressive, a 'for' expression:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:404
msgid ""
"This expression defines a new variable (\"i\" in this case) which iterates "
"from a starting value, while the condition (\"i < n\" in this case) is true, "
"incrementing by an optional step value (\"1.0\" in this case). If the step "
"value is omitted, it defaults to 1.0. While the loop is true, it executes "
"its body expression. Because we don't have anything better to return, we'll "
"just define the loop as always returning 0.0. In the future when we have "
"mutable variables, it will get more useful."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:412
msgid ""
"As before, lets talk about the changes that we need to Kaleidoscope to "
"support this."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:416
msgid "Lexer Extensions for the 'for' Loop"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:418
msgid "The lexer extensions are the same sort of thing as for if/then/else:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:439
msgid "AST Extensions for the 'for' Loop"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:441
msgid ""
"The AST variant is just as simple. It basically boils down to capturing the "
"variable name and the constituent expressions in the node."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:452
msgid "Parser Extensions for the 'for' Loop"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:454
msgid ""
"The parser code is also fairly standard. The only interesting thing here is "
"handling of the optional step value. The parser code handles it by checking "
"to see if the second comma is present. If not, it sets the step value to "
"null in the AST node:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:492
msgid "LLVM IR for the 'for' Loop"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:494
msgid ""
"Now we get to the good part: the LLVM IR we want to generate for this thing. "
"With the simple example above, we get this LLVM IR (note that this dump is "
"generated with optimizations disabled for clarity):"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:525
msgid ""
"This loop contains all the same constructs we saw before: a phi node, "
"several expressions, and some basic blocks. Lets see how this fits together."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:530
msgid "Code Generation for the 'for' Loop"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:532
msgid ""
"The first part of Codegen is very simple: we just output the start "
"expression for the loop value:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:543
msgid ""
"With this out of the way, the next step is to set up the LLVM basic block "
"for the start of the loop body. In the case above, the whole loop body is "
"one block, but remember that the body code itself could consist of multiple "
"blocks (e.g. if it contains an if/then/else or a for/in expression)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:561
msgid ""
"This code is similar to what we saw for if/then/else. Because we will need "
"it to create the Phi node, we remember the block that falls through into the "
"loop. Once we have that, we create the actual block that starts the loop and "
"create an unconditional branch for the fall-through between the two blocks."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:575
msgid ""
"Now that the \"preheader\" for the loop is set up, we switch to emitting "
"code for the loop body. To begin with, we move the insertion point and "
"create the PHI node for the loop induction variable. Since we already know "
"the incoming value for the starting value, we add it to the Phi node. Note "
"that the Phi will eventually get a second value for the backedge, but we "
"can't set it up yet (because it doesn't exist!)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:597
msgid ""
"Now the code starts to get more interesting. Our 'for' loop introduces a new "
"variable to the symbol table. This means that our symbol table can now "
"contain either function arguments or loop variables. To handle this, before "
"we codegen the body of the loop, we add the loop variable as the current "
"value for its name. Note that it is possible that there is a variable of the "
"same name in the outer scope. It would be easy to make this an error (emit "
"an error and return null if there is already an entry for VarName) but we "
"choose to allow shadowing of variables. In order to handle this correctly, "
"we remember the Value that we are potentially shadowing in ``old_val`` "
"(which will be None if there is no shadowed variable)."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:609
msgid ""
"Once the loop variable is set into the symbol table, the code recursively "
"codegen's the body. This allows the body to use the loop variable: any "
"references to it will naturally find it in the symbol table."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:626
msgid ""
"Now that the body is emitted, we compute the next value of the iteration "
"variable by adding the step value, or 1.0 if it isn't present. "
"'``next_var``' will be the value of the loop variable on the next iteration "
"of the loop."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:640
msgid ""
"Finally, we evaluate the exit value of the loop, to determine whether the "
"loop should exit. This mirrors the condition evaluation for the if/then/else "
"statement."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:656
msgid ""
"With the code for the body of the loop complete, we just need to finish up "
"the control flow for it. This code remembers the end block (for the phi "
"node), then creates the block for the loop exit (\"afterloop\"). Based on "
"the value of the exit condition, it creates a conditional branch that "
"chooses between executing the loop again and exiting the loop. Any future "
"code is emitted in the \"afterloop\" block, so it sets the insertion "
"position to it."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:678
msgid ""
"The final code handles various cleanups: now that we have the "
"\"``next_var``\" value, we can add the incoming value to the loop PHI node. "
"After that, we remove the loop variable from the symbol table, so that it "
"isn't in scope after the for loop. Finally, code generation of the for loop "
"always returns 0.0, so that is what we return from ``Codegen.codegen_expr``."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:685
msgid ""
"With this, we conclude the \"adding control flow to Kaleidoscope\" chapter "
"of the tutorial. In this chapter we added two control flow constructs, and "
"used them to motivate a couple of aspects of the LLVM IR that are important "
"for front-end implementors to know. In the next chapter of our saga, we will "
"get a bit crazier and add `user-defined operators <OCamlLangImpl6.html>`_ to "
"our poor innocent language."
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:693
msgid "Full Code Listing"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:695
msgid ""
"Here is the complete code listing for our running example, enhanced with the "
"if/then/else and for expressions.. To build this example, use:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:705
msgid "Here is the code:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:713
msgid "\\_tags:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:727
msgid "myocamlbuild.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:750
msgid "token.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:811
msgid "lexer.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:846
msgid "ast.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:1008
msgid "parser.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:1237
msgid "codegen.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:1290
msgid "toplevel.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:1347
msgid "toy.ml:"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:1358
msgid "bindings.c"
msgstr ""

#: ../../../tutorial/OCamlLangImpl5.rst:1360
msgid ""
"`Next: Extending the language: user-defined operators <OCamlLangImpl6.html>`_"
msgstr ""
