# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../GlobalISel.rst:3
msgid "Global Instruction Selection"
msgstr ""

#: ../../../GlobalISel.rst:10
msgid ""
"This document is a work in progress.  It reflects the current state of the "
"implementation, as well as open design and implementation issues."
msgstr ""

#: ../../../GlobalISel.rst:14
msgid "Introduction"
msgstr ""

#: ../../../GlobalISel.rst:16
msgid ""
"GlobalISel is a framework that provides a set of reusable passes and "
"utilities for instruction selection --- translation from LLVM IR to target-"
"specific Machine IR (MIR)."
msgstr ""

#: ../../../GlobalISel.rst:20
msgid ""
"GlobalISel is intended to be a replacement for SelectionDAG and FastISel, to "
"solve three major problems:"
msgstr ""

#: ../../../GlobalISel.rst:23
msgid ""
"**Performance** --- SelectionDAG introduces a dedicated intermediate "
"representation, which has a compile-time cost."
msgstr ""

#: ../../../GlobalISel.rst:26
msgid ""
"GlobalISel directly operates on the post-isel representation used by the "
"rest of the code generator, MIR. It does require extensions to that "
"representation to support arbitrary incoming IR: :ref:`gmir`."
msgstr ""

#: ../../../GlobalISel.rst:31
msgid ""
"**Granularity** --- SelectionDAG and FastISel operate on individual basic "
"blocks, losing some global optimization opportunities."
msgstr ""

#: ../../../GlobalISel.rst:34
msgid "GlobalISel operates on the whole function."
msgstr ""

#: ../../../GlobalISel.rst:36
msgid ""
"**Modularity** --- SelectionDAG and FastISel are radically different and "
"share very little code."
msgstr ""

#: ../../../GlobalISel.rst:39
msgid ""
"GlobalISel is built in a way that enables code reuse. For instance, both the "
"optimized and fast selectors share the :ref:`pipeline`, and targets can "
"configure that pipeline to better suit their needs."
msgstr ""

#: ../../../GlobalISel.rst:47
msgid "Generic Machine IR"
msgstr ""

#: ../../../GlobalISel.rst:49
msgid ""
"Machine IR operates on physical registers, register classes, and (mostly) "
"target-specific instructions."
msgstr ""

#: ../../../GlobalISel.rst:52
msgid ""
"To bridge the gap with LLVM IR, GlobalISel introduces \"generic\" extensions "
"to Machine IR:"
msgstr ""

#: ../../../GlobalISel.rst:58
msgid ""
"``NOTE``: The generic MIR (GMIR) representation still contains references to "
"IR constructs (such as ``GlobalValue``).  Removing those should let us write "
"more accurate tests, or delete IR after building the initial MIR.  However, "
"it is not part of the GlobalISel effort."
msgstr ""

#: ../../../GlobalISel.rst:67
msgid "Generic Instructions"
msgstr ""

#: ../../../GlobalISel.rst:69
msgid ""
"The main addition is support for pre-isel generic machine instructions (e."
"g., ``G_ADD``).  Like other target-independent instructions (e.g., ``COPY`` "
"or ``PHI``), these are available on all targets."
msgstr ""

#: ../../../GlobalISel.rst:73
msgid ""
"``TODO``: While we're progressively adding instructions, one kind in "
"particular exposes interesting problems: compares and how to represent "
"condition codes. Some targets (x86, ARM) have generic comparisons setting "
"multiple flags, which are then used by predicated variants. Others (IR) "
"specify the predicate in the comparison and users just get a single bit.  "
"SelectionDAG uses SETCC/CONDBR vs BR_CC (and similar for select) to "
"represent this."
msgstr ""

#: ../../../GlobalISel.rst:82
msgid ""
"The ``MachineIRBuilder`` class wraps the ``MachineInstrBuilder`` and "
"provides a convenient way to create these generic instructions."
msgstr ""

#: ../../../GlobalISel.rst:88
msgid "Generic Virtual Registers"
msgstr ""

#: ../../../GlobalISel.rst:90
msgid ""
"Generic instructions operate on a new kind of register: \"generic\" virtual "
"registers.  As opposed to non-generic vregs, they are not assigned a "
"Register Class.  Instead, generic vregs have a :ref:`gmir-llt`, and can be "
"assigned a :ref:`gmir-regbank`."
msgstr ""

#: ../../../GlobalISel.rst:95
msgid ""
"``MachineRegisterInfo`` tracks the same information that it does for non-"
"generic vregs (e.g., use-def chains).  Additionally, it also tracks the :ref:"
"`gmir-llt` of the register, and, instead of the ``TargetRegisterClass``, "
"its :ref:`gmir-regbank`, if any."
msgstr ""

#: ../../../GlobalISel.rst:100
msgid "For simplicity, most generic instructions only accept generic vregs:"
msgstr ""

#: ../../../GlobalISel.rst:102
msgid ""
"instead of immediates, they use a gvreg defined by an instruction "
"materializing the immediate value (see :ref:`irtranslator-constants`)."
msgstr ""

#: ../../../GlobalISel.rst:104
msgid "instead of physical register, they use a gvreg defined by a ``COPY``."
msgstr ""

#: ../../../GlobalISel.rst:106
msgid ""
"``NOTE``: We started with an alternative representation, where MRI tracks a "
"size for each gvreg, and instructions have lists of types. That had two "
"flaws: the type and size are redundant, and there was no generic way of "
"getting a given operand's type (as there was no 1:1 mapping between "
"instruction types and operands). We considered putting the type in some "
"variant of MCInstrDesc instead: See `PR26576 <http://llvm.org/PR26576>`_: "
"[GlobalISel] Generic MachineInstrs need a type but this increases the memory "
"footprint of the related objects"
msgstr ""

#: ../../../GlobalISel.rst:119
msgid "Register Bank"
msgstr ""

#: ../../../GlobalISel.rst:121
msgid ""
"A Register Bank is a set of register classes defined by the target. A bank "
"has a size, which is the maximum store size of all covered classes."
msgstr ""

#: ../../../GlobalISel.rst:124
msgid ""
"In general, cross-class copies inside a bank are expected to be cheaper than "
"copies across banks.  They are also coalesceable by the register coalescer, "
"whereas cross-bank copies are not."
msgstr ""

#: ../../../GlobalISel.rst:128
msgid ""
"Also, equivalent operations can be performed on different banks using "
"different instructions."
msgstr ""

#: ../../../GlobalISel.rst:131
msgid ""
"For example, X86 can be seen as having 3 main banks: general-purpose, x87, "
"and vector (which could be further split into a bank per domain for single "
"vs double precision instructions)."
msgstr ""

#: ../../../GlobalISel.rst:135
msgid ""
"Register banks are described by a target-provided API, :ref:"
"`RegisterBankInfo <api-registerbankinfo>`."
msgstr ""

#: ../../../GlobalISel.rst:141
msgid "Low Level Type"
msgstr ""

#: ../../../GlobalISel.rst:143
msgid ""
"Additionally, every generic virtual register has a type, represented by an "
"instance of the ``LLT`` class."
msgstr ""

#: ../../../GlobalISel.rst:146
msgid ""
"Like ``EVT``/``MVT``/``Type``, it has no distinction between unsigned and "
"signed integer types.  Furthermore, it also has no distinction between "
"integer and floating-point types: it mainly conveys absolutely necessary "
"information, such as size and number of vector lanes:"
msgstr ""

#: ../../../GlobalISel.rst:151
msgid "``sN`` for scalars"
msgstr ""

#: ../../../GlobalISel.rst:152
msgid "``pN`` for pointers"
msgstr ""

#: ../../../GlobalISel.rst:153
msgid "``<N x sM>`` for vectors"
msgstr ""

#: ../../../GlobalISel.rst:154
msgid "``unsized`` for labels, etc.."
msgstr ""

#: ../../../GlobalISel.rst:156
msgid "``LLT`` is intended to replace the usage of ``EVT`` in SelectionDAG."
msgstr ""

#: ../../../GlobalISel.rst:158
msgid "Here are some LLT examples and their ``EVT`` and ``Type`` equivalents:"
msgstr ""

#: ../../../GlobalISel.rst:161
msgid "LLT"
msgstr ""

#: ../../../GlobalISel.rst:161
msgid "EVT"
msgstr ""

#: ../../../GlobalISel.rst:161
msgid "IR Type"
msgstr ""

#: ../../../GlobalISel.rst:163
msgid "``s1``"
msgstr ""

#: ../../../GlobalISel.rst:163
msgid "``i1``"
msgstr ""

#: ../../../GlobalISel.rst:164
msgid "``s8``"
msgstr ""

#: ../../../GlobalISel.rst:164
msgid "``i8``"
msgstr ""

#: ../../../GlobalISel.rst:165 ../../../GlobalISel.rst:166
#: ../../../GlobalISel.rst:169
msgid "``s32``"
msgstr ""

#: ../../../GlobalISel.rst:165
msgid "``i32``"
msgstr ""

#: ../../../GlobalISel.rst:166
msgid "``f32``"
msgstr ""

#: ../../../GlobalISel.rst:166
msgid "``float``"
msgstr ""

#: ../../../GlobalISel.rst:167
msgid "``s17``"
msgstr ""

#: ../../../GlobalISel.rst:167
msgid "``i17``"
msgstr ""

#: ../../../GlobalISel.rst:168
msgid "``s16``"
msgstr ""

#: ../../../GlobalISel.rst:168 ../../../GlobalISel.rst:169
msgid "N/A"
msgstr ""

#: ../../../GlobalISel.rst:168
msgid "``{i8, i8}``"
msgstr ""

#: ../../../GlobalISel.rst:169
msgid "``[4 x i8]``"
msgstr ""

#: ../../../GlobalISel.rst:170
msgid "``p0``"
msgstr ""

#: ../../../GlobalISel.rst:170 ../../../GlobalISel.rst:171
msgid "``iPTR``"
msgstr ""

#: ../../../GlobalISel.rst:170
msgid "``i8*``, ``i32*``, ``%opaque*``"
msgstr ""

#: ../../../GlobalISel.rst:171
msgid "``p2``"
msgstr ""

#: ../../../GlobalISel.rst:171
msgid "``i8 addrspace(2)*``"
msgstr ""

#: ../../../GlobalISel.rst:172
msgid "``<4 x s32>``"
msgstr ""

#: ../../../GlobalISel.rst:172
msgid "``v4f32``"
msgstr ""

#: ../../../GlobalISel.rst:172
msgid "``<4 x float>``"
msgstr ""

#: ../../../GlobalISel.rst:173
msgid "``s64``"
msgstr ""

#: ../../../GlobalISel.rst:173
msgid "``v1f64``"
msgstr ""

#: ../../../GlobalISel.rst:173
msgid "``<1 x double>``"
msgstr ""

#: ../../../GlobalISel.rst:174
msgid "``<3 x s32>``"
msgstr ""

#: ../../../GlobalISel.rst:174
msgid "``v3i32``"
msgstr ""

#: ../../../GlobalISel.rst:174
msgid "``<3 x i32>``"
msgstr ""

#: ../../../GlobalISel.rst:175
msgid "``unsized``"
msgstr ""

#: ../../../GlobalISel.rst:175
msgid "``Other``"
msgstr ""

#: ../../../GlobalISel.rst:175
msgid "``label``"
msgstr ""

#: ../../../GlobalISel.rst:179
msgid ""
"Rationale: instructions already encode a specific interpretation of types (e."
"g., ``add`` vs. ``fadd``, or ``sdiv`` vs. ``udiv``).  Also encoding that "
"information in the type system requires introducing bitcast with no real "
"advantage for the selector."
msgstr ""

#: ../../../GlobalISel.rst:184
msgid ""
"Pointer types are distinguished by address space.  This matches IR, as "
"opposed to SelectionDAG where address space is an attribute on operations. "
"This representation better supports pointers having different sizes "
"depending on their addressspace."
msgstr ""

#: ../../../GlobalISel.rst:189
msgid ""
"``NOTE``: Currently, LLT requires at least 2 elements in vectors, but some "
"targets have the concept of a '1-element vector'.  Representing them as "
"their underlying scalar type is a nice simplification."
msgstr ""

#: ../../../GlobalISel.rst:194
msgid ""
"``TODO``: Currently, non-generic virtual registers, defined by non-pre-isel-"
"generic instructions, cannot have a type, and thus cannot be used by a pre-"
"isel generic instruction.  Instead, they are given a type using a COPY.  We "
"could relax that and allow types on all vregs: this would reduce the number "
"of MI required when emitting target-specific MIR early in the pipeline.  "
"This should purely be a compile-time optimization."
msgstr ""

#: ../../../GlobalISel.rst:205
msgid "Core Pipeline"
msgstr ""

#: ../../../GlobalISel.rst:207
msgid "There are four required passes, regardless of the optimization mode:"
msgstr ""

#: ../../../GlobalISel.rst:212
msgid ""
"Additional passes can then be inserted at higher optimization levels or for "
"specific targets. For example, to match the current SelectionDAG set of "
"transformations: MachineCSE and a better MachineCombiner between every pass."
msgstr ""

#: ../../../GlobalISel.rst:216
msgid ""
"``NOTE``: In theory, not all passes are always necessary. As an additional "
"compile-time optimization, we could skip some of the passes by setting the "
"relevant MachineFunction properties.  For instance, if the IRTranslator did "
"not encounter any illegal instruction, it would set the ``legalized`` "
"property to avoid running the :ref:`milegalizer`. Similarly, we considered "
"specializing the IRTranslator per-target to directly emit target-specific "
"MI. However, we instead decided to keep the core pipeline simple, and focus "
"on minimizing the overhead of the passes in the no-op cases."
msgstr ""

#: ../../../GlobalISel.rst:231
msgid "IRTranslator"
msgstr ""

#: ../../../GlobalISel.rst:233
msgid ""
"This pass translates the input LLVM IR ``Function`` to a GMIR "
"``MachineFunction``."
msgstr ""

#: ../../../GlobalISel.rst:236
msgid ""
"``TODO``: This currently doesn't support the more complex instructions, in "
"particular those involving control flow (``switch``, ``invoke``, ...). For "
"``switch`` in particular, we can initially use the ``LowerSwitch`` pass."
msgstr ""

#: ../../../GlobalISel.rst:244
msgid "API: CallLowering"
msgstr ""

#: ../../../GlobalISel.rst:246
msgid ""
"The ``IRTranslator`` (using the ``CallLowering`` target-provided utility) "
"also implements the ABI's calling convention by lowering calls, returns, and "
"arguments to the appropriate physical register usage and instruction "
"sequences."
msgstr ""

#: ../../../GlobalISel.rst:253
msgid "Aggregates"
msgstr ""

#: ../../../GlobalISel.rst:255
msgid ""
"Aggregates are lowered to a single scalar vreg. This differs from "
"SelectionDAG's multiple vregs via ``GetValueVTs``."
msgstr ""

#: ../../../GlobalISel.rst:258
msgid ""
"``TODO``: As some of the bits are undef (padding), we should consider "
"augmenting the representation with additional metadata (in effect, caching "
"computeKnownBits information on vregs). See `PR26161 <http://llvm.org/"
"PR26161>`_: [GlobalISel] Value to vreg during IR to MachineInstr translation "
"for aggregate type"
msgstr ""

#: ../../../GlobalISel.rst:268
msgid "Constant Lowering"
msgstr ""

#: ../../../GlobalISel.rst:270
msgid ""
"The ``IRTranslator`` lowers ``Constant`` operands into uses of gvregs "
"defined by ``G_CONSTANT`` or ``G_FCONSTANT`` instructions. Currently, these "
"instructions are always emitted in the entry basic block. In a "
"``MachineFunction``, each ``Constant`` is materialized by a single gvreg."
msgstr ""

#: ../../../GlobalISel.rst:275
msgid ""
"This is beneficial as it allows us to fold constants into immediate operands "
"during :ref:`instructionselect`, while still avoiding redundant "
"materializations for expensive non-foldable constants. However, this can "
"lead to unnecessary spills and reloads in an -O0 pipeline, as these vregs "
"can have long live ranges."
msgstr ""

#: ../../../GlobalISel.rst:281
msgid ""
"``TODO``: We're investigating better placement of these instructions, in "
"fast and optimized modes."
msgstr ""

#: ../../../GlobalISel.rst:289
msgid "Legalizer"
msgstr ""

#: ../../../GlobalISel.rst:291
msgid ""
"This pass transforms the generic machine instructions such that they are "
"legal."
msgstr ""

#: ../../../GlobalISel.rst:293
msgid "A legal instruction is defined as:"
msgstr ""

#: ../../../GlobalISel.rst:295
msgid ""
"**selectable** --- the target will later be able to select it to a target-"
"specific (non-generic) instruction."
msgstr ""

#: ../../../GlobalISel.rst:298
msgid ""
"operating on **vregs that can be loaded and stored** -- if necessary, the "
"target can select a ``G_LOAD``/``G_STORE`` of each gvreg operand."
msgstr ""

#: ../../../GlobalISel.rst:301
msgid ""
"As opposed to SelectionDAG, there are no legalization phases.  In "
"particular, 'type' and 'operation' legalization are not separate."
msgstr ""

#: ../../../GlobalISel.rst:304
msgid ""
"Legalization is iterative, and all state is contained in GMIR.  To maintain "
"the validity of the intermediate code, instructions are introduced:"
msgstr ""

#: ../../../GlobalISel.rst:307
msgid ""
"``G_SEQUENCE`` --- concatenate multiple registers into a single wider "
"register."
msgstr ""

#: ../../../GlobalISel.rst:310
msgid ""
"``G_EXTRACT`` --- extract multiple registers (as contiguous sequences of "
"bits) from a single wider register."
msgstr ""

#: ../../../GlobalISel.rst:313
msgid ""
"As they are expected to be temporary byproducts of the legalization process, "
"they are combined at the end of the :ref:`milegalizer` pass. If any remain, "
"they are expected to always be selectable, using loads and stores if "
"necessary."
msgstr ""

#: ../../../GlobalISel.rst:321
msgid "API: LegalizerInfo"
msgstr ""

#: ../../../GlobalISel.rst:323
msgid ""
"Currently the API is broadly similar to SelectionDAG/TargetLowering, but "
"extended in two ways:"
msgstr ""

#: ../../../GlobalISel.rst:326
msgid ""
"The set of available actions is wider, avoiding the currently very "
"overloaded ``Expand`` (which can cover everything from libcalls to "
"scalarization depending on the node's opcode)."
msgstr ""

#: ../../../GlobalISel.rst:330
msgid ""
"Since there's no separate type legalization, independently varying types on "
"an instruction can have independent actions. For example a ``G_ICMP`` has 2 "
"independent types: the result and the inputs; we need to be able to say that "
"comparing 2 s32s is OK, but the s1 result must be dealt with in another way."
msgstr ""

#: ../../../GlobalISel.rst:336
msgid ""
"As such, the primary key when deciding what to do is the ``InstrAspect``, "
"essentially a tuple consisting of ``(Opcode, TypeIdx, Type)`` and mapping to "
"a suggested course of action."
msgstr ""

#: ../../../GlobalISel.rst:340
msgid "An example use might be:"
msgstr ""

#: ../../../GlobalISel.rst:350
msgid ""
"``TODO``: An alternative worth investigating is to generalize the API to "
"represent actions using ``std::function`` that implements the action, "
"instead of explicit enum tokens (``Legal``, ``WidenScalar``, ...)."
msgstr ""

#: ../../../GlobalISel.rst:355
msgid ""
"``TODO``: Moreover, we could use TableGen to initially infer legality of "
"operation from existing patterns (as any pattern we can select is by "
"definition legal). Expanding that to describe legalization actions is a much "
"larger but potentially useful project."
msgstr ""

#: ../../../GlobalISel.rst:364
msgid "Non-power of 2 types"
msgstr ""

#: ../../../GlobalISel.rst:366
msgid ""
"``TODO``: Types which have a size that isn't a power of 2 aren't currently "
"supported. The setAction API will probably require changes to support them. "
"Even notionally explicitly specified operations only make suggestions like "
"\"Widen\" or \"Narrow\". The eventual type is still unspecified and a search "
"is performed by repeated doubling/halving of the type's size. This is "
"incorrect for types that aren't a power of 2.  It's reasonable to expect we "
"could construct an efficient set of side-tables for more general lookups "
"though, encoding a map from the integers (i.e. the size of the current type) "
"to types (the legal size)."
msgstr ""

#: ../../../GlobalISel.rst:381
msgid "Vector types"
msgstr ""

#: ../../../GlobalISel.rst:383
msgid ""
"Vectors first get their element type legalized: ``<A x sB>`` becomes ``<A x "
"sC>`` such that at least one operation is legal with ``sC``."
msgstr ""

#: ../../../GlobalISel.rst:386
msgid ""
"This is currently specified by the function ``setScalarInVectorAction``, "
"called for example as:"
msgstr ""

#: ../../../GlobalISel.rst:389
msgid "setScalarInVectorAction(G_ICMP, s1, WidenScalar);"
msgstr ""

#: ../../../GlobalISel.rst:391
msgid ""
"Next the number of elements is chosen so that the entire operation is legal. "
"This aspect is not controllable at the moment, but probably should be (you "
"could imagine disagreements on whether a ``<2 x s8>`` operation should be "
"scalarized or extended to ``<8 x s8>``)."
msgstr ""

#: ../../../GlobalISel.rst:400
msgid "RegBankSelect"
msgstr ""

#: ../../../GlobalISel.rst:402
msgid ""
"This pass constrains the :ref:`gmir-gvregs` operands of generic instructions "
"to some :ref:`gmir-regbank`."
msgstr ""

#: ../../../GlobalISel.rst:405
msgid ""
"It iteratively maps instructions to a set of per-operand bank assignment. "
"The possible mappings are determined by the target-provided :ref:"
"`RegisterBankInfo <api-registerbankinfo>`. The mapping is then applied, "
"possibly introducing ``COPY`` instructions if necessary."
msgstr ""

#: ../../../GlobalISel.rst:411
msgid ""
"It traverses the ``MachineFunction`` top down so that all operands are "
"already mapped when analyzing an instruction."
msgstr ""

#: ../../../GlobalISel.rst:414
msgid ""
"This pass could also remap target-specific instructions when beneficial. In "
"the future, this could replace the ExeDepsFix pass, as we can directly "
"select the best variant for an instruction that's available on multiple "
"banks."
msgstr ""

#: ../../../GlobalISel.rst:421
msgid "API: RegisterBankInfo"
msgstr ""

#: ../../../GlobalISel.rst:423
msgid ""
"The ``RegisterBankInfo`` class describes multiple aspects of register banks."
msgstr ""

#: ../../../GlobalISel.rst:425
msgid ""
"**Banks**: ``addRegBankCoverage`` --- which register bank covers each "
"register class."
msgstr ""

#: ../../../GlobalISel.rst:428
msgid ""
"**Cross-Bank Copies**: ``copyCost`` --- the cost of a ``COPY`` from one bank "
"to another."
msgstr ""

#: ../../../GlobalISel.rst:431
msgid ""
"**Default Mapping**: ``getInstrMapping`` --- the default bank assignments "
"for a given instruction."
msgstr ""

#: ../../../GlobalISel.rst:434
msgid ""
"**Alternative Mapping**: ``getInstrAlternativeMapping`` --- the other "
"possible bank assignments for a given instruction."
msgstr ""

#: ../../../GlobalISel.rst:437
msgid ""
"``TODO``: All this information should eventually be static and generated by "
"TableGen, mostly using existing information augmented by bank descriptions."
msgstr ""

#: ../../../GlobalISel.rst:441
msgid ""
"``TODO``: ``getInstrMapping`` is currently separate from "
"``getInstrAlternativeMapping`` because the latter is more expensive: as we "
"move to static mapping info, both methods should be free, and we should "
"merge them."
msgstr ""

#: ../../../GlobalISel.rst:449
msgid "RegBankSelect Modes"
msgstr ""

#: ../../../GlobalISel.rst:451
msgid "``RegBankSelect`` currently has two modes:"
msgstr ""

#: ../../../GlobalISel.rst:453
msgid ""
"**Fast** --- For each instruction, pick a target-provided \"default\" bank "
"assignment.  This is the default at -O0."
msgstr ""

#: ../../../GlobalISel.rst:456
msgid ""
"**Greedy** --- For each instruction, pick the cheapest of several target-"
"provided bank assignment alternatives."
msgstr ""

#: ../../../GlobalISel.rst:459
msgid "We intend to eventually introduce an additional optimizing mode:"
msgstr ""

#: ../../../GlobalISel.rst:461
msgid ""
"**Global** --- Across multiple instructions, pick the cheapest combination "
"of bank assignments."
msgstr ""

#: ../../../GlobalISel.rst:464
msgid ""
"``NOTE``: On AArch64, we are considering using the Greedy mode even at -O0 "
"(or perhaps at backend -O1):  because :ref:`gmir-llt` doesn't distinguish "
"floating point from integer scalars, the default assignment for loads and "
"stores is the integer bank, introducing cross-bank copies on most floating "
"point operations."
msgstr ""

#: ../../../GlobalISel.rst:474
msgid "InstructionSelect"
msgstr ""

#: ../../../GlobalISel.rst:476
msgid ""
"This pass transforms generic machine instructions into equivalent target-"
"specific instructions.  It traverses the ``MachineFunction`` bottom-up, "
"selecting uses before definitions, enabling trivial dead code elimination."
msgstr ""

#: ../../../GlobalISel.rst:483
msgid "API: InstructionSelector"
msgstr ""

#: ../../../GlobalISel.rst:485
msgid ""
"The target implements the ``InstructionSelector`` class, containing the "
"target-specific selection logic proper."
msgstr ""

#: ../../../GlobalISel.rst:488
msgid ""
"The instance is provided by the subtarget, so that it can specialize the "
"selector by subtarget feature (with, e.g., a vector selector overriding "
"parts of a general-purpose common selector). We might also want to "
"parameterize it by MachineFunction, to enable selector variants based on "
"function attributes like optsize."
msgstr ""

#: ../../../GlobalISel.rst:494
msgid "The simple API consists of:"
msgstr ""

#: ../../../GlobalISel.rst:500
msgid ""
"This target-provided method is responsible for mutating (or replacing) a "
"possibly-generic MI into a fully target-specific equivalent. It is also "
"responsible for doing the necessary constraining of gvregs into the "
"appropriate register classes."
msgstr ""

#: ../../../GlobalISel.rst:505
msgid ""
"The ``InstructionSelector`` can fold other instructions into the selected "
"MI, by walking the use-def chain of the vreg operands. As GlobalISel is "
"Global, this folding can occur across basic blocks."
msgstr ""

#: ../../../GlobalISel.rst:509
msgid ""
"``TODO``: Currently, the Select pass is implemented with hand-written c++, "
"similar to FastISel, rather than backed by tblgen'erated pattern-matching. "
"We intend to eventually reuse SelectionDAG patterns."
msgstr ""

#: ../../../GlobalISel.rst:518
msgid "Maintainability"
msgstr ""

#: ../../../GlobalISel.rst:523
msgid "Iterative Transformations"
msgstr ""

#: ../../../GlobalISel.rst:525
msgid ""
"Passes are split into small, iterative transformations, with all state "
"represented in the MIR."
msgstr ""

#: ../../../GlobalISel.rst:528
msgid ""
"This differs from SelectionDAG (in particular, the legalizer) using various "
"in-memory side-tables."
msgstr ""

#: ../../../GlobalISel.rst:535
msgid "MIR Serialization"
msgstr ""

#: ../../../GlobalISel.rst:539
msgid ""
":ref:`gmir` is serializable (see :doc:`MIRLangRef`). Combined with :ref:"
"`maintainability-iterative`, this enables much finer-grained testing, rather "
"than requiring large and fragile IR-to-assembly tests."
msgstr ""

#: ../../../GlobalISel.rst:543
msgid ""
"The current \"stage\" in the :ref:`pipeline` is represented by a set of "
"``MachineFunctionProperties``:"
msgstr ""

#: ../../../GlobalISel.rst:546
msgid "``legalized``"
msgstr ""

#: ../../../GlobalISel.rst:547
msgid "``regBankSelected``"
msgstr ""

#: ../../../GlobalISel.rst:548
msgid "``selected``"
msgstr ""

#: ../../../GlobalISel.rst:554
msgid "MachineVerifier"
msgstr ""

#: ../../../GlobalISel.rst:556
msgid ""
"The pass approach lets us use the ``MachineVerifier`` to enforce invariants. "
"For instance, a ``regBankSelected`` function may not have gvregs without a "
"bank."
msgstr ""

#: ../../../GlobalISel.rst:560
msgid ""
"``TODO``: The ``MachineVerifier`` being monolithic, some of the checks we "
"want to do can't be integrated to it:  GlobalISel is a separate library, so "
"we can't directly reference it from CodeGen.  For instance, legality checks "
"are currently done in RegBankSelect/InstructionSelect proper.  We could "
"#ifdef out the checks, or we could add some sort of verifier API."
msgstr ""

#: ../../../GlobalISel.rst:571
msgid "Progress and Future Work"
msgstr ""

#: ../../../GlobalISel.rst:573
msgid ""
"The initial goal is to replace FastISel on AArch64.  The next step will be "
"to replace SelectionDAG as the optimized ISel."
msgstr ""

#: ../../../GlobalISel.rst:576
msgid ""
"``NOTE``: While we iterate on GlobalISel, we strive to avoid affecting the "
"performance of SelectionDAG, FastISel, or the other MIR passes.  For "
"instance, the types of :ref:`gmir-gvregs` are stored in a separate table in "
"``MachineRegisterInfo``, that is destroyed after :ref:`instructionselect`."
msgstr ""

#: ../../../GlobalISel.rst:585
msgid "FastISel Replacement"
msgstr ""

#: ../../../GlobalISel.rst:587
msgid ""
"For the initial FastISel replacement, we intend to fallback to SelectionDAG "
"on selection failures."
msgstr ""

#: ../../../GlobalISel.rst:590
msgid ""
"Currently, compile-time of the fast pipeline is within 1.5x of FastISel. "
"We're optimistic we can get to within 1.1/1.2x, but beating FastISel will be "
"challenging given the multi-pass approach. Still, supporting all IR (via a "
"complete legalizer) and avoiding the fallback to SelectionDAG in the worst "
"case should enable better amortized performance than SelectionDAG+FastISel."
msgstr ""

#: ../../../GlobalISel.rst:597
msgid ""
"``NOTE``: We considered never having a fallback to SelectionDAG, instead "
"deciding early whether a given function is supported by GlobalISel or not.  "
"The decision would be based on :ref:`milegalizer` queries. We abandoned that "
"for two reasons: a) on IR inputs, we'd need to basically simulate the :ref:"
"`irtranslator`; b) to be robust against unforeseen failures and to enable "
"iterative improvements."
msgstr ""

#: ../../../GlobalISel.rst:609
msgid "Support For Other Targets"
msgstr ""

#: ../../../GlobalISel.rst:611
msgid ""
"In parallel, we're investigating adding support for other - ideally quite "
"different - targets.  For instance, there is some initial AMDGPU support."
msgstr ""

#: ../../../GlobalISel.rst:618
msgid "Porting GlobalISel to A New Target"
msgstr ""

#: ../../../GlobalISel.rst:620
msgid "There are four major classes to implement by the target:"
msgstr ""

#: ../../../GlobalISel.rst:622
msgid ""
":ref:`CallLowering <api-calllowering>` --- lower calls, returns, and "
"arguments according to the ABI."
msgstr ""

#: ../../../GlobalISel.rst:624
msgid ""
":ref:`RegisterBankInfo <api-registerbankinfo>` --- describe :ref:`gmir-"
"regbank` coverage, cross-bank copy cost, and the mapping of operands onto "
"banks for each instruction."
msgstr ""

#: ../../../GlobalISel.rst:627
msgid ""
":ref:`LegalizerInfo <api-legalizerinfo>` --- describe what is legal, and how "
"to legalize what isn't."
msgstr ""

#: ../../../GlobalISel.rst:629
msgid ""
":ref:`InstructionSelector <api-instructionselector>` --- select generic MIR "
"to target-specific MIR."
msgstr ""

#: ../../../GlobalISel.rst:632
msgid "Additionally:"
msgstr ""

#: ../../../GlobalISel.rst:634
msgid ""
"``TargetPassConfig`` --- create the passes constituting the pipeline, "
"including additional passes not included in the :ref:`pipeline`."
msgstr ""

#: ../../../GlobalISel.rst:636
msgid ""
"``GISelAccessor`` --- setup the various subtarget-provided classes, with a "
"graceful fallback to no-op when GlobalISel isn't enabled."
msgstr ""
