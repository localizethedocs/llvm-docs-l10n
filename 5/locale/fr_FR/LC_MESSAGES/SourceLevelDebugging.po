# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../SourceLevelDebugging.rst:3
msgid "Source Level Debugging with LLVM"
msgstr ""

#: ../../../SourceLevelDebugging.rst:9 ../../../SourceLevelDebugging.rst:503
#: ../../../SourceLevelDebugging.rst:716
msgid "Introduction"
msgstr ""

#: ../../../SourceLevelDebugging.rst:11
msgid ""
"This document is the central repository for all information pertaining to "
"debug information in LLVM.  It describes the :ref:`actual format that the "
"LLVM debug information takes <format>`, which is useful for those interested "
"in creating front-ends or dealing directly with the information.  Further, "
"this document provides specific examples of what debug information for C/C++ "
"looks like."
msgstr ""

#: ../../../SourceLevelDebugging.rst:18
msgid "Philosophy behind LLVM debugging information"
msgstr ""

#: ../../../SourceLevelDebugging.rst:20
msgid ""
"The idea of the LLVM debugging information is to capture how the important "
"pieces of the source-language's Abstract Syntax Tree map onto LLVM code. "
"Several design aspects have shaped the solution that appears here.  The "
"important ones are:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:25
msgid ""
"Debugging information should have very little impact on the rest of the "
"compiler.  No transformations, analyses, or code generators should need to "
"be modified because of debugging information."
msgstr ""

#: ../../../SourceLevelDebugging.rst:29
msgid ""
"LLVM optimizations should interact in :ref:`well-defined and easily "
"described ways <intro_debugopt>` with the debugging information."
msgstr ""

#: ../../../SourceLevelDebugging.rst:32
msgid ""
"Because LLVM is designed to support arbitrary programming languages, LLVM-to-"
"LLVM tools should not need to know anything about the semantics of the "
"source-level-language."
msgstr ""

#: ../../../SourceLevelDebugging.rst:36
msgid ""
"Source-level languages are often **widely** different from one another. LLVM "
"should not put any restrictions of the flavor of the source-language, and "
"the debugging information should work with any language."
msgstr ""

#: ../../../SourceLevelDebugging.rst:40
msgid ""
"With code generator support, it should be possible to use an LLVM compiler "
"to compile a program to native machine code and standard debugging formats.  "
"This allows compatibility with traditional machine-code level debuggers, "
"like GDB or DBX."
msgstr ""

#: ../../../SourceLevelDebugging.rst:45
msgid ""
"The approach used by the LLVM implementation is to use a small set of :ref:"
"`intrinsic functions <format_common_intrinsics>` to define a mapping between "
"LLVM program objects and the source-level objects.  The description of the "
"source-level program is maintained in LLVM metadata in an :ref:"
"`implementation-defined format <ccxx_frontend>` (the C/C++ front-end "
"currently uses working draft 7 of the `DWARF 3 standard <http://www.eagercon."
"com/dwarf/dwarf3std.htm>`_)."
msgstr ""

#: ../../../SourceLevelDebugging.rst:53
msgid ""
"When a program is being debugged, a debugger interacts with the user and "
"turns the stored debug information into source-language specific "
"information.  As such, a debugger must be aware of the source-language, and "
"is thus tied to a specific language or family of languages."
msgstr ""

#: ../../../SourceLevelDebugging.rst:59
msgid "Debug information consumers"
msgstr ""

#: ../../../SourceLevelDebugging.rst:61
msgid ""
"The role of debug information is to provide meta information normally "
"stripped away during the compilation process.  This meta information "
"provides an LLVM user a relationship between generated code and the original "
"program source code."
msgstr ""

#: ../../../SourceLevelDebugging.rst:66
msgid ""
"Currently, there are two backend consumers of debug info: DwarfDebug and "
"CodeViewDebug. DwarfDebug produces DWARF suitable for use with GDB, LLDB, "
"and other DWARF-based debuggers. :ref:`CodeViewDebug <codeview>` produces "
"CodeView, the Microsoft debug info format, which is usable with Microsoft "
"debuggers such as Visual Studio and WinDBG. LLVM's debug information format "
"is mostly derived from and inspired by DWARF, but it is feasible to "
"translate into other target debug info formats such as STABS."
msgstr ""

#: ../../../SourceLevelDebugging.rst:74
msgid ""
"It would also be reasonable to use debug information to feed profiling tools "
"for analysis of generated code, or, tools for reconstructing the original "
"source from generated code."
msgstr ""

#: ../../../SourceLevelDebugging.rst:81
msgid "Debugging optimized code"
msgstr ""

#: ../../../SourceLevelDebugging.rst:83
msgid ""
"An extremely high priority of LLVM debugging information is to make it "
"interact well with optimizations and analysis.  In particular, the LLVM "
"debug information provides the following guarantees:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:87
msgid ""
"LLVM debug information **always provides information to accurately read the "
"source-level state of the program**, regardless of which LLVM optimizations "
"have been run, and without any modification to the optimizations "
"themselves.  However, some optimizations may impact the ability to modify "
"the current state of the program with a debugger, such as setting program "
"variables, or calling functions that have been deleted."
msgstr ""

#: ../../../SourceLevelDebugging.rst:95
msgid ""
"As desired, LLVM optimizations can be upgraded to be aware of debugging "
"information, allowing them to update the debugging information as they "
"perform aggressive optimizations.  This means that, with effort, the LLVM "
"optimizers could optimize debug code just as well as non-debug code."
msgstr ""

#: ../../../SourceLevelDebugging.rst:100
msgid ""
"LLVM debug information does not prevent optimizations from happening (for "
"example inlining, basic block reordering/merging/cleanup, tail duplication, "
"etc)."
msgstr ""

#: ../../../SourceLevelDebugging.rst:104
msgid ""
"LLVM debug information is automatically optimized along with the rest of the "
"program, using existing facilities.  For example, duplicate information is "
"automatically merged by the linker, and unused information is automatically "
"removed."
msgstr ""

#: ../../../SourceLevelDebugging.rst:109
msgid ""
"Basically, the debug information allows you to compile a program with \"``-"
"O0 -g``\" and get full debug information, allowing you to arbitrarily modify "
"the program as it executes from a debugger.  Compiling a program with \"``-"
"O3 -g``\" gives you full debug information that is always available and "
"accurate for reading (e.g., you get accurate stack traces despite tail call "
"elimination and inlining), but you might lose the ability to modify the "
"program and call functions which were optimized out of the program, or "
"inlined away completely."
msgstr ""

#: ../../../SourceLevelDebugging.rst:118
msgid ""
"The :ref:`LLVM test suite <test-suite-quickstart>` provides a framework to "
"test optimizer's handling of debugging information.  It can be run like this:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:126
msgid ""
"This will test impact of debugging information on optimization passes.  If "
"debugging information influences optimization passes then it will be "
"reported as a failure.  See :doc:`TestingGuide` for more information on LLVM "
"test infrastructure and how to run various tests."
msgstr ""

#: ../../../SourceLevelDebugging.rst:134 ../../../SourceLevelDebugging.rst:497
msgid "Debugging information format"
msgstr ""

#: ../../../SourceLevelDebugging.rst:136
msgid ""
"LLVM debugging information has been carefully designed to make it possible "
"for the optimizer to optimize the program and debugging information without "
"necessarily having to know anything about debugging information.  In "
"particular, the use of metadata avoids duplicated debugging information from "
"the beginning, and the global dead code elimination pass automatically "
"deletes debugging information for a function if it decides to delete the "
"function."
msgstr ""

#: ../../../SourceLevelDebugging.rst:143
msgid ""
"To do this, most of the debugging information (descriptors for types, "
"variables, functions, source files, etc) is inserted by the language front-"
"end in the form of LLVM metadata."
msgstr ""

#: ../../../SourceLevelDebugging.rst:147
msgid ""
"Debug information is designed to be agnostic about the target debugger and "
"debugging information representation (e.g. DWARF/Stabs/etc).  It uses a "
"generic pass to decode the information that represents variables, types, "
"functions, namespaces, etc: this allows for arbitrary source-language "
"semantics and type-systems to be used, as long as there is a module written "
"for the target debugger to interpret the information."
msgstr ""

#: ../../../SourceLevelDebugging.rst:154
msgid ""
"To provide basic functionality, the LLVM debugger does have to make some "
"assumptions about the source-level language being debugged, though it keeps "
"these to a minimum.  The only common features that the LLVM debugger assumes "
"exist are `source files <LangRef.html#difile>`_, and `program objects "
"<LangRef.html#diglobalvariable>`_.  These abstract objects are used by a "
"debugger to form stack traces, show information about local variables, etc."
msgstr ""

#: ../../../SourceLevelDebugging.rst:161
msgid ""
"This section of the documentation first describes the representation aspects "
"common to any source-language.  :ref:`ccxx_frontend` describes the data "
"layout conventions used by the C and C++ front-ends."
msgstr ""

#: ../../../SourceLevelDebugging.rst:165
msgid ""
"Debug information descriptors are `specialized metadata nodes <LangRef."
"html#specialized-metadata>`_, first-class subclasses of ``Metadata``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:171
msgid "Debugger intrinsic functions"
msgstr ""

#: ../../../SourceLevelDebugging.rst:173
msgid ""
"LLVM uses several intrinsic functions (name prefixed with \"``llvm.dbg``\") "
"to provide debug information at various points in generated code."
msgstr ""

#: ../../../SourceLevelDebugging.rst:177
msgid "``llvm.dbg.declare``"
msgstr ""

#: ../../../SourceLevelDebugging.rst:183
msgid ""
"This intrinsic provides information about a local element (e.g., variable).  "
"The first argument is metadata holding the alloca for the variable.  The "
"second argument is a `local variable <LangRef.html#dilocalvariable>`_ "
"containing a description of the variable.  The third argument is a `complex "
"expression <LangRef.html#diexpression>`_.  An `llvm.dbg.declare` instrinsic "
"describes the *location* of a source variable."
msgstr ""

#: ../../../SourceLevelDebugging.rst:206
msgid "``llvm.dbg.value``"
msgstr ""

#: ../../../SourceLevelDebugging.rst:212
msgid ""
"This intrinsic provides information when a user source variable is set to a "
"new value.  The first argument is the new value (wrapped as metadata).  The "
"second argument is the offset in the user source variable where the new "
"value is written.  The third argument is a `local variable <LangRef."
"html#dilocalvariable>`_ containing a description of the variable.  The "
"fourth argument is a `complex expression <LangRef.html#diexpression>`_."
msgstr ""

#: ../../../SourceLevelDebugging.rst:220
msgid "Object lifetimes and scoping"
msgstr ""

#: ../../../SourceLevelDebugging.rst:222
msgid ""
"In many languages, the local variables in functions can have their lifetimes "
"or scopes limited to a subset of a function.  In the C family of languages, "
"for example, variables are only live (readable and writable) within the "
"source block that they are defined in.  In functional languages, values are "
"only readable after they have been defined.  Though this is a very obvious "
"concept, it is non-trivial to model in LLVM, because it has no notion of "
"scoping in this sense, and does not want to be tied to a language's scoping "
"rules."
msgstr ""

#: ../../../SourceLevelDebugging.rst:230
msgid ""
"In order to handle this, the LLVM debug format uses the metadata attached to "
"llvm instructions to encode line number and scoping information.  Consider "
"the following C fragment, for example:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:246
msgid "Compiled to LLVM, this function would be represented like this:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:306
msgid ""
"This example illustrates a few important details about LLVM debugging "
"information.  In particular, it shows how the ``llvm.dbg.declare`` intrinsic "
"and location information, which are attached to an instruction, are applied "
"together to allow a debugger to analyze the relationship between statements, "
"variable definitions, and the code used to implement the function."
msgstr ""

#: ../../../SourceLevelDebugging.rst:317
msgid ""
"The first intrinsic ``%llvm.dbg.declare`` encodes debugging information for "
"the variable ``X``.  The metadata ``!dbg !14`` attached to the intrinsic "
"provides scope information for the variable ``X``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:328
msgid ""
"Here ``!14`` is metadata providing `location information <LangRef."
"html#dilocation>`_.  In this example, scope is encoded by ``!4``, a "
"`subprogram descriptor <LangRef.html#disubprogram>`_.  This way the location "
"information attached to the intrinsics indicates that the variable ``X`` is "
"declared at line number 2 at a function level scope in function ``foo``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:334
msgid "Now lets take another example."
msgstr ""

#: ../../../SourceLevelDebugging.rst:341
msgid ""
"The third intrinsic ``%llvm.dbg.declare`` encodes debugging information for "
"variable ``Z``.  The metadata ``!dbg !19`` attached to the intrinsic "
"provides scope information for the variable ``Z``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:350
msgid ""
"Here ``!19`` indicates that ``Z`` is declared at line number 5 and column "
"number 0 inside of lexical scope ``!18``.  The lexical scope itself resides "
"inside of subprogram ``!4`` described above."
msgstr ""

#: ../../../SourceLevelDebugging.rst:354
msgid ""
"The scope information attached with each instruction provides a "
"straightforward way to find instructions covered by a scope."
msgstr ""

#: ../../../SourceLevelDebugging.rst:360
msgid "C/C++ front-end specific debug information"
msgstr ""

#: ../../../SourceLevelDebugging.rst:362
msgid ""
"The C and C++ front-ends represent information about the program in a format "
"that is effectively identical to `DWARF 3.0 <http://www.eagercon.com/dwarf/"
"dwarf3std.htm>`_ in terms of information content.  This allows code "
"generators to trivially support native debuggers by generating standard "
"dwarf information, and contains enough information for non-dwarf targets to "
"translate it as needed."
msgstr ""

#: ../../../SourceLevelDebugging.rst:369
msgid ""
"This section describes the forms used to represent C and C++ programs.  "
"Other languages could pattern themselves after this (which itself is tuned "
"to representing programs in the same way that DWARF 3 does), or they could "
"choose to provide completely different forms if they don't fit into the "
"DWARF model. As support for debugging information gets added to the various "
"LLVM source-language front-ends, the information used should be documented "
"here."
msgstr ""

#: ../../../SourceLevelDebugging.rst:376
msgid ""
"The following sections provide examples of a few C/C++ constructs and the "
"debug information that would best describe those constructs.  The canonical "
"references are the ``DIDescriptor`` classes defined in ``include/llvm/IR/"
"DebugInfo.h`` and the implementations of the helper functions in ``lib/IR/"
"DIBuilder.cpp``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:383
msgid "C/C++ source file information"
msgstr ""

#: ../../../SourceLevelDebugging.rst:385
msgid ""
"``llvm::Instruction`` provides easy access to metadata attached with an "
"instruction.  One can extract line number information encoded in LLVM IR "
"using ``Instruction::getDebugLoc()`` and ``DILocation::getLine()``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:398
msgid "C/C++ global variable information"
msgstr ""

#: ../../../SourceLevelDebugging.rst:400
msgid "Given an integer global variable declared as follows:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:406 ../../../SourceLevelDebugging.rst:477
msgid "a C/C++ front-end would generate the following descriptors:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:460
msgid ""
"The align value in DIGlobalVariable description specifies variable alignment "
"in case it was forced by C11 _Alignas(), C++11 alignas() keywords or "
"compiler attribute __attribute__((aligned ())). In other case (when this "
"field is missing) alignment is considered default. This is used when "
"producing DWARF output for DW_AT_alignment value."
msgstr ""

#: ../../../SourceLevelDebugging.rst:467
msgid "C/C++ function information"
msgstr ""

#: ../../../SourceLevelDebugging.rst:469
msgid "Given a function declared as follows:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:500
msgid "Debugging Information Extension for Objective C Properties"
msgstr ""

#: ../../../SourceLevelDebugging.rst:505
msgid ""
"Objective C provides a simpler way to declare and define accessor methods "
"using declared properties.  The language provides features to declare a "
"property and to let compiler synthesize accessor methods."
msgstr ""

#: ../../../SourceLevelDebugging.rst:509
msgid ""
"The debugger lets developer inspect Objective C interfaces and their "
"instance variables and class variables.  However, the debugger does not know "
"anything about the properties defined in Objective C interfaces.  The "
"debugger consumes information generated by compiler in DWARF format.  The "
"format does not support encoding of Objective C properties.  This proposal "
"describes DWARF extensions to encode Objective C properties, which the "
"debugger can use to let developers inspect Objective C properties."
msgstr ""

#: ../../../SourceLevelDebugging.rst:518
msgid "Proposal"
msgstr ""

#: ../../../SourceLevelDebugging.rst:520
msgid ""
"Objective C properties exist separately from class members.  A property can "
"be defined only by \"setter\" and \"getter\" selectors, and be calculated "
"anew on each access.  Or a property can just be a direct access to some "
"declared ivar. Finally it can have an ivar \"automatically synthesized\" for "
"it by the compiler, in which case the property can be referred to in user "
"code directly using the standard C dereference syntax as well as through the "
"property \"dot\" syntax, but there is no entry in the ``@interface`` "
"declaration corresponding to this ivar."
msgstr ""

#: ../../../SourceLevelDebugging.rst:528
msgid ""
"To facilitate debugging, these properties we will add a new DWARF TAG into "
"the ``DW_TAG_structure_type`` definition for the class to hold the "
"description of a given property, and a set of DWARF attributes that provide "
"said description. The property tag will also contain the name and declared "
"type of the property."
msgstr ""

#: ../../../SourceLevelDebugging.rst:533
msgid ""
"If there is a related ivar, there will also be a DWARF property attribute "
"placed in the ``DW_TAG_member`` DIE for that ivar referring back to the "
"property TAG for that property.  And in the case where the compiler "
"synthesizes the ivar directly, the compiler is expected to generate a "
"``DW_TAG_member`` for that ivar (with the ``DW_AT_artificial`` set to 1), "
"whose name will be the name used to access this ivar directly in code, and "
"with the property attribute pointing back to the property it is backing."
msgstr ""

#: ../../../SourceLevelDebugging.rst:541
msgid "The following examples will serve as illustration for our discussion:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:558
msgid ""
"This produces the following DWARF (this is a \"pseudo dwarfdump\" output):"
msgstr ""

#: ../../../SourceLevelDebugging.rst:589
msgid ""
"Note, the current convention is that the name of the ivar for an auto-"
"synthesized property is the name of the property from which it derives with "
"an underscore prepended, as is shown in the example.  But we actually don't "
"need to know this convention, since we are given the name of the ivar "
"directly."
msgstr ""

#: ../../../SourceLevelDebugging.rst:595
msgid ""
"Also, it is common practice in ObjC to have different property declarations "
"in the @interface and @implementation - e.g. to provide a read-only property "
"in the interface,and a read-write interface in the implementation.  In that "
"case, the compiler should emit whichever property declaration will be in "
"force in the current translation unit."
msgstr ""

#: ../../../SourceLevelDebugging.rst:601
msgid ""
"Developers can decorate a property with attributes which are encoded using "
"``DW_AT_APPLE_property_attribute``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:615
msgid ""
"The setter and getter method names are attached to the property using "
"``DW_AT_APPLE_property_setter`` and ``DW_AT_APPLE_property_getter`` "
"attributes."
msgstr ""

#: ../../../SourceLevelDebugging.rst:630
msgid "The DWARF for this would be:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:652
msgid "New DWARF Tags"
msgstr ""

#: ../../../SourceLevelDebugging.rst:655
msgid "TAG"
msgstr ""

#: ../../../SourceLevelDebugging.rst:655 ../../../SourceLevelDebugging.rst:664
#: ../../../SourceLevelDebugging.rst:679
msgid "Value"
msgstr ""

#: ../../../SourceLevelDebugging.rst:657
msgid "DW_TAG_APPLE_property"
msgstr ""

#: ../../../SourceLevelDebugging.rst:657
msgid "0x4200"
msgstr ""

#: ../../../SourceLevelDebugging.rst:661
msgid "New DWARF Attributes"
msgstr ""

#: ../../../SourceLevelDebugging.rst:664
msgid "Attribute"
msgstr ""

#: ../../../SourceLevelDebugging.rst:664
msgid "Classes"
msgstr ""

#: ../../../SourceLevelDebugging.rst:666
msgid "DW_AT_APPLE_property"
msgstr ""

#: ../../../SourceLevelDebugging.rst:666
msgid "0x3fed"
msgstr ""

#: ../../../SourceLevelDebugging.rst:666
msgid "Reference"
msgstr ""

#: ../../../SourceLevelDebugging.rst:668
msgid "DW_AT_APPLE_property_getter"
msgstr ""

#: ../../../SourceLevelDebugging.rst:668
msgid "0x3fe9"
msgstr ""

#: ../../../SourceLevelDebugging.rst:668 ../../../SourceLevelDebugging.rst:670
msgid "String"
msgstr ""

#: ../../../SourceLevelDebugging.rst:670
msgid "DW_AT_APPLE_property_setter"
msgstr ""

#: ../../../SourceLevelDebugging.rst:670
msgid "0x3fea"
msgstr ""

#: ../../../SourceLevelDebugging.rst:672
msgid "DW_AT_APPLE_property_attribute"
msgstr ""

#: ../../../SourceLevelDebugging.rst:672
msgid "0x3feb"
msgstr ""

#: ../../../SourceLevelDebugging.rst:672
msgid "Constant"
msgstr ""

#: ../../../SourceLevelDebugging.rst:676
msgid "New DWARF Constants"
msgstr ""

#: ../../../SourceLevelDebugging.rst:679
msgid "Name"
msgstr ""

#: ../../../SourceLevelDebugging.rst:681
msgid "DW_APPLE_PROPERTY_readonly"
msgstr ""

#: ../../../SourceLevelDebugging.rst:681
msgid "0x01"
msgstr ""

#: ../../../SourceLevelDebugging.rst:683
msgid "DW_APPLE_PROPERTY_getter"
msgstr ""

#: ../../../SourceLevelDebugging.rst:683
msgid "0x02"
msgstr ""

#: ../../../SourceLevelDebugging.rst:685
msgid "DW_APPLE_PROPERTY_assign"
msgstr ""

#: ../../../SourceLevelDebugging.rst:685
msgid "0x04"
msgstr ""

#: ../../../SourceLevelDebugging.rst:687
msgid "DW_APPLE_PROPERTY_readwrite"
msgstr ""

#: ../../../SourceLevelDebugging.rst:687
msgid "0x08"
msgstr ""

#: ../../../SourceLevelDebugging.rst:689
msgid "DW_APPLE_PROPERTY_retain"
msgstr ""

#: ../../../SourceLevelDebugging.rst:689
msgid "0x10"
msgstr ""

#: ../../../SourceLevelDebugging.rst:691
msgid "DW_APPLE_PROPERTY_copy"
msgstr ""

#: ../../../SourceLevelDebugging.rst:691
msgid "0x20"
msgstr ""

#: ../../../SourceLevelDebugging.rst:693
msgid "DW_APPLE_PROPERTY_nonatomic"
msgstr ""

#: ../../../SourceLevelDebugging.rst:693
msgid "0x40"
msgstr ""

#: ../../../SourceLevelDebugging.rst:695
msgid "DW_APPLE_PROPERTY_setter"
msgstr ""

#: ../../../SourceLevelDebugging.rst:695
msgid "0x80"
msgstr ""

#: ../../../SourceLevelDebugging.rst:697
msgid "DW_APPLE_PROPERTY_atomic"
msgstr ""

#: ../../../SourceLevelDebugging.rst:697
msgid "0x100"
msgstr ""

#: ../../../SourceLevelDebugging.rst:699
msgid "DW_APPLE_PROPERTY_weak"
msgstr ""

#: ../../../SourceLevelDebugging.rst:699
msgid "0x200"
msgstr ""

#: ../../../SourceLevelDebugging.rst:701
msgid "DW_APPLE_PROPERTY_strong"
msgstr ""

#: ../../../SourceLevelDebugging.rst:701
msgid "0x400"
msgstr ""

#: ../../../SourceLevelDebugging.rst:703
msgid "DW_APPLE_PROPERTY_unsafe_unretained"
msgstr ""

#: ../../../SourceLevelDebugging.rst:703
msgid "0x800"
msgstr ""

#: ../../../SourceLevelDebugging.rst:705
msgid "DW_APPLE_PROPERTY_nullability"
msgstr ""

#: ../../../SourceLevelDebugging.rst:705
msgid "0x1000"
msgstr ""

#: ../../../SourceLevelDebugging.rst:707
msgid "DW_APPLE_PROPERTY_null_resettable"
msgstr ""

#: ../../../SourceLevelDebugging.rst:707
msgid "0x2000"
msgstr ""

#: ../../../SourceLevelDebugging.rst:709
msgid "DW_APPLE_PROPERTY_class"
msgstr ""

#: ../../../SourceLevelDebugging.rst:709
msgid "0x4000"
msgstr ""

#: ../../../SourceLevelDebugging.rst:713
msgid "Name Accelerator Tables"
msgstr ""

#: ../../../SourceLevelDebugging.rst:718
msgid ""
"The \"``.debug_pubnames``\" and \"``.debug_pubtypes``\" formats are not what "
"a debugger needs.  The \"``pub``\" in the section name indicates that the "
"entries in the table are publicly visible names only.  This means no static "
"or hidden functions show up in the \"``.debug_pubnames``\".  No static "
"variables or private class variables are in the \"``.debug_pubtypes``\".  "
"Many compilers add different things to these tables, so we can't rely upon "
"the contents between gcc, icc, or clang."
msgstr ""

#: ../../../SourceLevelDebugging.rst:726
msgid ""
"The typical query given by users tends not to match up with the contents of "
"these tables.  For example, the DWARF spec states that \"In the case of the "
"name of a function member or static data member of a C++ structure, class or "
"union, the name presented in the \"``.debug_pubnames``\" section is not the "
"simple name given by the ``DW_AT_name attribute`` of the referenced "
"debugging information entry, but rather the fully qualified name of the data "
"or function member.\" So the only names in these tables for complex C++ "
"entries is a fully qualified name.  Debugger users tend not to enter their "
"search strings as \"``a::b::c(int,const Foo&) const``\", but rather as "
"\"``c``\", \"``b::c``\" , or \"``a::b::c``\".  So the name entered in the "
"name table must be demangled in order to chop it up appropriately and "
"additional names must be manually entered into the table to make it "
"effective as a name lookup table for debuggers to use."
msgstr ""

#: ../../../SourceLevelDebugging.rst:740
msgid ""
"All debuggers currently ignore the \"``.debug_pubnames``\" table as a result "
"of its inconsistent and useless public-only name content making it a waste "
"of space in the object file.  These tables, when they are written to disk, "
"are not sorted in any way, leaving every debugger to do its own parsing and "
"sorting. These tables also include an inlined copy of the string values in "
"the table itself making the tables much larger than they need to be on disk, "
"especially for large C++ programs."
msgstr ""

#: ../../../SourceLevelDebugging.rst:748
msgid ""
"Can't we just fix the sections by adding all of the names we need to this "
"table? No, because that is not what the tables are defined to contain and we "
"won't know the difference between the old bad tables and the new good "
"tables. At best we could make our own renamed sections that contain all of "
"the data we need."
msgstr ""

#: ../../../SourceLevelDebugging.rst:754
msgid ""
"These tables are also insufficient for what a debugger like LLDB needs.  "
"LLDB uses clang for its expression parsing where LLDB acts as a PCH.  LLDB "
"is then often asked to look for type \"``foo``\" or namespace \"``bar``\", "
"or list items in namespace \"``baz``\".  Namespaces are not included in the "
"pubnames or pubtypes tables.  Since clang asks a lot of questions when it is "
"parsing an expression, we need to be very fast when looking up names, as it "
"happens a lot.  Having new accelerator tables that are optimized for very "
"quick lookups will benefit this type of debugging experience greatly."
msgstr ""

#: ../../../SourceLevelDebugging.rst:763
msgid ""
"We would like to generate name lookup tables that can be mapped into memory "
"from disk, and used as is, with little or no up-front parsing.  We would "
"also be able to control the exact content of these different tables so they "
"contain exactly what we need.  The Name Accelerator Tables were designed to "
"fix these issues.  In order to solve these issues we need to:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:769
msgid "Have a format that can be mapped into memory from disk and used as is"
msgstr ""

#: ../../../SourceLevelDebugging.rst:770
msgid "Lookups should be very fast"
msgstr ""

#: ../../../SourceLevelDebugging.rst:771
msgid "Extensible table format so these tables can be made by many producers"
msgstr ""

#: ../../../SourceLevelDebugging.rst:772
msgid "Contain all of the names needed for typical lookups out of the box"
msgstr ""

#: ../../../SourceLevelDebugging.rst:773
msgid "Strict rules for the contents of tables"
msgstr ""

#: ../../../SourceLevelDebugging.rst:775
msgid ""
"Table size is important and the accelerator table format should allow the "
"reuse of strings from common string tables so the strings for the names are "
"not duplicated.  We also want to make sure the table is ready to be used as-"
"is by simply mapping the table into memory with minimal header parsing."
msgstr ""

#: ../../../SourceLevelDebugging.rst:780
msgid ""
"The name lookups need to be fast and optimized for the kinds of lookups that "
"debuggers tend to do.  Optimally we would like to touch as few parts of the "
"mapped table as possible when doing a name lookup and be able to quickly "
"find the name entry we are looking for, or discover there are no matches.  "
"In the case of debuggers we optimized for lookups that fail most of the time."
msgstr ""

#: ../../../SourceLevelDebugging.rst:786
msgid ""
"Each table that is defined should have strict rules on exactly what is in "
"the accelerator tables and documented so clients can rely on the content."
msgstr ""

#: ../../../SourceLevelDebugging.rst:790
msgid "Hash Tables"
msgstr ""

#: ../../../SourceLevelDebugging.rst:793
msgid "Standard Hash Tables"
msgstr ""

#: ../../../SourceLevelDebugging.rst:795
msgid ""
"Typical hash tables have a header, buckets, and each bucket points to the "
"bucket contents:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:808
msgid "The BUCKETS are an array of offsets to DATA for each hash:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:821
msgid ""
"So for ``bucket[3]`` in the example above, we have an offset into the table "
"0x000034f0 which points to a chain of entries for the bucket.  Each bucket "
"must contain a next pointer, full 32 bit hash value, the string itself, and "
"the data for the current string value."
msgstr ""

#: ../../../SourceLevelDebugging.rst:845
msgid ""
"The problem with this layout for debuggers is that we need to optimize for "
"the negative lookup case where the symbol we're searching for is not "
"present.  So if we were to lookup \"``printf``\" in the table above, we "
"would make a 32-bit hash for \"``printf``\", it might match ``bucket[3]``.  "
"We would need to go to the offset 0x000034f0 and start looking to see if our "
"32 bit hash matches.  To do so, we need to read the next pointer, then read "
"the hash, compare it, and skip to the next bucket.  Each time we are "
"skipping many bytes in memory and touching new pages just to do the compare "
"on the full 32 bit hash.  All of these accesses then tell us that we didn't "
"have a match."
msgstr ""

#: ../../../SourceLevelDebugging.rst:856
msgid "Name Hash Tables"
msgstr ""

#: ../../../SourceLevelDebugging.rst:858
msgid ""
"To solve the issues mentioned above we have structured the hash tables a bit "
"differently: a header, buckets, an array of all unique 32 bit hash values, "
"followed by an array of hash value data offsets, one for each hash value, "
"then the data for all hash values:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:877
msgid ""
"The ``BUCKETS`` in the name tables are an index into the ``HASHES`` array.  "
"By making all of the full 32 bit hash values contiguous in memory, we allow "
"ourselves to efficiently check for a match while touching as little memory "
"as possible.  Most often checking the 32 bit hash values is as far as the "
"lookup goes.  If it does match, it usually is a match with no collisions.  "
"So for a table with \"``n_buckets``\" buckets, and \"``n_hashes``\" unique "
"32 bit hash values, we can clarify the contents of the ``BUCKETS``, "
"``HASHES`` and ``OFFSETS`` as:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:906
msgid ""
"So taking the exact same data from the standard hash example above we end up "
"with:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:992
msgid ""
"So we still have all of the same data, we just organize it more efficiently "
"for debugger lookup.  If we repeat the same \"``printf``\" lookup from "
"above, we would hash \"``printf``\" and find it matches ``BUCKETS[3]`` by "
"taking the 32 bit hash value and modulo it by ``n_buckets``.  ``BUCKETS[3]`` "
"contains \"6\" which is the index into the ``HASHES`` table.  We would then "
"compare any consecutive 32 bit hashes values in the ``HASHES`` array as long "
"as the hashes would be in ``BUCKETS[3]``.  We do this by verifying that each "
"subsequent hash value modulo ``n_buckets`` is still 3.  In the case of a "
"failed lookup we would access the memory for ``BUCKETS[3]``, and then "
"compare a few consecutive 32 bit hashes before we know that we have no "
"match.  We don't end up marching through multiple words of memory and we "
"really keep the number of processor data cache lines being accessed as small "
"as possible."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1005
msgid ""
"The string hash that is used for these lookup tables is the Daniel J. "
"Bernstein hash which is also used in the ELF ``GNU_HASH`` sections.  It is a "
"very good hash for all kinds of names in programs with very few hash "
"collisions."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1010
msgid ""
"Empty buckets are designated by using an invalid hash index of "
"``UINT32_MAX``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1013
msgid "Details"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1015
msgid ""
"These name hash tables are designed to be generic where specializations of "
"the table get to define additional data that goes into the header "
"(\"``HeaderData``\"), how the string value is stored (\"``KeyType``\") and "
"the content of the data for each hash value."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1021
msgid "Header Layout"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1023
msgid ""
"The header has a fixed part, and the specialized part.  The exact format of "
"the header is:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1041
msgid ""
"The header starts with a 32 bit \"``magic``\" value which must be ``'HASH'`` "
"encoded as an ASCII integer.  This allows the detection of the start of the "
"hash table and also allows the table's byte order to be determined so the "
"table can be correctly extracted.  The \"``magic``\" value is followed by a "
"16 bit ``version`` number which allows the table to be revised and modified "
"in the future.  The current version number is 1. ``hash_function`` is a "
"``uint16_t`` enumeration that specifies which hash function was used to "
"produce this table. The current values for the hash function enumerations "
"include:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1057
msgid ""
"``bucket_count`` is a 32 bit unsigned integer that represents how many "
"buckets are in the ``BUCKETS`` array.  ``hashes_count`` is the number of "
"unique 32 bit hash values that are in the ``HASHES`` array, and is the same "
"number of offsets are contained in the ``OFFSETS`` array.  "
"``header_data_len`` specifies the size in bytes of the ``HeaderData`` that "
"is filled in by specialized versions of this table."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1065
msgid "Fixed Lookup"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1067
msgid ""
"The header is followed by the buckets, hashes, offsets, and hash value data."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1078
msgid ""
"``buckets`` is an array of 32 bit indexes into the ``hashes`` array.  The "
"``hashes`` array contains all of the 32 bit hash values for all names in the "
"hash table.  Each hash in the ``hashes`` table has an offset in the "
"``offsets`` array that points to the data for the hash value."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1083
msgid ""
"This table setup makes it very easy to repurpose these tables to contain "
"different data, while keeping the lookup mechanism the same for all tables. "
"This layout also makes it possible to save the table to disk and map it in "
"later and do very efficient name lookups with little or no parsing."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1088
msgid ""
"DWARF lookup tables can be implemented in a variety of ways and can store a "
"lot of information for each name.  We want to make the DWARF tables "
"extensible and able to store the data efficiently so we have used some of "
"the DWARF features that enable efficient data storage to define exactly what "
"kind of data we store for each name."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1094
msgid ""
"The ``HeaderData`` contains a definition of the contents of each HashData "
"chunk. We might want to store an offset to all of the debug information "
"entries (DIEs) for each name.  To keep things extensible, we create a list "
"of items, or Atoms, that are contained in the data for each name.  First "
"comes the type of the data in each atom:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1112
msgid "The enumeration values and their meanings are:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1123
msgid ""
"Then we allow each atom type to define the atom type and how the data for "
"each atom type data is encoded:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1134
msgid ""
"The ``form`` type above is from the DWARF specification and defines the "
"exact encoding of the data for the Atom type.  See the DWARF specification "
"for the ``DW_FORM_`` definitions."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1147
msgid ""
"``HeaderData`` defines the base DIE offset that should be added to any atoms "
"that are encoded using the ``DW_FORM_ref1``, ``DW_FORM_ref2``, "
"``DW_FORM_ref4``, ``DW_FORM_ref8`` or ``DW_FORM_ref_udata``.  It also "
"defines what is contained in each ``HashData`` object -- ``Atom.form`` tells "
"us how large each field will be in the ``HashData`` and the ``Atom.type`` "
"tells us how this data should be interpreted."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1154
msgid ""
"For the current implementations of the \"``.apple_names``\" (all functions + "
"globals), the \"``.apple_types``\" (names of all types that are defined), "
"and the \"``.apple_namespaces``\" (all namespaces), we currently set the "
"``Atom`` array to be:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1165
msgid ""
"This defines the contents to be the DIE offset (eAtomTypeDIEOffset) that is "
"encoded as a 32 bit value (DW_FORM_data4).  This allows a single name to "
"have multiple matching DIEs in a single file, which could come up with an "
"inlined function for instance.  Future tables could include more information "
"about the DIE such as flags indicating if the DIE is a function, method, "
"block, or inlined."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1172
msgid ""
"The KeyType for the DWARF table is a 32 bit string table offset into the \"."
"debug_str\" table.  The \".debug_str\" is the string table for the DWARF "
"which may already contain copies of all of the strings.  This helps make "
"sure, with help from the compiler, that we reuse the strings between all of "
"the DWARF sections and keeps the hash table size down.  Another benefit to "
"having the compiler generate all strings as DW_FORM_strp in the debug info, "
"is that DWARF parsing can be made much faster."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1180
msgid ""
"After a lookup is made, we get an offset into the hash data.  The hash data "
"needs to be able to deal with 32 bit hash collisions, so the chunk of data "
"at the offset in the hash data consists of a triple:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1190
msgid ""
"If \"str_offset\" is zero, then the bucket contents are done. 99.9% of the "
"hash data chunks contain a single item (no 32 bit hash collision):"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1205
msgid "If there are collisions, you will have multiple valid string offsets:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1223
msgid ""
"Current testing with real world C++ binaries has shown that there is around "
"1 32 bit hash collision per 100,000 name entries."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1227
msgid "Contents"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1229
msgid ""
"As we said, we want to strictly define exactly what is included in the "
"different tables.  For DWARF, we have 3 tables: \"``.apple_names``\", \"``."
"apple_types``\", and \"``.apple_namespaces``\"."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1233
msgid ""
"\"``.apple_names``\" sections should contain an entry for each DWARF DIE "
"whose ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or "
"``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``, "
"``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``.  It also contains "
"``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the location (global "
"and static variables).  All global and static variables should be included, "
"including those scoped within functions and classes.  For example using the "
"following code:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1251
msgid ""
"Both of the static ``var`` variables would be included in the table.  All "
"functions should emit both their full names and their basenames.  For C or C+"
"+, the full name is the mangled name (if available) which is usually in the "
"``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` contains the "
"function basename.  If global or static variables have a mangled name in a "
"``DW_AT_MIPS_linkage_name`` attribute, this should be emitted along with the "
"simple name found in the ``DW_AT_name`` attribute."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1259
msgid ""
"\"``.apple_types``\" sections should contain an entry for each DWARF DIE "
"whose tag is one of:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1262
msgid "DW_TAG_array_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1263
msgid "DW_TAG_class_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1264
msgid "DW_TAG_enumeration_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1265
msgid "DW_TAG_pointer_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1266
msgid "DW_TAG_reference_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1267
msgid "DW_TAG_string_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1268
msgid "DW_TAG_structure_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1269
msgid "DW_TAG_subroutine_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1270
msgid "DW_TAG_typedef"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1271
msgid "DW_TAG_union_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1272
msgid "DW_TAG_ptr_to_member_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1273
msgid "DW_TAG_set_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1274
msgid "DW_TAG_subrange_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1275
msgid "DW_TAG_base_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1276
msgid "DW_TAG_const_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1277
msgid "DW_TAG_file_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1278
msgid "DW_TAG_namelist"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1279
msgid "DW_TAG_packed_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1280
msgid "DW_TAG_volatile_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1281
msgid "DW_TAG_restrict_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1282
msgid "DW_TAG_atomic_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1283
msgid "DW_TAG_interface_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1284
msgid "DW_TAG_unspecified_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1285
msgid "DW_TAG_shared_type"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1287
msgid ""
"Only entries with a ``DW_AT_name`` attribute are included, and the entry "
"must not be a forward declaration (``DW_AT_declaration`` attribute with a "
"non-zero value).  For example, using the following code:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1299
msgid "We get a few type DIEs:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1312
msgid ""
"The DW_TAG_pointer_type is not included because it does not have a "
"``DW_AT_name``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1314
msgid ""
"\"``.apple_namespaces``\" section should contain all ``DW_TAG_namespace`` "
"DIEs. If we run into a namespace that has no name this is an anonymous "
"namespace, and the name should be output as \"``(anonymous "
"namespace)``\" (without the quotes). Why?  This matches the output of the "
"``abi::cxa_demangle()`` that is in the standard C++ library that demangles "
"mangled names."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1322
msgid "Language Extensions and File Format Changes"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1325
msgid "Objective-C Extensions"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1327
msgid ""
"\"``.apple_objc``\" section should contain all ``DW_TAG_subprogram`` DIEs "
"for an Objective-C class.  The name used in the hash table is the name of "
"the Objective-C class itself.  If the Objective-C class has a category, then "
"an entry is made for both the class name without the category, and for the "
"class name with the category.  So if we have a DIE at offset 0x1234 with a "
"name of method \"``-[NSString(my_additions) stringWithSpecialString:]``\", "
"we would add an entry for \"``NSString``\" that points to DIE 0x1234, and an "
"entry for \"``NSString(my_additions)``\" that points to 0x1234.  This allows "
"us to quickly track down all Objective-C methods for an Objective-C class "
"when doing expressions.  It is needed because of the dynamic nature of "
"Objective-C where anyone can add methods to a class.  The DWARF for "
"Objective-C methods is also emitted differently from C++ classes where the "
"methods are not usually contained in the class definition, they are "
"scattered about across one or more compile units.  Categories can also be "
"defined in different shared libraries. So we need to be able to quickly find "
"all of the methods and class functions given the Objective-C class name, or "
"quickly find all methods and class functions for a class + category name.  "
"This table does not contain any selector names, it just maps Objective-C "
"class names (or class names + category) to all of the methods and class "
"functions.  The selectors are added as function basenames in the \"``."
"debug_names``\" section."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1348
msgid ""
"In the \"``.apple_names``\" section for Objective-C functions, the full name "
"is the entire function name with the brackets (\"``-[NSString "
"stringWithCString:]``\") and the basename is the selector only "
"(\"``stringWithCString:``\")."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1354
msgid "Mach-O Changes"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1356
msgid ""
"The sections names for the apple hash tables are for non-mach-o files.  For "
"mach-o files, the sections should be contained in the ``__DWARF`` segment "
"with names as follows:"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1360
msgid "\"``.apple_names``\" -> \"``__apple_names``\""
msgstr ""

#: ../../../SourceLevelDebugging.rst:1361
msgid "\"``.apple_types``\" -> \"``__apple_types``\""
msgstr ""

#: ../../../SourceLevelDebugging.rst:1362
msgid ""
"\"``.apple_namespaces``\" -> \"``__apple_namespac``\" (16 character limit)"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1363
msgid "\"``.apple_objc``\" -> \"``__apple_objc``\""
msgstr ""

#: ../../../SourceLevelDebugging.rst:1368
msgid "CodeView Debug Info Format"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1370
msgid ""
"LLVM supports emitting CodeView, the Microsoft debug info format, and this "
"section describes the design and implementation of that support."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1374
msgid "Format Background"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1376
msgid ""
"CodeView as a format is clearly oriented around C++ debugging, and in C++, "
"the majority of debug information tends to be type information. Therefore, "
"the overriding design constraint of CodeView is the separation of type "
"information from other \"symbol\" information so that type information can "
"be efficiently merged across translation units. Both type information and "
"symbol information is generally stored as a sequence of records, where each "
"record begins with a 16-bit record size and a 16-bit record kind."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1384
msgid ""
"Type information is usually stored in the ``.debug$T`` section of the object "
"file.  All other debug info, such as line info, string table, symbol info, "
"and inlinee info, is stored in one or more ``.debug$S`` sections. There may "
"only be one ``.debug$T`` section per object file, since all other debug info "
"refers to it. If a PDB (enabled by the ``/Zi`` MSVC option) was used during "
"compilation, the ``.debug$T`` section will contain only an "
"``LF_TYPESERVER2`` record pointing to the PDB. When using PDBs, symbol "
"information appears to remain in the object file ``.debug$S`` sections."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1393
msgid ""
"Type records are referred to by their index, which is the number of records "
"in the stream before a given record plus ``0x1000``. Many common basic "
"types, such as the basic integral types and unqualified pointers to them, "
"are represented using type indices less than ``0x1000``. Such basic types "
"are built in to CodeView consumers and do not require type records."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1399
msgid ""
"Each type record may only contain type indices that are less than its own "
"type index. This ensures that the graph of type stream references is "
"acyclic. While the source-level type graph may contain cycles through "
"pointer types (consider a linked list struct), these cycles are removed from "
"the type stream by always referring to the forward declaration record of "
"user-defined record types. Only \"symbol\" records in the ``.debug$S`` "
"streams may refer to complete, non-forward-declaration type records."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1408
msgid "Working with CodeView"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1410
msgid ""
"These are instructions for some common tasks for developers working to "
"improve LLVM's CodeView support. Most of them revolve around using the "
"CodeView dumper embedded in ``llvm-readobj``."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1414
msgid "Testing MSVC's output::"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1419
msgid "Getting LLVM IR debug info out of Clang::"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1423
msgid "Use this to generate LLVM IR for LLVM test cases."
msgstr ""

#: ../../../SourceLevelDebugging.rst:1425
msgid "Generate and dump CodeView from LLVM IR metadata::"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1430
msgid ""
"Use this pattern in lit test cases and FileCheck the output of llvm-readobj"
msgstr ""

#: ../../../SourceLevelDebugging.rst:1432
msgid ""
"Improving LLVM's CodeView support is a process of finding interesting type "
"records, constructing a C++ test case that makes MSVC emit those records, "
"dumping the records, understanding them, and then generating equivalent "
"records in LLVM's backend."
msgstr ""
