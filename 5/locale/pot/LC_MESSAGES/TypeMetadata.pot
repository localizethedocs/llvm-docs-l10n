# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TypeMetadata.rst:3
msgid "Type Metadata"
msgstr ""

#: ../../../TypeMetadata.rst:5
msgid ""
"Type metadata is a mechanism that allows IR modules to co-operatively build "
"pointer sets corresponding to addresses within a given set of globals. "
"LLVM's `control flow integrity`_ implementation uses this metadata to "
"efficiently check (at each call site) that a given address corresponds to "
"either a valid vtable or function pointer for a given class or function "
"type, and its whole-program devirtualization pass uses the metadata to "
"identify potential callees for a given virtual call."
msgstr ""

#: ../../../TypeMetadata.rst:13
msgid ""
"To use the mechanism, a client creates metadata nodes with two elements:"
msgstr ""

#: ../../../TypeMetadata.rst:15
msgid "a byte offset into the global (generally zero for functions)"
msgstr ""

#: ../../../TypeMetadata.rst:16
msgid "a metadata object representing an identifier for the type"
msgstr ""

#: ../../../TypeMetadata.rst:18
msgid ""
"These metadata nodes are associated with globals by using global object "
"metadata attachments with the ``!type`` metadata kind."
msgstr ""

#: ../../../TypeMetadata.rst:21
msgid ""
"Each type identifier must exclusively identify either global variables or "
"functions."
msgstr ""

#: ../../../TypeMetadata.rst:24
msgid "Limitation"
msgstr ""

#: ../../../TypeMetadata.rst:26
msgid ""
"The current implementation only supports attaching metadata to functions on "
"the x86-32 and x86-64 architectures."
msgstr ""

#: ../../../TypeMetadata.rst:29
msgid ""
"An intrinsic, :ref:`llvm.type.test <type.test>`, is used to test whether a "
"given pointer is associated with a type identifier."
msgstr ""

#: ../../../TypeMetadata.rst:35
msgid "Representing Type Information using Type Metadata"
msgstr ""

#: ../../../TypeMetadata.rst:37
msgid ""
"This section describes how Clang represents C++ type information associated "
"with virtual tables using type metadata."
msgstr ""

#: ../../../TypeMetadata.rst:40
msgid "Consider the following inheritance hierarchy:"
msgstr ""

#: ../../../TypeMetadata.rst:62
msgid ""
"The virtual table objects for A, B, C and D look like this (under the "
"Itanium ABI):"
msgstr ""

#: ../../../TypeMetadata.rst:64
msgid "Virtual Table Layout for A, B, C, D"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "Class"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "0"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "1"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "2"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "3"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "4"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "5"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "6"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "A"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "A::offset-to-top"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&A::rtti"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&A::f"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "B"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "B::offset-to-top"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&B::rtti"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&B::f"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&B::g"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "C"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "C::offset-to-top"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&C::rtti"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&C::h"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "D"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "D::offset-to-top"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&D::rtti"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&D::f"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "&D::h"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "thunk for &D::h"
msgstr ""

#: ../../../TypeMetadata.rst:72
msgid ""
"When an object of type A is constructed, the address of ``&A::f`` in A's "
"virtual table object is stored in the object's vtable pointer.  In ABI "
"parlance this address is known as an `address point`_. Similarly, when an "
"object of type B is constructed, the address of ``&B::f`` is stored in the "
"vtable pointer. In this way, the vtable in B's virtual table object is "
"compatible with A's vtable."
msgstr ""

#: ../../../TypeMetadata.rst:78
msgid ""
"D is a little more complicated, due to the use of multiple inheritance. Its "
"virtual table object contains two vtables, one compatible with A's vtable "
"and the other compatible with C's vtable. Objects of type D contain two "
"virtual pointers, one belonging to the A subobject and containing the "
"address of the vtable compatible with A's vtable, and the other belonging to "
"the C subobject and containing the address of the vtable compatible with C's "
"vtable."
msgstr ""

#: ../../../TypeMetadata.rst:85
msgid ""
"The full set of compatibility information for the above class hierarchy is "
"shown below. The following table shows the name of a class, the offset of an "
"address point within that class's vtable and the name of one of the classes "
"with which that address point is compatible."
msgstr ""

#: ../../../TypeMetadata.rst:90
msgid "Type Offsets for A, B, C, D"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "VTable for"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "Offset"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "Compatible Class"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "16"
msgstr ""

#: ../../../TypeMetadata.rst:1
msgid "48"
msgstr ""

#: ../../../TypeMetadata.rst:101
msgid ""
"The next step is to encode this compatibility information into the IR. The "
"way this is done is to create type metadata named after each of the "
"compatible classes, with which we associate each of the compatible address "
"points in each vtable. For example, these type metadata entries encode the "
"compatibility information for the above hierarchy:"
msgstr ""

#: ../../../TypeMetadata.rst:120
msgid ""
"With this type metadata, we can now use the ``llvm.type.test`` intrinsic to "
"test whether a given pointer is compatible with a type identifier. Working "
"backwards, if ``llvm.type.test`` returns true for a particular pointer, we "
"can also statically determine the identities of the virtual functions that a "
"particular virtual call may call. For example, if a program assumes a "
"pointer to be a member of ``!\"_ZST1A\"``, we know that the address can be "
"only be one of ``_ZTV1A+16``, ``_ZTV1B+16`` or ``_ZTV1D+16`` (i.e. the "
"address points of the vtables of A, B and D respectively). If we then load "
"an address from that pointer, we know that the address can only be one of "
"``&A::f``, ``&B::f`` or ``&D::f``."
msgstr ""

#: ../../../TypeMetadata.rst:134
msgid "Testing Addresses For Type Membership"
msgstr ""

#: ../../../TypeMetadata.rst:136
msgid ""
"If a program tests an address using ``llvm.type.test``, this will cause a "
"link-time optimization pass, ``LowerTypeTests``, to replace calls to this "
"intrinsic with efficient code to perform type member tests. At a high level, "
"the pass will lay out referenced globals in a consecutive memory region in "
"the object file, construct bit vectors that map onto that memory region, and "
"generate code at each of the ``llvm.type.test`` call sites to test pointers "
"against those bit vectors. Because of the layout manipulation, the globals' "
"definitions must be available at LTO time. For more information, see the "
"`control flow integrity design document`_."
msgstr ""

#: ../../../TypeMetadata.rst:146
msgid ""
"A type identifier that identifies functions is transformed into a jump "
"table, which is a block of code consisting of one branch instruction for "
"each of the functions associated with the type identifier that branches to "
"the target function. The pass will redirect any taken function addresses to "
"the corresponding jump table entry. In the object file's symbol table, the "
"jump table entries take the identities of the original functions, so that "
"addresses taken outside the module will pass any verification done inside "
"the module."
msgstr ""

#: ../../../TypeMetadata.rst:154
msgid ""
"Jump tables may call external functions, so their definitions need not be "
"available at LTO time. Note that if an externally defined function is "
"associated with a type identifier, there is no guarantee that its identity "
"within the module will be the same as its identity outside of the module, as "
"the former will be the jump table entry if a jump table is necessary."
msgstr ""

#: ../../../TypeMetadata.rst:160
msgid ""
"The `GlobalLayoutBuilder`_ class is responsible for laying out the globals "
"efficiently to minimize the sizes of the underlying bitsets."
msgstr ""

#: ../../../TypeMetadata.rst:0
msgid "Example"
msgstr ""
