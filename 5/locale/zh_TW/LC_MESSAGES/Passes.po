# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../Passes.rst:32
msgid "LLVM's Analysis and Transform Passes"
msgstr ""

#: ../../../Passes.rst:38
msgid "Introduction"
msgstr "簡介"

#: ../../../Passes.rst:40
msgid ""
"This document serves as a high level summary of the optimization features "
"that LLVM provides.  Optimizations are implemented as Passes that traverse "
"some portion of a program to either collect information or transform the "
"program. The table below divides the passes that LLVM provides into three "
"categories. Analysis passes compute information that other passes can use or "
"for debugging or program visualization purposes.  Transform passes can use "
"(or invalidate) the analysis passes.  Transform passes all mutate the "
"program in some way. Utility passes provides some utility but don't "
"otherwise fit categorization. For example passes to extract functions to "
"bitcode or write a module to bitcode are neither analysis nor transform "
"passes.  The table of contents above provides a quick summary of each pass "
"and links to the more complete pass description later in the document."
msgstr ""

#: ../../../Passes.rst:54
msgid "Analysis Passes"
msgstr ""

#: ../../../Passes.rst:56
msgid "This section describes the LLVM Analysis Passes."
msgstr ""

#: ../../../Passes.rst:59
msgid "``-aa-eval``: Exhaustive Alias Analysis Precision Evaluator"
msgstr ""

#: ../../../Passes.rst:61
msgid ""
"This is a simple N^2 alias analysis accuracy evaluator.  Basically, for each "
"function in the program, it simply queries to see how the alias analysis "
"implementation answers alias queries between each pair of pointers in the "
"function."
msgstr ""

#: ../../../Passes.rst:66
msgid ""
"This is inspired and adapted from code by: Naveen Neelakantam, Francesco "
"Spadini, and Wojciech Stryjewski."
msgstr ""

#: ../../../Passes.rst:70
msgid "``-basicaa``: Basic Alias Analysis (stateless AA impl)"
msgstr ""

#: ../../../Passes.rst:72
msgid ""
"A basic alias analysis pass that implements identities (two different "
"globals cannot alias, etc), but does no stateful analysis."
msgstr ""

#: ../../../Passes.rst:76
msgid "``-basiccg``: Basic CallGraph Construction"
msgstr ""

#: ../../../Passes.rst:78 ../../../Passes.rst:271
msgid "Yet to be written."
msgstr ""

#: ../../../Passes.rst:81
msgid "``-count-aa``: Count Alias Analysis Query Responses"
msgstr ""

#: ../../../Passes.rst:83
msgid ""
"A pass which can be used to count how many alias queries are being made and "
"how the alias analysis implementation being used responds."
msgstr ""

#: ../../../Passes.rst:87
msgid "``-da``: Dependence Analysis"
msgstr ""

#: ../../../Passes.rst:89
msgid ""
"Dependence analysis framework, which is used to detect dependences in memory "
"accesses."
msgstr ""

#: ../../../Passes.rst:93
msgid "``-debug-aa``: AA use debugger"
msgstr ""

#: ../../../Passes.rst:95
msgid ""
"This simple pass checks alias analysis users to ensure that if they create a "
"new value, they do not query AA without informing it of the value.  It acts "
"as a shim over any other AA pass you want."
msgstr ""

#: ../../../Passes.rst:99
msgid ""
"Yes keeping track of every value in the program is expensive, but this is a "
"debugging pass."
msgstr ""

#: ../../../Passes.rst:103
msgid "``-domfrontier``: Dominance Frontier Construction"
msgstr ""

#: ../../../Passes.rst:105
msgid ""
"This pass is a simple dominator construction algorithm for finding forward "
"dominator frontiers."
msgstr ""

#: ../../../Passes.rst:109
msgid "``-domtree``: Dominator Tree Construction"
msgstr ""

#: ../../../Passes.rst:111
msgid ""
"This pass is a simple dominator construction algorithm for finding forward "
"dominators."
msgstr ""

#: ../../../Passes.rst:116
msgid "``-dot-callgraph``: Print Call Graph to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:118
msgid ""
"This pass, only available in ``opt``, prints the call graph into a ``.dot`` "
"graph.  This graph can then be processed with the \"dot\" tool to convert it "
"to postscript or some other suitable format."
msgstr ""

#: ../../../Passes.rst:123
msgid "``-dot-cfg``: Print CFG of function to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:125
msgid ""
"This pass, only available in ``opt``, prints the control flow graph into a "
"``.dot`` graph.  This graph can then be processed with the :program:`dot` "
"tool to convert it to postscript or some other suitable format."
msgstr ""

#: ../../../Passes.rst:130
msgid ""
"``-dot-cfg-only``: Print CFG of function to \"dot\" file (with no function "
"bodies)"
msgstr ""

#: ../../../Passes.rst:132
msgid ""
"This pass, only available in ``opt``, prints the control flow graph into a "
"``.dot`` graph, omitting the function bodies.  This graph can then be "
"processed with the :program:`dot` tool to convert it to postscript or some "
"other suitable format."
msgstr ""

#: ../../../Passes.rst:138
msgid "``-dot-dom``: Print dominance tree of function to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:140
msgid ""
"This pass, only available in ``opt``, prints the dominator tree into a ``."
"dot`` graph.  This graph can then be processed with the :program:`dot` tool "
"to convert it to postscript or some other suitable format."
msgstr ""

#: ../../../Passes.rst:145
msgid ""
"``-dot-dom-only``: Print dominance tree of function to \"dot\" file (with no "
"function bodies)"
msgstr ""

#: ../../../Passes.rst:147
msgid ""
"This pass, only available in ``opt``, prints the dominator tree into a ``."
"dot`` graph, omitting the function bodies.  This graph can then be processed "
"with the :program:`dot` tool to convert it to postscript or some other "
"suitable format."
msgstr ""

#: ../../../Passes.rst:152
msgid "``-dot-postdom``: Print postdominance tree of function to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:154
msgid ""
"This pass, only available in ``opt``, prints the post dominator tree into a "
"``.dot`` graph.  This graph can then be processed with the :program:`dot` "
"tool to convert it to postscript or some other suitable format."
msgstr ""

#: ../../../Passes.rst:159
msgid ""
"``-dot-postdom-only``: Print postdominance tree of function to \"dot\" file "
"(with no function bodies)"
msgstr ""

#: ../../../Passes.rst:161
msgid ""
"This pass, only available in ``opt``, prints the post dominator tree into a "
"``.dot`` graph, omitting the function bodies.  This graph can then be "
"processed with the :program:`dot` tool to convert it to postscript or some "
"other suitable format."
msgstr ""

#: ../../../Passes.rst:167
msgid "``-globalsmodref-aa``: Simple mod/ref analysis for globals"
msgstr ""

#: ../../../Passes.rst:169
msgid ""
"This simple pass provides alias and mod/ref information for global values "
"that do not have their address taken, and keeps track of whether functions "
"read or write memory (are \"pure\").  For this simple (but very common) "
"case, we can provide pretty accurate and useful information."
msgstr ""

#: ../../../Passes.rst:175
msgid "``-instcount``: Counts the various types of ``Instruction``\\ s"
msgstr ""

#: ../../../Passes.rst:177
msgid "This pass collects the count of all instructions and reports them."
msgstr ""

#: ../../../Passes.rst:180
msgid "``-intervals``: Interval Partition Construction"
msgstr ""

#: ../../../Passes.rst:182
msgid ""
"This analysis calculates and represents the interval partition of a "
"function, or a preexisting interval partition."
msgstr ""

#: ../../../Passes.rst:185
msgid ""
"In this way, the interval partition may be used to reduce a flow graph down "
"to its degenerate single node interval partition (unless it is irreducible)."
msgstr ""

#: ../../../Passes.rst:189
msgid "``-iv-users``: Induction Variable Users"
msgstr ""

#: ../../../Passes.rst:191
msgid ""
"Bookkeeping for \"interesting\" users of expressions computed from induction "
"variables."
msgstr ""

#: ../../../Passes.rst:195
msgid "``-lazy-value-info``: Lazy Value Information Analysis"
msgstr ""

#: ../../../Passes.rst:197
msgid "Interface for lazy computation of value constraint information."
msgstr ""

#: ../../../Passes.rst:200
msgid "``-libcall-aa``: LibCall Alias Analysis"
msgstr ""

#: ../../../Passes.rst:202
msgid "LibCall Alias Analysis."
msgstr ""

#: ../../../Passes.rst:205
msgid "``-lint``: Statically lint-checks LLVM IR"
msgstr ""

#: ../../../Passes.rst:207
msgid ""
"This pass statically checks for common and easily-identified constructs "
"which produce undefined or likely unintended behavior in LLVM IR."
msgstr ""

#: ../../../Passes.rst:210
msgid ""
"It is not a guarantee of correctness, in two ways.  First, it isn't "
"comprehensive.  There are checks which could be done statically which are "
"not yet implemented.  Some of these are indicated by TODO comments, but "
"those aren't comprehensive either.  Second, many conditions cannot be "
"checked statically.  This pass does no dynamic instrumentation, so it can't "
"check for all possible problems."
msgstr ""

#: ../../../Passes.rst:217
msgid ""
"Another limitation is that it assumes all code will be executed.  A store "
"through a null pointer in a basic block which is never reached is harmless, "
"but this pass will warn about it anyway."
msgstr ""

#: ../../../Passes.rst:221
msgid ""
"Optimization passes may make conditions that this pass checks for more or "
"less obvious.  If an optimization pass appears to be introducing a warning, "
"it may be that the optimization pass is merely exposing an existing "
"condition in the code."
msgstr ""

#: ../../../Passes.rst:226
msgid ""
"This code may be run before :ref:`instcombine <passes-instcombine>`.  In "
"many cases, instcombine checks for the same kinds of things and turns "
"instructions with undefined behavior into unreachable (or equivalent).  "
"Because of this, this pass makes some effort to look through bitcasts and so "
"on."
msgstr ""

#: ../../../Passes.rst:232
msgid "``-loops``: Natural Loop Information"
msgstr ""

#: ../../../Passes.rst:234
msgid ""
"This analysis is used to identify natural loops and determine the loop depth "
"of various nodes of the CFG.  Note that the loops identified may actually be "
"several natural loops that share the same header node... not just a single "
"natural loop."
msgstr ""

#: ../../../Passes.rst:240
msgid "``-memdep``: Memory Dependence Analysis"
msgstr ""

#: ../../../Passes.rst:242
msgid ""
"An analysis that determines, for a given memory operation, what preceding "
"memory operations it depends on.  It builds on alias analysis information, "
"and tries to provide a lazy, caching interface to a common kind of alias "
"information query."
msgstr ""

#: ../../../Passes.rst:248
msgid "``-module-debuginfo``: Decodes module-level debug info"
msgstr ""

#: ../../../Passes.rst:250
msgid ""
"This pass decodes the debug info metadata in a module and prints in a "
"(sufficiently-prepared-) human-readable form."
msgstr ""

#: ../../../Passes.rst:253
msgid ""
"For example, run this pass from ``opt`` along with the ``-analyze`` option, "
"and it'll print to standard output."
msgstr ""

#: ../../../Passes.rst:257
msgid "``-postdomfrontier``: Post-Dominance Frontier Construction"
msgstr ""

#: ../../../Passes.rst:259
msgid ""
"This pass is a simple post-dominator construction algorithm for finding post-"
"dominator frontiers."
msgstr ""

#: ../../../Passes.rst:263
msgid "``-postdomtree``: Post-Dominator Tree Construction"
msgstr ""

#: ../../../Passes.rst:265
msgid ""
"This pass is a simple post-dominator construction algorithm for finding post-"
"dominators."
msgstr ""

#: ../../../Passes.rst:269
msgid "``-print-alias-sets``: Alias Set Printer"
msgstr ""

#: ../../../Passes.rst:274
msgid "``-print-callgraph``: Print a call graph"
msgstr ""

#: ../../../Passes.rst:276
msgid ""
"This pass, only available in ``opt``, prints the call graph to standard "
"error in a human-readable form."
msgstr ""

#: ../../../Passes.rst:280
msgid "``-print-callgraph-sccs``: Print SCCs of the Call Graph"
msgstr ""

#: ../../../Passes.rst:282
msgid ""
"This pass, only available in ``opt``, prints the SCCs of the call graph to "
"standard error in a human-readable form."
msgstr ""

#: ../../../Passes.rst:286
msgid "``-print-cfg-sccs``: Print SCCs of each function CFG"
msgstr ""

#: ../../../Passes.rst:288
msgid ""
"This pass, only available in ``opt``, printsthe SCCs of each function CFG to "
"standard error in a human-readable fom."
msgstr ""

#: ../../../Passes.rst:292
msgid "``-print-dom-info``: Dominator Info Printer"
msgstr ""

#: ../../../Passes.rst:294
msgid "Dominator Info Printer."
msgstr ""

#: ../../../Passes.rst:297
msgid ""
"``-print-externalfnconstants``: Print external fn callsites passed constants"
msgstr ""

#: ../../../Passes.rst:299
msgid ""
"This pass, only available in ``opt``, prints out call sites to external "
"functions that are called with constant arguments.  This can be useful when "
"looking for standard library functions we should constant fold or handle in "
"alias analyses."
msgstr ""

#: ../../../Passes.rst:305
msgid "``-print-function``: Print function to stderr"
msgstr ""

#: ../../../Passes.rst:307
msgid ""
"The ``PrintFunctionPass`` class is designed to be pipelined with other "
"``FunctionPasses``, and prints out the functions of the module as they are "
"processed."
msgstr ""

#: ../../../Passes.rst:312
msgid "``-print-module``: Print module to stderr"
msgstr ""

#: ../../../Passes.rst:314
msgid "This pass simply prints out the entire module when it is executed."
msgstr ""

#: ../../../Passes.rst:319
msgid "``-print-used-types``: Find Used Types"
msgstr ""

#: ../../../Passes.rst:321
msgid ""
"This pass is used to seek out all of the types in use by the program.  Note "
"that this analysis explicitly does not include types only used by the symbol "
"table."
msgstr ""

#: ../../../Passes.rst:326
msgid "``-regions``: Detect single entry single exit regions"
msgstr ""

#: ../../../Passes.rst:328
msgid ""
"The ``RegionInfo`` pass detects single entry single exit regions in a "
"function, where a region is defined as any subgraph that is connected to the "
"remaining graph at only two spots.  Furthermore, an hierarchical region tree "
"is built."
msgstr ""

#: ../../../Passes.rst:333
msgid "``-scalar-evolution``: Scalar Evolution Analysis"
msgstr ""

#: ../../../Passes.rst:335
msgid ""
"The ``ScalarEvolution`` analysis can be used to analyze and catagorize "
"scalar expressions in loops.  It specializes in recognizing general "
"induction variables, representing them with the abstract and opaque ``SCEV`` "
"class. Given this analysis, trip counts of loops and other important "
"properties can be obtained."
msgstr ""

#: ../../../Passes.rst:341
msgid ""
"This analysis is primarily useful for induction variable substitution and "
"strength reduction."
msgstr ""

#: ../../../Passes.rst:345
msgid "``-scev-aa``: ScalarEvolution-based Alias Analysis"
msgstr ""

#: ../../../Passes.rst:347
msgid ""
"Simple alias analysis implemented in terms of ``ScalarEvolution`` queries."
msgstr ""

#: ../../../Passes.rst:349
msgid ""
"This differs from traditional loop dependence analysis in that it tests for "
"dependencies within a single iteration of a loop, rather than dependencies "
"between different iterations."
msgstr ""

#: ../../../Passes.rst:353
msgid ""
"``ScalarEvolution`` has a more complete understanding of pointer arithmetic "
"than ``BasicAliasAnalysis``' collection of ad-hoc analyses."
msgstr ""

#: ../../../Passes.rst:357
msgid "``-targetdata``: Target Data Layout"
msgstr ""

#: ../../../Passes.rst:359
msgid ""
"Provides other passes access to information on how the size and alignment "
"required by the target ABI for various data types."
msgstr ""

#: ../../../Passes.rst:363
msgid "Transform Passes"
msgstr ""

#: ../../../Passes.rst:365
msgid "This section describes the LLVM Transform Passes."
msgstr ""

#: ../../../Passes.rst:368
msgid "``-adce``: Aggressive Dead Code Elimination"
msgstr ""

#: ../../../Passes.rst:370
msgid ""
"ADCE aggressively tries to eliminate code.  This pass is similar to :ref:"
"`DCE <passes-dce>` but it assumes that values are dead until proven "
"otherwise.  This is similar to :ref:`SCCP <passes-sccp>`, except applied to "
"the liveness of values."
msgstr ""

#: ../../../Passes.rst:376
msgid "``-always-inline``: Inliner for ``always_inline`` functions"
msgstr ""

#: ../../../Passes.rst:378
msgid ""
"A custom inliner that handles only functions that are marked as \"always "
"inline\"."
msgstr ""

#: ../../../Passes.rst:382
msgid "``-argpromotion``: Promote 'by reference' arguments to scalars"
msgstr ""

#: ../../../Passes.rst:384
msgid ""
"This pass promotes \"by reference\" arguments to be \"by value\" arguments.  "
"In practice, this means looking for internal functions that have pointer "
"arguments.  If it can prove, through the use of alias analysis, that an "
"argument is *only* loaded, then it can pass the value into the function "
"instead of the address of the value.  This can cause recursive "
"simplification of code and lead to the elimination of allocas (especially in "
"C++ template code like the STL)."
msgstr ""

#: ../../../Passes.rst:392
msgid ""
"This pass also handles aggregate arguments that are passed into a function, "
"scalarizing them if the elements of the aggregate are only loaded.  Note "
"that it refuses to scalarize aggregates which would require passing in more "
"than three operands to the function, because passing thousands of operands "
"for a large array or structure is unprofitable!"
msgstr ""

#: ../../../Passes.rst:398
msgid ""
"Note that this transformation could also be done for arguments that are only "
"stored to (returning the value instead), but does not currently.  This case "
"would be best handled when and if LLVM starts supporting multiple return "
"values from functions."
msgstr ""

#: ../../../Passes.rst:404
msgid "``-bb-vectorize``: Basic-Block Vectorization"
msgstr ""

#: ../../../Passes.rst:406
msgid ""
"This pass combines instructions inside basic blocks to form vector "
"instructions.  It iterates over each basic block, attempting to pair "
"compatible instructions, repeating this process until no additional pairs "
"are selected for vectorization.  When the outputs of some pair of compatible "
"instructions are used as inputs by some other pair of compatible "
"instructions, those pairs are part of a potential vectorization chain.  "
"Instruction pairs are only fused into vector instructions when they are part "
"of a chain longer than some threshold length.  Moreover, the pass attempts "
"to find the best possible chain for each pair of compatible instructions.  "
"These heuristics are intended to prevent vectorization in cases where it "
"would not yield a performance increase of the resulting code."
msgstr ""

#: ../../../Passes.rst:419
msgid "``-block-placement``: Profile Guided Basic Block Placement"
msgstr ""

#: ../../../Passes.rst:421
msgid ""
"This pass is a very simple profile guided basic block placement algorithm.  "
"The idea is to put frequently executed blocks together at the start of the "
"function and hopefully increase the number of fall-through conditional "
"branches.  If there is no profile information for a particular function, "
"this pass basically orders blocks in depth-first order."
msgstr ""

#: ../../../Passes.rst:428
msgid "``-break-crit-edges``: Break critical edges in CFG"
msgstr ""

#: ../../../Passes.rst:430
msgid ""
"Break all of the critical edges in the CFG by inserting a dummy basic block. "
"It may be \"required\" by passes that cannot deal with critical edges.  This "
"transformation obviously invalidates the CFG, but can update forward "
"dominator (set, immediate dominators, tree, and frontier) information."
msgstr ""

#: ../../../Passes.rst:436
msgid "``-codegenprepare``: Optimize for code generation"
msgstr ""

#: ../../../Passes.rst:438
msgid ""
"This pass munges the code in the input function to better prepare it for "
"SelectionDAG-based code generation.  This works around limitations in its "
"basic-block-at-a-time approach.  It should eventually be removed."
msgstr ""

#: ../../../Passes.rst:443
msgid "``-constmerge``: Merge Duplicate Global Constants"
msgstr ""

#: ../../../Passes.rst:445
msgid ""
"Merges duplicate global constants together into a single constant that is "
"shared.  This is useful because some passes (i.e., TraceValues) insert a lot "
"of string constants into the program, regardless of whether or not an "
"existing string is available."
msgstr ""

#: ../../../Passes.rst:451
msgid "``-constprop``: Simple constant propagation"
msgstr ""

#: ../../../Passes.rst:453
msgid ""
"This pass implements constant propagation and merging.  It looks for "
"instructions involving only constant operands and replaces them with a "
"constant value instead of an instruction.  For example:"
msgstr ""

#: ../../../Passes.rst:461
msgid "becomes"
msgstr ""

#: ../../../Passes.rst:467
msgid ""
"NOTE: this pass has a habit of making definitions be dead.  It is a good "
"idea to run a :ref:`Dead Instruction Elimination <passes-die>` pass sometime "
"after running this pass."
msgstr ""

#: ../../../Passes.rst:474
msgid "``-dce``: Dead Code Elimination"
msgstr ""

#: ../../../Passes.rst:476
msgid ""
"Dead code elimination is similar to :ref:`dead instruction elimination "
"<passes-die>`, but it rechecks instructions that were used by removed "
"instructions to see if they are newly dead."
msgstr ""

#: ../../../Passes.rst:481
msgid "``-deadargelim``: Dead Argument Elimination"
msgstr ""

#: ../../../Passes.rst:483
msgid ""
"This pass deletes dead arguments from internal functions.  Dead argument "
"elimination removes arguments which are directly dead, as well as arguments "
"only passed into function calls as dead arguments of other functions.  This "
"pass also deletes dead arguments in a similar way."
msgstr ""

#: ../../../Passes.rst:488
msgid ""
"This pass is often useful as a cleanup pass to run after aggressive "
"interprocedural passes, which add possibly-dead arguments."
msgstr ""

#: ../../../Passes.rst:492
msgid "``-deadtypeelim``: Dead Type Elimination"
msgstr ""

#: ../../../Passes.rst:494
msgid ""
"This pass is used to cleanup the output of GCC.  It eliminate names for "
"types that are unused in the entire translation unit, using the :ref:`find "
"used types <passes-print-used-types>` pass."
msgstr ""

#: ../../../Passes.rst:501
msgid "``-die``: Dead Instruction Elimination"
msgstr ""

#: ../../../Passes.rst:503
msgid ""
"Dead instruction elimination performs a single pass over the function, "
"removing instructions that are obviously dead."
msgstr ""

#: ../../../Passes.rst:507
msgid "``-dse``: Dead Store Elimination"
msgstr ""

#: ../../../Passes.rst:509
msgid ""
"A trivial dead store elimination that only considers basic-block local "
"redundant stores."
msgstr ""

#: ../../../Passes.rst:515
msgid "``-functionattrs``: Deduce function attributes"
msgstr ""

#: ../../../Passes.rst:517
msgid ""
"A simple interprocedural pass which walks the call-graph, looking for "
"functions which do not access or only read non-local memory, and marking "
"them ``readnone``/``readonly``.  In addition, it marks function arguments "
"(of pointer type) \"``nocapture``\" if a call to the function does not "
"create any copies of the pointer value that outlive the call.  This more or "
"less means that the pointer is only dereferenced, and not returned from the "
"function or stored in a global.  This pass is implemented as a bottom-up "
"traversal of the call-graph."
msgstr ""

#: ../../../Passes.rst:527
msgid "``-globaldce``: Dead Global Elimination"
msgstr ""

#: ../../../Passes.rst:529
msgid ""
"This transform is designed to eliminate unreachable internal globals from "
"the program.  It uses an aggressive algorithm, searching out globals that "
"are known to be alive.  After it finds all of the globals which are needed, "
"it deletes whatever is left over.  This allows it to delete recursive chunks "
"of the program which are unreachable."
msgstr ""

#: ../../../Passes.rst:536
msgid "``-globalopt``: Global Variable Optimizer"
msgstr ""

#: ../../../Passes.rst:538
msgid ""
"This pass transforms simple global variables that never have their address "
"taken.  If obviously true, it marks read/write globals as constant, deletes "
"variables only stored to, etc."
msgstr ""

#: ../../../Passes.rst:543
msgid "``-gvn``: Global Value Numbering"
msgstr ""

#: ../../../Passes.rst:545
msgid ""
"This pass performs global value numbering to eliminate fully and partially "
"redundant instructions.  It also performs redundant load elimination."
msgstr ""

#: ../../../Passes.rst:551
msgid "``-indvars``: Canonicalize Induction Variables"
msgstr ""

#: ../../../Passes.rst:553
msgid ""
"This transformation analyzes and transforms the induction variables (and "
"computations derived from them) into simpler forms suitable for subsequent "
"analysis and transformation."
msgstr ""

#: ../../../Passes.rst:557
msgid ""
"This transformation makes the following changes to each loop with an "
"identifiable induction variable:"
msgstr ""

#: ../../../Passes.rst:560
msgid ""
"All loops are transformed to have a *single* canonical induction variable "
"which starts at zero and steps by one."
msgstr ""

#: ../../../Passes.rst:562
msgid ""
"The canonical induction variable is guaranteed to be the first PHI node in "
"the loop header block."
msgstr ""

#: ../../../Passes.rst:564
msgid "Any pointer arithmetic recurrences are raised to use array subscripts."
msgstr ""

#: ../../../Passes.rst:566
msgid ""
"If the trip count of a loop is computable, this pass also makes the "
"following changes:"
msgstr ""

#: ../../../Passes.rst:569
msgid ""
"The exit condition for the loop is canonicalized to compare the induction "
"value against the exit value.  This turns loops like:"
msgstr ""

#: ../../../Passes.rst:582
msgid ""
"Any use outside of the loop of an expression derived from the indvar is "
"changed to compute the derived value outside of the loop, eliminating the "
"dependence on the exit value of the induction variable.  If the only purpose "
"of the loop is to compute the exit value of some derived expression, this "
"transformation will make the loop dead."
msgstr ""

#: ../../../Passes.rst:588
msgid ""
"This transformation should be followed by strength reduction after all of "
"the desired loop transformations have been performed.  Additionally, on "
"targets where it is profitable, the loop could be transformed to count down "
"to zero (the \"do loop\" optimization)."
msgstr ""

#: ../../../Passes.rst:594
msgid "``-inline``: Function Integration/Inlining"
msgstr ""

#: ../../../Passes.rst:596
msgid "Bottom-up inlining of functions into callees."
msgstr ""

#: ../../../Passes.rst:601
msgid "``-instcombine``: Combine redundant instructions"
msgstr ""

#: ../../../Passes.rst:603
msgid ""
"Combine instructions to form fewer, simple instructions.  This pass does not "
"modify the CFG. This pass is where algebraic simplification happens."
msgstr ""

#: ../../../Passes.rst:606
msgid "This pass combines things like:"
msgstr ""

#: ../../../Passes.rst:613
msgid "into:"
msgstr ""

#: ../../../Passes.rst:619
msgid "This is a simple worklist driven algorithm."
msgstr ""

#: ../../../Passes.rst:621
msgid ""
"This pass guarantees that the following canonicalizations are performed on "
"the program:"
msgstr ""

#: ../../../Passes.rst:624
msgid ""
"If a binary operator has a constant operand, it is moved to the right-hand "
"side."
msgstr ""

#: ../../../Passes.rst:626
msgid ""
"Bitwise operators with constant operands are always grouped so that shifts "
"are performed first, then ``or``\\ s, then ``and``\\ s, then ``xor``\\ s."
msgstr ""

#: ../../../Passes.rst:628
msgid ""
"Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to "
"``=`` or ``≠`` if possible."
msgstr ""

#: ../../../Passes.rst:630
msgid ""
"All ``cmp`` instructions on boolean values are replaced with logical "
"operations."
msgstr ""

#: ../../../Passes.rst:632
msgid "``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``"
msgstr ""

#: ../../../Passes.rst:633
msgid ""
"Multiplies with a constant power-of-two argument are transformed into shifts."
msgstr ""

#: ../../../Passes.rst:635
msgid "… etc."
msgstr ""

#: ../../../Passes.rst:637
msgid ""
"This pass can also simplify calls to specific well-known function calls (e."
"g. runtime library functions).  For example, a call ``exit(3)`` that occurs "
"within the ``main()`` function can be transformed into simply ``return 3``. "
"Whether or not library calls are simplified is controlled by the :ref:`-"
"functionattrs <passes-functionattrs>` pass and LLVM's knowledge of library "
"calls on different targets."
msgstr ""

#: ../../../Passes.rst:645
msgid "``-internalize``: Internalize Global Symbols"
msgstr ""

#: ../../../Passes.rst:647
msgid ""
"This pass loops over all of the functions in the input module, looking for a "
"main function.  If a main function is found, all other functions and all "
"global variables with initializers are marked as internal."
msgstr ""

#: ../../../Passes.rst:652
msgid "``-ipconstprop``: Interprocedural constant propagation"
msgstr ""

#: ../../../Passes.rst:654
msgid ""
"This pass implements an *extremely* simple interprocedural constant "
"propagation pass.  It could certainly be improved in many different ways, "
"like using a worklist.  This pass makes arguments dead, but does not remove "
"them.  The existing dead argument elimination pass should be run after this "
"to clean up the mess."
msgstr ""

#: ../../../Passes.rst:661
msgid "``-ipsccp``: Interprocedural Sparse Conditional Constant Propagation"
msgstr ""

#: ../../../Passes.rst:663
msgid ""
"An interprocedural variant of :ref:`Sparse Conditional Constant Propagation "
"<passes-sccp>`."
msgstr ""

#: ../../../Passes.rst:667
msgid "``-jump-threading``: Jump Threading"
msgstr ""

#: ../../../Passes.rst:669
msgid ""
"Jump threading tries to find distinct threads of control flow running "
"through a basic block.  This pass looks at blocks that have multiple "
"predecessors and multiple successors.  If one or more of the predecessors of "
"the block can be proven to always cause a jump to one of the successors, we "
"forward the edge from the predecessor to the successor by duplicating the "
"contents of this block."
msgstr ""

#: ../../../Passes.rst:676
msgid "An example of when this can occur is code like this:"
msgstr ""

#: ../../../Passes.rst:685
msgid ""
"In this case, the unconditional branch at the end of the first if can be "
"revectored to the false side of the second if."
msgstr ""

#: ../../../Passes.rst:689
msgid "``-lcssa``: Loop-Closed SSA Form Pass"
msgstr ""

#: ../../../Passes.rst:691
msgid ""
"This pass transforms loops by placing phi nodes at the end of the loops for "
"all values that are live across the loop boundary.  For example, it turns "
"the left into the right code:"
msgstr ""

#: ../../../Passes.rst:706
msgid ""
"This is still valid LLVM; the extra phi nodes are purely redundant, and will "
"be trivially eliminated by ``InstCombine``.  The major benefit of this "
"transformation is that it makes many other loop optimizations, such as "
"``LoopUnswitch``\\ ing, simpler."
msgstr ""

#: ../../../Passes.rst:714
msgid "``-licm``: Loop Invariant Code Motion"
msgstr ""

#: ../../../Passes.rst:716
msgid ""
"This pass performs loop invariant code motion, attempting to remove as much "
"code from the body of a loop as possible.  It does this by either hoisting "
"code into the preheader block, or by sinking code to the exit blocks if it "
"is safe. This pass also promotes must-aliased memory locations in the loop "
"to live in registers, thus hoisting and sinking \"invariant\" loads and "
"stores."
msgstr ""

#: ../../../Passes.rst:722
msgid "This pass uses alias analysis for two purposes:"
msgstr ""

#: ../../../Passes.rst:724
msgid ""
"Moving loop invariant loads and calls out of loops.  If we can determine "
"that a load or call inside of a loop never aliases anything stored to, we "
"can hoist it or sink it like any other instruction."
msgstr ""

#: ../../../Passes.rst:728
msgid ""
"Scalar Promotion of Memory.  If there is a store instruction inside of the "
"loop, we try to move the store to happen AFTER the loop instead of inside of "
"the loop.  This can only happen if a few conditions are true:"
msgstr ""

#: ../../../Passes.rst:732
msgid "The pointer stored through is loop invariant."
msgstr ""

#: ../../../Passes.rst:733
msgid ""
"There are no stores or loads in the loop which *may* alias the pointer. "
"There are no calls in the loop which mod/ref the pointer."
msgstr ""

#: ../../../Passes.rst:736
msgid ""
"If these conditions are true, we can promote the loads and stores in the "
"loop of the pointer to use a temporary alloca'd variable.  We then use the :"
"ref:`mem2reg <passes-mem2reg>` functionality to construct the appropriate "
"SSA form for the variable."
msgstr ""

#: ../../../Passes.rst:742
msgid "``-loop-deletion``: Delete dead loops"
msgstr ""

#: ../../../Passes.rst:744
msgid ""
"This file implements the Dead Loop Deletion Pass.  This pass is responsible "
"for eliminating loops with non-infinite computable trip counts that have no "
"side effects or volatile instructions, and do not contribute to the "
"computation of the function's return value."
msgstr ""

#: ../../../Passes.rst:752
msgid "``-loop-extract``: Extract loops into new functions"
msgstr ""

#: ../../../Passes.rst:754
msgid ""
"A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract "
"each top-level loop into its own new function.  If the loop is the *only* "
"loop in a given function, it is not touched.  This is a pass most useful for "
"debugging via bugpoint."
msgstr ""

#: ../../../Passes.rst:760
msgid "``-loop-extract-single``: Extract at most one loop into a new function"
msgstr ""

#: ../../../Passes.rst:762
msgid ""
"Similar to :ref:`Extract loops into new functions <passes-loop-extract>`, "
"this pass extracts one natural loop from the program into a function if it "
"can. This is used by :program:`bugpoint`."
msgstr ""

#: ../../../Passes.rst:767
msgid "``-loop-reduce``: Loop Strength Reduction"
msgstr ""

#: ../../../Passes.rst:769
msgid ""
"This pass performs a strength reduction on array references inside loops "
"that have as one or more of their components the loop induction variable.  "
"This is accomplished by creating a new value to hold the initial value of "
"the array access for the first iteration, and then creating a new GEP "
"instruction in the loop to increment the value by the appropriate amount."
msgstr ""

#: ../../../Passes.rst:776
msgid "``-loop-rotate``: Rotate Loops"
msgstr ""

#: ../../../Passes.rst:778
msgid "A simple loop rotation transformation."
msgstr ""

#: ../../../Passes.rst:781
msgid "``-loop-simplify``: Canonicalize natural loops"
msgstr ""

#: ../../../Passes.rst:783
msgid ""
"This pass performs several transformations to transform natural loops into a "
"simpler form, which makes subsequent analyses and transformations simpler "
"and more effective."
msgstr ""

#: ../../../Passes.rst:787
msgid ""
"Loop pre-header insertion guarantees that there is a single, non-critical "
"entry edge from outside of the loop to the loop header.  This simplifies a "
"number of analyses and transformations, such as :ref:`LICM <passes-licm>`."
msgstr ""

#: ../../../Passes.rst:791
msgid ""
"Loop exit-block insertion guarantees that all exit blocks from the loop "
"(blocks which are outside of the loop that have predecessors inside of the "
"loop) only have predecessors from inside of the loop (and are thus dominated "
"by the loop header).  This simplifies transformations such as store-sinking "
"that are built into LICM."
msgstr ""

#: ../../../Passes.rst:797
msgid "This pass also guarantees that loops will have exactly one backedge."
msgstr ""

#: ../../../Passes.rst:799
msgid ""
"Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up "
"blocks which are split out but end up being unnecessary, so usage of this "
"pass should not pessimize generated code."
msgstr ""

#: ../../../Passes.rst:803
msgid ""
"This pass obviously modifies the CFG, but updates loop information and "
"dominator information."
msgstr ""

#: ../../../Passes.rst:807
msgid "``-loop-unroll``: Unroll loops"
msgstr ""

#: ../../../Passes.rst:809
msgid ""
"This pass implements a simple loop unroller.  It works best when loops have "
"been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it "
"to determine the trip counts of loops easily."
msgstr ""

#: ../../../Passes.rst:814
msgid "``-loop-unswitch``: Unswitch loops"
msgstr ""

#: ../../../Passes.rst:816
msgid ""
"This pass transforms loops that contain branches on loop-invariant "
"conditions to have multiple loops.  For example, it turns the left into the "
"right code:"
msgstr ""

#: ../../../Passes.rst:828
msgid ""
"This can increase the size of the code exponentially (doubling it every time "
"a loop is unswitched) so we only unswitch if the resultant code will be "
"smaller than a threshold."
msgstr ""

#: ../../../Passes.rst:832
msgid ""
"This pass expects :ref:`LICM <passes-licm>` to be run before it to hoist "
"invariant conditions out of the loop, to make the unswitching opportunity "
"obvious."
msgstr ""

#: ../../../Passes.rst:837
msgid "``-loweratomic``: Lower atomic intrinsics to non-atomic form"
msgstr ""

#: ../../../Passes.rst:839
msgid ""
"This pass lowers atomic intrinsics to non-atomic form for use in a known non-"
"preemptible environment."
msgstr ""

#: ../../../Passes.rst:842
msgid ""
"The pass does not verify that the environment is non-preemptible (in general "
"this would require knowledge of the entire call graph of the program "
"including any libraries which may not be available in bitcode form); it "
"simply lowers every atomic intrinsic."
msgstr ""

#: ../../../Passes.rst:848
msgid ""
"``-lowerinvoke``: Lower invokes to calls, for unwindless code generators"
msgstr ""

#: ../../../Passes.rst:850
msgid ""
"This transformation is designed for use by code generators which do not yet "
"support stack unwinding.  This pass converts ``invoke`` instructions to "
"``call`` instructions, so that any exception-handling ``landingpad`` blocks "
"become dead code (which can be removed by running the ``-simplifycfg`` pass "
"afterwards)."
msgstr ""

#: ../../../Passes.rst:857
msgid "``-lowerswitch``: Lower ``SwitchInst``\\ s to branches"
msgstr ""

#: ../../../Passes.rst:859
msgid ""
"Rewrites switch instructions with a sequence of branches, which allows "
"targets to get away with not implementing the switch instruction until it is "
"convenient."
msgstr ""

#: ../../../Passes.rst:866
msgid "``-mem2reg``: Promote Memory to Register"
msgstr ""

#: ../../../Passes.rst:868
msgid ""
"This file promotes memory references to be register references.  It promotes "
"alloca instructions which only have loads and stores as uses.  An ``alloca`` "
"is transformed by using dominator frontiers to place phi nodes, then "
"traversing the function in depth-first order to rewrite loads and stores as "
"appropriate. This is just the standard SSA construction algorithm to "
"construct \"pruned\" SSA form."
msgstr ""

#: ../../../Passes.rst:876
msgid "``-memcpyopt``: MemCpy Optimization"
msgstr ""

#: ../../../Passes.rst:878
msgid ""
"This pass performs various transformations related to eliminating ``memcpy`` "
"calls, or transforming sets of stores into ``memset``\\ s."
msgstr ""

#: ../../../Passes.rst:882
msgid "``-mergefunc``: Merge Functions"
msgstr ""

#: ../../../Passes.rst:884
msgid ""
"This pass looks for equivalent functions that are mergable and folds them."
msgstr ""

#: ../../../Passes.rst:886
msgid ""
"Total-ordering is introduced among the functions set: we define comparison "
"that answers for every two functions which of them is greater. It allows to "
"arrange functions into the binary tree."
msgstr ""

#: ../../../Passes.rst:890
msgid "For every new function we check for equivalent in tree."
msgstr ""

#: ../../../Passes.rst:892
msgid ""
"If equivalent exists we fold such functions. If both functions are "
"overridable, we move the functionality into a new internal function and "
"leave two overridable thunks to it."
msgstr ""

#: ../../../Passes.rst:896
msgid "If there is no equivalent, then we add this function to tree."
msgstr ""

#: ../../../Passes.rst:898
msgid ""
"Lookup routine has O(log(n)) complexity, while whole merging process has "
"complexity of O(n*log(n))."
msgstr ""

#: ../../../Passes.rst:901
msgid "Read :doc:`this <MergeFunctions>` article for more details."
msgstr ""

#: ../../../Passes.rst:906
msgid "``-mergereturn``: Unify function exit nodes"
msgstr ""

#: ../../../Passes.rst:908
msgid ""
"Ensure that functions have at most one ``ret`` instruction in them. "
"Additionally, it keeps track of which node is the new exit node of the CFG."
msgstr ""

#: ../../../Passes.rst:912
msgid "``-partial-inliner``: Partial Inliner"
msgstr ""

#: ../../../Passes.rst:914
msgid ""
"This pass performs partial inlining, typically by inlining an ``if`` "
"statement that surrounds the body of the function."
msgstr ""

#: ../../../Passes.rst:918
msgid "``-prune-eh``: Remove unused exception handling info"
msgstr ""

#: ../../../Passes.rst:920
msgid ""
"This file implements a simple interprocedural pass which walks the call-"
"graph, turning invoke instructions into call instructions if and only if the "
"callee cannot throw an exception.  It implements this as a bottom-up "
"traversal of the call-graph."
msgstr ""

#: ../../../Passes.rst:926
msgid "``-reassociate``: Reassociate expressions"
msgstr ""

#: ../../../Passes.rst:928
msgid ""
"This pass reassociates commutative expressions in an order that is designed "
"to promote better constant propagation, GCSE, :ref:`LICM <passes-licm>`, "
"PRE, etc."
msgstr ""

#: ../../../Passes.rst:931
msgid "For example: 4 + (x + 5) ⇒ x + (4 + 5)"
msgstr ""

#: ../../../Passes.rst:933
msgid ""
"In the implementation of this algorithm, constants are assigned rank = 0, "
"function arguments are rank = 1, and other values are assigned ranks "
"corresponding to the reverse post order traversal of current function "
"(starting at 2), which effectively gives values in deep loops higher rank "
"than values not in loops."
msgstr ""

#: ../../../Passes.rst:940
msgid "``-reg2mem``: Demote all values to stack slots"
msgstr ""

#: ../../../Passes.rst:942
msgid ""
"This file demotes all registers to memory references.  It is intended to be "
"the inverse of :ref:`mem2reg <passes-mem2reg>`.  By converting to ``load`` "
"instructions, the only values live across basic blocks are ``alloca`` "
"instructions and ``load`` instructions before ``phi`` nodes.  It is intended "
"that this should make CFG hacking much easier.  To make later hacking "
"easier, the entry block is split into two, such that all introduced "
"``alloca`` instructions (and nothing else) are in the entry block."
msgstr ""

#: ../../../Passes.rst:951
msgid "``-sroa``: Scalar Replacement of Aggregates"
msgstr ""

#: ../../../Passes.rst:953
msgid ""
"The well-known scalar replacement of aggregates transformation.  This "
"transform breaks up ``alloca`` instructions of aggregate type (structure or "
"array) into individual ``alloca`` instructions for each member if possible.  "
"Then, if possible, it transforms the individual ``alloca`` instructions into "
"nice clean scalar SSA form."
msgstr ""

#: ../../../Passes.rst:962
msgid "``-sccp``: Sparse Conditional Constant Propagation"
msgstr ""

#: ../../../Passes.rst:964
msgid ""
"Sparse conditional constant propagation and merging, which can be summarized "
"as:"
msgstr ""

#: ../../../Passes.rst:967
msgid "Assumes values are constant unless proven otherwise"
msgstr ""

#: ../../../Passes.rst:968
msgid "Assumes BasicBlocks are dead unless proven otherwise"
msgstr ""

#: ../../../Passes.rst:969
msgid "Proves values to be constant, and replaces them with constants"
msgstr ""

#: ../../../Passes.rst:970
msgid "Proves conditional branches to be unconditional"
msgstr ""

#: ../../../Passes.rst:972
msgid ""
"Note that this pass has a habit of making definitions be dead.  It is a good "
"idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass."
msgstr ""

#: ../../../Passes.rst:978
msgid "``-simplifycfg``: Simplify the CFG"
msgstr ""

#: ../../../Passes.rst:980
msgid "Performs dead code elimination and basic block merging.  Specifically:"
msgstr ""

#: ../../../Passes.rst:982
msgid "Removes basic blocks with no predecessors."
msgstr ""

#: ../../../Passes.rst:983
msgid ""
"Merges a basic block into its predecessor if there is only one and the "
"predecessor only has one successor."
msgstr ""

#: ../../../Passes.rst:985
msgid "Eliminates PHI nodes for basic blocks with a single predecessor."
msgstr ""

#: ../../../Passes.rst:986
msgid "Eliminates a basic block that only contains an unconditional branch."
msgstr ""

#: ../../../Passes.rst:989
msgid "``-sink``: Code sinking"
msgstr ""

#: ../../../Passes.rst:991
msgid ""
"This pass moves instructions into successor blocks, when possible, so that "
"they aren't executed on paths where their results aren't needed."
msgstr ""

#: ../../../Passes.rst:995
msgid "``-strip``: Strip all symbols from a module"
msgstr ""

#: ../../../Passes.rst:997
msgid "Performs code stripping.  This transformation can delete:"
msgstr ""

#: ../../../Passes.rst:999 ../../../Passes.rst:1014 ../../../Passes.rst:1037
#: ../../../Passes.rst:1052
msgid "names for virtual registers"
msgstr ""

#: ../../../Passes.rst:1000 ../../../Passes.rst:1015 ../../../Passes.rst:1038
#: ../../../Passes.rst:1053
msgid "symbols for internal globals and functions"
msgstr ""

#: ../../../Passes.rst:1001 ../../../Passes.rst:1016 ../../../Passes.rst:1039
#: ../../../Passes.rst:1054
msgid "debug information"
msgstr ""

#: ../../../Passes.rst:1003
msgid ""
"Note that this transformation makes code much less readable, so it should "
"only be used in situations where the strip utility would be used, such as "
"reducing code size or making it harder to reverse engineer code."
msgstr ""

#: ../../../Passes.rst:1008
msgid "``-strip-dead-debug-info``: Strip debug info for unused symbols"
msgstr ""

#: ../../../Passes.rst:1012
msgid "performs code stripping. this transformation can delete:"
msgstr ""

#: ../../../Passes.rst:1018
msgid ""
"note that this transformation makes code much less readable, so it should "
"only be used in situations where the strip utility would be used, such as "
"reducing code size or making it harder to reverse engineer code."
msgstr ""

#: ../../../Passes.rst:1023
msgid "``-strip-dead-prototypes``: Strip Unused Function Prototypes"
msgstr ""

#: ../../../Passes.rst:1025
msgid ""
"This pass loops over all of the functions in the input module, looking for "
"dead declarations and removes them.  Dead declarations are declarations of "
"functions for which no implementation is available (i.e., declarations for "
"unused library functions)."
msgstr ""

#: ../../../Passes.rst:1031
msgid "``-strip-debug-declare``: Strip all ``llvm.dbg.declare`` intrinsics"
msgstr ""

#: ../../../Passes.rst:1035 ../../../Passes.rst:1050
msgid "This pass implements code stripping.  Specifically, it can delete:"
msgstr ""

#: ../../../Passes.rst:1041 ../../../Passes.rst:1056
msgid ""
"Note that this transformation makes code much less readable, so it should "
"only be used in situations where the 'strip' utility would be used, such as "
"reducing code size or making it harder to reverse engineer code."
msgstr ""

#: ../../../Passes.rst:1046
msgid ""
"``-strip-nondebug``: Strip all symbols, except dbg symbols, from a module"
msgstr ""

#: ../../../Passes.rst:1061
msgid "``-tailcallelim``: Tail Call Elimination"
msgstr ""

#: ../../../Passes.rst:1063
msgid ""
"This file transforms calls of the current function (self recursion) followed "
"by a return instruction with a branch to the entry of the function, creating "
"a loop.  This pass also implements the following extensions to the basic "
"algorithm:"
msgstr ""

#: ../../../Passes.rst:1068
msgid ""
"Trivial instructions between the call and return do not prevent the "
"transformation from taking place, though currently the analysis cannot "
"support moving any really useful instructions (only dead ones)."
msgstr ""

#: ../../../Passes.rst:1071
msgid ""
"This pass transforms functions that are prevented from being tail recursive "
"by an associative expression to use an accumulator variable, thus compiling "
"the typical naive factorial or fib implementation into efficient code."
msgstr ""

#: ../../../Passes.rst:1074
msgid ""
"TRE is performed if the function returns void, if the return returns the "
"result returned by the call, or if the function returns a run-time constant "
"on all exits from the function.  It is possible, though unlikely, that the "
"return returns something else (like constant 0), and can still be TRE'd.  It "
"can be TRE'd if *all other* return instructions in the function return the "
"exact same value."
msgstr ""

#: ../../../Passes.rst:1080
msgid ""
"If it can prove that callees do not access theier caller stack frame, they "
"are marked as eligible for tail call elimination (by the code generator)."
msgstr ""

#: ../../../Passes.rst:1084
msgid "Utility Passes"
msgstr ""

#: ../../../Passes.rst:1086
msgid "This section describes the LLVM Utility Passes."
msgstr ""

#: ../../../Passes.rst:1089
msgid ""
"``-deadarghaX0r``: Dead Argument Hacking (BUGPOINT USE ONLY; DO NOT USE)"
msgstr ""

#: ../../../Passes.rst:1091
msgid ""
"Same as dead argument elimination, but deletes arguments to functions which "
"are external.  This is only for use by :doc:`bugpoint <Bugpoint>`."
msgstr ""

#: ../../../Passes.rst:1095
msgid ""
"``-extract-blocks``: Extract Basic Blocks From Module (for bugpoint use)"
msgstr ""

#: ../../../Passes.rst:1097
msgid ""
"This pass is used by bugpoint to extract all blocks from the module into "
"their own functions."
msgstr ""

#: ../../../Passes.rst:1101
msgid "``-instnamer``: Assign names to anonymous instructions"
msgstr ""

#: ../../../Passes.rst:1103
msgid ""
"This is a little utility pass that gives instructions names, this is mostly "
"useful when diffing the effect of an optimization because deleting an "
"unnamed instruction can change all other instruction numbering, making the "
"diff very noisy."
msgstr ""

#: ../../../Passes.rst:1111
msgid "``-verify``: Module Verifier"
msgstr ""

#: ../../../Passes.rst:1113
msgid ""
"Verifies an LLVM IR code.  This is useful to run after an optimization which "
"is undergoing testing.  Note that llvm-as verifies its input before emitting "
"bitcode, and also that malformed bitcode is likely to make LLVM crash.  All "
"language front-ends are therefore encouraged to verify their output before "
"performing optimizing transformations."
msgstr ""

#: ../../../Passes.rst:1119
msgid "Both of a binary operator's parameters are of the same type."
msgstr ""

#: ../../../Passes.rst:1120
msgid ""
"Verify that the indices of mem access instructions match other operands."
msgstr ""

#: ../../../Passes.rst:1121
msgid ""
"Verify that arithmetic and other things are only performed on first-class "
"types.  Verify that shifts and logicals only happen on integrals f.e."
msgstr ""

#: ../../../Passes.rst:1123
msgid "All of the constants in a switch statement are of the correct type."
msgstr ""

#: ../../../Passes.rst:1124
msgid "The code is in valid SSA form."
msgstr ""

#: ../../../Passes.rst:1125
msgid ""
"It is illegal to put a label into any other type (like a structure) or to "
"return one."
msgstr ""

#: ../../../Passes.rst:1127
msgid ""
"Only phi nodes can be self referential: ``%x = add i32 %x``, ``%x`` is "
"invalid."
msgstr ""

#: ../../../Passes.rst:1129
msgid "PHI nodes must have an entry for each predecessor, with no extras."
msgstr ""

#: ../../../Passes.rst:1130
msgid ""
"PHI nodes must be the first thing in a basic block, all grouped together."
msgstr ""

#: ../../../Passes.rst:1131
msgid "PHI nodes must have at least one entry."
msgstr ""

#: ../../../Passes.rst:1132
msgid ""
"All basic blocks should only end with terminator insts, not contain them."
msgstr ""

#: ../../../Passes.rst:1133
msgid "The entry node to a function must not have predecessors."
msgstr ""

#: ../../../Passes.rst:1134
msgid "All Instructions must be embedded into a basic block."
msgstr ""

#: ../../../Passes.rst:1135
msgid "Functions cannot take a void-typed parameter."
msgstr ""

#: ../../../Passes.rst:1136
msgid "Verify that a function's argument list agrees with its declared type."
msgstr ""

#: ../../../Passes.rst:1137
msgid "It is illegal to specify a name for a void value."
msgstr ""

#: ../../../Passes.rst:1138
msgid "It is illegal to have an internal global value with no initializer."
msgstr ""

#: ../../../Passes.rst:1139
msgid ""
"It is illegal to have a ``ret`` instruction that returns a value that does "
"not agree with the function return value type."
msgstr ""

#: ../../../Passes.rst:1141
msgid "Function call argument types match the function prototype."
msgstr ""

#: ../../../Passes.rst:1142
msgid "All other things that are tested by asserts spread about the code."
msgstr ""

#: ../../../Passes.rst:1144
msgid ""
"Note that this does not provide full security verification (like Java), but "
"instead just tries to ensure that code is well-formed."
msgstr ""

#: ../../../Passes.rst:1148
msgid "``-view-cfg``: View CFG of function"
msgstr ""

#: ../../../Passes.rst:1150
msgid "Displays the control flow graph using the GraphViz tool."
msgstr ""

#: ../../../Passes.rst:1153
msgid "``-view-cfg-only``: View CFG of function (with no function bodies)"
msgstr ""

#: ../../../Passes.rst:1155
msgid ""
"Displays the control flow graph using the GraphViz tool, but omitting "
"function bodies."
msgstr ""

#: ../../../Passes.rst:1159
msgid "``-view-dom``: View dominance tree of function"
msgstr ""

#: ../../../Passes.rst:1161
msgid "Displays the dominator tree using the GraphViz tool."
msgstr ""

#: ../../../Passes.rst:1164
msgid ""
"``-view-dom-only``: View dominance tree of function (with no function bodies)"
msgstr ""

#: ../../../Passes.rst:1166
msgid ""
"Displays the dominator tree using the GraphViz tool, but omitting function "
"bodies."
msgstr ""

#: ../../../Passes.rst:1170
msgid "``-view-postdom``: View postdominance tree of function"
msgstr ""

#: ../../../Passes.rst:1172
msgid "Displays the post dominator tree using the GraphViz tool."
msgstr ""

#: ../../../Passes.rst:1175
msgid ""
"``-view-postdom-only``: View postdominance tree of function (with no "
"function bodies)"
msgstr ""

#: ../../../Passes.rst:1177
msgid ""
"Displays the post dominator tree using the GraphViz tool, but omitting "
"function bodies."
msgstr ""
