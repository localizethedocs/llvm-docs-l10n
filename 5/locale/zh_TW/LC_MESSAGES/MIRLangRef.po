# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../MIRLangRef.rst:3
msgid "Machine IR (MIR) Format Reference Manual"
msgstr ""

#: ../../../MIRLangRef.rst:9
msgid "This is a work in progress."
msgstr ""

#: ../../../MIRLangRef.rst:12
msgid "Introduction"
msgstr ""

#: ../../../MIRLangRef.rst:14
msgid ""
"This document is a reference manual for the Machine IR (MIR) serialization "
"format. MIR is a human readable serialization format that is used to "
"represent LLVM's :ref:`machine specific intermediate representation <machine "
"code representation>`."
msgstr ""

#: ../../../MIRLangRef.rst:19
msgid ""
"The MIR serialization format is designed to be used for testing the code "
"generation passes in LLVM."
msgstr ""

#: ../../../MIRLangRef.rst:23
msgid "Overview"
msgstr ""

#: ../../../MIRLangRef.rst:25
msgid ""
"The MIR serialization format uses a YAML container. YAML is a standard data "
"serialization language, and the full YAML language spec can be read at `yaml."
"org <http://www.yaml.org/spec/1.2/spec.html#Introduction>`_."
msgstr ""

#: ../../../MIRLangRef.rst:30
msgid ""
"A MIR file is split up into a series of `YAML documents`_. The first "
"document can contain an optional embedded LLVM IR module, and the rest of "
"the documents contain the serialized machine functions."
msgstr ""

#: ../../../MIRLangRef.rst:37
msgid "MIR Testing Guide"
msgstr ""

#: ../../../MIRLangRef.rst:39
msgid "You can use the MIR format for testing in two different ways:"
msgstr ""

#: ../../../MIRLangRef.rst:41
msgid ""
"You can write MIR tests that invoke a single code generation pass using the "
"``-run-pass`` option in llc."
msgstr ""

#: ../../../MIRLangRef.rst:44
msgid ""
"You can use llc's ``-stop-after`` option with existing or new LLVM assembly "
"tests and check the MIR output of a specific code generation pass."
msgstr ""

#: ../../../MIRLangRef.rst:48
msgid "Testing Individual Code Generation Passes"
msgstr ""

#: ../../../MIRLangRef.rst:50
msgid ""
"The ``-run-pass`` option in llc allows you to create MIR tests that invoke "
"just a single code generation pass. When this option is used, llc will parse "
"an input MIR file, run the specified code generation pass(es), and output "
"the resulting MIR code."
msgstr ""

#: ../../../MIRLangRef.rst:55
msgid ""
"You can generate an input MIR file for the test by using the ``-stop-after`` "
"or ``-stop-before`` option in llc. For example, if you would like to write a "
"test for the post register allocation pseudo instruction expansion pass, you "
"can specify the machine copy propagation pass in the ``-stop-after`` option, "
"as it runs just before the pass that we are trying to test:"
msgstr ""

#: ../../../MIRLangRef.rst:61
msgid "``llc -stop-after=machine-cp bug-trigger.ll > test.mir``"
msgstr ""

#: ../../../MIRLangRef.rst:63
msgid ""
"After generating the input MIR file, you'll have to add a run line that uses "
"the ``-run-pass`` option to it. In order to test the post register "
"allocation pseudo instruction expansion pass on X86-64, a run line like the "
"one shown below can be used:"
msgstr ""

#: ../../../MIRLangRef.rst:68
msgid ""
"``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck "
"%s``"
msgstr ""

#: ../../../MIRLangRef.rst:70
msgid ""
"The MIR files are target dependent, so they have to be placed in the target "
"specific test directories (``lib/CodeGen/TARGETNAME``). They also need to "
"specify a target triple or a target architecture either in the run line or "
"in the embedded LLVM IR module."
msgstr ""

#: ../../../MIRLangRef.rst:76
msgid "Simplifying MIR files"
msgstr ""

#: ../../../MIRLangRef.rst:78
msgid ""
"The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose; "
"Tests are more accessible and future proof when simplified:"
msgstr ""

#: ../../../MIRLangRef.rst:81
msgid "Use the ``-simplify-mir`` option with llc."
msgstr ""

#: ../../../MIRLangRef.rst:83
msgid ""
"Machine function attributes often have default values or the test works just "
"as well with default values. Typical candidates for this are: `alignment:`, "
"`exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`. The whole "
"`frameInfo` section is often unnecessary if there is no special frame usage "
"in the function. `tracksRegLiveness` on the other hand is often necessary "
"for some passes that care about block livein lists."
msgstr ""

#: ../../../MIRLangRef.rst:90
msgid ""
"The (global) `liveins:` list is typically only interesting for early "
"instruction selection passes and can be removed when testing later passes. "
"The per-block `liveins:` on the other hand are necessary if "
"`tracksRegLiveness` is true."
msgstr ""

#: ../../../MIRLangRef.rst:95
msgid ""
"Branch probability data in block `successors:` lists can be dropped if the "
"test doesn't depend on it. Example: `successors: %bb.1(0x40000000), "
"%bb.2(0x40000000)` can be replaced with `successors: %bb.1, %bb.2`."
msgstr ""

#: ../../../MIRLangRef.rst:100
msgid ""
"MIR code contains a whole IR module. This is necessary because there are no "
"equivalents in MIR for global variables, references to external functions, "
"function attributes, metadata, debug info. Instead some MIR data references "
"the IR constructs. You can often remove them if the test doesn't depend on "
"them."
msgstr ""

#: ../../../MIRLangRef.rst:106
msgid ""
"Alias Analysis is performed on IR values. These are referenced by memory "
"operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`. If "
"the test doesn't depend on (good) alias analysis the references can be "
"dropped: `:: (load 8)`"
msgstr ""

#: ../../../MIRLangRef.rst:111
msgid ""
"MIR blocks can reference IR blocks for debug printing, profile information "
"or debug locations. Example: `bb.42.myblock` in MIR references the IR block "
"`myblock`. It is usually possible to drop the `.myblock` reference and "
"simply use `bb.42`."
msgstr ""

#: ../../../MIRLangRef.rst:116
msgid ""
"If there are no memory operands or blocks referencing the IR then the IR "
"function can be replaced by a parameterless dummy function like `define "
"@func() { ret void }`."
msgstr ""

#: ../../../MIRLangRef.rst:120
msgid ""
"It is possible to drop the whole IR section of the MIR file if it only "
"contains dummy functions (see above). The .mir loader will create the IR "
"functions automatically in this case."
msgstr ""

#: ../../../MIRLangRef.rst:125
msgid "Limitations"
msgstr ""

#: ../../../MIRLangRef.rst:127
msgid ""
"Currently the MIR format has several limitations in terms of which state it "
"can serialize:"
msgstr ""

#: ../../../MIRLangRef.rst:130
msgid ""
"The target-specific state in the target-specific ``MachineFunctionInfo`` "
"subclasses isn't serialized at the moment."
msgstr ""

#: ../../../MIRLangRef.rst:133
msgid ""
"The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and "
"SystemZ backends) aren't serialized at the moment."
msgstr ""

#: ../../../MIRLangRef.rst:136
msgid ""
"The ``MCSymbol`` machine operands are only printed, they can't be parsed."
msgstr ""

#: ../../../MIRLangRef.rst:138
msgid ""
"A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI "
"instructions and the variable debug information from MMI is serialized right "
"now."
msgstr ""

#: ../../../MIRLangRef.rst:142
msgid ""
"These limitations impose restrictions on what you can test with the MIR "
"format. For now, tests that would like to test some behaviour that depends "
"on the state of certain ``MCSymbol``  operands or the exception handling "
"state in MMI, can't use the MIR format. As well as that, tests that test "
"some behaviour that depends on the state of the target specific "
"``MachineFunctionInfo`` or ``MachineConstantPoolValue`` subclasses can't use "
"the MIR format at the moment."
msgstr ""

#: ../../../MIRLangRef.rst:150
msgid "High Level Structure"
msgstr ""

#: ../../../MIRLangRef.rst:155
msgid "Embedded Module"
msgstr ""

#: ../../../MIRLangRef.rst:157
msgid ""
"When the first YAML document contains a `YAML block literal string`_, the "
"MIR parser will treat this string as an LLVM assembly language string that "
"represents an embedded LLVM IR module. Here is an example of a YAML document "
"that contains an LLVM module:"
msgstr ""

#: ../../../MIRLangRef.rst:175
msgid "Machine Functions"
msgstr ""

#: ../../../MIRLangRef.rst:177
msgid ""
"The remaining YAML documents contain the machine functions. This is an "
"example of such YAML document:"
msgstr ""

#: ../../../MIRLangRef.rst:197
msgid ""
"The document above consists of attributes that represent the various "
"properties and data structures in a machine function."
msgstr ""

#: ../../../MIRLangRef.rst:200
msgid ""
"The attribute ``name`` is required, and its value should be identical to the "
"name of a function that this machine function is based on."
msgstr ""

#: ../../../MIRLangRef.rst:203
msgid ""
"The attribute ``body`` is a `YAML block literal string`_. Its value "
"represents the function's machine basic blocks and their machine "
"instructions."
msgstr ""

#: ../../../MIRLangRef.rst:207
msgid "Machine Instructions Format Reference"
msgstr ""

#: ../../../MIRLangRef.rst:209
msgid ""
"The machine basic blocks and their instructions are represented using a "
"custom, human readable serialization language. This language is used in the "
"`YAML block literal string`_ that corresponds to the machine function's body."
msgstr ""

#: ../../../MIRLangRef.rst:213
msgid ""
"A source string that uses this language contains a list of machine basic "
"blocks, which are described in the section below."
msgstr ""

#: ../../../MIRLangRef.rst:217
msgid "Machine Basic Blocks"
msgstr ""

#: ../../../MIRLangRef.rst:219
msgid ""
"A machine basic block is defined in a single block definition source "
"construct that contains the block's ID. The example below defines two blocks "
"that have an ID of zero and one:"
msgstr ""

#: ../../../MIRLangRef.rst:230
msgid ""
"A machine basic block can also have a name. It should be specified after the "
"ID in the block's definition:"
msgstr ""

#: ../../../MIRLangRef.rst:238
msgid ""
"The block's name should be identical to the name of the IR block that this "
"machine block is based on."
msgstr ""

#: ../../../MIRLangRef.rst:242
msgid "Block References"
msgstr ""

#: ../../../MIRLangRef.rst:244
msgid ""
"The machine basic blocks are identified by their ID numbers. Individual "
"blocks are referenced using the following syntax:"
msgstr ""

#: ../../../MIRLangRef.rst:251
msgid "Examples:"
msgstr ""

#: ../../../MIRLangRef.rst:259
msgid "Successors"
msgstr ""

#: ../../../MIRLangRef.rst:261
msgid ""
"The machine basic block's successors have to be specified before any of the "
"instructions:"
msgstr ""

#: ../../../MIRLangRef.rst:274
msgid ""
"The branch weights can be specified in brackets after the successor blocks. "
"The example below defines a block that has two successors with branch "
"weights of 32 and 16:"
msgstr ""

#: ../../../MIRLangRef.rst:286
msgid "Live In Registers"
msgstr ""

#: ../../../MIRLangRef.rst:288
msgid ""
"The machine basic block's live in registers have to be specified before any "
"of the instructions:"
msgstr ""

#: ../../../MIRLangRef.rst:296
msgid ""
"The list of live in registers and successors can be empty. The language also "
"allows multiple live in register and successor lists - they are combined "
"into one list by the parser."
msgstr ""

#: ../../../MIRLangRef.rst:301
msgid "Miscellaneous Attributes"
msgstr ""

#: ../../../MIRLangRef.rst:303
msgid ""
"The attributes ``IsAddressTaken``, ``IsLandingPad`` and ``Alignment`` can be "
"specified in brackets after the block's definition:"
msgstr ""

#: ../../../MIRLangRef.rst:319
msgid "Machine Instructions"
msgstr ""

#: ../../../MIRLangRef.rst:321
msgid ""
"A machine instruction is composed of a name, :ref:`machine operands <machine-"
"operands>`, :ref:`instruction flags <instruction-flags>`, and machine memory "
"operands."
msgstr ""

#: ../../../MIRLangRef.rst:325
msgid ""
"The instruction's name is usually specified before the operands. The example "
"below shows an instance of the X86 ``RETQ`` instruction with a single "
"machine operand:"
msgstr ""

#: ../../../MIRLangRef.rst:333
msgid ""
"However, if the machine instruction has one or more explicitly defined "
"register operands, the instruction's name has to be specified after them. "
"The example below shows an instance of the AArch64 ``LDPXpost`` instruction "
"with three defined register operands:"
msgstr ""

#: ../../../MIRLangRef.rst:342
msgid ""
"The instruction names are serialized using the exact definitions from the "
"target's ``*InstrInfo.td`` files, and they are case sensitive. This means "
"that similar instruction names like ``TSTri`` and ``tSTRi`` represent "
"different machine instructions."
msgstr ""

#: ../../../MIRLangRef.rst:350
msgid "Instruction Flags"
msgstr ""

#: ../../../MIRLangRef.rst:352
msgid ""
"The flag ``frame-setup`` can be specified before the instruction's name:"
msgstr ""

#: ../../../MIRLangRef.rst:361
msgid "Registers"
msgstr ""

#: ../../../MIRLangRef.rst:363
msgid ""
"Registers are one of the key primitives in the machine instructions "
"serialization language. They are primarly used in the :ref:`register machine "
"operands <register-operands>`, but they can also be used in a number of "
"other places, like the :ref:`basic block's live in list <bb-liveins>`."
msgstr ""

#: ../../../MIRLangRef.rst:369
msgid ""
"The physical registers are identified by their name. They use the following "
"syntax:"
msgstr ""

#: ../../../MIRLangRef.rst:376
msgid "The example below shows three X86 physical registers:"
msgstr ""

#: ../../../MIRLangRef.rst:384
msgid ""
"The virtual registers are identified by their ID number. They use the "
"following syntax:"
msgstr ""

#: ../../../MIRLangRef.rst:391
msgid "Example:"
msgstr ""

#: ../../../MIRLangRef.rst:397
msgid ""
"The null registers are represented using an underscore ('``_``'). They can "
"also be represented using a '``%noreg``' named register, although the former "
"syntax is preferred."
msgstr ""

#: ../../../MIRLangRef.rst:404
msgid "Machine Operands"
msgstr ""

#: ../../../MIRLangRef.rst:406
msgid ""
"There are seventeen different kinds of machine operands, and all of them, "
"except the ``MCSymbol`` operand, can be serialized. The ``MCSymbol`` "
"operands are just printed out - they can't be parsed back yet."
msgstr ""

#: ../../../MIRLangRef.rst:411
msgid "Immediate Operands"
msgstr ""

#: ../../../MIRLangRef.rst:413
msgid ""
"The immediate machine operands are untyped, 64-bit signed integers. The "
"example below shows an instance of the X86 ``MOV32ri`` instruction that has "
"an immediate machine operand ``-42``:"
msgstr ""

#: ../../../MIRLangRef.rst:426
msgid "Register Operands"
msgstr ""

#: ../../../MIRLangRef.rst:428
msgid ""
"The :ref:`register <registers>` primitive is used to represent the register "
"machine operands. The register operands can also have optional :ref:"
"`register flags <register-flags>`, :ref:`a subregister index <subregister-"
"indices>`, and a reference to the tied register operand. The full syntax of "
"a register operand is shown below:"
msgstr ""

#: ../../../MIRLangRef.rst:439
msgid ""
"This example shows an instance of the X86 ``XOR32rr`` instruction that has 5 "
"register operands with different register flags:"
msgstr ""

#: ../../../MIRLangRef.rst:449
msgid "Register Flags"
msgstr ""

#: ../../../MIRLangRef.rst:451
msgid ""
"The table below shows all of the possible register flags along with the "
"corresponding internal ``llvm::RegState`` representation:"
msgstr ""

#: ../../../MIRLangRef.rst:457
msgid "Flag"
msgstr ""

#: ../../../MIRLangRef.rst:458
msgid "Internal Value"
msgstr ""

#: ../../../MIRLangRef.rst:460
msgid "``implicit``"
msgstr ""

#: ../../../MIRLangRef.rst:461
msgid "``RegState::Implicit``"
msgstr ""

#: ../../../MIRLangRef.rst:463
msgid "``implicit-def``"
msgstr ""

#: ../../../MIRLangRef.rst:464
msgid "``RegState::ImplicitDefine``"
msgstr ""

#: ../../../MIRLangRef.rst:466
msgid "``def``"
msgstr ""

#: ../../../MIRLangRef.rst:467
msgid "``RegState::Define``"
msgstr ""

#: ../../../MIRLangRef.rst:469
msgid "``dead``"
msgstr ""

#: ../../../MIRLangRef.rst:470
msgid "``RegState::Dead``"
msgstr ""

#: ../../../MIRLangRef.rst:472
msgid "``killed``"
msgstr ""

#: ../../../MIRLangRef.rst:473
msgid "``RegState::Kill``"
msgstr ""

#: ../../../MIRLangRef.rst:475
msgid "``undef``"
msgstr ""

#: ../../../MIRLangRef.rst:476
msgid "``RegState::Undef``"
msgstr ""

#: ../../../MIRLangRef.rst:478
msgid "``internal``"
msgstr ""

#: ../../../MIRLangRef.rst:479
msgid "``RegState::InternalRead``"
msgstr ""

#: ../../../MIRLangRef.rst:481
msgid "``early-clobber``"
msgstr ""

#: ../../../MIRLangRef.rst:482
msgid "``RegState::EarlyClobber``"
msgstr ""

#: ../../../MIRLangRef.rst:484
msgid "``debug-use``"
msgstr ""

#: ../../../MIRLangRef.rst:485
msgid "``RegState::Debug``"
msgstr ""

#: ../../../MIRLangRef.rst:490
msgid "Subregister Indices"
msgstr ""

#: ../../../MIRLangRef.rst:492
msgid ""
"The register machine operands can reference a portion of a register by using "
"the subregister indices. The example below shows an instance of the ``COPY`` "
"pseudo instruction that uses the X86 ``sub_8bit`` subregister index to copy "
"8 lower bits from the 32-bit virtual register 0 to the 8-bit virtual "
"register 1:"
msgstr ""

#: ../../../MIRLangRef.rst:501
msgid ""
"The names of the subregister indices are target specific, and are typically "
"defined in the target's ``*RegisterInfo.td`` file."
msgstr ""

#: ../../../MIRLangRef.rst:505
msgid "Global Value Operands"
msgstr ""

#: ../../../MIRLangRef.rst:507
msgid ""
"The global value machine operands reference the global values from the :ref:"
"`embedded LLVM IR module <embedded-module>`. The example below shows an "
"instance of the X86 ``MOV64rm`` instruction that has a global value operand "
"named ``G``:"
msgstr ""

#: ../../../MIRLangRef.rst:516
msgid ""
"The named global values are represented using an identifier with the '@' "
"prefix. If the identifier doesn't match the regular expression `[-a-zA-Z$._]"
"[-a-zA-Z$._0-9]*`, then this identifier must be quoted."
msgstr ""

#: ../../../MIRLangRef.rst:520
msgid ""
"The unnamed global values are represented using an unsigned numeric value "
"with the '@' prefix, like in the following examples: ``@0``, ``@989``."
msgstr ""
