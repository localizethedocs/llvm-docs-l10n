# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../GlobalISel/MIRPatterns.rst:6
msgid "MIR Patterns in TableGen"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:13
msgid "User's Guide"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:15
msgid ""
"This section is intended for developers who want to use MIR patterns in "
"their TableGen files."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:18
msgid ""
"``NOTE``: This feature is still in active development. This document may "
"become outdated over time. If you see something that's incorrect, please "
"update it."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:23
msgid "Use Cases"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:25
msgid "MIR patterns are supported in the following places:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:27
msgid "GlobalISel ``GICombineRule``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:28
msgid "GlobalISel ``GICombinePatFrag``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:31
msgid "Syntax"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:33
msgid "MIR patterns use the DAG datatype in TableGen."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:39
msgid ""
"``inst`` must be a def which inherits from ``Instruction`` (e.g. ``G_FADD``) "
"or ``GICombinePatFrag``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:42
msgid "Operands essentially fall into one of two categories:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:44
msgid "immediates"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:46
msgid "untyped, unnamed: ``0``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:47
msgid "untyped, named: ``0:$y``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:48
msgid "typed, unnamed: ``(i32 0)``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:49
msgid "typed, named: ``(i32 0):$y``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:51
msgid "machine operands"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:53
msgid "untyped: ``$x``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:54
msgid "typed: ``i32:$x``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:56
#: ../../../GlobalISel/MIRPatterns.rst:122
#: ../../../GlobalISel/MIRPatterns.rst:165
#: ../../../GlobalISel/MIRPatterns.rst:180
msgid "Semantics:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:58
msgid "A typed operand always adds an operand type check to the matcher."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:59
msgid "There is a trivial type inference system to propagate types."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:61
msgid ""
"e.g. You only need to use ``i32:$x`` once in any pattern of a "
"``GICombinePatFrag`` alternative or ``GICombineRule``, then all other "
"patterns in that rule/alternative can simply use ``$x`` (``i32:$x`` is "
"redundant)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:66
msgid ""
"A named operand's behavior depends on whether the name has been seen before."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:68
msgid ""
"For match patterns, reusing an operand name checks that the operands are "
"identical (see example 2 below)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:70
msgid ""
"For apply patterns, reusing an operand name simply copies that operand into "
"the new instruction (see example 2 below)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:73
msgid ""
"Operands are ordered just like they would be in a MachineInstr: the defs "
"(outs) come first, then the uses (ins)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:76
msgid ""
"Patterns are generally grouped into another DAG datatype with a dummy "
"operator such as ``match``, ``apply`` or ``pattern``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:79
msgid ""
"Finally, any DAG datatype in TableGen can be named. This also holds for "
"patterns. e.g. the following is valid: ``(G_FOO $root, (i32 0):$cst):"
"$mypat``. This may also be helpful to debug issues. Patterns are *always* "
"named, and if they don't have a name, an \"anonymous\" one is given to them. "
"If you're trying to debug an error related to a MIR pattern, but the error "
"mentions an anonymous pattern, you can try naming your patterns to see "
"exactly where the issue is."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:86
msgid "Pattern Example 1"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:95
msgid "Pattern Example 2"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:105
msgid "Types"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:108
msgid "ValueType"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:110
msgid "Subclasses of ``ValueType`` are valid types, e.g. ``i32``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:113
msgid "GITypeOf"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:115
msgid ""
"``GITypeOf<\"$x\">`` is a ``GISpecialType`` that allows for the creation of "
"a register or immediate with the same type as another (register) operand."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:118
msgid "Operand:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:120
msgid "An operand name as a string, prefixed by ``$``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:124
#: ../../../GlobalISel/MIRPatterns.rst:167
msgid "Can only appear in an 'apply' pattern."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:125
msgid ""
"The operand name used must appear in the 'match' pattern of the same "
"``GICombineRule``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:128
msgid "Example: Immediate"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:137
msgid "Example: Temp Reg"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:147
msgid "Builtin Operations"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:149
msgid ""
"MIR Patterns also offer builtin operations, also called \"builtin "
"instructions\". They offer some powerful features that would otherwise "
"require use of C++ code."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:153
msgid "GIReplaceReg"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:155
#: ../../../GlobalISel/MIRPatterns.rst:175
msgid "Usage"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:160
msgid "Operands:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:162
msgid "``$old`` (out) register defined by a matched instruction"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:163
msgid "``$new`` (in)  register"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:168
msgid ""
"If both old/new are operands of matched instructions, ``canReplaceReg`` is "
"checked before applying the rule."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:173
msgid "GIEraseRoot"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:182
msgid "Can only appear as the only pattern of an 'apply' pattern list."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:183
msgid "The root cannot have any output operands."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:184
msgid "The root must be a CodeGenInstruction"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:187
msgid "Instruction Flags"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:189
msgid "MIR Patterns support both matching & writing ``MIFlags``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:191
#: ../../../GlobalISel/MIRPatterns.rst:202
#: ../../../GlobalISel/MIRPatterns.rst:215
msgid "Example"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:199
msgid ""
"In ``apply`` patterns, we also support referring to a matched instruction to "
"\"take\" its MIFlags."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:212
msgid ""
"The ``not`` operator can be used to check that a flag is NOT present on a "
"matched instruction, and to remove a flag from a generated instruction."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:226
msgid "Limitations"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:228
msgid ""
"This a non-exhaustive list of known issues with MIR patterns at this time."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:230
msgid "Matching intrinsics is not yet possible."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:231
msgid ""
"Using ``GICombinePatFrag`` within another ``GICombinePatFrag`` is not "
"supported."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:233
msgid "``GICombinePatFrag`` can only have a single root."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:234
msgid ""
"Instructions with multiple defs cannot be the root of a ``GICombinePatFrag``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:235
msgid ""
"Using ``GICombinePatFrag`` in the ``apply`` pattern of a ``GICombineRule`` "
"is not supported."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:237
msgid "We cannot rewrite a matched instruction other than the root."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:238
msgid ""
"Matching/creating a (CImm) immediate >64 bits is not supported (see comment "
"in ``GIM_CheckConstantInt``)"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:240
msgid ""
"There is currently no way to constrain two register/immediate types to "
"match. e.g. if a pattern needs to work on both i32 and i64, you either need "
"to leave it untyped and check the type in C++, or duplicate the pattern."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:246
msgid "GICombineRule"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:248
msgid ""
"MIR patterns can appear in the ``match`` or ``apply`` patterns of a "
"``GICombineRule``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:251
msgid ""
"The ``root`` of the rule can either be a def of an instruction, or a named "
"pattern. The latter is helpful when the instruction you want to match has no "
"defs. The former is generally preferred because it's less verbose."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:256
msgid "Combine Rule root is a def"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:267
msgid "Combine Rule root is a named pattern"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:277
msgid ""
"Combine Rules also allow mixing C++ code with MIR patterns, so that you may "
"perform additional checks when matching, or run additional code after "
"rewriting a pattern."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:281
msgid "The following expansions are available for MIR patterns:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:283
msgid "operand names (``MachineOperand &``)"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:284
msgid ""
"pattern names (``MachineInstr *`` for ``match``, ``MachineInstrBuilder &`` "
"for apply)"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:287
msgid "Example C++ Expansions"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:296
msgid "Common Pattern #1: Replace a Register with Another"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:298
msgid ""
"The 'apply' pattern must always redefine all operands defined by the match "
"root. Sometimes, we do not need to create instructions, simply replace a def "
"with another matched register. The ``GIReplaceReg`` builtin can do just that."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:309
msgid ""
"This also works if the replacement register is a temporary register from the "
"``apply`` pattern."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:322
msgid "Common Pattern #2: Erasing a Def-less Root"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:324
msgid ""
"If we simply want to erase a def-less match root, we can use the "
"``GIEraseRoot`` builtin."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:335
msgid "Common Pattern #3: Emitting a Constant Value"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:337
msgid ""
"When an immediate operand appears in an 'apply' pattern, the behavior "
"depends on whether it's typed or not."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:340
msgid ""
"If the immediate is typed, ``MachineIRBuilder::buildConstant`` is used to "
"create a ``G_CONSTANT``. A ``G_BUILD_VECTOR`` will be used for vectors."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:342
msgid ""
"If the immediate is untyped, a simple immediate is added "
"(``MachineInstrBuilder::addImm``)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:345
msgid ""
"There is of course a special case for ``G_CONSTANT``. Immediates for "
"``G_CONSTANT`` must always be typed, and a CImm is added "
"(``MachineInstrBuilder::addCImm``)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:349
msgid "Constant Emission Examples:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:377
msgid "GICombinePatFrag"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:379
msgid ""
"``GICombinePatFrag`` is an equivalent of ``PatFrags`` for MIR patterns. They "
"have two main usecases:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:382
msgid ""
"Reduce repetition by creating a ``GICombinePatFrag`` for common patterns "
"(see example 1)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:384
msgid ""
"Implicitly duplicate a CombineRule for multiple variants of a pattern (see "
"example 2)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:387
msgid "A ``GICombinePatFrag`` is composed of three elements:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:389
msgid "zero or more ``in`` (def) parameter"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:390
msgid "zero or more ``out`` parameter"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:391
msgid "A list of MIR patterns that can match."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:393
msgid ""
"When a ``GICombinePatFrag`` is used within a pattern, the pattern is cloned "
"once for each alternative that can match."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:396
msgid "Parameters can have the following types:"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:398
msgid "``gi_mo``, which is the implicit default (no type = ``gi_mo``)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:400
msgid "Refers to any operand of an instruction (register, BB ref, imm, etc.)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:401
msgid "Can be used in both ``in`` and ``out`` parameters."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:402
msgid ""
"Users of the PatFrag can only use an operand name for this parameter (e.g. "
"``(my_pat_frag $foo)``)."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:405
msgid "``root``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:407
msgid "This is identical to ``gi_mo``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:408
msgid ""
"Can only be used in ``out`` parameters to declare the root of the pattern."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:410
msgid ""
"Non-empty ``out`` parameter lists must always have exactly one ``root``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:412
msgid "``gi_imm``"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:414
msgid "Refers to an (potentially typed) immediate."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:415
msgid "Can only be used in ``in`` parameters."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:416
msgid ""
"Users of the PatFrag can only use an immediate for this parameter (e.g. "
"``(my_pat_frag 0)`` or ``(my_pat_frag (i32 0))``)"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:419
msgid ""
"``out`` operands can only be empty if the ``GICombinePatFrag`` only contains "
"C++ code. If the fragment contains instruction patterns, it has to have at "
"least one ``out`` operand of type ``root``."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:423
msgid ""
"``in`` operands are less restricted, but there is one important concept to "
"remember: you can pass \"unbound\" operand names, but only if the "
"``GICombinePatFrag`` binds it. See example 3 below."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:427
msgid ""
"``GICombinePatFrag`` are used just like any other instructions. Note that "
"the ``out`` operands are defs, so they come first in the list of operands."
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:431
msgid "Example 1: Reduce Repetition"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:451
msgid "Example 2: Generate Multiple Rules at Once"
msgstr ""

#: ../../../GlobalISel/MIRPatterns.rst:472
msgid "Example 3: Unbound Operand Names"
msgstr ""
