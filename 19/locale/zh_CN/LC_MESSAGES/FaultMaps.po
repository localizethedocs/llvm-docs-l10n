# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 19\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../FaultMaps.rst:3
msgid "FaultMaps and implicit checks"
msgstr ""

#: ../../../FaultMaps.rst:10
msgid "Motivation"
msgstr ""

#: ../../../FaultMaps.rst:12
msgid ""
"Code generated by managed language runtimes tend to have checks that are "
"required for safety but never fail in practice.  In such cases, it is "
"profitable to make the non-failing case cheaper even if it makes the failing "
"case significantly more expensive.  This asymmetry can be exploited by "
"folding such safety checks into operations that can be made to fault "
"reliably if the check would have failed, and recovering from such a fault by "
"using a signal handler."
msgstr ""

#: ../../../FaultMaps.rst:20
msgid ""
"For example, Java requires null checks on objects before they are read from "
"or written to.  If the object is ``null`` then a ``NullPointerException`` "
"has to be thrown, interrupting normal execution.  In practice, however, "
"dereferencing a ``null`` pointer is extremely rare in well-behaved Java "
"programs, and typically the null check can be folded into a nearby memory "
"operation that operates on the same memory location."
msgstr ""

#: ../../../FaultMaps.rst:29
msgid "The Fault Map Section"
msgstr ""

#: ../../../FaultMaps.rst:31
msgid ""
"Information about implicit checks generated by LLVM are put in a special "
"\"fault map\" section.  On Darwin this section is named ``__llvm_faultmaps``."
msgstr ""

#: ../../../FaultMaps.rst:35
msgid "The format of this section is"
msgstr ""

#: ../../../FaultMaps.rst:56
msgid ""
"FailtKind describes the reason of expected fault. Currently three kind of "
"faults are supported:"
msgstr ""

#: ../../../FaultMaps.rst:59
msgid "``FaultMaps::FaultingLoad`` - fault due to load from memory."
msgstr ""

#: ../../../FaultMaps.rst:60
msgid ""
"``FaultMaps::FaultingLoadStore`` - fault due to instruction load and store."
msgstr ""

#: ../../../FaultMaps.rst:61
msgid "``FaultMaps::FaultingStore`` - fault due to store to memory."
msgstr ""

#: ../../../FaultMaps.rst:64
msgid "The ``ImplicitNullChecks`` pass"
msgstr ""

#: ../../../FaultMaps.rst:66
msgid ""
"The ``ImplicitNullChecks`` pass transforms explicit control flow for "
"checking if a pointer is ``null``, like:"
msgstr ""

#: ../../../FaultMaps.rst:85
msgid ""
"to control flow implicit in the instruction loading or storing through the "
"pointer being null checked:"
msgstr ""

#: ../../../FaultMaps.rst:98
msgid ""
"This transform happens at the ``MachineInstr`` level, not the LLVM IR level "
"(so the above example is only representative, not literal).  The "
"``ImplicitNullChecks`` pass runs during codegen, if ``-enable-implicit-null-"
"checks`` is passed to ``llc``."
msgstr ""

#: ../../../FaultMaps.rst:103
msgid ""
"The ``ImplicitNullChecks`` pass adds entries to the ``__llvm_faultmaps`` "
"section described above as needed."
msgstr ""

#: ../../../FaultMaps.rst:107
msgid "``make.implicit`` metadata"
msgstr ""

#: ../../../FaultMaps.rst:109
msgid ""
"Making null checks implicit is an aggressive optimization, and it can be a "
"net performance pessimization if too many memory operations end up faulting "
"because of it.  A language runtime typically needs to ensure that only a "
"negligible number of implicit null checks actually fault once the "
"application has reached a steady state.  A standard way of doing this is by "
"healing failed implicit null checks into explicit null checks via code "
"patching or recompilation.  It follows that there are two requirements an "
"explicit null check needs to satisfy for it to be profitable to convert it "
"to an implicit null check:"
msgstr ""

#: ../../../FaultMaps.rst:119
msgid ""
"The case where the pointer is actually null (i.e. the \"failing\" case) is "
"extremely rare."
msgstr ""

#: ../../../FaultMaps.rst:122
msgid ""
"The failing path heals the implicit null check into an explicit null check "
"so that the application does not repeatedly page fault."
msgstr ""

#: ../../../FaultMaps.rst:126
msgid ""
"The frontend is expected to mark branches that satisfy (1) and (2) using a "
"``!make.implicit`` metadata node (the actual content of the metadata node is "
"ignored).  Only branches that are marked with ``!make.implicit`` metadata "
"are considered as candidates for conversion into implicit null checks."
msgstr ""

#: ../../../FaultMaps.rst:132
msgid ""
"(Note that while we could deal with (1) using profiling data, dealing with "
"(2) requires some information not present in branch profiles.)"
msgstr ""
