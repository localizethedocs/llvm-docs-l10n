# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 19\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../XRayExample.rst:3
msgid "Debugging with XRay"
msgstr ""

#: ../../../XRayExample.rst:5
msgid ""
"This document shows an example of how you would go about analyzing "
"applications built with XRay instrumentation. Here we will attempt to debug "
"``llc`` compiling some sample LLVM IR generated by Clang."
msgstr ""

#: ../../../XRayExample.rst:13
msgid "Building with XRay"
msgstr ""

#: ../../../XRayExample.rst:15
msgid ""
"To debug an application with XRay instrumentation, we need to build it with "
"a Clang that supports the ``-fxray-instrument`` option. See `XRay <XRay."
"html>`_ for more technical details of how XRay works for background "
"information."
msgstr ""

#: ../../../XRayExample.rst:19
msgid ""
"In our example, we need to add ``-fxray-instrument`` to the list of flags "
"passed to Clang when building a binary. Note that we need to link with Clang "
"as well to get the XRay runtime linked in appropriately. For building "
"``llc`` with XRay, we do something similar below for our LLVM build:"
msgstr ""

#: ../../../XRayExample.rst:34
msgid ""
"To verify that we have an XRay instrumented binary, we can use ``objdump`` "
"to look for the ``xray_instr_map`` section."
msgstr ""

#: ../../../XRayExample.rst:48
msgid "Getting Traces"
msgstr ""

#: ../../../XRayExample.rst:50
msgid ""
"By default, XRay does not write out the trace files or patch the application "
"before main starts. If we run ``llc`` it should work like a normally built "
"binary. If we want to get a full trace of the application's operations (of "
"the functions we do end up instrumenting with XRay) then we need to enable "
"XRay at application start. To do this, XRay checks the ``XRAY_OPTIONS`` "
"environment variable."
msgstr ""

#: ../../../XRayExample.rst:66
msgid "At this point we now have an XRay trace we can start analysing."
msgstr ""

#: ../../../XRayExample.rst:69
msgid "The ``llvm-xray`` Tool"
msgstr ""

#: ../../../XRayExample.rst:71
msgid ""
"Having a trace then allows us to do basic accounting of the functions that "
"were instrumented, and how much time we're spending in parts of the code. To "
"make sense of this data, we use the ``llvm-xray`` tool which has a few "
"subcommands to help us understand our trace."
msgstr ""

#: ../../../XRayExample.rst:76
msgid ""
"One of the things we can do is to get an accounting of the functions that "
"have been instrumented. We can see an example accounting with ``llvm-xray "
"account``:"
msgstr ""

#: ../../../XRayExample.rst:95
msgid ""
"This shows us that for our input file, ``llc`` spent the most cumulative "
"time in the lexer (a total of 1 millisecond). If we wanted for example to "
"work with this data in a spreadsheet, we can output the results as CSV using "
"the ``-format=csv`` option to the command for further analysis."
msgstr ""

#: ../../../XRayExample.rst:100
msgid ""
"If we want to get a textual representation of the raw trace we can use the "
"``llvm-xray convert`` tool to get YAML output. The first few lines of that "
"output for an example trace would look like the following:"
msgstr ""

#: ../../../XRayExample.rst:129
msgid "Controlling Fidelity"
msgstr ""

#: ../../../XRayExample.rst:131
msgid ""
"So far in our examples, we haven't been getting full coverage of the "
"functions we have in the binary. To get that, we need to modify the compiler "
"flags so that we can instrument more (if not all) the functions we have in "
"the binary. We have two options for doing that, and we explore both of these "
"below."
msgstr ""

#: ../../../XRayExample.rst:137
msgid "Instruction Threshold"
msgstr ""

#: ../../../XRayExample.rst:139
msgid ""
"The first \"blunt\" way of doing this is by setting the minimum threshold "
"for function bodies to 1. We can do that with the ``-fxray-instruction-"
"threshold=N`` flag when building our binary. We rebuild ``llc`` with this "
"option and observe the results:"
msgstr ""

#: ../../../XRayExample.rst:170
msgid "Instrumentation Attributes"
msgstr ""

#: ../../../XRayExample.rst:172
msgid ""
"The other way is to use configuration files for selecting which functions "
"should always be instrumented by the compiler. This gives us a way of "
"ensuring that certain functions are either always or never instrumented by "
"not having to add the attribute to the source."
msgstr ""

#: ../../../XRayExample.rst:177
msgid ""
"To use this feature, you can define one file for the functions to always "
"instrument, and another for functions to never instrument. The format of "
"these files are exactly the same as the SanitizerLists files that control "
"similar things for the sanitizer implementations. For example:"
msgstr ""

#: ../../../XRayExample.rst:193
msgid ""
"Given the file above we can re-build by providing it to the ``-fxray-attr-"
"list=`` flag to clang. You can have multiple files, each defining different "
"sets of attribute sets, to be combined into a single list by clang."
msgstr ""

#: ../../../XRayExample.rst:198
msgid "The XRay stack tool"
msgstr ""

#: ../../../XRayExample.rst:200
msgid ""
"Given a trace, and optionally an instrumentation map, the ``llvm-xray "
"stack`` command can be used to analyze a call stack graph constructed from "
"the function call timeline."
msgstr ""

#: ../../../XRayExample.rst:204
msgid ""
"The way to use the command is to output the top stacks by call count and "
"time spent."
msgstr ""

#: ../../../XRayExample.rst:226
msgid ""
"In the default mode, identical stacks on different threads are independently "
"aggregated. In a multithreaded program, you may end up having identical call "
"stacks fill your list of top calls."
msgstr ""

#: ../../../XRayExample.rst:230
msgid ""
"To address this, you may specify the ``--aggregate-threads`` or ``--per-"
"thread-stacks`` flags. ``--per-thread-stacks`` treats the thread id as an "
"implicit root in each call stack tree, while ``--aggregate-threads`` "
"combines identical stacks from all threads."
msgstr ""

#: ../../../XRayExample.rst:236
msgid "Flame Graph Generation"
msgstr ""

#: ../../../XRayExample.rst:238
msgid ""
"The ``llvm-xray stack`` tool may also be used to generate flamegraphs for "
"visualizing your instrumented invocations. The tool does not generate the "
"graphs themselves, but instead generates a format that can be used with "
"Brendan Gregg's FlameGraph tool, currently available on `github <https://"
"github.com/brendangregg/FlameGraph>`_."
msgstr ""

#: ../../../XRayExample.rst:244
msgid "To generate output for a flamegraph, a few more options are necessary."
msgstr ""

#: ../../../XRayExample.rst:246
msgid "``--all-stacks`` - Emits all of the stacks."
msgstr ""

#: ../../../XRayExample.rst:247
msgid "``--stack-format`` - Choose the flamegraph output format 'flame'."
msgstr ""

#: ../../../XRayExample.rst:248
msgid "``--aggregation-type`` - Choose the metric to graph."
msgstr ""

#: ../../../XRayExample.rst:250
msgid ""
"You may pipe the command output directly to the flamegraph tool to obtain an "
"svg file."
msgstr ""

#: ../../../XRayExample.rst:258
msgid ""
"If you open the svg in a browser, mouse events allow exploring the call "
"stacks."
msgstr ""

#: ../../../XRayExample.rst:261
msgid "Chrome Trace Viewer Visualization"
msgstr ""

#: ../../../XRayExample.rst:263
msgid ""
"We can also generate a trace which can be loaded by the Chrome Trace Viewer "
"from the same generated trace:"
msgstr ""

#: ../../../XRayExample.rst:272
msgid ""
"From a Chrome browser, navigating to ``chrome:///tracing`` allows us to load "
"the ``sample-trace.txt.gz`` file to visualize the execution trace."
msgstr ""

#: ../../../XRayExample.rst:276
msgid "Further Exploration"
msgstr ""

#: ../../../XRayExample.rst:278
msgid ""
"The ``llvm-xray`` tool has a few other subcommands that are in various "
"stages of being developed. One interesting subcommand that can highlight a "
"few interesting things is the ``graph`` subcommand. Given for example the "
"following toy program that we build with XRay instrumentation, we can see "
"how the generated graph may be a helpful indicator of where time is being "
"spent for the application."
msgstr ""

#: ../../../XRayExample.rst:314
msgid "We then build the above with XRay instrumentation:"
msgstr ""

#: ../../../XRayExample.rst:321
msgid ""
"We can then explore the graph rendering of the trace generated by this "
"sample application. We assume you have the graphviz tools available in your "
"system, including both ``unflatten`` and ``dot``. If you prefer rendering or "
"exploring the graph using another tool, then that should be feasible as "
"well. ``llvm-xray graph`` will create DOT format graphs which should be "
"usable in most graph rendering applications. One example invocation of the "
"``llvm-xray graph`` command should yield some interesting insights to the "
"workings of C++ applications:"
msgstr ""

#: ../../../XRayExample.rst:337
msgid "Next Steps"
msgstr ""

#: ../../../XRayExample.rst:339
msgid ""
"If you have some interesting analyses you'd like to implement as part of the "
"llvm-xray tool, please feel free to propose them on the llvm-dev@ mailing "
"list. The following are some ideas to inspire you in getting involved and "
"potentially making things better."
msgstr ""

#: ../../../XRayExample.rst:344
msgid ""
"Implement a query/filtering library that allows for finding patterns in the "
"XRay traces."
msgstr ""

#: ../../../XRayExample.rst:346
msgid ""
"Collecting function call stacks and how often they're encountered in the "
"XRay trace."
msgstr ""
