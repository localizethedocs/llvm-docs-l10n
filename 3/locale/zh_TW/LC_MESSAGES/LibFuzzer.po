# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../LibFuzzer.rst:3
msgid "libFuzzer – a library for coverage-guided fuzz testing."
msgstr ""

#: ../../../LibFuzzer.rst:9
msgid "Introduction"
msgstr "簡介"

#: ../../../LibFuzzer.rst:11
msgid ""
"LibFuzzer is a library for in-process, coverage-guided, evolutionary fuzzing "
"of other libraries."
msgstr ""

#: ../../../LibFuzzer.rst:14
msgid ""
"LibFuzzer is similar in concept to American Fuzzy Lop (AFL_), but it "
"performs all of its fuzzing inside a single process.  This in-process "
"fuzzing can be more restrictive and fragile, but is potentially much faster "
"as there is no overhead for process start-up."
msgstr ""

#: ../../../LibFuzzer.rst:19
msgid ""
"The fuzzer is linked with the library under test, and feeds fuzzed inputs to "
"the library via a specific fuzzing entrypoint (aka \"target function\"); the "
"fuzzer then tracks which areas of the code are reached, and generates "
"mutations on the corpus of input data in order to maximize the code "
"coverage.  The code coverage information for libFuzzer is provided by LLVM's "
"SanitizerCoverage_ instrumentation."
msgstr ""

#: ../../../LibFuzzer.rst:26
msgid "Contact: libfuzzer(#)googlegroups.com"
msgstr ""

#: ../../../LibFuzzer.rst:29
msgid "Versions"
msgstr ""

#: ../../../LibFuzzer.rst:31
msgid ""
"LibFuzzer is under active development so a current (or at least very recent) "
"version of Clang is the only supported variant."
msgstr ""

#: ../../../LibFuzzer.rst:34
msgid ""
"(If `building Clang from trunk`_ is too time-consuming or difficult, then "
"the Clang binaries that the Chromium developers build are likely to be "
"fairly recent:"
msgstr ""

#: ../../../LibFuzzer.rst:46
msgid ""
"This installs the Clang binary as ``./third_party/llvm-build/Release+Asserts/"
"bin/clang``)"
msgstr ""

#: ../../../LibFuzzer.rst:49
msgid ""
"The libFuzzer code resides in the LLVM repository, and requires a recent "
"Clang compiler to build (and is used to `fuzz various parts of LLVM "
"itself`_). However the fuzzer itself does not (and should not) depend on any "
"part of LLVM infrastructure and can be used for other projects without "
"requiring the rest of LLVM."
msgstr ""

#: ../../../LibFuzzer.rst:58
msgid "Getting Started"
msgstr ""

#: ../../../LibFuzzer.rst:65
msgid "Building"
msgstr ""

#: ../../../LibFuzzer.rst:67
msgid ""
"The first step for using libFuzzer on a library is to implement a fuzzing "
"target function that accepts a sequence of bytes, like this:"
msgstr ""

#: ../../../LibFuzzer.rst:78
msgid ""
"Next, build the libFuzzer library as a static archive, without any sanitizer "
"options. Note that the libFuzzer library contains the ``main()`` function:"
msgstr ""

#: ../../../LibFuzzer.rst:89
msgid ""
"Then build the fuzzing target function and the library under test using the "
"SanitizerCoverage_ option, which instruments the code so that the fuzzer can "
"retrieve code coverage information (to guide the fuzzing).  Linking with the "
"libFuzzer code then gives an fuzzer executable."
msgstr ""

#: ../../../LibFuzzer.rst:94
msgid ""
"You should also enable one or more of the *sanitizers*, which help to expose "
"latent bugs by making incorrect behavior generate errors at runtime:"
msgstr ""

#: ../../../LibFuzzer.rst:97
msgid ""
"AddressSanitizer_ (ASAN) detects memory access errors. Use `-"
"fsanitize=address`."
msgstr ""

#: ../../../LibFuzzer.rst:98
msgid ""
"UndefinedBehaviorSanitizer_ (UBSAN) detects the use of various features of C/"
"C++ that are explicitly listed as resulting in undefined behavior.  Use `-"
"fsanitize=undefined -fno-sanitize-recover=undefined` or any individual UBSAN "
"check, e.g.  `-fsanitize=signed-integer-overflow -fno-sanitize-"
"recover=undefined`. You may combine ASAN and UBSAN in one build."
msgstr ""

#: ../../../LibFuzzer.rst:102
msgid ""
"MemorySanitizer_ (MSAN) detects uninitialized reads: code whose behavior "
"relies on memory contents that have not been initialized to a specific "
"value. Use `-fsanitize=memory`. MSAN can not be combined with other "
"sanirizers and should be used as a seprate build."
msgstr ""

#: ../../../LibFuzzer.rst:106
msgid "Finally, link with ``libFuzzer.a``::"
msgstr ""

#: ../../../LibFuzzer.rst:111
msgid "Corpus"
msgstr ""

#: ../../../LibFuzzer.rst:113
msgid ""
"Coverage-guided fuzzers like libFuzzer rely on a corpus of sample inputs for "
"the code under test.  This corpus should ideally be seeded with a varied "
"collection of valid and invalid inputs for the code under test; for example, "
"for a graphics library the initial corpus might hold a variety of different "
"small PNG/JPG/GIF files.  The fuzzer generates random mutations based around "
"the sample inputs in the current corpus.  If a mutation triggers execution "
"of a previously-uncovered path in the code under test, then that mutation is "
"saved to the corpus for future variations."
msgstr ""

#: ../../../LibFuzzer.rst:122
msgid ""
"LibFuzzer will work without any initial seeds, but will be less efficient if "
"the library under test accepts complex, structured inputs."
msgstr ""

#: ../../../LibFuzzer.rst:126
msgid ""
"The corpus can also act as a sanity/regression check, to confirm that the "
"fuzzing entrypoint still works and that all of the sample inputs run through "
"the code under test without problems."
msgstr ""

#: ../../../LibFuzzer.rst:130
msgid ""
"If you have a large corpus (either generated by fuzzing or acquired by other "
"means) you may want to minimize it while still preserving the full coverage. "
"One way to do that is to use the `-merge=1` flag:"
msgstr ""

#: ../../../LibFuzzer.rst:139
msgid ""
"You may use the same flag to add more interesting items to an existing "
"corpus. Only the inputs that trigger new coverage will be added to the first "
"corpus."
msgstr ""

#: ../../../LibFuzzer.rst:148
msgid "Running"
msgstr ""

#: ../../../LibFuzzer.rst:150
msgid ""
"To run the fuzzer, first create a Corpus_ directory that holds the initial "
"\"seed\" sample inputs:"
msgstr ""

#: ../../../LibFuzzer.rst:158
msgid "Then run the fuzzer on the corpus directory:"
msgstr ""

#: ../../../LibFuzzer.rst:164
msgid ""
"As the fuzzer discovers new interesting test cases (i.e. test cases that "
"trigger coverage of new paths through the code under test), those test cases "
"will be added to the corpus directory."
msgstr ""

#: ../../../LibFuzzer.rst:168
msgid ""
"By default, the fuzzing process will continue indefinitely – at least until "
"a bug is found.  Any crashes or sanitizer failures will be reported as "
"usual, stopping the fuzzing process, and the particular input that triggered "
"the bug will be written to disk (typically as ``crash-<sha1>``, ``leak-"
"<sha1>``, or ``timeout-<sha1>``)."
msgstr ""

#: ../../../LibFuzzer.rst:176
msgid "Parallel Fuzzing"
msgstr ""

#: ../../../LibFuzzer.rst:178
msgid ""
"Each libFuzzer process is single-threaded, unless the library under test "
"starts its own threads.  However, it is possible to run multiple libFuzzer "
"processes in parallel with a shared corpus directory; this has the advantage "
"that any new inputs found by one fuzzer process will be available to the "
"other fuzzer processes (unless you disable this with the ``-reload=0`` "
"option)."
msgstr ""

#: ../../../LibFuzzer.rst:184
msgid ""
"This is primarily controlled by the ``-jobs=N`` option, which indicates that "
"that `N` fuzzing jobs should be run to completion (i.e. until a bug is found "
"or time/iteration limits are reached).  These jobs will be run across a set "
"of worker processes, by default using half of the available CPU cores; the "
"count of worker processes can be overridden by the ``-workers=N`` option.  "
"For example, running with ``-jobs=30`` on a 12-core machine would run 6 "
"workers by default, with each worker averaging 5 bugs by completion of the "
"entire process."
msgstr ""

#: ../../../LibFuzzer.rst:194
msgid "Options"
msgstr ""

#: ../../../LibFuzzer.rst:196
msgid ""
"To run the fuzzer, pass zero or more corpus directories as command line "
"arguments.  The fuzzer will read test inputs from each of these corpus "
"directories, and any new test inputs that are generated will be written back "
"to the first corpus directory:"
msgstr ""

#: ../../../LibFuzzer.rst:205
msgid ""
"If a list of files (rather than directories) are passed to the fuzzer "
"program, then it will re-run those files as test inputs but will not perform "
"any fuzzing. In this mode the fuzzer binary can be used as a regression test "
"(e.g. on a continuous integration system) to check the target function and "
"saved inputs still work."
msgstr ""

#: ../../../LibFuzzer.rst:211
msgid "The most important command line options are:"
msgstr ""

#: ../../../LibFuzzer.rst:213
msgid "``-help``"
msgstr ""

#: ../../../LibFuzzer.rst:214
msgid "Print help message."
msgstr ""

#: ../../../LibFuzzer.rst:215
msgid "``-seed``"
msgstr ""

#: ../../../LibFuzzer.rst:216
msgid "Random seed. If 0 (the default), the seed is generated."
msgstr ""

#: ../../../LibFuzzer.rst:217
msgid "``-runs``"
msgstr ""

#: ../../../LibFuzzer.rst:218
msgid "Number of individual test runs, -1 (the default) to run indefinitely."
msgstr ""

#: ../../../LibFuzzer.rst:220
msgid "``-max_len``"
msgstr ""

#: ../../../LibFuzzer.rst:220
msgid ""
"Maximum length of a test input. If 0 (the default), libFuzzer tries to guess "
"a good value based on the corpus (and reports it)."
msgstr ""

#: ../../../LibFuzzer.rst:223
msgid "``-timeout``"
msgstr ""

#: ../../../LibFuzzer.rst:223
msgid ""
"Timeout in seconds, default 1200. If an input takes longer than this "
"timeout, the process is treated as a failure case."
msgstr ""

#: ../../../LibFuzzer.rst:229
msgid "``-rss_limit_mb``"
msgstr ""

#: ../../../LibFuzzer.rst:226
msgid ""
"Memory usage limit in Mb, default 2048. Use 0 to disable the limit. If an "
"input requires more than this amount of RSS memory to execute, the process "
"is treated as a failure case. The limit is checked in a separate thread "
"every second. If running w/o ASAN/MSAN, you may use 'ulimit -v' instead."
msgstr ""

#: ../../../LibFuzzer.rst:232
msgid "``-timeout_exitcode``"
msgstr ""

#: ../../../LibFuzzer.rst:232
msgid ""
"Exit code (default 77) to emit when terminating due to timeout, when ``-"
"abort_on_timeout`` is not set."
msgstr ""

#: ../../../LibFuzzer.rst:235
msgid "``-max_total_time``"
msgstr ""

#: ../../../LibFuzzer.rst:235
msgid ""
"If positive, indicates the maximum total time in seconds to run the fuzzer. "
"If 0 (the default), run indefinitely."
msgstr ""

#: ../../../LibFuzzer.rst:239
msgid "``-merge``"
msgstr ""

#: ../../../LibFuzzer.rst:238
msgid ""
"If set to 1, any corpus inputs from the 2nd, 3rd etc. corpus directories "
"that trigger new code coverage will be merged into the first corpus "
"directory.  Defaults to 0. This flag can be used to minimize a corpus."
msgstr ""

#: ../../../LibFuzzer.rst:243
msgid "``-reload``"
msgstr ""

#: ../../../LibFuzzer.rst:242
msgid ""
"If set to 1 (the default), the corpus directory is re-read periodically to "
"check for new inputs; this allows detection of new inputs that were "
"discovered by other fuzzing processes."
msgstr ""

#: ../../../LibFuzzer.rst:249
msgid "``-jobs``"
msgstr ""

#: ../../../LibFuzzer.rst:246
msgid ""
"Number of fuzzing jobs to run to completion. Default value is 0, which runs "
"a single fuzzing process until completion.  If the value is >= 1, then this "
"number of jobs performing fuzzing are run, in a collection of parallel "
"separate worker processes; each such worker process has its ``stdout``/"
"``stderr`` redirected to ``fuzz-<JOB>.log``."
msgstr ""

#: ../../../LibFuzzer.rst:252
msgid "``-workers``"
msgstr ""

#: ../../../LibFuzzer.rst:252
msgid ""
"Number of simultaneous worker processes to run the fuzzing jobs to "
"completion in. If 0 (the default), ``min(jobs, NumberOfCpuCores()/2)`` is "
"used."
msgstr ""

#: ../../../LibFuzzer.rst:254
msgid "``-dict``"
msgstr ""

#: ../../../LibFuzzer.rst:255
msgid "Provide a dictionary of input keywords; see Dictionaries_."
msgstr ""

#: ../../../LibFuzzer.rst:257
msgid "``-use_counters``"
msgstr ""

#: ../../../LibFuzzer.rst:257
msgid ""
"Use `coverage counters`_ to generate approximate counts of how often code "
"blocks are hit; defaults to 1."
msgstr ""

#: ../../../LibFuzzer.rst:259
msgid "``-use_traces``"
msgstr ""

#: ../../../LibFuzzer.rst:260
msgid ""
"Use instruction traces (experimental, defaults to 0); see `Data-flow-guided "
"fuzzing`_."
msgstr ""

#: ../../../LibFuzzer.rst:261
msgid "``-only_ascii``"
msgstr ""

#: ../../../LibFuzzer.rst:262
msgid ""
"If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0."
msgstr ""

#: ../../../LibFuzzer.rst:264
msgid "``-artifact_prefix``"
msgstr ""

#: ../../../LibFuzzer.rst:264
msgid ""
"Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or "
"slow inputs) as ``$(artifact_prefix)file``.  Defaults to empty."
msgstr ""

#: ../../../LibFuzzer.rst:269
msgid "``-exact_artifact_path``"
msgstr ""

#: ../../../LibFuzzer.rst:267
msgid ""
"Ignored if empty (the default).  If non-empty, write the single artifact on "
"failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides ``-"
"artifact_prefix`` and will not use checksum in the file name. Do not use the "
"same path for several parallel processes."
msgstr ""

#: ../../../LibFuzzer.rst:271
msgid "``-print_final_stats``"
msgstr ""

#: ../../../LibFuzzer.rst:272
msgid "If 1, print statistics at exit.  Defaults to 0."
msgstr ""

#: ../../../LibFuzzer.rst:274
msgid "``-detect-leaks``"
msgstr ""

#: ../../../LibFuzzer.rst:274
msgid ""
"If 1 (default) and if LeakSanitizer is enabled try to detect memory leaks "
"during fuzzing (i.e. not only at shut down)."
msgstr ""

#: ../../../LibFuzzer.rst:283
msgid "``-close_fd_mask``"
msgstr ""

#: ../../../LibFuzzer.rst:277
msgid ""
"Indicate output streams to close at startup. Be careful, this will remove "
"diagnostic output from target code (e.g. messages on assert failure)."
msgstr ""

#: ../../../LibFuzzer.rst:280
msgid "0 (default): close neither ``stdout`` nor ``stderr``"
msgstr ""

#: ../../../LibFuzzer.rst:281
msgid "1 : close ``stdout``"
msgstr ""

#: ../../../LibFuzzer.rst:282
msgid "2 : close ``stderr``"
msgstr ""

#: ../../../LibFuzzer.rst:283
msgid "3 : close both ``stdout`` and ``stderr``."
msgstr ""

#: ../../../LibFuzzer.rst:285
msgid "For the full list of flags run the fuzzer binary with ``-help=1``."
msgstr ""

#: ../../../LibFuzzer.rst:288
msgid "Output"
msgstr ""

#: ../../../LibFuzzer.rst:290
msgid ""
"During operation the fuzzer prints information to ``stderr``, for example::"
msgstr ""

#: ../../../LibFuzzer.rst:302
msgid ""
"The early parts of the output include information about the fuzzer options "
"and configuration, including the current random seed (in the ``Seed:`` line; "
"this can be overridden with the ``-seed=N`` flag)."
msgstr ""

#: ../../../LibFuzzer.rst:306
msgid ""
"Further output lines have the form of an event code and statistics.  The "
"possible event codes are:"
msgstr ""

#: ../../../LibFuzzer.rst:310
msgid "``READ``"
msgstr ""

#: ../../../LibFuzzer.rst:310
msgid ""
"The fuzzer has read in all of the provided input samples from the corpus "
"directories."
msgstr ""

#: ../../../LibFuzzer.rst:313
msgid "``INITED``"
msgstr ""

#: ../../../LibFuzzer.rst:313
msgid ""
"The fuzzer has completed initialization, which includes running each of the "
"initial input samples through the code under test."
msgstr ""

#: ../../../LibFuzzer.rst:316
msgid "``NEW``"
msgstr ""

#: ../../../LibFuzzer.rst:316
msgid ""
"The fuzzer has created a test input that covers new areas of the code under "
"test.  This input will be saved to the primary corpus directory."
msgstr ""

#: ../../../LibFuzzer.rst:319
msgid "``pulse``"
msgstr ""

#: ../../../LibFuzzer.rst:319
msgid ""
"The fuzzer has generated 2\\ :sup:`n` inputs (generated periodically to "
"reassure the user that the fuzzer is still working)."
msgstr ""

#: ../../../LibFuzzer.rst:322
msgid "``DONE``"
msgstr ""

#: ../../../LibFuzzer.rst:322
msgid ""
"The fuzzer has completed operation because it has reached the specified "
"iteration limit (``-runs``) or time limit (``-max_total_time``)."
msgstr ""

#: ../../../LibFuzzer.rst:325
msgid "``MIN<n>``"
msgstr ""

#: ../../../LibFuzzer.rst:325
msgid ""
"The fuzzer is minimizing the combination of input corpus directories into a "
"single unified corpus (due to the ``-merge`` command line option)."
msgstr ""

#: ../../../LibFuzzer.rst:330
msgid "``RELOAD``"
msgstr ""

#: ../../../LibFuzzer.rst:328
msgid ""
"The fuzzer is performing a periodic reload of inputs from the corpus "
"directory; this allows it to discover any inputs discovered by other fuzzer "
"processes (see `Parallel Fuzzing`_)."
msgstr ""

#: ../../../LibFuzzer.rst:332
msgid "Each output line also reports the following statistics (when non-zero):"
msgstr ""

#: ../../../LibFuzzer.rst:335
msgid "``cov:``"
msgstr ""

#: ../../../LibFuzzer.rst:335
msgid ""
"Total number of code blocks or edges covered by the executing the current "
"corpus."
msgstr ""

#: ../../../LibFuzzer.rst:338
msgid "``bits:``"
msgstr ""

#: ../../../LibFuzzer.rst:338
msgid ""
"Rough measure of the number of code blocks or edges covered, and how often; "
"only valid if the fuzzer is run with ``-use_counters=1``."
msgstr ""

#: ../../../LibFuzzer.rst:342
msgid "``indir:``"
msgstr ""

#: ../../../LibFuzzer.rst:341
msgid ""
"Number of distinct function `caller-callee pairs`_ executed with the current "
"corpus; only valid if the code under test was built with ``-fsanitize-"
"coverage=indirect-calls``."
msgstr ""

#: ../../../LibFuzzer.rst:344
msgid "``units:``"
msgstr ""

#: ../../../LibFuzzer.rst:345
msgid "Number of entries in the current input corpus."
msgstr ""

#: ../../../LibFuzzer.rst:347
msgid "``exec/s:``"
msgstr ""

#: ../../../LibFuzzer.rst:347
msgid "Number of fuzzer iterations per second."
msgstr ""

#: ../../../LibFuzzer.rst:349
msgid ""
"For ``NEW`` events, the output line also includes information about the "
"mutation operation that produced the new input:"
msgstr ""

#: ../../../LibFuzzer.rst:352
msgid "``L:``"
msgstr ""

#: ../../../LibFuzzer.rst:353
msgid "Size of the new input in bytes."
msgstr ""

#: ../../../LibFuzzer.rst:356
msgid "``MS: <n> <operations>``"
msgstr ""

#: ../../../LibFuzzer.rst:355
msgid "Count and list of the mutation operations used to generate the input."
msgstr ""

#: ../../../LibFuzzer.rst:359
msgid "Examples"
msgstr ""

#: ../../../LibFuzzer.rst:365
msgid "Toy example"
msgstr ""

#: ../../../LibFuzzer.rst:367
msgid ""
"A simple function that does something interesting if it receives the input "
"\"HI!\"::"
msgstr ""

#: ../../../LibFuzzer.rst:386
msgid "You should get an error pretty quickly::"
msgstr ""

#: ../../../LibFuzzer.rst:401
msgid "PCRE2"
msgstr ""

#: ../../../LibFuzzer.rst:403
msgid ""
"Here we show how to use libFuzzer on something real, yet simple: pcre2_::"
msgstr ""

#: ../../../LibFuzzer.rst:434
msgid ""
"This will give you a binary of the fuzzer, called ``pcre_fuzzer``. Now, "
"create a directory that will hold the test corpus:"
msgstr ""

#: ../../../LibFuzzer.rst:441
msgid ""
"For simple input languages like regular expressions this is all you need. "
"For more complicated/structured inputs, the fuzzer works much more "
"efficiently if you can populate the corpus directory with a variety of valid "
"and invalid inputs for the code under test. Now run the fuzzer with the "
"corpus directory as the only parameter:"
msgstr ""

#: ../../../LibFuzzer.rst:451
msgid "Initially, you will see Output_ like this::"
msgstr ""

#: ../../../LibFuzzer.rst:463
msgid "Now, interrupt the fuzzer and run it again the same way. You will see::"
msgstr ""

#: ../../../LibFuzzer.rst:475
msgid ""
"On the second execution the fuzzer has a non-empty input corpus (405 "
"items).  As the first step, the fuzzer minimized this corpus (the ``INITED`` "
"line) to produce 286 interesting items, omitting inputs that do not hit any "
"additional code."
msgstr ""

#: ../../../LibFuzzer.rst:480
msgid ""
"(Aside: although the fuzzer only saves new inputs that hit additional code, "
"this does not mean that the corpus as a whole is kept minimized.  For "
"example, if an input hitting A-B-C then an input that hits A-B-C-D are "
"generated, they will both be saved, even though the latter subsumes the "
"former.)"
msgstr ""

#: ../../../LibFuzzer.rst:486
msgid "You may run ``N`` independent fuzzer jobs in parallel on ``M`` CPUs:"
msgstr ""

#: ../../../LibFuzzer.rst:492
msgid ""
"By default (``-reload=1``) the fuzzer processes will periodically scan the "
"corpus directory and reload any new tests. This way the test inputs found by "
"one process will be picked up by all others."
msgstr ""

#: ../../../LibFuzzer.rst:496
msgid ""
"If ``-workers=$M`` is not supplied, ``min($N,NumberOfCpuCore/2)`` will be "
"used."
msgstr ""

#: ../../../LibFuzzer.rst:499
msgid "Heartbleed"
msgstr ""

#: ../../../LibFuzzer.rst:500
msgid ""
"Remember Heartbleed_? As it was recently `shown <https://blog.hboeck.de/"
"archives/868-How-Heartbleed-couldve-been-found.html>`_, fuzzing with "
"AddressSanitizer_ can find Heartbleed. Indeed, here are the step-by-step "
"instructions to find Heartbleed with libFuzzer::"
msgstr ""

#: ../../../LibFuzzer.rst:553
msgid "Voila::"
msgstr ""

#: ../../../LibFuzzer.rst:563
msgid ""
"Note: a `similar fuzzer <https://boringssl.googlesource.com/boringssl/+/HEAD/"
"FUZZING.md>`_ is now a part of the BoringSSL_ source tree."
msgstr ""

#: ../../../LibFuzzer.rst:567
msgid "Advanced features"
msgstr ""

#: ../../../LibFuzzer.rst:573
msgid "Dictionaries"
msgstr ""

#: ../../../LibFuzzer.rst:574
msgid ""
"LibFuzzer supports user-supplied dictionaries with input language keywords "
"or other interesting byte sequences (e.g. multi-byte magic values). Use ``-"
"dict=DICTIONARY_FILE``. For some input languages using a dictionary may "
"significantly improve the search speed. The dictionary syntax is similar to "
"that used by AFL_ for its ``-x`` option::"
msgstr ""

#: ../../../LibFuzzer.rst:592
msgid "Data-flow-guided fuzzing"
msgstr ""

#: ../../../LibFuzzer.rst:594
msgid ""
"*EXPERIMENTAL*. With an additional compiler flag ``-fsanitize-coverage=trace-"
"cmp`` (see SanitizerCoverageTraceDataFlow_) and extra run-time flag ``-"
"use_traces=1`` the fuzzer will try to apply *data-flow-guided fuzzing*. That "
"is, the fuzzer will record the inputs to comparison instructions, switch "
"statements, and several libc functions (``memcmp``, ``strcmp``, ``strncmp``, "
"etc). It will later use those recorded inputs during mutations."
msgstr ""

#: ../../../LibFuzzer.rst:601
msgid ""
"This mode can be combined with DataFlowSanitizer_ to achieve better "
"sensitivity."
msgstr ""

#: ../../../LibFuzzer.rst:604
msgid "Fuzzer-friendly build mode"
msgstr ""

#: ../../../LibFuzzer.rst:605
msgid "Sometimes the code under test is not fuzzing-friendly. Examples:"
msgstr ""

#: ../../../LibFuzzer.rst:607
msgid ""
"The target code uses a PRNG seeded e.g. by system time and thus two "
"consequent invocations may potentially execute different code paths even if "
"the end result will be the same. This will cause a fuzzer to treat two "
"similar inputs as significantly different and it will blow up the test "
"corpus. E.g. libxml uses ``rand()`` inside its hash table."
msgstr ""

#: ../../../LibFuzzer.rst:612
msgid ""
"The target code uses checksums to protect from invalid inputs. E.g. png "
"checks CRC for every chunk."
msgstr ""

#: ../../../LibFuzzer.rst:615
msgid ""
"In many cases it makes sense to build a special fuzzing-friendly build with "
"certain fuzzing-unfriendly features disabled. We propose to use a common "
"build macro for all such cases for consistency: "
"``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``."
msgstr ""

#: ../../../LibFuzzer.rst:633
msgid "AFL compatibility"
msgstr ""

#: ../../../LibFuzzer.rst:634
msgid ""
"LibFuzzer can be used together with AFL_ on the same test corpus. Both "
"fuzzers expect the test corpus to reside in a directory, one file per input. "
"You can run both fuzzers on the same corpus, one after another:"
msgstr ""

#: ../../../LibFuzzer.rst:643
msgid ""
"Periodically restart both fuzzers so that they can use each other's "
"findings. Currently, there is no simple way to run both fuzzing engines in "
"parallel while sharing the same corpus dir."
msgstr ""

#: ../../../LibFuzzer.rst:646
msgid ""
"You may also use AFL on your target function ``LLVMFuzzerTestOneInput``: see "
"an example `here <https://github.com/llvm-mirror/llvm/blob/master/lib/Fuzzer/"
"afl/afl_driver.cpp>`__."
msgstr ""

#: ../../../LibFuzzer.rst:650
msgid "How good is my fuzzer?"
msgstr ""

#: ../../../LibFuzzer.rst:652
msgid ""
"Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz "
"it to death, you will want to know whether the function or the corpus can be "
"improved further. One easy to use metric is, of course, code coverage. You "
"can get the coverage for your corpus like this:"
msgstr ""

#: ../../../LibFuzzer.rst:661
msgid ""
"This will run all tests in the CORPUS_DIR but will not perform any fuzzing. "
"At the end of the process it will dump a single html file with coverage "
"information. See SanitizerCoverage_ for details."
msgstr ""

#: ../../../LibFuzzer.rst:665
msgid ""
"You may also use other ways to visualize coverage, e.g. using `Clang "
"coverage <http://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_, but "
"those will require you to rebuild the code with different compiler flags."
msgstr ""

#: ../../../LibFuzzer.rst:671
msgid "User-supplied mutators"
msgstr ""

#: ../../../LibFuzzer.rst:673
msgid ""
"LibFuzzer allows to use custom (user-supplied) mutators, see FuzzerInterface."
"h_"
msgstr ""

#: ../../../LibFuzzer.rst:677
msgid "Startup initialization"
msgstr ""

#: ../../../LibFuzzer.rst:678
msgid ""
"If the library being tested needs to be initialized, there are several "
"options."
msgstr ""

#: ../../../LibFuzzer.rst:680
msgid ""
"The simplest way is to have a statically initialized global object inside "
"`LLVMFuzzerTestOneInput` (or in global scope if that works for you):"
msgstr ""

#: ../../../LibFuzzer.rst:689
msgid ""
"Alternatively, you may define an optional init function and it will receive "
"the program arguments that you can read and modify. Do this **only** if you "
"realy need to access ``argv``/``argc``."
msgstr ""

#: ../../../LibFuzzer.rst:702
msgid "Leaks"
msgstr ""

#: ../../../LibFuzzer.rst:704
msgid ""
"Binaries built with AddressSanitizer_ or LeakSanitizer_ will try to detect "
"memory leaks at the process shutdown. For in-process fuzzing this is "
"inconvenient since the fuzzer needs to report a leak with a reproducer as "
"soon as the leaky mutation is found. However, running full leak detection "
"after every mutation is expensive."
msgstr ""

#: ../../../LibFuzzer.rst:711
msgid ""
"By default (``-detect_leaks=1``) libFuzzer will count the number of "
"``malloc`` and ``free`` calls when executing every mutation. If the numbers "
"don't match (which by itself doesn't mean there is a leak) libFuzzer will "
"invoke the more expensive LeakSanitizer_ pass and if the actual leak is "
"found, it will be reported with the reproducer and the process will exit."
msgstr ""

#: ../../../LibFuzzer.rst:718
msgid ""
"If your target has massive leaks and the leak detection is disabled you will "
"eventually run out of RAM (see the ``-rss_limit_mb`` flag)."
msgstr ""

#: ../../../LibFuzzer.rst:723
msgid "Developing libFuzzer"
msgstr ""

#: ../../../LibFuzzer.rst:725
msgid ""
"Building libFuzzer as a part of LLVM project and running its test requires "
"fresh clang as the host compiler and special CMake configuration:"
msgstr ""

#: ../../../LibFuzzer.rst:735
msgid "Fuzzing components of LLVM"
msgstr ""

#: ../../../LibFuzzer.rst:740
msgid "To build any of the LLVM fuzz targets use the build instructions above."
msgstr ""

#: ../../../LibFuzzer.rst:743
msgid "clang-format-fuzzer"
msgstr ""

#: ../../../LibFuzzer.rst:744
msgid "The inputs are random pieces of C++-like text."
msgstr ""

#: ../../../LibFuzzer.rst:752
msgid ""
"Optionally build other kinds of binaries (ASan+Debug, MSan, UBSan, etc)."
msgstr ""

#: ../../../LibFuzzer.rst:754
msgid "Tracking bug: https://llvm.org/bugs/show_bug.cgi?id=23052"
msgstr ""

#: ../../../LibFuzzer.rst:757
msgid "clang-fuzzer"
msgstr ""

#: ../../../LibFuzzer.rst:759
msgid "The behavior is very similar to ``clang-format-fuzzer``."
msgstr ""

#: ../../../LibFuzzer.rst:761
msgid "Tracking bug: https://llvm.org/bugs/show_bug.cgi?id=23057"
msgstr ""

#: ../../../LibFuzzer.rst:764
msgid "llvm-as-fuzzer"
msgstr ""

#: ../../../LibFuzzer.rst:766
msgid "Tracking bug: https://llvm.org/bugs/show_bug.cgi?id=24639"
msgstr ""

#: ../../../LibFuzzer.rst:769
msgid "llvm-mc-fuzzer"
msgstr ""

#: ../../../LibFuzzer.rst:771
msgid ""
"This tool fuzzes the MC layer. Currently it is only able to fuzz the "
"disassembler but it is hoped that assembly, and round-trip verification will "
"be added in future."
msgstr ""

#: ../../../LibFuzzer.rst:775
msgid ""
"When run in dissassembly mode, the inputs are opcodes to be disassembled. "
"The fuzzer will consume as many instructions as possible and will stop when "
"it finds an invalid instruction or runs out of data."
msgstr ""

#: ../../../LibFuzzer.rst:779
msgid ""
"Please note that the command line interface differs slightly from that of "
"other fuzzers. The fuzzer arguments should follow ``--fuzzer-args`` and "
"should have a single dash, while other arguments control the operation mode "
"and target in a similar manner to ``llvm-mc`` and should have two dashes. "
"For example:"
msgstr ""

#: ../../../LibFuzzer.rst:789
msgid "Buildbot"
msgstr ""

#: ../../../LibFuzzer.rst:791
msgid ""
"A buildbot continuously runs the above fuzzers for LLVM components, with "
"results shown at http://lab.llvm.org:8011/builders/sanitizer-x86_64-linux-"
"fuzzer ."
msgstr ""

#: ../../../LibFuzzer.rst:795
msgid "FAQ"
msgstr ""

#: ../../../LibFuzzer.rst:798
msgid "Q. Why doesn't libFuzzer use any of the LLVM support?"
msgstr ""

#: ../../../LibFuzzer.rst:800
msgid "There are two reasons."
msgstr ""

#: ../../../LibFuzzer.rst:802
msgid ""
"First, we want this library to be used outside of the LLVM without users "
"having to build the rest of LLVM. This may sound unconvincing for many LLVM "
"folks, but in practice the need for building the whole LLVM frightens many "
"potential users -- and we want more users to use this code."
msgstr ""

#: ../../../LibFuzzer.rst:807
msgid ""
"Second, there is a subtle technical reason not to rely on the rest of LLVM, "
"or any other large body of code (maybe not even STL). When coverage "
"instrumentation is enabled, it will also instrument the LLVM support code "
"which will blow up the coverage set of the process (since the fuzzer is in-"
"process). In other words, by using more external dependencies we will slow "
"down the fuzzer while the main reason for it to exist is extreme speed."
msgstr ""

#: ../../../LibFuzzer.rst:815
msgid ""
"Q. What about Windows then? The fuzzer contains code that does not build on "
"Windows."
msgstr ""

#: ../../../LibFuzzer.rst:817
msgid "Volunteers are welcome."
msgstr ""

#: ../../../LibFuzzer.rst:820
msgid "Q. When this Fuzzer is not a good solution for a problem?"
msgstr ""

#: ../../../LibFuzzer.rst:822
msgid ""
"If the test inputs are validated by the target library and the validator "
"asserts/crashes on invalid inputs, in-process fuzzing is not applicable."
msgstr ""

#: ../../../LibFuzzer.rst:824
msgid ""
"Bugs in the target library may accumulate without being detected. E.g. a "
"memory corruption that goes undetected at first and then leads to a crash "
"while testing another input. This is why it is highly recommended to run "
"this in-process fuzzer with all sanitizers to detect most bugs on the spot."
msgstr ""

#: ../../../LibFuzzer.rst:828
msgid ""
"It is harder to protect the in-process fuzzer from excessive memory "
"consumption and infinite loops in the target library (still possible)."
msgstr ""

#: ../../../LibFuzzer.rst:830
msgid ""
"The target library should not have significant global state that is not "
"reset between the runs."
msgstr ""

#: ../../../LibFuzzer.rst:832
msgid ""
"Many interesting target libraries are not designed in a way that supports "
"the in-process fuzzer interface (e.g. require a file path instead of a byte "
"array)."
msgstr ""

#: ../../../LibFuzzer.rst:835
msgid ""
"If a single test run takes a considerable fraction of a second (or more) the "
"speed benefit from the in-process fuzzer is negligible."
msgstr ""

#: ../../../LibFuzzer.rst:837
msgid ""
"If the target library runs persistent threads (that outlive execution of one "
"test) the fuzzing results will be unreliable."
msgstr ""

#: ../../../LibFuzzer.rst:841
msgid "Q. So, what exactly this Fuzzer is good for?"
msgstr ""

#: ../../../LibFuzzer.rst:843
msgid ""
"This Fuzzer might be a good choice for testing libraries that have "
"relatively small inputs, each input takes < 10ms to run, and the library "
"code is not expected to crash on invalid inputs. Examples: regular "
"expression matchers, text or binary format parsers, compression, network, "
"crypto."
msgstr ""

#: ../../../LibFuzzer.rst:850
msgid "Trophies"
msgstr ""

#: ../../../LibFuzzer.rst:851
msgid "GLIBC: https://sourceware.org/glibc/wiki/FuzzingLibc"
msgstr ""

#: ../../../LibFuzzer.rst:853
msgid ""
"MUSL LIBC: `[1] <http://git.musl-libc.org/cgit/musl/commit/?"
"id=39dfd58417ef642307d90306e1c7e50aaec5a35c>`__ `[2] <http://www.openwall."
"com/lists/oss-security/2015/03/30/3>`__"
msgstr ""

#: ../../../LibFuzzer.rst:855
msgid "`pugixml <https://github.com/zeux/pugixml/issues/39>`_"
msgstr ""

#: ../../../LibFuzzer.rst:857
msgid ""
"PCRE: Search for \"LLVM fuzzer\" in http://vcs.pcre.org/pcre2/code/trunk/"
"ChangeLog?view=markup; also in `bugzilla <https://bugs.exim.org/buglist.cgi?"
"bug_status=__all__&content=libfuzzer&no_redirect=1&order=Importance&product=PCRE&query_format=specific>`_"
msgstr ""

#: ../../../LibFuzzer.rst:860
msgid "`ICU <http://bugs.icu-project.org/trac/ticket/11838>`_"
msgstr ""

#: ../../../LibFuzzer.rst:862
msgid ""
"`Freetype <https://savannah.nongnu.org/search/?"
"words=LibFuzzer&type_of_search=bugs&Search=Search&exact=1#options>`_"
msgstr ""

#: ../../../LibFuzzer.rst:864
msgid "`Harfbuzz <https://github.com/behdad/harfbuzz/issues/139>`_"
msgstr ""

#: ../../../LibFuzzer.rst:866
msgid "`SQLite <http://www3.sqlite.org/cgi/src/info/088009efdd56160b>`_"
msgstr ""

#: ../../../LibFuzzer.rst:868
msgid "`Python <http://bugs.python.org/issue25388>`_"
msgstr ""

#: ../../../LibFuzzer.rst:870
msgid ""
"OpenSSL/BoringSSL: `[1] <https://boringssl.googlesource.com/boringssl/+/"
"cb852981cd61733a7a1ae4fd8755b7ff950e857d>`_ `[2] <https://openssl.org/news/"
"secadv/20160301.txt>`_ `[3] <https://boringssl.googlesource.com/boringssl/"
"+/2b07fa4b22198ac02e0cee8f37f3337c3dba91bc>`_ `[4] <https://boringssl."
"googlesource.com/boringssl/+/6b6e0b20893e2be0e68af605a60ffa2cbb0ffa64>`_  "
"`[5] <https://github.com/openssl/openssl/pull/931/commits/"
"dd5ac557f052cc2b7f718ac44a8cb7ac6f77dca8>`_ `[6] <https://github.com/openssl/"
"openssl/pull/931/commits/19b5b9194071d1d84e38ac9a952e715afbc85a81>`_"
msgstr ""

#: ../../../LibFuzzer.rst:872
msgid ""
"`Libxml2 <https://bugzilla.gnome.org/buglist.cgi?"
"bug_status=__all__&content=libFuzzer&list_id=68957&order=Importance&product=libxml2&query_format=specific>`_ "
"and `[HT206167] <https://support.apple.com/en-gb/HT206167>`_ (CVE-2015-5312, "
"CVE-2015-7500, CVE-2015-7942)"
msgstr ""

#: ../../../LibFuzzer.rst:875
msgid "`Linux Kernel's BPF verifier <https://github.com/iovisor/bpf-fuzzer>`_"
msgstr ""

#: ../../../LibFuzzer.rst:877
msgid ""
"Capstone: `[1] <https://github.com/aquynh/capstone/issues/600>`__ `[2] "
"<https://github.com/aquynh/capstone/"
"commit/6b88d1d51eadf7175a8f8a11b690684443b11359>`__"
msgstr ""

#: ../../../LibFuzzer.rst:879
msgid ""
"file:`[1] <http://bugs.gw.com/view.php?id=550>`__  `[2] <http://bugs.gw.com/"
"view.php?id=551>`__  `[3] <http://bugs.gw.com/view.php?id=553>`__  `[4] "
"<http://bugs.gw.com/view.php?id=554>`__"
msgstr ""

#: ../../../LibFuzzer.rst:881
msgid ""
"Radare2: `[1] <https://github.com/revskills?"
"tab=contributions&from=2016-04-09>`__"
msgstr ""

#: ../../../LibFuzzer.rst:883
msgid ""
"gRPC: `[1] <https://github.com/grpc/grpc/pull/6071/commits/"
"df04c1f7f6aec6e95722ec0b023a6b29b6ea871c>`__ `[2] <https://github.com/grpc/"
"grpc/pull/6071/commits/22a3dfd95468daa0db7245a4e8e6679a52847579>`__ `[3] "
"<https://github.com/grpc/grpc/pull/6071/"
"commits/9cac2a12d9e181d130841092e9d40fa3309d7aa7>`__ `[4] <https://github."
"com/grpc/grpc/pull/6012/commits/82a91c91d01ce9b999c8821ed13515883468e203>`__ "
"`[5] <https://github.com/grpc/grpc/pull/6202/"
"commits/2e3e0039b30edaf89fb93bfb2c1d0909098519fa>`__ `[6] <https://github."
"com/grpc/grpc/pull/6106/files>`__"
msgstr ""

#: ../../../LibFuzzer.rst:885
msgid "WOFF2: `[1] <https://github.com/google/woff2/commit/a15a8ab>`__"
msgstr ""

#: ../../../LibFuzzer.rst:887
msgid ""
"LLVM: `Clang <https://llvm.org/bugs/show_bug.cgi?id=23057>`_, `Clang-format "
"<https://llvm.org/bugs/show_bug.cgi?id=23052>`_, `libc++ <https://llvm.org/"
"bugs/show_bug.cgi?id=24411>`_, `llvm-as <https://llvm.org/bugs/show_bug.cgi?"
"id=24639>`_, Disassembler: http://reviews.llvm.org/rL247405, http://reviews."
"llvm.org/rL247414, http://reviews.llvm.org/rL247416, http://reviews.llvm.org/"
"rL247417, http://reviews.llvm.org/rL247420, http://reviews.llvm.org/rL247422."
msgstr ""
