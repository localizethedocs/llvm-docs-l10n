# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../RISCV/RISCVVectorExtension.rst:3
msgid "RISC-V Vector Extension"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:8
msgid ""
"The RISC-V target supports the 1.0 version of the `RISC-V Vector Extension "
"(RVV) <https://github.com/riscv/riscv-v-spec/blob/v1.0/v-spec.adoc>`_. This "
"guide gives an overview of how it's modelled in LLVM IR and how the backend "
"generates code for it."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:12
msgid "Mapping to LLVM IR types"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:14
msgid ""
"RVV adds 32 VLEN sized registers, where VLEN is an unknown constant to the "
"compiler. To be able to represent VLEN sized values, the RISC-V backend "
"takes the same approach as AArch64's SVE and uses `scalable vector types "
"<https://llvm.org/docs/LangRef.html#t-vector>`_."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:16
msgid ""
"Scalable vector types are of the form ``<vscale x n x ty>``, which indicates "
"a vector with a multiple of ``n`` elements of type ``ty``. On RISC-V ``n`` "
"and ``ty`` control LMUL and SEW respectively."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:19
msgid ""
"LLVM only supports ELEN=32 or ELEN=64, so ``vscale`` is defined as VLEN/64 "
"(see ``RISCV::RVVBitsPerBlock``). Note this means that VLEN must be at least "
"64, so VLEN=32 isn't currently supported."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:23
msgid "LMUL=⅛"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:23
msgid "LMUL=¼"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:23
msgid "LMUL=½"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:23
msgid "LMUL=1"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:23
msgid "LMUL=2"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:23
msgid "LMUL=4"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:23
msgid "LMUL=8"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:25
msgid "i64 (ELEN=64)"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:25
#: ../../../RISCV/RISCVVectorExtension.rst:27
#: ../../../RISCV/RISCVVectorExtension.rst:29
#: ../../../RISCV/RISCVVectorExtension.rst:33
#: ../../../RISCV/RISCVVectorExtension.rst:35
#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "N/A"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:25
msgid "<v x 1 x i64>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:25
msgid "<v x 2 x i64>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:25
msgid "<v x 4 x i64>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:25
msgid "<v x 8 x i64>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:27
msgid "i32"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:27
msgid "<v x 1 x i32>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:27
msgid "<v x 2 x i32>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:27
msgid "<v x 4 x i32>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:27
msgid "<v x 8 x i32>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:27
msgid "<v x 16 x i32>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:29
msgid "i16"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:29
msgid "<v x 1 x i16>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:29
msgid "<v x 2 x i16>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:29
msgid "<v x 4 x i16>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:29
msgid "<v x 8 x i16>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:29
msgid "<v x 16 x i16>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:29
msgid "<v x 32 x i16>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "i8"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "<v x 1 x i8>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "<v x 2 x i8>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "<v x 4 x i8>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "<v x 8 x i8>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "<v x 16 x i8>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "<v x 32 x i8>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:31
msgid "<v x 64 x i8>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:33
msgid "double (ELEN=64)"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:33
msgid "<v x 1 x double>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:33
msgid "<v x 2 x double>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:33
msgid "<v x 4 x double>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:33
msgid "<v x 8 x double>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:35
msgid "float"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:35
msgid "<v x 1 x float>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:35
msgid "<v x 2 x float>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:35
msgid "<v x 4 x float>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:35
msgid "<v x 8 x float>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:35
msgid "<v x 16 x float>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "half"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "<v x 1 x half>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "<v x 2 x half>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "<v x 4 x half>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "<v x 8 x half>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "<v x 16 x half>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:37
msgid "<v x 32 x half>"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:40
msgid "(Read ``<v x k x ty>`` as ``<vscale x k x ty>``)"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:44
msgid "Mask vector types"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:46
msgid ""
"Mask vectors are physically represented using a layout of densely packed "
"bits in a vector register. They are mapped to the following LLVM IR types:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:49
msgid "``<vscale x 1 x i1>``"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:50
msgid "``<vscale x 2 x i1>``"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:51
msgid "``<vscale x 4 x i1>``"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:52
msgid "``<vscale x 8 x i1>``"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:53
msgid "``<vscale x 16 x i1>``"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:54
msgid "``<vscale x 32 x i1>``"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:55
msgid "``<vscale x 64 x i1>``"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:57
msgid ""
"Two types with the same SEW/LMUL ratio will have the same related mask type. "
"For instance, two different comparisons one under SEW=64, LMUL=2 and the "
"other under SEW=32, LMUL=1 will both generate a mask ``<vscale x 2 x i1>``."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:61
msgid "Representation in LLVM IR"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:63
msgid "Vector instructions can be represented in three main ways in LLVM IR:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:65
msgid "Regular instructions on both scalable and fixed-length vector types"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:72
msgid ""
"RISC-V vector intrinsics, which mirror the `C intrinsics specification "
"<https://github.com/riscv-non-isa/rvv-intrinsic-doc>`_"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:74
msgid "These come in unmasked variants:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:85
msgid "As well as masked variants:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:98
msgid ""
"Both allow setting the AVL as well as controlling the inactive/tail elements "
"via the passthru operand, but the masked variant also provides operands for "
"the mask and ``vta``/``vma`` policy bits."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:100
msgid "The only valid types are scalable vector types."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:102
msgid ":ref:`Vector predication (VP) intrinsics <int_vp>`"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:113
msgid ""
"Unlike RISC-V intrinsics, VP intrinsics are target agnostic so they can be "
"emitted from other optimisation passes in the middle-end (like the loop "
"vectorizer). They also support fixed-length vector types."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:115
msgid ""
"VP intrinsics also don't have passthru operands, but tail/mask undisturbed "
"behaviour can be emulated by using the output in a ``@llvm.vp.merge``. It "
"will get lowered as a ``vmerge``, but will be merged back into the "
"underlying instruction's mask via ``RISCVDAGToDAGISel::"
"performCombineVMergeAndVOps``."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:119
msgid ""
"The different properties of the above representations are summarized below:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:122
msgid "AVL"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:122
msgid "Masking"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:122
msgid "Passthru"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:122
msgid "Scalable vectors"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:122
#: ../../../RISCV/RISCVVectorExtension.rst:147
msgid "Fixed-length vectors"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:122
msgid "Target agnostic"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:124
msgid "LLVM IR instructions"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:124
msgid "Always VLMAX"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:124
#: ../../../RISCV/RISCVVectorExtension.rst:126
#: ../../../RISCV/RISCVVectorExtension.rst:128
msgid "No"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:124
msgid "None"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:124
#: ../../../RISCV/RISCVVectorExtension.rst:126
#: ../../../RISCV/RISCVVectorExtension.rst:128
msgid "Yes"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:126
msgid "RVV intrinsics"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:128
msgid "VP intrinsics"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:128
msgid "Yes (EVL)"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:132
msgid "SelectionDAG lowering"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:134
msgid ""
"For most regular **scalable** vector LLVM IR instructions, their "
"corresponding SelectionDAG nodes are legal on RISC-V and don't require any "
"custom lowering."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:140
msgid "RISC-V vector intrinsics also don't require any custom lowering."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:149
msgid ""
"Because there are no fixed-length vector patterns, fixed-length vectors need "
"to be custom lowered and performed in a scalable \"container\" type:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:151
msgid ""
"The fixed-length vector operands are inserted into scalable containers with "
"``insert_subvector`` nodes. The container type is chosen such that its "
"minimum size will fit the fixed-length vector (see "
"``getContainerForFixedLengthVector``)."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:152
msgid ""
"The operation is then performed on the container type via a **VL (vector "
"length) node**. These are custom nodes defined in "
"``RISCVInstrInfoVVLPatterns.td`` that mirror target agnostic SelectionDAG "
"nodes, as well as some RVV instructions. They contain an AVL operand, which "
"is set to the number of elements in the fixed-length vector. Some nodes also "
"have a passthru or mask operand, which will usually be set to ``undef`` and "
"all ones when lowering fixed-length vectors."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:154
msgid ""
"The result is put back into a fixed-length vector via ``extract_subvector``."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:172
msgid ""
"VL nodes often have a passthru or mask operand, which are usually set to "
"``undef`` and all ones for fixed-length vectors."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:174
msgid ""
"The ``insert_subvector`` and ``extract_subvector`` nodes responsible for "
"wrapping and unwrapping will get combined away, and eventually we will lower "
"all fixed-length vector types to scalable. Note that fixed-length vectors at "
"the interface of a function are passed in a scalable vector container."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:178
msgid ""
"The only ``insert_subvector`` and ``extract_subvector`` nodes that make it "
"through lowering are those that can be performed as an exact subregister "
"insert or extract. This means that any fixed-length vector "
"``insert_subvector`` and ``extract_subvector`` nodes that aren't legalized "
"must lie on a register group boundary, so the exact VLEN must be known at "
"compile time (i.e., compiled with ``-mrvv-vector-bits=zvl`` or ``-mllvm -"
"riscv-v-vector-bits-max=VLEN``, or have an exact ``vscale_range`` attribute)."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:181
msgid "Vector predication intrinsics"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:183
msgid "VP intrinsics also get custom lowered via VL nodes."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:193
msgid ""
"The VP EVL and mask are used for the VL node's AVL and mask respectively, "
"whilst the passthru is set to ``undef``."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:196
msgid "Instruction selection"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:198
msgid ""
"``vl`` and ``vtype`` need to be configured correctly, so we can't just "
"directly select the underlying vector ``MachineInstr``. Instead pseudo "
"instructions are selected, which carry the extra information needed to emit "
"the necessary ``vsetvli``\\s later."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:204
msgid ""
"Each vector instruction has multiple pseudo instructions defined in "
"``RISCVInstrInfoVPseudos.td``. There is a variant of each pseudo for each "
"possible LMUL, as well as a masked variant. So a typical instruction like "
"``vadd.vv`` would have the following pseudos:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:226
msgid ""
"Whilst the SEW can be encoded in an operand, we need to use separate pseudos "
"for each LMUL since different register groups will require different "
"register classes: see :ref:`rvv_register_allocation`."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:229
msgid ""
"Pseudos have operands for the AVL and SEW (encoded as a power of 2), as well "
"as potentially the mask, policy or rounding mode if applicable. The passthru "
"operand is tied to the destination register which will determine the "
"inactive/tail elements."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:232
msgid ""
"For scalable vectors that should use VLMAX, the AVL is set to a sentinel "
"value of ``-1``."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:234
msgid ""
"There are patterns for target agnostic SelectionDAG nodes in "
"``RISCVInstrInfoVSDPatterns.td``, VL nodes in ``RISCVInstrInfoVVLPatterns."
"td`` and RVV intrinsics in ``RISCVInstrInfoVPseudos.td``."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:236
msgid ""
"Instructions that operate only on masks like VMAND or VMSBF uses pseudo "
"instructions suffixed with B1, B2, B4, B8, B16, B32, or B64 where the number "
"is SEW/LMUL representing the ratio between SEW and LMUL needed in vtype. "
"These instructions always operate as if EEW=1 and always use a value of 0 as "
"their SEW operand."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:240
msgid "Mask patterns"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:242
msgid ""
"For masked pseudos the mask operand is copied to the physical ``$v0`` "
"register during instruction selection with a glued ``CopyToReg`` node:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:249
msgid ""
"The patterns in ``RISCVInstrInfoVVLPatterns.td`` only match masked pseudos "
"to reduce the size of the match table, even if the node's mask is all ones "
"and could be an unmasked pseudo. ``RISCVFoldMasks::convertToUnmasked`` will "
"detect if the mask is all ones and convert it into its unmasked form."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:263
msgid ""
"Any ``vmset.m`` can be treated as an all ones mask since the tail elements "
"past AVL are ``undef`` and can be replaced with ones."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:268
msgid "Register allocation"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:270
msgid ""
"Register allocation is split between vector and scalar registers, with "
"vector allocation running first:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:278
msgid ""
"Register allocation is split so that :ref:`RISCVInsertVSETVLI` can run after "
"vector register allocation, but before scalar register allocation. It needs "
"to be run before scalar register allocation as it may need to create a new "
"virtual register to set the AVL to VLMAX."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:280
msgid ""
"Performing ``RISCVInsertVSETVLI`` after vector register allocation imposes "
"fewer constraints on the machine scheduler since it cannot schedule "
"instructions past ``vsetvli``\\s, and it allows us to emit further vector "
"pseudos during spilling or constant rematerialization."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:282
msgid "There are four register classes for vectors:"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:284
msgid ""
"``VR`` for vector registers (``v0``, ``v1,``, ..., ``v32``). Used when :math:"
"`\\text{LMUL} \\leq 1` and mask registers."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:285
msgid ""
"``VRM2`` for vector groups of length 2 i.e., :math:`\\text{LMUL}=2` "
"(``v0m2``, ``v2m2``, ..., ``v30m2``)"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:286
msgid ""
"``VRM4`` for vector groups of length 4 i.e., :math:`\\text{LMUL}=4` "
"(``v0m4``, ``v4m4``, ..., ``v28m4``)"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:287
msgid ""
"``VRM8`` for vector groups of length 8 i.e., :math:`\\text{LMUL}=8` "
"(``v0m8``, ``v8m8``, ..., ``v24m8``)"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:289
msgid ""
":math:`\\text{LMUL} \\lt 1` types and mask types do not benefit from having "
"a dedicated class, so ``VR`` is used in their case."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:291
msgid ""
"Some instructions have a constraint that a register operand cannot be ``V0`` "
"or overlap with ``V0``, so for these cases we also have ``VRNoV0`` variants."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:296
msgid "RISCVInsertVSETVLI"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:298
msgid ""
"After vector registers are allocated, the ``RISCVInsertVSETVLI`` pass will "
"insert the necessary ``vsetvli``\\s for the pseudos."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:305
msgid ""
"The physical ``$vl`` and ``$vtype`` registers are implicitly defined by the "
"``PseudoVSETVLI``, and are implicitly used by the ``PseudoVADD``. The "
"``vtype`` operand (``209`` in this example) is encoded as per the "
"specification via ``RISCVVType::encodeVTYPE``."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:308
msgid ""
"``RISCVInsertVSETVLI`` performs dataflow analysis to emit as few "
"``vsetvli``\\s as possible. It will also try to minimize the number of "
"``vsetvli``\\s that set VL, i.e., it will emit ``vsetvli x0, x0`` if only "
"``vtype`` needs changed but ``vl`` doesn't."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:311
msgid "Pseudo expansion and printing"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:313
msgid ""
"After scalar register allocation, the ``RISCVExpandPseudoInsts.cpp`` pass "
"expands the ``PseudoVSETVLI`` instructions."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:320
msgid ""
"Note that the vector pseudo remains as it's needed to encode the register "
"class for the LMUL. Its AVL and SEW operands are no longer used."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:322
msgid ""
"``RISCVAsmPrinter`` will then lower the pseudo instructions into real "
"``MCInst``\\s."
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:332
msgid "See also"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:334
msgid ""
"`[llvm-dev] [RFC] Code generation for RISC-V V-extension <https://lists.llvm."
"org/pipermail/llvm-dev/2020-October/145850.html>`_"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:335
msgid ""
"`2023 LLVM Dev Mtg - Vector codegen in the RISC-V backend <https://youtu.be/-"
"ox8iJmbp0c?feature=shared>`_"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:336
msgid ""
"`2023 LLVM Dev Mtg - How to add an C intrinsic and code-gen it, using the "
"RISC-V vector C intrinsics <https://youtu.be/t17O_bU1jks?feature=shared>`_"
msgstr ""

#: ../../../RISCV/RISCVVectorExtension.rst:337
msgid ""
"`2021 LLVM Dev Mtg “Optimizing code for scalable vector architectures” "
"<https://youtu.be/daWLCyhwrZ8?feature=shared>`_"
msgstr ""
