# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CommandGuide/llvm-mca.rst:2
msgid "llvm-mca - LLVM Machine Code Analyzer"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:5
msgid "SYNOPSIS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:7
msgid ":program:`llvm-mca` [*options*] [input]"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:10
msgid "DESCRIPTION"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:12
msgid ""
":program:`llvm-mca` is a performance analysis tool that uses information "
"available in LLVM (e.g. scheduling models) to statically measure the "
"performance of machine code in a specific CPU."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:16
msgid ""
"Performance is measured in terms of throughput as well as processor resource "
"consumption. The tool currently works for processors with an out-of-order "
"backend, for which there is a scheduling model available in LLVM."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:20
msgid ""
"The main goal of this tool is not just to predict the performance of the "
"code when run on the target, but also help with diagnosing potential "
"performance issues."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:24
msgid ""
"Given an assembly code sequence, :program:`llvm-mca` estimates the "
"Instructions Per Cycle (IPC), as well as hardware resource pressure. The "
"analysis and reporting style were inspired by the IACA tool from Intel."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:28
msgid ""
"For example, you can compile code with clang, output assembly, and pipe it "
"directly into :program:`llvm-mca` for analysis:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:35
msgid "Or for Intel syntax:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:42
msgid "OPTIONS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:44
msgid ""
"If ``input`` is \"``-``\" or omitted, :program:`llvm-mca` reads from "
"standard input. Otherwise, it will read from the specified filename."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:47
msgid ""
"If the :option:`-o` option is omitted, then :program:`llvm-mca` will send "
"its output to standard output if the input is from standard input.  If the :"
"option:`-o` option specifies \"``-``\", then the output will also be sent to "
"standard output."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:54
msgid "Print a summary of command line options."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:58
msgid "Specify a target triple string."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:62
msgid ""
"Specify the architecture for which to analyze the code. It defaults to the "
"host default target."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:67
msgid ""
"Specify the processor for which to analyze the code.  By default, the cpu "
"name is autodetected from the host."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:72
msgid ""
"Specify the output assembly variant for the report generated by the tool. On "
"x86, possible values are [0, 1]. A value of 0 (vic. 1) for this flag enables "
"the AT&T (vic. Intel) assembly format for the code printed out by the tool "
"in the analysis report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:79
msgid ""
"Specify a different dispatch width for the processor. The dispatch width "
"defaults to field 'IssueWidth' in the processor scheduling model.  If width "
"is zero, then the default dispatch width is used."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:85
msgid ""
"Specify the size of the register file. When specified, this flag limits how "
"many physical registers are available for register renaming purposes. A "
"value of zero for this flag means \"unlimited number of physical registers\"."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:91
msgid ""
"Specify the number of iterations to run. If this flag is set to 0, then the "
"tool sets the number of iterations to a default value (i.e. 100)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:96
msgid ""
"If set, the tool assumes that loads and stores don't alias. This is the "
"default behavior."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:101
msgid ""
"Specify the size of the load queue in the load/store unit emulated by the "
"tool. By default, the tool assumes an unbound number of entries in the load "
"queue. A value of zero for this flag is ignored, and the default load queue "
"size is used instead."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:108
msgid ""
"Specify the size of the store queue in the load/store unit emulated by the "
"tool. By default, the tool assumes an unbound number of entries in the store "
"queue. A value of zero for this flag is ignored, and the default store queue "
"size is used instead."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:115
msgid "Enable the timeline view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:119
msgid ""
"Limit the number of iterations to print in the timeline view. By default, "
"the timeline view prints information for up to 10 iterations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:124
msgid ""
"Limit the number of cycles in the timeline view. By default, the number of "
"cycles is set to 80."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:129
msgid "Enable the resource pressure view. This is enabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:133
msgid "Enable register file usage statistics."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:137
msgid ""
"Enable extra dispatch statistics. This view collects and analyzes "
"instruction dispatch events, as well as static/dynamic dispatch stall "
"events. This view is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:143
msgid ""
"Enable extra scheduler statistics. This view collects and analyzes "
"instruction issue events. This view is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:148
msgid ""
"Enable extra retire control unit statistics. This view is disabled by "
"default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:152
msgid "Enable the instruction info view. This is enabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:156
msgid ""
"Print all hardware statistics. This enables extra statistics related to the "
"dispatch logic, the hardware schedulers, the register file(s), and the "
"retire control unit. This option is disabled by default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:162
msgid "Enable all the view."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:166
msgid ""
"Prints resource pressure information based on the static information "
"available from the processor model. This differs from the resource pressure "
"view because it doesn't require that the code is simulated. It instead "
"prints the theoretical uniform distribution of resource pressure for every "
"instruction in sequence."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:174
msgid "EXIT STATUS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:176
msgid ""
":program:`llvm-mca` returns 0 on success. Otherwise, an error message is "
"printed to standard error, and the tool returns 1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:180
msgid "USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:181
msgid ""
":program:`llvm-mca` allows for the optional usage of special code comments "
"to mark regions of the assembly code to be analyzed.  A comment starting "
"with substring ``LLVM-MCA-BEGIN`` marks the beginning of a code region. A "
"comment starting with substring ``LLVM-MCA-END`` marks the end of a code "
"region.  For example:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:193
msgid ""
"Multiple regions can be specified provided that they do not overlap.  A code "
"region can have an optional description. If no user-defined region is "
"specified, then :program:`llvm-mca` assumes a default region which contains "
"every instruction in the input file.  Every region is analyzed in isolation, "
"and the final performance report is the union of all the reports generated "
"for every code region."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:200
msgid ""
"Inline assembly directives may be used from source code to annotate the "
"assembly text:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:214
msgid "HOW LLVM-MCA WORKS"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:216
msgid ""
":program:`llvm-mca` takes assembly code as input. The assembly code is "
"parsed into a sequence of MCInst with the help of the existing LLVM target "
"assembly parsers. The parsed sequence of MCInst is then analyzed by a "
"``Pipeline`` module to generate a performance report."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:221
msgid ""
"The Pipeline module simulates the execution of the machine code sequence in "
"a loop of iterations (default is 100). During this process, the pipeline "
"collects a number of execution related statistics. At the end of this "
"process, the pipeline generates and prints a report from the collected "
"statistics."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:226
msgid ""
"Here is an example of a performance report generated by the tool for a dot-"
"product of two packed float vectors of four elements. The analysis is "
"conducted for target x86, cpu btver2.  The following result can be produced "
"via the following command using the example located at ``test/tools/llvm-mca/"
"X86/BtVer2/dot-product.s``:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:290
msgid ""
"According to this report, the dot-product kernel has been executed 300 "
"times, for a total of 900 simulated instructions. The total number of "
"simulated micro opcodes (uOps) is also 900."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:294
msgid ""
"The report is structured in three main sections.  The first section collects "
"a few performance numbers; the goal of this section is to give a very quick "
"overview of the performance throughput. Important performance indicators are "
"**IPC**, **uOps Per Cycle**, and  **Block RThroughput** (Block Reciprocal "
"Throughput)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:300
msgid ""
"IPC is computed dividing the total number of simulated instructions by the "
"total number of cycles. In the absence of loop-carried data dependencies, "
"the observed IPC tends to a theoretical maximum which can be computed by "
"dividing the number of instructions of a single iteration by the *Block "
"RThroughput*."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:305
msgid ""
"Field 'uOps Per Cycle' is computed dividing the total number of simulated "
"micro opcodes by the total number of cycles. A delta between Dispatch Width "
"and this field is an indicator of a performance issue. In the absence of "
"loop-carried data dependencies, the observed 'uOps Per Cycle' should tend to "
"a theoretical maximum throughput which can be computed by dividing the "
"number of uOps of a single iteration by the *Block RThroughput*."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:312
msgid ""
"Field *uOps Per Cycle* is bounded from above by the dispatch width. That is "
"because the dispatch width limits the maximum size of a dispatch group. Both "
"IPC and 'uOps Per Cycle' are limited by the amount of hardware parallelism. "
"The availability of hardware resources affects the resource pressure "
"distribution, and it limits the number of instructions that can be executed "
"in parallel every cycle.  A delta between Dispatch Width and the theoretical "
"maximum uOps per Cycle (computed by dividing the number of uOps of a single "
"iteration by the *Block RTrhoughput*) is an indicator of a performance "
"bottleneck caused by the lack of hardware resources. In general, the lower "
"the Block RThroughput, the better."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:323
msgid ""
"In this example, ``uOps per iteration/Block RThroughput`` is 1.50. Since "
"there are no loop-carried dependencies, the observed *uOps Per Cycle* is "
"expected to approach 1.50 when the number of iterations tends to infinity. "
"The delta between the Dispatch Width (2.00), and the theoretical maximum uOp "
"throughput (1.50) is an indicator of a performance bottleneck caused by the "
"lack of hardware resources, and the *Resource pressure view* can help to "
"identify the problematic resource usage."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:331
msgid ""
"The second section of the report shows the latency and reciprocal throughput "
"of every instruction in the sequence. That section also reports extra "
"information related to the number of micro opcodes, and opcode properties (i."
"e., 'MayLoad', 'MayStore', and 'HasSideEffects')."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:336
msgid ""
"The third section is the *Resource pressure view*.  This view reports the "
"average number of resource cycles consumed every iteration by instructions "
"for every processor resource unit available on the target.  Information is "
"structured in two tables. The first table reports the number of resource "
"cycles spent on average every iteration. The second table correlates the "
"resource cycles to the machine instruction in the sequence. For example, "
"every iteration of the instruction vmulps always executes on resource unit "
"[6] (JFPU1 - floating point pipeline #1), consuming an average of 1 resource "
"cycle per iteration.  Note that on AMD Jaguar, vector floating-point "
"multiply can only be issued to pipeline JFPU1, while horizontal floating-"
"point additions can only be issued to pipeline JFPU0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:348
msgid ""
"The resource pressure view helps with identifying bottlenecks caused by high "
"usage of specific hardware resources.  Situations with resource pressure "
"mainly concentrated on a few resources should, in general, be avoided.  "
"Ideally, pressure should be uniformly distributed between multiple resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:354
msgid "Timeline View"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:355
msgid ""
"The timeline view produces a detailed report of each instruction's state "
"transitions through an instruction pipeline.  This view is enabled by the "
"command line option ``-timeline``.  As instructions transition through the "
"various stages of the pipeline, their states are depicted in the view "
"report. These states are represented by the following characters:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:361
msgid "D : Instruction dispatched."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:362
msgid "e : Instruction executing."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:363
msgid "E : Instruction executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:364
msgid "R : Instruction retired."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:365
msgid "= : Instruction already dispatched, waiting to be executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:366
msgid "\\- : Instruction executed, waiting to be retired."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:368
msgid ""
"Below is the timeline view for a subset of the dot-product example located "
"in ``test/tools/llvm-mca/X86/BtVer2/dot-product.s`` and processed by :"
"program:`llvm-mca` using the following command:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:404
msgid ""
"The timeline view is interesting because it shows instruction state changes "
"during execution.  It also gives an idea of how the tool processes "
"instructions executed on the target, and how their timing information might "
"be calculated."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:408
msgid ""
"The timeline view is structured in two tables.  The first table shows "
"instructions changing state over time (measured in cycles); the second table "
"(named *Average Wait times*) reports useful timing statistics, which should "
"help diagnose performance bottlenecks caused by long data dependencies and "
"sub-optimal usage of hardware resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:414
msgid ""
"An instruction in the timeline view is identified by a pair of indices, "
"where the first index identifies an iteration, and the second index is the "
"instruction index (i.e., where it appears in the code sequence).  Since this "
"example was generated using 3 iterations: ``-iterations=3``, the iteration "
"indices range from 0-2 inclusively."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:420
msgid ""
"Excluding the first and last column, the remaining columns are in cycles. "
"Cycles are numbered sequentially starting from 0."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:423
msgid "From the example output above, we know the following:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:425
msgid "Instruction [1,0] was dispatched at cycle 1."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:426
msgid "Instruction [1,0] started executing at cycle 2."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:427
msgid "Instruction [1,0] reached the write back stage at cycle 4."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:428
msgid "Instruction [1,0] was retired at cycle 10."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:430
msgid ""
"Instruction [1,0] (i.e., vmulps from iteration #1) does not have to wait in "
"the scheduler's queue for the operands to become available. By the time "
"vmulps is dispatched, operands are already available, and pipeline JFPU1 is "
"ready to serve another instruction.  So the instruction can be immediately "
"issued on the JFPU1 pipeline. That is demonstrated by the fact that the "
"instruction only spent 1cy in the scheduler's queue."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:437
msgid ""
"There is a gap of 5 cycles between the write-back stage and the retire "
"event. That is because instructions must retire in program order, so [1,0] "
"has to wait for [0,2] to be retired first (i.e., it has to wait until cycle "
"10)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:441
msgid ""
"In the example, all instructions are in a RAW (Read After Write) dependency "
"chain.  Register %xmm2 written by vmulps is immediately used by the first "
"vhaddps, and register %xmm3 written by the first vhaddps is used by the "
"second vhaddps.  Long data dependencies negatively impact the ILP "
"(Instruction Level Parallelism)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:447
msgid ""
"In the dot-product example, there are anti-dependencies introduced by "
"instructions from different iterations.  However, those dependencies can be "
"removed at register renaming stage (at the cost of allocating register "
"aliases, and therefore consuming physical registers)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:452
msgid ""
"Table *Average Wait times* helps diagnose performance issues that are caused "
"by the presence of long latency instructions and potentially long data "
"dependencies which may limit the ILP.  Note that :program:`llvm-mca`, by "
"default, assumes at least 1cy between the dispatch event and the issue event."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:457
msgid ""
"When the performance is limited by data dependencies and/or long latency "
"instructions, the number of cycles spent while in the *ready* state is "
"expected to be very small when compared with the total number of cycles "
"spent in the scheduler's queue.  The difference between the two counters is "
"a good indicator of how large of an impact data dependencies had on the "
"execution of the instructions.  When performance is mostly limited by the "
"lack of hardware resources, the delta between the two counters is small.  "
"However, the number of cycles spent in the queue tends to be larger (i.e., "
"more than 1-3cy), especially when compared to other low latency instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:468
msgid "Extra Statistics to Further Diagnose Performance Issues"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:469
msgid ""
"The ``-all-stats`` command line option enables extra statistics and "
"performance counters for the dispatch logic, the reorder buffer, the retire "
"control unit, and the register file."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:473
msgid ""
"Below is an example of ``-all-stats`` output generated by  :program:`llvm-"
"mca` for 300 iterations of the dot-product example discussed in the previous "
"sections."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:538
msgid ""
"If we look at the *Dynamic Dispatch Stall Cycles* table, we see the counter "
"for SCHEDQ reports 272 cycles.  This counter is incremented every time the "
"dispatch logic is unable to dispatch a full group because the scheduler's "
"queue is full."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:542
msgid ""
"Looking at the *Dispatch Logic* table, we see that the pipeline was only "
"able to dispatch two micro opcodes 51.5% of the time.  The dispatch group "
"was limited to one micro opcode 44.6% of the cycles, which corresponds to "
"272 cycles.  The dispatch statistics are displayed by either using the "
"command option ``-all-stats`` or ``-dispatch-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:548
msgid ""
"The next table, *Schedulers*, presents a histogram displaying a count, "
"representing the number of instructions issued on some number of cycles.  In "
"this case, of the 610 simulated cycles, single instructions were issued 306 "
"times (50.2%) and there were 7 cycles where no instructions were issued."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:553
msgid ""
"The *Scheduler's queue usage* table shows that the average and maximum "
"number of buffer entries (i.e., scheduler queue entries) used at runtime.  "
"Resource JFPU01 reached its maximum (18 of 18 queue entries). Note that AMD "
"Jaguar implements three schedulers:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:558
msgid "JALU01 - A scheduler for ALU instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:559
msgid "JFPU01 - A scheduler floating point operations."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:560
msgid "JLSAGU - A scheduler for address generation."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:562
msgid ""
"The dot-product is a kernel of three floating point instructions (a vector "
"multiply followed by two horizontal adds).  That explains why only the "
"floating point scheduler appears to be used."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:566
msgid ""
"A full scheduler queue is either caused by data dependency chains or by a "
"sub-optimal usage of hardware resources.  Sometimes, resource pressure can "
"be mitigated by rewriting the kernel using different instructions that "
"consume different scheduler resources.  Schedulers with a small queue are "
"less resilient to bottlenecks caused by the presence of long data "
"dependencies.  The scheduler statistics are displayed by using the command "
"option ``-all-stats`` or ``-scheduler-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:574
msgid ""
"The next table, *Retire Control Unit*, presents a histogram displaying a "
"count, representing the number of instructions retired on some number of "
"cycles.  In this case, of the 610 simulated cycles, two instructions were "
"retired during the same cycle 399 times (65.4%) and there were 109 cycles "
"where no instructions were retired.  The retire statistics are displayed by "
"using the command option ``-all-stats`` or ``-retire-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:581
msgid ""
"The last table presented is *Register File statistics*.  Each physical "
"register file (PRF) used by the pipeline is presented in this table.  In the "
"case of AMD Jaguar, there are two register files, one for floating-point "
"registers (JFpuPRF) and one for integer registers (JIntegerPRF).  The table "
"shows that of the 900 instructions processed, there were 900 mappings "
"created.  Since this dot-product example utilized only floating point "
"registers, the JFPuPRF was responsible for creating the 900 mappings.  "
"However, we see that the pipeline only used a maximum of 35 of 72 available "
"register slots at any given time. We can conclude that the floating point "
"PRF was the only register file used for the example, and that it was never "
"resource constrained.  The register file statistics are displayed by using "
"the command option ``-all-stats`` or ``-register-file-stats``."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:594
msgid ""
"In this example, we can conclude that the IPC is mostly limited by data "
"dependencies, and not by resource pressure."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:598
msgid "Instruction Flow"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:599
msgid ""
"This section describes the instruction flow through the default pipeline of :"
"program:`llvm-mca`, as well as the functional units involved in the process."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:602
msgid ""
"The default pipeline implements the following sequence of stages used to "
"process instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:605
msgid "Dispatch (Instruction is dispatched to the schedulers)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:606
msgid "Issue (Instruction is issued to the processor pipelines)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:607
msgid "Write Back (Instruction is executed, and results are written back)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:608
msgid "Retire (Instruction is retired; writes are architecturally committed)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:610
msgid ""
"The default pipeline only models the out-of-order portion of a processor. "
"Therefore, the instruction fetch and decode stages are not modeled. "
"Performance bottlenecks in the frontend are not diagnosed. :program:`llvm-"
"mca` assumes that instructions have all been decoded and placed into a queue "
"before the simulation start.  Also, :program:`llvm-mca` does not model "
"branch prediction."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:617
msgid "Instruction Dispatch"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:618
msgid ""
"During the dispatch stage, instructions are picked in program order from a "
"queue of already decoded instructions, and dispatched in groups to the "
"simulated hardware schedulers."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:622
msgid ""
"The size of a dispatch group depends on the availability of the simulated "
"hardware resources.  The processor dispatch width defaults to the value of "
"the ``IssueWidth`` in LLVM's scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:626
msgid "An instruction can be dispatched if:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:628
msgid ""
"The size of the dispatch group is smaller than processor's dispatch width."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:629
msgid "There are enough entries in the reorder buffer."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:630
msgid "There are enough physical registers to do register renaming."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:631
msgid "The schedulers are not full."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:633
msgid ""
"Scheduling models can optionally specify which register files are available "
"on the processor. :program:`llvm-mca` uses that information to initialize "
"register file descriptors.  Users can limit the number of physical registers "
"that are globally available for register renaming by using the command "
"option ``-register-file-size``.  A value of zero for this option means "
"*unbounded*. By knowing how many registers are available for renaming, the "
"tool can predict dispatch stalls caused by the lack of physical registers."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:641
msgid ""
"The number of reorder buffer entries consumed by an instruction depends on "
"the number of micro-opcodes specified for that instruction by the target "
"scheduling model.  The reorder buffer is responsible for tracking the "
"progress of instructions that are \"in-flight\", and retiring them in "
"program order.  The number of entries in the reorder buffer defaults to the "
"value specified by field `MicroOpBufferSize` in the target scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:648
msgid ""
"Instructions that are dispatched to the schedulers consume scheduler buffer "
"entries. :program:`llvm-mca` queries the scheduling model to determine the "
"set of buffered resources consumed by an instruction.  Buffered resources "
"are treated like scheduler resources."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:654
msgid "Instruction Issue"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:655
msgid ""
"Each processor scheduler implements a buffer of instructions.  An "
"instruction has to wait in the scheduler's buffer until input register "
"operands become available.  Only at that point, does the instruction becomes "
"eligible for execution and may be issued (potentially out-of-order) for "
"execution. Instruction latencies are computed by :program:`llvm-mca` with "
"the help of the scheduling model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:662
msgid ""
":program:`llvm-mca`'s scheduler is designed to simulate multiple processor "
"schedulers.  The scheduler is responsible for tracking data dependencies, "
"and dynamically selecting which processor resources are consumed by "
"instructions. It delegates the management of processor resource units and "
"resource groups to a resource manager.  The resource manager is responsible "
"for selecting resource units that are consumed by instructions.  For "
"example, if an instruction consumes 1cy of a resource group, the resource "
"manager selects one of the available units from the group; by default, the "
"resource manager uses a round-robin selector to guarantee that resource "
"usage is uniformly distributed between all units of a group."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:673
msgid ""
":program:`llvm-mca`'s scheduler internally groups instructions into three "
"sets:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:675
msgid "WaitSet: a set of instructions whose operands are not ready."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:676
msgid "ReadySet: a set of instructions ready to execute."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:677
msgid "IssuedSet: a set of instructions executing."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:679
msgid ""
"Depending on the operands availability, instructions that are dispatched to "
"the scheduler are either placed into the WaitSet or into the ReadySet."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:682
msgid ""
"Every cycle, the scheduler checks if instructions can be moved from the "
"WaitSet to the ReadySet, and if instructions from the ReadySet can be issued "
"to the underlying pipelines. The algorithm prioritizes older instructions "
"over younger instructions."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:688
msgid "Write-Back and Retire Stage"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:689
msgid ""
"Issued instructions are moved from the ReadySet to the IssuedSet.  There, "
"instructions wait until they reach the write-back stage.  At that point, "
"they get removed from the queue and the retire control unit is notified."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:693
msgid ""
"When instructions are executed, the retire control unit flags the "
"instruction as \"ready to retire.\""
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:696
msgid ""
"Instructions are retired in program order.  The register file is notified of "
"the retirement so that it can free the physical registers that were "
"allocated for the instruction during the register renaming stage."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:701
msgid "Load/Store Unit and Memory Consistency Model"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:702
msgid ""
"To simulate an out-of-order execution of memory operations, :program:`llvm-"
"mca` utilizes a simulated load/store unit (LSUnit) to simulate the "
"speculative execution of loads and stores."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:706
msgid ""
"Each load (or store) consumes an entry in the load (or store) queue. Users "
"can specify flags ``-lqueue`` and ``-squeue`` to limit the number of entries "
"in the load and store queues respectively. The queues are unbounded by "
"default."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:710
msgid ""
"The LSUnit implements a relaxed consistency model for memory loads and "
"stores. The rules are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:713
msgid ""
"A younger load is allowed to pass an older load only if there are no "
"intervening stores or barriers between the two loads."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:715
msgid ""
"A younger load is allowed to pass an older store provided that the load does "
"not alias with the store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:717
msgid "A younger store is not allowed to pass an older store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:718
msgid "A younger store is not allowed to pass an older load."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:720
msgid ""
"By default, the LSUnit optimistically assumes that loads do not alias (`-"
"noalias=true`) store operations.  Under this assumption, younger loads are "
"always allowed to pass older stores.  Essentially, the LSUnit does not "
"attempt to run any alias analysis to predict when loads and stores do not "
"alias with each other."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:726
msgid ""
"Note that, in the case of write-combining memory, rule 3 could be relaxed to "
"allow reordering of non-aliasing store operations.  That being said, at the "
"moment, there is no way to further relax the memory model (``-noalias`` is "
"the only option).  Essentially, there is no option to specify a different "
"memory type (e.g., write-back, write-combining, write-through; etc.) and "
"consequently to weaken, or strengthen, the memory model."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:733
msgid "Other limitations are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:735
msgid "The LSUnit does not know when store-to-load forwarding may occur."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:736
msgid ""
"The LSUnit does not know anything about cache hierarchy and memory types."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:737
msgid ""
"The LSUnit does not know how to identify serializing operations and memory "
"fences."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:740
msgid ""
"The LSUnit does not attempt to predict if a load or store hits or misses the "
"L1 cache.  It only knows if an instruction \"MayLoad\" and/or \"MayStore.\"  "
"For loads, the scheduling model provides an \"optimistic\" load-to-use "
"latency (which usually matches the load-to-use latency for when there is a "
"hit in the L1D)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:745
msgid ""
":program:`llvm-mca` does not know about serializing operations or memory-"
"barrier like instructions.  The LSUnit conservatively assumes that an "
"instruction which has both \"MayLoad\" and unmodeled side effects behaves "
"like a \"soft\" load-barrier.  That means, it serializes loads without "
"forcing a flush of the load queue.  Similarly, instructions that "
"\"MayStore\" and have unmodeled side effects are treated like store "
"barriers.  A full memory barrier is a \"MayLoad\" and \"MayStore\" "
"instruction with unmodeled side effects.  This is inaccurate, but it is the "
"best that we can do at the moment with the current information available in "
"LLVM."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:755
msgid ""
"A load/store barrier consumes one entry of the load/store queue.  A load/"
"store barrier enforces ordering of loads/stores.  A younger load cannot pass "
"a load barrier.  Also, a younger store cannot pass a store barrier.  A "
"younger load has to wait for the memory/load barrier to execute.  A load/"
"store barrier is \"executed\" when it becomes the oldest entry in the load/"
"store queue(s). That also means, by construction, all of the older loads/"
"stores have been executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:762
msgid "In conclusion, the full set of load/store consistency rules are:"
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:764
msgid "A store may not pass a previous store."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:765
msgid "A store may not pass a previous load (regardless of ``-noalias``)."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:766
msgid "A store has to wait until an older store barrier is fully executed."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:767
msgid "A load may pass a previous load."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:768
msgid "A load may not pass a previous store unless ``-noalias`` is set."
msgstr ""

#: ../../../CommandGuide/llvm-mca.rst:769
msgid "A load has to wait until an older load barrier is fully executed."
msgstr ""
