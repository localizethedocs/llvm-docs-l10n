# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../StackMaps.rst:3
msgid "Stack maps and patch points in LLVM"
msgstr ""

#: ../../../StackMaps.rst:10
msgid "Definitions"
msgstr ""

#: ../../../StackMaps.rst:12
msgid ""
"In this document we refer to the \"runtime\" collectively as all components "
"that serve as the LLVM client, including the LLVM IR generator, object code "
"consumer, and code patcher."
msgstr ""

#: ../../../StackMaps.rst:16
msgid ""
"A stack map records the location of ``live values`` at a particular "
"instruction address. These ``live values`` do not refer to all the LLVM "
"values live across the stack map. Instead, they are only the values that the "
"runtime requires to be live at this point. For example, they may be the "
"values the runtime will need to resume program execution at that point "
"independent of the compiled function containing the stack map."
msgstr ""

#: ../../../StackMaps.rst:24
msgid ""
"LLVM emits stack map data into the object code within a designated :ref:"
"`stackmap-section`. This stack map data contains a record for each stack "
"map. The record stores the stack map's instruction address and contains an "
"entry for each mapped value. Each entry encodes a value's location as a "
"register, stack offset, or constant."
msgstr ""

#: ../../../StackMaps.rst:30
msgid ""
"A patch point is an instruction address at which space is reserved for "
"patching a new instruction sequence at run time. Patch points look much like "
"calls to LLVM. They take arguments that follow a calling convention and may "
"return a value. They also imply stack map generation, which allows the "
"runtime to locate the patchpoint and find the location of ``live values`` at "
"that point."
msgstr ""

#: ../../../StackMaps.rst:38
msgid "Motivation"
msgstr ""

#: ../../../StackMaps.rst:40
msgid ""
"This functionality is currently experimental but is potentially useful in a "
"variety of settings, the most obvious being a runtime (JIT) compiler. "
"Example applications of the patchpoint intrinsics are implementing an inline "
"call cache for polymorphic method dispatch or optimizing the retrieval of "
"properties in dynamically typed languages such as JavaScript."
msgstr ""

#: ../../../StackMaps.rst:47
msgid ""
"The intrinsics documented here are currently used by the JavaScript compiler "
"within the open source WebKit project, see the `FTL JIT <https://trac.webkit."
"org/wiki/FTLJIT>`_, but they are designed to be used whenever stack maps or "
"code patching are needed. Because the intrinsics have experimental status, "
"compatibility across LLVM releases is not guaranteed."
msgstr ""

#: ../../../StackMaps.rst:54
msgid ""
"The stack map functionality described in this document is separate from the "
"functionality described in :ref:`stack-map`. `GCFunctionMetadata` provides "
"the location of pointers into a collected heap captured by the `GCRoot` "
"intrinsic, which can also be considered a \"stack map\". Unlike the stack "
"maps defined above, the `GCFunctionMetadata` stack map interface does not "
"provide a way to associate live register values of arbitrary type with an "
"instruction address, nor does it specify a format for the resulting stack "
"map. The stack maps described here could potentially provide richer "
"information to a garbage collecting runtime, but that usage will not be "
"discussed in this document."
msgstr ""

#: ../../../StackMaps.rst:67
msgid "Intrinsics"
msgstr ""

#: ../../../StackMaps.rst:69
msgid ""
"The following two kinds of intrinsics can be used to implement stack maps "
"and patch points: ``llvm.experimental.stackmap`` and ``llvm.experimental."
"patchpoint``. Both kinds of intrinsics generate a stack map record, and they "
"both allow some form of code patching. They can be used independently (i.e. "
"``llvm.experimental.patchpoint`` implicitly generates a stack map without "
"the need for an additional call to ``llvm.experimental.stackmap``). The "
"choice of which to use depends on whether it is necessary to reserve space "
"for code patching and whether any of the intrinsic arguments should be "
"lowered according to calling conventions. ``llvm.experimental.stackmap`` "
"does not reserve any space, nor does it expect any call arguments. If the "
"runtime patches code at the stack map's address, it will destructively "
"overwrite the program text. This is unlike ``llvm.experimental.patchpoint``, "
"which reserves space for in-place patching without overwriting surrounding "
"code. The ``llvm.experimental.patchpoint`` intrinsic also lowers a specified "
"number of arguments according to its calling convention. This allows patched "
"code to make in-place function calls without marshaling."
msgstr ""

#: ../../../StackMaps.rst:88
msgid ""
"Each instance of one of these intrinsics generates a stack map record in "
"the :ref:`stackmap-section`. The record includes an ID, allowing the runtime "
"to uniquely identify the stack map, and the offset within the code from the "
"beginning of the enclosing function."
msgstr ""

#: ../../../StackMaps.rst:94
msgid "'``llvm.experimental.stackmap``' Intrinsic"
msgstr ""

#: ../../../StackMaps.rst:97 ../../../StackMaps.rst:186
msgid "Syntax:"
msgstr ""

#: ../../../StackMaps.rst:105 ../../../StackMaps.rst:198
msgid "Overview:"
msgstr ""

#: ../../../StackMaps.rst:107
msgid ""
"The '``llvm.experimental.stackmap``' intrinsic records the location of "
"specified values in the stack map without generating any code."
msgstr ""

#: ../../../StackMaps.rst:111 ../../../StackMaps.rst:205
msgid "Operands:"
msgstr ""

#: ../../../StackMaps.rst:113
msgid ""
"The first operand is an ID to be encoded within the stack map. The second "
"operand is the number of shadow bytes following the intrinsic. These first "
"two operands should be immediate, e.g. cannot be passed as variables. The "
"variable number of operands that follow are the ``live values`` for which "
"locations will be recorded in the stack map."
msgstr ""

#: ../../../StackMaps.rst:119
msgid ""
"To use this intrinsic as a bare-bones stack map, with no code patching "
"support, the number of shadow bytes can be set to zero."
msgstr ""

#: ../../../StackMaps.rst:123 ../../../StackMaps.rst:216
msgid "Semantics:"
msgstr ""

#: ../../../StackMaps.rst:125
msgid ""
"The stack map intrinsic generates no code in place, unless nops are needed "
"to cover its shadow (see below). However, its offset from function entry is "
"stored in the stack map. This is the relative instruction address "
"immediately following the instructions that precede the stack map."
msgstr ""

#: ../../../StackMaps.rst:131
msgid ""
"The stack map ID allows a runtime to locate the desired stack map record. "
"LLVM passes this ID through directly to the stack map record without "
"checking uniqueness."
msgstr ""

#: ../../../StackMaps.rst:135
msgid ""
"LLVM guarantees a shadow of instructions following the stack map's "
"instruction offset during which neither the end of the basic block nor "
"another call to ``llvm.experimental.stackmap`` or ``llvm.experimental."
"patchpoint`` may occur. This allows the runtime to patch the code at this "
"point in response to an event triggered from outside the code. The code for "
"instructions following the stack map may be emitted in the stack map's "
"shadow, and these instructions may be overwritten by destructive patching. "
"Without shadow bytes, this destructive patching could overwrite program text "
"or data outside the current function. We disallow overlapping stack map "
"shadows so that the runtime does not need to consider this corner case."
msgstr ""

#: ../../../StackMaps.rst:147
msgid "For example, a stack map with 8-byte shadow:"
msgstr ""

#: ../../../StackMaps.rst:158
msgid "May require one byte of nop-padding:"
msgstr ""

#: ../../../StackMaps.rst:169
msgid ""
"Now, if the runtime needs to invalidate the compiled code, it may patch 8 "
"bytes of code at the stack map's address at follows:"
msgstr ""

#: ../../../StackMaps.rst:178
msgid ""
"This way, after the normal call to the runtime returns, the code will "
"execute a patched call to a special entry point that can rebuild a stack "
"frame from the values located by the stack map."
msgstr ""

#: ../../../StackMaps.rst:183
msgid "'``llvm.experimental.patchpoint.*``' Intrinsic"
msgstr ""

#: ../../../StackMaps.rst:200
msgid ""
"The '``llvm.experimental.patchpoint.*``' intrinsics creates a function call "
"to the specified ``<target>`` and records the location of specified values "
"in the stack map."
msgstr ""

#: ../../../StackMaps.rst:207
msgid ""
"The first operand is an ID, the second operand is the number of bytes "
"reserved for the patchable region, the third operand is the target address "
"of a function (optionally null), and the fourth operand specifies how many "
"of the following variable operands are considered function call arguments. "
"The remaining variable number of operands are the ``live values`` for which "
"locations will be recorded in the stack map."
msgstr ""

#: ../../../StackMaps.rst:218
msgid ""
"The patch point intrinsic generates a stack map. It also emits a function "
"call to the address specified by ``<target>`` if the address is not a "
"constant null. The function call and its arguments are lowered according to "
"the calling convention specified at the intrinsic's callsite. Variants of "
"the intrinsic with non-void return type also return a value according to "
"calling convention."
msgstr ""

#: ../../../StackMaps.rst:225
msgid ""
"On PowerPC, note that ``<target>`` must be the ABI function pointer for the "
"intended target of the indirect call. Specifically, when compiling for the "
"ELF V1 ABI, ``<target>`` is the function-descriptor address normally used as "
"the C/C++ function-pointer representation."
msgstr ""

#: ../../../StackMaps.rst:230
msgid ""
"Requesting zero patch point arguments is valid. In this case, all variable "
"operands are handled just like ``llvm.experimental.stackmap.*``. The "
"difference is that space will still be reserved for patching, a call will be "
"emitted, and a return value is allowed."
msgstr ""

#: ../../../StackMaps.rst:236
msgid ""
"The location of the arguments are not normally recorded in the stack map "
"because they are already fixed by the calling convention. The remaining "
"``live values`` will have their location recorded, which could be a "
"register, stack location, or constant. A special calling convention has been "
"introduced for use with stack maps, anyregcc, which forces the arguments to "
"be loaded into registers but allows those register to be dynamically "
"allocated. These argument registers will have their register locations "
"recorded in the stack map in addition to the remaining ``live values``."
msgstr ""

#: ../../../StackMaps.rst:246
msgid ""
"The patch point also emits nops to cover at least ``<numBytes>`` of "
"instruction encoding space. Hence, the client must ensure that "
"``<numBytes>`` is enough to encode a call to the target address on the "
"supported targets. If the call target is constant null, then there is no "
"minimum requirement. A zero-byte null target patchpoint is valid."
msgstr ""

#: ../../../StackMaps.rst:253
msgid ""
"The runtime may patch the code emitted for the patch point, including the "
"call sequence and nops. However, the runtime may not assume anything about "
"the code LLVM emits within the reserved space. Partial patching is not "
"allowed. The runtime must patch all reserved bytes, padding with nops if "
"necessary."
msgstr ""

#: ../../../StackMaps.rst:259
msgid ""
"This example shows a patch point reserving 15 bytes, with one argument in "
"$rdi, and a return value in $rax per native calling convention:"
msgstr ""

#: ../../../StackMaps.rst:271
msgid "May generate:"
msgstr ""

#: ../../../StackMaps.rst:282
msgid ""
"Note that no stack map locations will be recorded. If the patched code "
"sequence does not need arguments fixed to specific calling convention "
"registers, then the ``anyregcc`` convention may be used:"
msgstr ""

#: ../../../StackMaps.rst:292
msgid ""
"The stack map now indicates the location of the %ptr argument and return "
"value:"
msgstr ""

#: ../../../StackMaps.rst:299
msgid ""
"The patch code sequence may now use the argument that happened to be "
"allocated in %r8 and return a value allocated in %r9:"
msgstr ""

#: ../../../StackMaps.rst:314
msgid "Stack Map Format"
msgstr ""

#: ../../../StackMaps.rst:316
msgid ""
"The existence of a stack map or patch point intrinsic within an LLVM Module "
"forces code emission to create a :ref:`stackmap-section`. The format of this "
"section follows:"
msgstr ""

#: ../../../StackMaps.rst:362
msgid ""
"The first byte of each location encodes a type that indicates how to "
"interpret the ``RegNum`` and ``Offset`` fields as follows:"
msgstr ""

#: ../../../StackMaps.rst:366
msgid "Encoding"
msgstr ""

#: ../../../StackMaps.rst:366
msgid "Type"
msgstr ""

#: ../../../StackMaps.rst:366
msgid "Value"
msgstr ""

#: ../../../StackMaps.rst:366
msgid "Description"
msgstr "Description"

#: ../../../StackMaps.rst:368
msgid "0x1"
msgstr ""

#: ../../../StackMaps.rst:368
msgid "Register"
msgstr ""

#: ../../../StackMaps.rst:368
msgid "Reg"
msgstr ""

#: ../../../StackMaps.rst:368
msgid "Value in a register"
msgstr ""

#: ../../../StackMaps.rst:369
msgid "0x2"
msgstr ""

#: ../../../StackMaps.rst:369
msgid "Direct"
msgstr ""

#: ../../../StackMaps.rst:369
msgid "Reg + Offset"
msgstr ""

#: ../../../StackMaps.rst:369
msgid "Frame index value"
msgstr ""

#: ../../../StackMaps.rst:370
msgid "0x3"
msgstr ""

#: ../../../StackMaps.rst:370
msgid "Indirect"
msgstr ""

#: ../../../StackMaps.rst:370
msgid "[Reg + Offset]"
msgstr ""

#: ../../../StackMaps.rst:370
msgid "Spilled value"
msgstr ""

#: ../../../StackMaps.rst:371
msgid "0x4"
msgstr ""

#: ../../../StackMaps.rst:371
msgid "Constant"
msgstr ""

#: ../../../StackMaps.rst:371
msgid "Offset"
msgstr ""

#: ../../../StackMaps.rst:371
msgid "Small constant"
msgstr ""

#: ../../../StackMaps.rst:372
msgid "0x5"
msgstr ""

#: ../../../StackMaps.rst:372
msgid "ConstIndex"
msgstr ""

#: ../../../StackMaps.rst:372
msgid "Constants[Offset]"
msgstr ""

#: ../../../StackMaps.rst:372
msgid "Large constant"
msgstr ""

#: ../../../StackMaps.rst:375
msgid ""
"In the common case, a value is available in a register, and the ``Offset`` "
"field will be zero. Values spilled to the stack are encoded as ``Indirect`` "
"locations. The runtime must load those values from a stack address, "
"typically in the form ``[BP + Offset]``. If an ``alloca`` value is passed "
"directly to a stack map intrinsic, then LLVM may fold the frame index into "
"the stack map as an optimization to avoid allocating a register or stack "
"slot. These frame indices will be encoded as ``Direct`` locations in the "
"form ``BP + Offset``. LLVM may also optimize constants by emitting them "
"directly in the stack map, either in the ``Offset`` of a ``Constant`` "
"location or in the constant pool, referred to by ``ConstantIndex`` locations."
msgstr ""

#: ../../../StackMaps.rst:387
msgid ""
"At each callsite, a \"liveout\" register list is also recorded. These are "
"the registers that are live across the stackmap and therefore must be saved "
"by the runtime. This is an important optimization when the patchpoint "
"intrinsic is used with a calling convention that by default preserves most "
"registers as callee-save."
msgstr ""

#: ../../../StackMaps.rst:393
msgid ""
"Each entry in the liveout register list contains a DWARF register number and "
"size in bytes. The stackmap format deliberately omits specific subregister "
"information. Instead the runtime must interpret this information "
"conservatively. For example, if the stackmap reports one byte at ``%rax``, "
"then the value may be in either ``%al`` or ``%ah``. It doesn't matter in "
"practice, because the runtime will simply save ``%rax``. However, if the "
"stackmap reports 16 bytes at ``%ymm0``, then the runtime can safely optimize "
"by saving only ``%xmm0``."
msgstr ""

#: ../../../StackMaps.rst:403
msgid ""
"The stack map format is a contract between an LLVM SVN revision and the "
"runtime. It is currently experimental and may change in the short term, but "
"minimizing the need to update the runtime is important. Consequently, the "
"stack map design is motivated by simplicity and extensibility. Compactness "
"of the representation is secondary because the runtime is expected to parse "
"the data immediately after compiling a module and encode the information in "
"its own format. Since the runtime controls the allocation of sections, it "
"can reuse the same stack map space for multiple modules."
msgstr ""

#: ../../../StackMaps.rst:413
msgid ""
"Stackmap support is currently only implemented for 64-bit platforms. "
"However, a 32-bit implementation should be able to use the same format with "
"an insignificant amount of wasted space."
msgstr ""

#: ../../../StackMaps.rst:420
msgid "Stack Map Section"
msgstr ""

#: ../../../StackMaps.rst:422
msgid ""
"A JIT compiler can easily access this section by providing its own memory "
"manager via the LLVM C API ``LLVMCreateSimpleMCJITMemoryManager()``. When "
"creating the memory manager, the JIT provides a callback: "
"``LLVMMemoryManagerAllocateDataSectionCallback()``. When LLVM creates this "
"section, it invokes the callback and passes the section name. The JIT can "
"record the in-memory address of the section at this time and later parse it "
"to recover the stack map data."
msgstr ""

#: ../../../StackMaps.rst:431
msgid ""
"For MachO (e.g. on Darwin), the stack map section name is "
"\"__llvm_stackmaps\". The segment name is \"__LLVM_STACKMAPS\"."
msgstr ""

#: ../../../StackMaps.rst:434
msgid ""
"For ELF (e.g. on Linux), the stack map section name is \".llvm_stackmaps\".  "
"The segment name is \"__LLVM_STACKMAPS\"."
msgstr ""

#: ../../../StackMaps.rst:438
msgid "Stack Map Usage"
msgstr ""

#: ../../../StackMaps.rst:440
msgid ""
"The stack map support described in this document can be used to precisely "
"determine the location of values at a specific position in the code. LLVM "
"does not maintain any mapping between those values and any higher-level "
"entity. The runtime must be able to interpret the stack map record given "
"only the ID, offset, and the order of the locations, records, and functions, "
"which LLVM preserves."
msgstr ""

#: ../../../StackMaps.rst:447
msgid ""
"Note that this is quite different from the goal of debug information, which "
"is a best-effort attempt to track the location of named variables at every "
"instruction."
msgstr ""

#: ../../../StackMaps.rst:451
msgid ""
"An important motivation for this design is to allow a runtime to commandeer "
"a stack frame when execution reaches an instruction address associated with "
"a stack map. The runtime must be able to rebuild a stack frame and resume "
"program execution using the information provided by the stack map. For "
"example, execution may resume in an interpreter or a recompiled version of "
"the same function."
msgstr ""

#: ../../../StackMaps.rst:458
msgid ""
"This usage restricts LLVM optimization. Clearly, LLVM must not move stores "
"across a stack map. However, loads must also be handled conservatively. If "
"the load may trigger an exception, hoisting it above a stack map could be "
"invalid. For example, the runtime may determine that a load is safe to "
"execute without a type check given the current state of the type system. If "
"the type system changes while some activation of the load's function exists "
"on the stack, the load becomes unsafe. The runtime can prevent subsequent "
"execution of that load by immediately patching any stack map location that "
"lies between the current call site and the load (typically, the runtime "
"would simply patch all stack map locations to invalidate the function). If "
"the compiler had hoisted the load above the stack map, then the program "
"could crash before the runtime could take back control."
msgstr ""

#: ../../../StackMaps.rst:472
msgid ""
"To enforce these semantics, stackmap and patchpoint intrinsics are "
"considered to potentially read and write all memory. This may limit "
"optimization more than some clients desire. This limitation may be avoided "
"by marking the call site as \"readonly\". In the future we may also allow "
"meta-data to be added to the intrinsic call to express aliasing, thereby "
"allowing optimizations to hoist certain loads above stack maps."
msgstr ""

#: ../../../StackMaps.rst:481
msgid "Direct Stack Map Entries"
msgstr ""

#: ../../../StackMaps.rst:483
msgid ""
"As shown in :ref:`stackmap-section`, a Direct stack map location records the "
"address of frame index. This address is itself the value that the runtime "
"requested. This differs from Indirect locations, which refer to a stack "
"locations from which the requested values must be loaded. Direct locations "
"can communicate the address if an alloca, while Indirect locations handle "
"register spills."
msgstr ""

#: ../../../StackMaps.rst:490
msgid "For example:"
msgstr ""

#: ../../../StackMaps.rst:498
msgid ""
"The runtime can determine this alloca's relative location on the stack "
"immediately after compilation, or at any time thereafter. This differs from "
"Register and Indirect locations, because the runtime can only read the "
"values in those locations when execution reaches the instruction address of "
"the stack map."
msgstr ""

#: ../../../StackMaps.rst:504
msgid ""
"This functionality requires LLVM to treat entry-block allocas specially when "
"they are directly consumed by an intrinsics. (This is the same requirement "
"imposed by the llvm.gcroot intrinsic.) LLVM transformations must not "
"substitute the alloca with any intervening value. This can be verified by "
"the runtime simply by checking that the stack map's location is a Direct "
"location type."
msgstr ""

#: ../../../StackMaps.rst:513
msgid "Supported Architectures"
msgstr ""

#: ../../../StackMaps.rst:515
msgid ""
"Support for StackMap generation and the related intrinsics requires some "
"code for each backend.  Today, only a subset of LLVM's backends are "
"supported.  The currently supported architectures are X86_64, PowerPC, "
"AArch64 and SystemZ."
msgstr ""
