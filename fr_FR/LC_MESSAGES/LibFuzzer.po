# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../LibFuzzer.rst:3
msgid "libFuzzer – a library for coverage-guided fuzz testing."
msgstr ""

#: ../../../LibFuzzer.rst:9
msgid "Introduction"
msgstr ""

#: ../../../LibFuzzer.rst:11
msgid ""
"LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine."
msgstr ""

#: ../../../LibFuzzer.rst:13
msgid ""
"LibFuzzer is linked with the library under test, and feeds fuzzed inputs to "
"the library via a specific fuzzing entrypoint (aka \"target function\"); the "
"fuzzer then tracks which areas of the code are reached, and generates "
"mutations on the corpus of input data in order to maximize the code "
"coverage. The code coverage information for libFuzzer is provided by LLVM's "
"SanitizerCoverage_ instrumentation."
msgstr ""

#: ../../../LibFuzzer.rst:21
msgid "Contact: libfuzzer(#)googlegroups.com"
msgstr ""

#: ../../../LibFuzzer.rst:24
msgid "Status"
msgstr "Statut"

#: ../../../LibFuzzer.rst:26
msgid ""
"The original authors of libFuzzer have stopped active work on it and "
"switched to working on another fuzzing engine, Centipede_. LibFuzzer is "
"still fully supported in that important bugs will get fixed. However, please "
"do not expect major new features or code reviews, other than for bug fixes."
msgstr ""

#: ../../../LibFuzzer.rst:32
msgid "Versions"
msgstr ""

#: ../../../LibFuzzer.rst:34
msgid "LibFuzzer requires a matching version of Clang."
msgstr ""

#: ../../../LibFuzzer.rst:38
msgid "Getting Started"
msgstr ""

#: ../../../LibFuzzer.rst:45
msgid "Fuzz Target"
msgstr ""

#: ../../../LibFuzzer.rst:47
msgid ""
"The first step in using libFuzzer on a library is to implement a *fuzz "
"target* -- a function that accepts an array of bytes and does something "
"interesting with these bytes using the API under test. Like this:"
msgstr ""

#: ../../../LibFuzzer.rst:60
msgid ""
"Note that this fuzz target does not depend on libFuzzer in any way and so it "
"is possible and even desirable to use it with other fuzzing engines e.g. "
"AFL_ and/or Radamsa_."
msgstr ""

#: ../../../LibFuzzer.rst:64
msgid "Some important things to remember about fuzz targets:"
msgstr ""

#: ../../../LibFuzzer.rst:66
msgid ""
"The fuzzing engine will execute the fuzz target many times with different "
"inputs in the same process."
msgstr ""

#: ../../../LibFuzzer.rst:67
msgid "It must tolerate any kind of input (empty, huge, malformed, etc)."
msgstr ""

#: ../../../LibFuzzer.rst:68
msgid "It must not `exit()` on any input."
msgstr ""

#: ../../../LibFuzzer.rst:69
msgid ""
"It may use threads but ideally all threads should be joined at the end of "
"the function."
msgstr ""

#: ../../../LibFuzzer.rst:70
msgid ""
"It must be as deterministic as possible. Non-determinism (e.g. random "
"decisions not based on the input bytes) will make fuzzing inefficient."
msgstr ""

#: ../../../LibFuzzer.rst:71
msgid ""
"It must be fast. Try avoiding cubic or greater complexity, logging, or "
"excessive memory consumption."
msgstr ""

#: ../../../LibFuzzer.rst:72
msgid ""
"Ideally, it should not modify any global state (although that's not strict)."
msgstr ""

#: ../../../LibFuzzer.rst:73
msgid ""
"Usually, the narrower the target the better. E.g. if your target can parse "
"several data formats, split it into several targets, one per format."
msgstr ""

#: ../../../LibFuzzer.rst:77
msgid "Fuzzer Usage"
msgstr ""

#: ../../../LibFuzzer.rst:79
msgid ""
"Recent versions of Clang (starting from 6.0) include libFuzzer, and no extra "
"installation is necessary."
msgstr ""

#: ../../../LibFuzzer.rst:81
msgid ""
"In order to build your fuzzer binary, use the `-fsanitize=fuzzer` flag "
"during the compilation and linking. In most cases you may want to combine "
"libFuzzer with AddressSanitizer_ (ASAN), UndefinedBehaviorSanitizer_ "
"(UBSAN), or both.  You can also build with MemorySanitizer_ (MSAN), but "
"support is experimental::"
msgstr ""

#: ../../../LibFuzzer.rst:91
msgid ""
"This will perform the necessary instrumentation, as well as linking with the "
"libFuzzer library. Note that ``-fsanitize=fuzzer`` links in the libFuzzer's "
"``main()`` symbol."
msgstr ""

#: ../../../LibFuzzer.rst:94
msgid ""
"If modifying ``CFLAGS`` of a large project, which also compiles executables "
"requiring their own ``main`` symbol, it may be desirable to request just the "
"instrumentation without linking::"
msgstr ""

#: ../../../LibFuzzer.rst:100
msgid ""
"Then libFuzzer can be linked to the desired driver by passing in ``-"
"fsanitize=fuzzer`` during the linking stage."
msgstr ""

#: ../../../LibFuzzer.rst:106
msgid "Corpus"
msgstr ""

#: ../../../LibFuzzer.rst:108
msgid ""
"Coverage-guided fuzzers like libFuzzer rely on a corpus of sample inputs for "
"the code under test.  This corpus should ideally be seeded with a varied "
"collection of valid and invalid inputs for the code under test; for example, "
"for a graphics library the initial corpus might hold a variety of different "
"small PNG/JPG/GIF files.  The fuzzer generates random mutations based around "
"the sample inputs in the current corpus.  If a mutation triggers execution "
"of a previously-uncovered path in the code under test, then that mutation is "
"saved to the corpus for future variations."
msgstr ""

#: ../../../LibFuzzer.rst:117
msgid ""
"LibFuzzer will work without any initial seeds, but will be less efficient if "
"the library under test accepts complex, structured inputs."
msgstr ""

#: ../../../LibFuzzer.rst:121
msgid ""
"The corpus can also act as a sanity/regression check, to confirm that the "
"fuzzing entrypoint still works and that all of the sample inputs run through "
"the code under test without problems."
msgstr ""

#: ../../../LibFuzzer.rst:125
msgid ""
"If you have a large corpus (either generated by fuzzing or acquired by other "
"means) you may want to minimize it while still preserving the full coverage. "
"One way to do that is to use the `-merge=1` flag:"
msgstr ""

#: ../../../LibFuzzer.rst:134
msgid ""
"You may use the same flag to add more interesting items to an existing "
"corpus. Only the inputs that trigger new coverage will be added to the first "
"corpus."
msgstr ""

#: ../../../LibFuzzer.rst:142
msgid "Running"
msgstr ""

#: ../../../LibFuzzer.rst:144
msgid ""
"To run the fuzzer, first create a Corpus_ directory that holds the initial "
"\"seed\" sample inputs:"
msgstr ""

#: ../../../LibFuzzer.rst:152
msgid "Then run the fuzzer on the corpus directory:"
msgstr ""

#: ../../../LibFuzzer.rst:158
msgid ""
"As the fuzzer discovers new interesting test cases (i.e. test cases that "
"trigger coverage of new paths through the code under test), those test cases "
"will be added to the corpus directory."
msgstr ""

#: ../../../LibFuzzer.rst:162
msgid ""
"By default, the fuzzing process will continue indefinitely – at least until "
"a bug is found.  Any crashes or sanitizer failures will be reported as "
"usual, stopping the fuzzing process, and the particular input that triggered "
"the bug will be written to disk (typically as ``crash-<sha1>``, ``leak-"
"<sha1>``, or ``timeout-<sha1>``)."
msgstr ""

#: ../../../LibFuzzer.rst:170
msgid "Parallel Fuzzing"
msgstr ""

#: ../../../LibFuzzer.rst:172
msgid ""
"Each libFuzzer process is single-threaded, unless the library under test "
"starts its own threads.  However, it is possible to run multiple libFuzzer "
"processes in parallel with a shared corpus directory; this has the advantage "
"that any new inputs found by one fuzzer process will be available to the "
"other fuzzer processes (unless you disable this with the ``-reload=0`` "
"option)."
msgstr ""

#: ../../../LibFuzzer.rst:178
msgid ""
"This is primarily controlled by the ``-jobs=N`` option, which indicates that "
"that `N` fuzzing jobs should be run to completion (i.e. until a bug is found "
"or time/iteration limits are reached).  These jobs will be run across a set "
"of worker processes, by default using half of the available CPU cores; the "
"count of worker processes can be overridden by the ``-workers=N`` option.  "
"For example, running with ``-jobs=30`` on a 12-core machine would run 6 "
"workers by default, with each worker averaging 5 bugs by completion of the "
"entire process."
msgstr ""

#: ../../../LibFuzzer.rst:187
msgid "Fork mode"
msgstr ""

#: ../../../LibFuzzer.rst:189
msgid ""
"**Experimental** mode ``-fork=N`` (where ``N`` is the number of parallel "
"jobs) enables oom-, timeout-, and crash-resistant fuzzing with separate "
"processes (using ``fork-exec``, not just ``fork``)."
msgstr ""

#: ../../../LibFuzzer.rst:193
msgid ""
"The top libFuzzer process will not do any fuzzing itself, but will spawn up "
"to ``N`` concurrent child processes providing them small random subsets of "
"the corpus. After a child exits, the top process merges the corpus generated "
"by the child back to the main corpus."
msgstr ""

#: ../../../LibFuzzer.rst:198
msgid "Related flags:"
msgstr ""

#: ../../../LibFuzzer.rst:201
msgid "``-ignore_ooms``"
msgstr ""

#: ../../../LibFuzzer.rst:201
msgid ""
"True by default. If an OOM happens during fuzzing in one of the child "
"processes, the reproducer is saved on disk, and fuzzing continues."
msgstr ""

#: ../../../LibFuzzer.rst:203
msgid "``-ignore_timeouts``"
msgstr ""

#: ../../../LibFuzzer.rst:204
msgid "True by default, same as ``-ignore_ooms``, but for timeouts."
msgstr ""

#: ../../../LibFuzzer.rst:206
msgid "``-ignore_crashes``"
msgstr ""

#: ../../../LibFuzzer.rst:206
msgid "False by default, same as ``-ignore_ooms``, but for all other crashes."
msgstr ""

#: ../../../LibFuzzer.rst:208
msgid ""
"The plan is to eventually replace ``-jobs=N`` and ``-workers=N`` with ``-"
"fork=N``."
msgstr ""

#: ../../../LibFuzzer.rst:211
msgid "Resuming merge"
msgstr ""

#: ../../../LibFuzzer.rst:213
msgid ""
"Merging large corpora may be time consuming, and it is often desirable to do "
"it on preemptable VMs, where the process may be killed at any time. In order "
"to seamlessly resume the merge, use the ``-merge_control_file`` flag and use "
"``killall -SIGUSR1 /path/to/fuzzer/binary`` to stop the merge gracefully. "
"Example:"
msgstr ""

#: ../../../LibFuzzer.rst:238
msgid "Options"
msgstr ""

#: ../../../LibFuzzer.rst:240
msgid ""
"To run the fuzzer, pass zero or more corpus directories as command line "
"arguments.  The fuzzer will read test inputs from each of these corpus "
"directories, and any new test inputs that are generated will be written back "
"to the first corpus directory:"
msgstr ""

#: ../../../LibFuzzer.rst:249
msgid ""
"If a list of files (rather than directories) are passed to the fuzzer "
"program, then it will re-run those files as test inputs but will not perform "
"any fuzzing. In this mode the fuzzer binary can be used as a regression test "
"(e.g. on a continuous integration system) to check the target function and "
"saved inputs still work."
msgstr ""

#: ../../../LibFuzzer.rst:255
msgid "The most important command line options are:"
msgstr ""

#: ../../../LibFuzzer.rst:257
msgid "``-help``"
msgstr ""

#: ../../../LibFuzzer.rst:258
msgid "Print help message (``-help=1``)."
msgstr ""

#: ../../../LibFuzzer.rst:259
msgid "``-seed``"
msgstr ""

#: ../../../LibFuzzer.rst:260
msgid "Random seed. If 0 (the default), the seed is generated."
msgstr ""

#: ../../../LibFuzzer.rst:261
msgid "``-runs``"
msgstr ""

#: ../../../LibFuzzer.rst:262
msgid "Number of individual test runs, -1 (the default) to run indefinitely."
msgstr ""

#: ../../../LibFuzzer.rst:264
msgid "``-max_len``"
msgstr ""

#: ../../../LibFuzzer.rst:264
msgid ""
"Maximum length of a test input. If 0 (the default), libFuzzer tries to guess "
"a good value based on the corpus (and reports it)."
msgstr ""

#: ../../../LibFuzzer.rst:268
msgid "``-len_control``"
msgstr ""

#: ../../../LibFuzzer.rst:267
msgid ""
"Try generating small inputs first, then try larger inputs over time. "
"Specifies the rate at which the length limit is increased (smaller == "
"faster). Default is 100. If 0, immediately try inputs with size up to "
"max_len."
msgstr ""

#: ../../../LibFuzzer.rst:271
msgid "``-timeout``"
msgstr ""

#: ../../../LibFuzzer.rst:271
msgid ""
"Timeout in seconds, default 1200. If an input takes longer than this "
"timeout, the process is treated as a failure case."
msgstr ""

#: ../../../LibFuzzer.rst:277
msgid "``-rss_limit_mb``"
msgstr ""

#: ../../../LibFuzzer.rst:274
msgid ""
"Memory usage limit in Mb, default 2048. Use 0 to disable the limit. If an "
"input requires more than this amount of RSS memory to execute, the process "
"is treated as a failure case. The limit is checked in a separate thread "
"every second. If running w/o ASAN/MSAN, you may use 'ulimit -v' instead."
msgstr ""

#: ../../../LibFuzzer.rst:281
msgid "``-malloc_limit_mb``"
msgstr ""

#: ../../../LibFuzzer.rst:280
msgid ""
"If non-zero, the fuzzer will exit if the target tries to allocate this "
"number of Mb with one malloc call. If zero (default) same limit as "
"rss_limit_mb is applied."
msgstr ""

#: ../../../LibFuzzer.rst:283
msgid "``-timeout_exitcode``"
msgstr ""

#: ../../../LibFuzzer.rst:284
msgid "Exit code (default 77) used if libFuzzer reports a timeout."
msgstr ""

#: ../../../LibFuzzer.rst:285
msgid "``-error_exitcode``"
msgstr ""

#: ../../../LibFuzzer.rst:286
msgid ""
"Exit code (default 77) used if libFuzzer itself (not a sanitizer) reports a "
"bug (leak, OOM, etc)."
msgstr ""

#: ../../../LibFuzzer.rst:288
msgid "``-max_total_time``"
msgstr ""

#: ../../../LibFuzzer.rst:288
msgid ""
"If positive, indicates the maximum total time in seconds to run the fuzzer. "
"If 0 (the default), run indefinitely."
msgstr ""

#: ../../../LibFuzzer.rst:292
msgid "``-merge``"
msgstr ""

#: ../../../LibFuzzer.rst:291
msgid ""
"If set to 1, any corpus inputs from the 2nd, 3rd etc. corpus directories "
"that trigger new code coverage will be merged into the first corpus "
"directory.  Defaults to 0. This flag can be used to minimize a corpus."
msgstr ""

#: ../../../LibFuzzer.rst:296
msgid "``-merge_control_file``"
msgstr ""

#: ../../../LibFuzzer.rst:295
msgid ""
"Specify a control file used for the merge process. If a merge process gets "
"killed it tries to leave this file in a state suitable for resuming the "
"merge. By default a temporary file will be used."
msgstr ""

#: ../../../LibFuzzer.rst:299
msgid "``-minimize_crash``"
msgstr ""

#: ../../../LibFuzzer.rst:299
msgid ""
"If 1, minimizes the provided crash input. Use with -runs=N or -"
"max_total_time=N to limit the number of attempts."
msgstr ""

#: ../../../LibFuzzer.rst:303
msgid "``-reload``"
msgstr ""

#: ../../../LibFuzzer.rst:302
msgid ""
"If set to 1 (the default), the corpus directory is re-read periodically to "
"check for new inputs; this allows detection of new inputs that were "
"discovered by other fuzzing processes."
msgstr ""

#: ../../../LibFuzzer.rst:309
msgid "``-jobs``"
msgstr ""

#: ../../../LibFuzzer.rst:306
msgid ""
"Number of fuzzing jobs to run to completion. Default value is 0, which runs "
"a single fuzzing process until completion.  If the value is >= 1, then this "
"number of jobs performing fuzzing are run, in a collection of parallel "
"separate worker processes; each such worker process has its ``stdout``/"
"``stderr`` redirected to ``fuzz-<JOB>.log``."
msgstr ""

#: ../../../LibFuzzer.rst:312
msgid "``-workers``"
msgstr ""

#: ../../../LibFuzzer.rst:312
msgid ""
"Number of simultaneous worker processes to run the fuzzing jobs to "
"completion in. If 0 (the default), ``min(jobs, NumberOfCpuCores()/2)`` is "
"used."
msgstr ""

#: ../../../LibFuzzer.rst:314
msgid "``-dict``"
msgstr ""

#: ../../../LibFuzzer.rst:315
msgid "Provide a dictionary of input keywords; see Dictionaries_."
msgstr ""

#: ../../../LibFuzzer.rst:317
msgid "``-use_counters``"
msgstr ""

#: ../../../LibFuzzer.rst:317
msgid ""
"Use `coverage counters`_ to generate approximate counts of how often code "
"blocks are hit; defaults to 1."
msgstr ""

#: ../../../LibFuzzer.rst:320
msgid "``-reduce_inputs``"
msgstr ""

#: ../../../LibFuzzer.rst:320
msgid ""
"Try to reduce the size of inputs while preserving their full feature sets; "
"defaults to 1."
msgstr ""

#: ../../../LibFuzzer.rst:322
msgid "``-use_value_profile``"
msgstr ""

#: ../../../LibFuzzer.rst:323
msgid "Use `value profile`_ to guide corpus expansion; defaults to 0."
msgstr ""

#: ../../../LibFuzzer.rst:324
msgid "``-only_ascii``"
msgstr ""

#: ../../../LibFuzzer.rst:325
msgid ""
"If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0."
msgstr ""

#: ../../../LibFuzzer.rst:327
msgid "``-artifact_prefix``"
msgstr ""

#: ../../../LibFuzzer.rst:327
msgid ""
"Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or "
"slow inputs) as ``$(artifact_prefix)file``.  Defaults to empty."
msgstr ""

#: ../../../LibFuzzer.rst:332
msgid "``-exact_artifact_path``"
msgstr ""

#: ../../../LibFuzzer.rst:330
msgid ""
"Ignored if empty (the default).  If non-empty, write the single artifact on "
"failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides ``-"
"artifact_prefix`` and will not use checksum in the file name. Do not use the "
"same path for several parallel processes."
msgstr ""

#: ../../../LibFuzzer.rst:334
msgid "``-print_pcs``"
msgstr ""

#: ../../../LibFuzzer.rst:335
msgid "If 1, print out newly covered PCs. Defaults to 0."
msgstr ""

#: ../../../LibFuzzer.rst:336
msgid "``-print_final_stats``"
msgstr ""

#: ../../../LibFuzzer.rst:337
msgid "If 1, print statistics at exit.  Defaults to 0."
msgstr ""

#: ../../../LibFuzzer.rst:339
msgid "``-detect_leaks``"
msgstr ""

#: ../../../LibFuzzer.rst:339
msgid ""
"If 1 (default) and if LeakSanitizer is enabled try to detect memory leaks "
"during fuzzing (i.e. not only at shut down)."
msgstr ""

#: ../../../LibFuzzer.rst:348
msgid "``-close_fd_mask``"
msgstr ""

#: ../../../LibFuzzer.rst:342
msgid ""
"Indicate output streams to close at startup. Be careful, this will remove "
"diagnostic output from target code (e.g. messages on assert failure)."
msgstr ""

#: ../../../LibFuzzer.rst:345
msgid "0 (default): close neither ``stdout`` nor ``stderr``"
msgstr ""

#: ../../../LibFuzzer.rst:346
msgid "1 : close ``stdout``"
msgstr ""

#: ../../../LibFuzzer.rst:347
msgid "2 : close ``stderr``"
msgstr ""

#: ../../../LibFuzzer.rst:348
msgid "3 : close both ``stdout`` and ``stderr``."
msgstr ""

#: ../../../LibFuzzer.rst:350
msgid "For the full list of flags run the fuzzer binary with ``-help=1``."
msgstr ""

#: ../../../LibFuzzer.rst:353
msgid "Output"
msgstr ""

#: ../../../LibFuzzer.rst:355
msgid ""
"During operation the fuzzer prints information to ``stderr``, for example::"
msgstr ""

#: ../../../LibFuzzer.rst:369
msgid ""
"The early parts of the output include information about the fuzzer options "
"and configuration, including the current random seed (in the ``Seed:`` line; "
"this can be overridden with the ``-seed=N`` flag)."
msgstr ""

#: ../../../LibFuzzer.rst:373
msgid ""
"Further output lines have the form of an event code and statistics.  The "
"possible event codes are:"
msgstr ""

#: ../../../LibFuzzer.rst:377
msgid "``READ``"
msgstr ""

#: ../../../LibFuzzer.rst:377
msgid ""
"The fuzzer has read in all of the provided input samples from the corpus "
"directories."
msgstr ""

#: ../../../LibFuzzer.rst:380
msgid "``INITED``"
msgstr ""

#: ../../../LibFuzzer.rst:380
msgid ""
"The fuzzer has completed initialization, which includes running each of the "
"initial input samples through the code under test."
msgstr ""

#: ../../../LibFuzzer.rst:383
msgid "``NEW``"
msgstr ""

#: ../../../LibFuzzer.rst:383
msgid ""
"The fuzzer has created a test input that covers new areas of the code under "
"test.  This input will be saved to the primary corpus directory."
msgstr ""

#: ../../../LibFuzzer.rst:386
msgid "``REDUCE``"
msgstr ""

#: ../../../LibFuzzer.rst:386
msgid ""
"The fuzzer has found a better (smaller) input that triggers previously "
"discovered features (set ``-reduce_inputs=0`` to disable)."
msgstr ""

#: ../../../LibFuzzer.rst:389
msgid "``pulse``"
msgstr ""

#: ../../../LibFuzzer.rst:389
msgid ""
"The fuzzer has generated 2\\ :sup:`n` inputs (generated periodically to "
"reassure the user that the fuzzer is still working)."
msgstr ""

#: ../../../LibFuzzer.rst:392
msgid "``DONE``"
msgstr ""

#: ../../../LibFuzzer.rst:392
msgid ""
"The fuzzer has completed operation because it has reached the specified "
"iteration limit (``-runs``) or time limit (``-max_total_time``)."
msgstr ""

#: ../../../LibFuzzer.rst:397
msgid "``RELOAD``"
msgstr ""

#: ../../../LibFuzzer.rst:395
msgid ""
"The fuzzer is performing a periodic reload of inputs from the corpus "
"directory; this allows it to discover any inputs discovered by other fuzzer "
"processes (see `Parallel Fuzzing`_)."
msgstr ""

#: ../../../LibFuzzer.rst:399
msgid "Each output line also reports the following statistics (when non-zero):"
msgstr ""

#: ../../../LibFuzzer.rst:401
msgid "``cov:``"
msgstr ""

#: ../../../LibFuzzer.rst:402
msgid ""
"Total number of code blocks or edges covered by executing the current corpus."
msgstr ""

#: ../../../LibFuzzer.rst:405
msgid "``ft:``"
msgstr ""

#: ../../../LibFuzzer.rst:404
msgid ""
"libFuzzer uses different signals to evaluate the code coverage: edge "
"coverage, edge counters, value profiles, indirect caller/callee pairs, etc. "
"These signals combined are called *features* (`ft:`)."
msgstr ""

#: ../../../LibFuzzer.rst:407
msgid "``corp:``"
msgstr ""

#: ../../../LibFuzzer.rst:408
msgid ""
"Number of entries in the current in-memory test corpus and its size in bytes."
msgstr ""

#: ../../../LibFuzzer.rst:410
msgid "``lim:``"
msgstr ""

#: ../../../LibFuzzer.rst:410
msgid ""
"Current limit on the length of new entries in the corpus.  Increases over "
"time until the max length (``-max_len``) is reached."
msgstr ""

#: ../../../LibFuzzer.rst:412
msgid "``exec/s:``"
msgstr ""

#: ../../../LibFuzzer.rst:413
msgid "Number of fuzzer iterations per second."
msgstr ""

#: ../../../LibFuzzer.rst:415
msgid "``rss:``"
msgstr ""

#: ../../../LibFuzzer.rst:415
msgid "Current memory consumption."
msgstr ""

#: ../../../LibFuzzer.rst:417
msgid ""
"For ``NEW`` and ``REDUCE`` events, the output line also includes information "
"about the mutation operation that produced the new input:"
msgstr ""

#: ../../../LibFuzzer.rst:420
msgid "``L:``"
msgstr ""

#: ../../../LibFuzzer.rst:421
msgid "Size of the new input in bytes."
msgstr ""

#: ../../../LibFuzzer.rst:424
msgid "``MS: <n> <operations>``"
msgstr ""

#: ../../../LibFuzzer.rst:423
msgid "Count and list of the mutation operations used to generate the input."
msgstr ""

#: ../../../LibFuzzer.rst:427
msgid "Examples"
msgstr ""

#: ../../../LibFuzzer.rst:433
msgid "Toy example"
msgstr ""

#: ../../../LibFuzzer.rst:435
msgid ""
"A simple function that does something interesting if it receives the input "
"\"HI!\"::"
msgstr ""

#: ../../../LibFuzzer.rst:454
msgid "You should get an error pretty quickly::"
msgstr ""

#: ../../../LibFuzzer.rst:472
msgid "More examples"
msgstr ""

#: ../../../LibFuzzer.rst:474
msgid ""
"Examples of real-life fuzz targets and the bugs they find can be found at "
"http://tutorial.libfuzzer.info. Among other things you can learn how to "
"detect Heartbleed_ in one second."
msgstr ""

#: ../../../LibFuzzer.rst:480
msgid "Advanced features"
msgstr ""

#: ../../../LibFuzzer.rst:486
msgid "Dictionaries"
msgstr ""

#: ../../../LibFuzzer.rst:487
msgid ""
"LibFuzzer supports user-supplied dictionaries with input language keywords "
"or other interesting byte sequences (e.g. multi-byte magic values). Use ``-"
"dict=DICTIONARY_FILE``. For some input languages using a dictionary may "
"significantly improve the search speed. The dictionary syntax is similar to "
"that used by AFL_ for its ``-x`` option::"
msgstr ""

#: ../../../LibFuzzer.rst:507
msgid "Tracing CMP instructions"
msgstr ""

#: ../../../LibFuzzer.rst:509
msgid ""
"With an additional compiler flag ``-fsanitize-coverage=trace-cmp`` (on by "
"default as part of ``-fsanitize=fuzzer``, see "
"SanitizerCoverageTraceDataFlow_) libFuzzer will intercept CMP instructions "
"and guide mutations based on the arguments of intercepted CMP instructions. "
"This may slow down the fuzzing but is very likely to improve the results."
msgstr ""

#: ../../../LibFuzzer.rst:516
msgid "Value Profile"
msgstr ""

#: ../../../LibFuzzer.rst:518
msgid ""
"With  ``-fsanitize-coverage=trace-cmp`` (default with ``-fsanitize=fuzzer``) "
"and extra run-time flag ``-use_value_profile=1`` the fuzzer will collect "
"value profiles for the parameters of compare instructions and treat some new "
"values as new coverage."
msgstr ""

#: ../../../LibFuzzer.rst:523
msgid "The current implementation does roughly the following:"
msgstr ""

#: ../../../LibFuzzer.rst:525
msgid ""
"The compiler instruments all CMP instructions with a callback that receives "
"both CMP arguments."
msgstr ""

#: ../../../LibFuzzer.rst:526
msgid ""
"The callback computes `(caller_pc&4095) | (popcnt(Arg1 ^ Arg2) << 12)` and "
"uses this value to set a bit in a bitset."
msgstr ""

#: ../../../LibFuzzer.rst:527
msgid "Every new observed bit in the bitset is treated as new coverage."
msgstr ""

#: ../../../LibFuzzer.rst:530
msgid ""
"This feature has a potential to discover many interesting inputs, but there "
"are two downsides. First, the extra instrumentation may bring up to 2x "
"additional slowdown. Second, the corpus may grow by several times."
msgstr ""

#: ../../../LibFuzzer.rst:536
msgid "Fuzzer-friendly build mode"
msgstr ""

#: ../../../LibFuzzer.rst:537
msgid "Sometimes the code under test is not fuzzing-friendly. Examples:"
msgstr ""

#: ../../../LibFuzzer.rst:539
msgid ""
"The target code uses a PRNG seeded e.g. by system time and thus two "
"consequent invocations may potentially execute different code paths even if "
"the end result will be the same. This will cause a fuzzer to treat two "
"similar inputs as significantly different and it will blow up the test "
"corpus. E.g. libxml uses ``rand()`` inside its hash table."
msgstr ""

#: ../../../LibFuzzer.rst:544
msgid ""
"The target code uses checksums to protect from invalid inputs. E.g. png "
"checks CRC for every chunk."
msgstr ""

#: ../../../LibFuzzer.rst:547
msgid ""
"In many cases it makes sense to build a special fuzzing-friendly build with "
"certain fuzzing-unfriendly features disabled. We propose to use a common "
"build macro for all such cases for consistency: "
"``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``."
msgstr ""

#: ../../../LibFuzzer.rst:565
msgid "AFL compatibility"
msgstr ""

#: ../../../LibFuzzer.rst:566
msgid ""
"LibFuzzer can be used together with AFL_ on the same test corpus. Both "
"fuzzers expect the test corpus to reside in a directory, one file per input. "
"You can run both fuzzers on the same corpus, one after another:"
msgstr ""

#: ../../../LibFuzzer.rst:575
msgid ""
"Periodically restart both fuzzers so that they can use each other's "
"findings. Currently, there is no simple way to run both fuzzing engines in "
"parallel while sharing the same corpus dir."
msgstr ""

#: ../../../LibFuzzer.rst:578
msgid ""
"You may also use AFL on your target function ``LLVMFuzzerTestOneInput``: see "
"an example `here <https://github.com/llvm/llvm-project/tree/main/compiler-rt/"
"lib/fuzzer/afl>`__."
msgstr ""

#: ../../../LibFuzzer.rst:582
msgid "How good is my fuzzer?"
msgstr ""

#: ../../../LibFuzzer.rst:584
msgid ""
"Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz "
"it to death, you will want to know whether the function or the corpus can be "
"improved further. One easy to use metric is, of course, code coverage."
msgstr ""

#: ../../../LibFuzzer.rst:588
msgid ""
"We recommend to use `Clang Coverage <https://clang.llvm.org/docs/"
"SourceBasedCodeCoverage.html>`_, to visualize and study your code coverage "
"(`example <https://github.com/google/fuzzer-test-suite/blob/master/tutorial/"
"libFuzzerTutorial.md#visualizing-coverage>`_)."
msgstr ""

#: ../../../LibFuzzer.rst:595
msgid "User-supplied mutators"
msgstr ""

#: ../../../LibFuzzer.rst:597
msgid ""
"LibFuzzer allows to use custom (user-supplied) mutators, see `Structure-"
"Aware Fuzzing <https://github.com/google/fuzzing/blob/master/docs/structure-"
"aware-fuzzing.md>`_ for more details."
msgstr ""

#: ../../../LibFuzzer.rst:602
msgid "Startup initialization"
msgstr ""

#: ../../../LibFuzzer.rst:603
msgid ""
"If the library being tested needs to be initialized, there are several "
"options."
msgstr ""

#: ../../../LibFuzzer.rst:605
msgid ""
"The simplest way is to have a statically initialized global object inside "
"`LLVMFuzzerTestOneInput` (or in global scope if that works for you):"
msgstr ""

#: ../../../LibFuzzer.rst:614
msgid ""
"Alternatively, you may define an optional init function and it will receive "
"the program arguments that you can read and modify. Do this **only** if you "
"really need to access ``argv``/``argc``."
msgstr ""

#: ../../../LibFuzzer.rst:626
msgid "Using libFuzzer as a library"
msgstr ""

#: ../../../LibFuzzer.rst:627
msgid ""
"If the code being fuzzed must provide its own `main`, it's possible to "
"invoke libFuzzer as a library. Be sure to pass ``-fsanitize=fuzzer-no-link`` "
"during compilation, and link your binary against the no-main version of "
"libFuzzer. On Linux installations, this is typically located at:"
msgstr ""

#: ../../../LibFuzzer.rst:636
msgid ""
"If building libFuzzer from source, this is located at the following path in "
"the build output directory:"
msgstr ""

#: ../../../LibFuzzer.rst:643
msgid ""
"From here, the code can do whatever setup it requires, and when it's ready "
"to start fuzzing, it can call `LLVMFuzzerRunDriver`, passing in the program "
"arguments and a callback. This callback is invoked just like "
"`LLVMFuzzerTestOneInput`, and has the same signature."
msgstr ""

#: ../../../LibFuzzer.rst:655
msgid "Rejecting unwanted inputs"
msgstr ""

#: ../../../LibFuzzer.rst:657
msgid ""
"It may be desirable to reject some inputs, i.e. to not add them to the "
"corpus."
msgstr ""

#: ../../../LibFuzzer.rst:659
msgid ""
"For example, when fuzzing an API consisting of parsing and other logic, one "
"may want to allow only those inputs into the corpus that parse successfully."
msgstr ""

#: ../../../LibFuzzer.rst:662
msgid ""
"If the fuzz target returns -1 on a given input, libFuzzer will not add that "
"input top the corpus, regardless of what coverage it triggers."
msgstr ""

#: ../../../LibFuzzer.rst:678
msgid "Leaks"
msgstr ""

#: ../../../LibFuzzer.rst:680
msgid ""
"Binaries built with AddressSanitizer_ or LeakSanitizer_ will try to detect "
"memory leaks at the process shutdown. For in-process fuzzing this is "
"inconvenient since the fuzzer needs to report a leak with a reproducer as "
"soon as the leaky mutation is found. However, running full leak detection "
"after every mutation is expensive."
msgstr ""

#: ../../../LibFuzzer.rst:687
msgid ""
"By default (``-detect_leaks=1``) libFuzzer will count the number of "
"``malloc`` and ``free`` calls when executing every mutation. If the numbers "
"don't match (which by itself doesn't mean there is a leak) libFuzzer will "
"invoke the more expensive LeakSanitizer_ pass and if the actual leak is "
"found, it will be reported with the reproducer and the process will exit."
msgstr ""

#: ../../../LibFuzzer.rst:694
msgid ""
"If your target has massive leaks and the leak detection is disabled you will "
"eventually run out of RAM (see the ``-rss_limit_mb`` flag)."
msgstr ""

#: ../../../LibFuzzer.rst:699
msgid "Developing libFuzzer"
msgstr ""

#: ../../../LibFuzzer.rst:701
msgid ""
"LibFuzzer is built as a part of LLVM project by default on macos and Linux. "
"Users of other operating systems can explicitly request compilation using ``-"
"DCOMPILER_RT_BUILD_LIBFUZZER=ON`` flag. Tests are run using ``check-fuzzer`` "
"target from the build directory which was configured with ``-"
"DCOMPILER_RT_INCLUDE_TESTS=ON`` flag."
msgstr ""

#: ../../../LibFuzzer.rst:713
msgid "FAQ"
msgstr ""

#: ../../../LibFuzzer.rst:716
msgid "Q. Why doesn't libFuzzer use any of the LLVM support?"
msgstr ""

#: ../../../LibFuzzer.rst:718
msgid "There are two reasons."
msgstr ""

#: ../../../LibFuzzer.rst:720
msgid ""
"First, we want this library to be used outside of the LLVM without users "
"having to build the rest of LLVM. This may sound unconvincing for many LLVM "
"folks, but in practice the need for building the whole LLVM frightens many "
"potential users -- and we want more users to use this code."
msgstr ""

#: ../../../LibFuzzer.rst:725
msgid ""
"Second, there is a subtle technical reason not to rely on the rest of LLVM, "
"or any other large body of code (maybe not even STL). When coverage "
"instrumentation is enabled, it will also instrument the LLVM support code "
"which will blow up the coverage set of the process (since the fuzzer is in-"
"process). In other words, by using more external dependencies we will slow "
"down the fuzzer while the main reason for it to exist is extreme speed."
msgstr ""

#: ../../../LibFuzzer.rst:733
msgid "Q. Does libFuzzer Support Windows?"
msgstr ""

#: ../../../LibFuzzer.rst:735
msgid ""
"Yes, libFuzzer now supports Windows. Initial support was added in r341082. "
"Any build of Clang 9 supports it. You can download a build of Clang for "
"Windows that has libFuzzer from `LLVM Snapshot Builds <https://llvm.org/"
"builds/>`_."
msgstr ""

#: ../../../LibFuzzer.rst:740
msgid ""
"Using libFuzzer on Windows without ASAN is unsupported. Building fuzzers "
"with the ``/MD`` (dynamic runtime library) compile option is unsupported. "
"Support for these may be added in the future. Linking fuzzers with the ``/"
"INCREMENTAL`` link option (or the ``/DEBUG`` option which implies it) is "
"also unsupported."
msgstr ""

#: ../../../LibFuzzer.rst:745
msgid ""
"Send any questions or comments to the mailing list: libfuzzer(#)googlegroups."
"com"
msgstr ""

#: ../../../LibFuzzer.rst:748
msgid "Q. When libFuzzer is not a good solution for a problem?"
msgstr ""

#: ../../../LibFuzzer.rst:750
msgid ""
"If the test inputs are validated by the target library and the validator "
"asserts/crashes on invalid inputs, in-process fuzzing is not applicable."
msgstr ""

#: ../../../LibFuzzer.rst:752
msgid ""
"Bugs in the target library may accumulate without being detected. E.g. a "
"memory corruption that goes undetected at first and then leads to a crash "
"while testing another input. This is why it is highly recommended to run "
"this in-process fuzzer with all sanitizers to detect most bugs on the spot."
msgstr ""

#: ../../../LibFuzzer.rst:756
msgid ""
"It is harder to protect the in-process fuzzer from excessive memory "
"consumption and infinite loops in the target library (still possible)."
msgstr ""

#: ../../../LibFuzzer.rst:758
msgid ""
"The target library should not have significant global state that is not "
"reset between the runs."
msgstr ""

#: ../../../LibFuzzer.rst:760
msgid ""
"Many interesting target libraries are not designed in a way that supports "
"the in-process fuzzer interface (e.g. require a file path instead of a byte "
"array)."
msgstr ""

#: ../../../LibFuzzer.rst:763
msgid ""
"If a single test run takes a considerable fraction of a second (or more) the "
"speed benefit from the in-process fuzzer is negligible."
msgstr ""

#: ../../../LibFuzzer.rst:765
msgid ""
"If the target library runs persistent threads (that outlive execution of one "
"test) the fuzzing results will be unreliable."
msgstr ""

#: ../../../LibFuzzer.rst:769
msgid "Q. So, what exactly this Fuzzer is good for?"
msgstr ""

#: ../../../LibFuzzer.rst:771
msgid ""
"This Fuzzer might be a good choice for testing libraries that have "
"relatively small inputs, each input takes < 10ms to run, and the library "
"code is not expected to crash on invalid inputs. Examples: regular "
"expression matchers, text or binary format parsers, compression, network, "
"crypto."
msgstr ""

#: ../../../LibFuzzer.rst:778
msgid ""
"Q. LibFuzzer crashes on my complicated fuzz target (but works fine for me on "
"smaller targets)."
msgstr ""

#: ../../../LibFuzzer.rst:780
msgid ""
"Check if your fuzz target uses ``dlclose``. Currently, libFuzzer doesn't "
"support targets that call ``dlclose``, this may be fixed in future."
msgstr ""

#: ../../../LibFuzzer.rst:786
msgid "Trophies"
msgstr ""

#: ../../../LibFuzzer.rst:787
msgid ""
"Thousands of bugs found on OSS-Fuzz:  https://opensource.googleblog."
"com/2017/05/oss-fuzz-five-months-later-and.html"
msgstr ""

#: ../../../LibFuzzer.rst:789
msgid "GLIBC: https://sourceware.org/glibc/wiki/FuzzingLibc"
msgstr ""

#: ../../../LibFuzzer.rst:791
msgid ""
"MUSL LIBC: `[1] <http://git.musl-libc.org/cgit/musl/commit/?"
"id=39dfd58417ef642307d90306e1c7e50aaec5a35c>`__ `[2] <http://www.openwall."
"com/lists/oss-security/2015/03/30/3>`__"
msgstr ""

#: ../../../LibFuzzer.rst:793
msgid "`pugixml <https://github.com/zeux/pugixml/issues/39>`_"
msgstr ""

#: ../../../LibFuzzer.rst:795
msgid ""
"PCRE: Search for \"LLVM fuzzer\" in http://vcs.pcre.org/pcre2/code/trunk/"
"ChangeLog?view=markup; also in `bugzilla <https://bugs.exim.org/buglist.cgi?"
"bug_status=__all__&content=libfuzzer&no_redirect=1&order=Importance&product=PCRE&query_format=specific>`_"
msgstr ""

#: ../../../LibFuzzer.rst:798
msgid "`ICU <http://bugs.icu-project.org/trac/ticket/11838>`_"
msgstr ""

#: ../../../LibFuzzer.rst:800
msgid ""
"`Freetype <https://savannah.nongnu.org/search/?"
"words=LibFuzzer&type_of_search=bugs&Search=Search&exact=1#options>`_"
msgstr ""

#: ../../../LibFuzzer.rst:802
msgid "`Harfbuzz <https://github.com/behdad/harfbuzz/issues/139>`_"
msgstr ""

#: ../../../LibFuzzer.rst:804
msgid "`SQLite <http://www3.sqlite.org/cgi/src/info/088009efdd56160b>`_"
msgstr ""

#: ../../../LibFuzzer.rst:806
msgid "`Python <http://bugs.python.org/issue25388>`_"
msgstr ""

#: ../../../LibFuzzer.rst:808
msgid ""
"OpenSSL/BoringSSL: `[1] <https://boringssl.googlesource.com/boringssl/+/"
"cb852981cd61733a7a1ae4fd8755b7ff950e857d>`_ `[2] <https://openssl.org/news/"
"secadv/20160301.txt>`_ `[3] <https://boringssl.googlesource.com/boringssl/"
"+/2b07fa4b22198ac02e0cee8f37f3337c3dba91bc>`_ `[4] <https://boringssl."
"googlesource.com/boringssl/+/6b6e0b20893e2be0e68af605a60ffa2cbb0ffa64>`_  "
"`[5] <https://github.com/openssl/openssl/pull/931/commits/"
"dd5ac557f052cc2b7f718ac44a8cb7ac6f77dca8>`_ `[6] <https://github.com/openssl/"
"openssl/pull/931/commits/19b5b9194071d1d84e38ac9a952e715afbc85a81>`_"
msgstr ""

#: ../../../LibFuzzer.rst:810
msgid ""
"`Libxml2 <https://bugzilla.gnome.org/buglist.cgi?"
"bug_status=__all__&content=libFuzzer&list_id=68957&order=Importance&product=libxml2&query_format=specific>`_ "
"and `[HT206167] <https://support.apple.com/en-gb/HT206167>`_ (CVE-2015-5312, "
"CVE-2015-7500, CVE-2015-7942)"
msgstr ""

#: ../../../LibFuzzer.rst:813
msgid "`Linux Kernel's BPF verifier <https://github.com/iovisor/bpf-fuzzer>`_"
msgstr ""

#: ../../../LibFuzzer.rst:815
msgid ""
"`Linux Kernel's Crypto code <https://www.spinics.net/lists/stable/msg199712."
"html>`_"
msgstr ""

#: ../../../LibFuzzer.rst:817
msgid ""
"Capstone: `[1] <https://github.com/aquynh/capstone/issues/600>`__ `[2] "
"<https://github.com/aquynh/capstone/"
"commit/6b88d1d51eadf7175a8f8a11b690684443b11359>`__"
msgstr ""

#: ../../../LibFuzzer.rst:819
msgid ""
"file:`[1] <http://bugs.gw.com/view.php?id=550>`__  `[2] <http://bugs.gw.com/"
"view.php?id=551>`__  `[3] <http://bugs.gw.com/view.php?id=553>`__  `[4] "
"<http://bugs.gw.com/view.php?id=554>`__"
msgstr ""

#: ../../../LibFuzzer.rst:821
msgid ""
"Radare2: `[1] <https://github.com/revskills?"
"tab=contributions&from=2016-04-09>`__"
msgstr ""

#: ../../../LibFuzzer.rst:823
msgid ""
"gRPC: `[1] <https://github.com/grpc/grpc/pull/6071/commits/"
"df04c1f7f6aec6e95722ec0b023a6b29b6ea871c>`__ `[2] <https://github.com/grpc/"
"grpc/pull/6071/commits/22a3dfd95468daa0db7245a4e8e6679a52847579>`__ `[3] "
"<https://github.com/grpc/grpc/pull/6071/"
"commits/9cac2a12d9e181d130841092e9d40fa3309d7aa7>`__ `[4] <https://github."
"com/grpc/grpc/pull/6012/commits/82a91c91d01ce9b999c8821ed13515883468e203>`__ "
"`[5] <https://github.com/grpc/grpc/pull/6202/"
"commits/2e3e0039b30edaf89fb93bfb2c1d0909098519fa>`__ `[6] <https://github."
"com/grpc/grpc/pull/6106/files>`__"
msgstr ""

#: ../../../LibFuzzer.rst:825
msgid "WOFF2: `[1] <https://github.com/google/woff2/commit/a15a8ab>`__"
msgstr ""

#: ../../../LibFuzzer.rst:827
msgid ""
"LLVM: `Clang <https://bugs.llvm.org/show_bug.cgi?id=23057>`_, `Clang-format "
"<https://bugs.llvm.org/show_bug.cgi?id=23052>`_, `libc++ <https://bugs.llvm."
"org/show_bug.cgi?id=24411>`_, `llvm-as <https://bugs.llvm.org/show_bug.cgi?"
"id=24639>`_, `Demangler <https://bugs.chromium.org/p/chromium/issues/detail?"
"id=606626>`_, Disassembler: http://reviews.llvm.org/rL247405, http://reviews."
"llvm.org/rL247414, http://reviews.llvm.org/rL247416, http://reviews.llvm.org/"
"rL247417, http://reviews.llvm.org/rL247420, http://reviews.llvm.org/rL247422."
msgstr ""

#: ../../../LibFuzzer.rst:829
msgid ""
"Tensorflow: `[1] <https://da-data.blogspot.com/2017/01/finding-bugs-in-"
"tensorflow-with.html>`__"
msgstr ""

#: ../../../LibFuzzer.rst:831
msgid ""
"Ffmpeg: `[1] <https://github.com/FFmpeg/FFmpeg/commit/"
"c92f55847a3d9cd12db60bfcd0831ff7f089c37c>`__  `[2] <https://github.com/"
"FFmpeg/FFmpeg/commit/25ab1a65f3acb5ec67b53fb7a2463a7368f1ad16>`__  `[3] "
"<https://github.com/FFmpeg/FFmpeg/"
"commit/85d23e5cbc9ad6835eef870a5b4247de78febe56>`__ `[4] <https://github.com/"
"FFmpeg/FFmpeg/commit/04bd1b38ee6b8df410d0ab8d4949546b6c4af26a>`__"
msgstr ""

#: ../../../LibFuzzer.rst:833
msgid ""
"`Wireshark <https://bugs.wireshark.org/bugzilla/buglist.cgi?"
"bug_status=UNCONFIRMED&bug_status=CONFIRMED&bug_status=IN_PROGRESS&bug_status=INCOMPLETE&bug_status=RESOLVED&bug_status=VERIFIED&f0=OP&f1=OP&f2=product&f3=component&f4=alias&f5=short_desc&f7=content&f8=CP&f9=CP&j1=OR&o2=substring&o3=substring&o4=substring&o5=substring&o6=substring&o7=matches&order=bug_id%20DESC&query_format=advanced&v2=libfuzzer&v3=libfuzzer&v4=libfuzzer&v5=libfuzzer&v6=libfuzzer&v7=%22libfuzzer%22>`_"
msgstr ""

#: ../../../LibFuzzer.rst:835
msgid ""
"`QEMU <https://researchcenter.paloaltonetworks.com/2017/09/unit42-palo-alto-"
"networks-discovers-new-qemu-vulnerability/>`_"
msgstr ""
