# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TransformMetadata.rst:5
msgid "Code Transformation Metadata"
msgstr ""

#: ../../../TransformMetadata.rst:11
msgid "Overview"
msgstr ""

#: ../../../TransformMetadata.rst:13
msgid ""
"LLVM transformation passes can be controlled by attaching metadata to the "
"code to transform. By default, transformation passes use heuristics to "
"determine whether or not to perform transformations, and when doing so, "
"other details of how the transformations are applied (e.g., which "
"vectorization factor to select). Unless the optimizer is otherwise directed, "
"transformations are applied conservatively. This conservatism generally "
"allows the optimizer to avoid unprofitable transformations, but in practice, "
"this results in the optimizer not applying transformations that would be "
"highly profitable."
msgstr ""

#: ../../../TransformMetadata.rst:23
msgid ""
"Frontends can give additional hints to LLVM passes on which transformations "
"they should apply. This can be additional knowledge that cannot be derived "
"from the emitted IR, or directives passed from the user/programmer. OpenMP "
"pragmas are an example of the latter."
msgstr ""

#: ../../../TransformMetadata.rst:28
msgid ""
"If any such metadata is dropped from the program, the code's semantics must "
"not change."
msgstr ""

#: ../../../TransformMetadata.rst:32
msgid "Metadata on Loops"
msgstr ""

#: ../../../TransformMetadata.rst:34
msgid ""
"Attributes can be attached to loops as described in :ref:`llvm.loop`. "
"Attributes can describe properties of the loop, disable transformations, "
"force specific transformations and set transformation options."
msgstr ""

#: ../../../TransformMetadata.rst:38
msgid ""
"Because metadata nodes are immutable (with the exception of ``MDNode::"
"replaceOperandWith`` which is dangerous to use on uniqued metadata), in "
"order to add or remove a loop attributes, a new ``MDNode`` must be created "
"and assigned as the new ``llvm.loop`` metadata. Any connection between the "
"old ``MDNode`` and the loop is lost. The ``llvm.loop`` node is also used as "
"LoopID (``Loop::getLoopID()``), i.e. the loop effectively gets a new "
"identifier. For instance, ``llvm.mem.parallel_loop_access`` references the "
"LoopID. Therefore, if the parallel access property is to be preserved after "
"adding/removing loop attributes, any ``llvm.mem.parallel_loop_access`` "
"reference must be updated to the new LoopID."
msgstr ""

#: ../../../TransformMetadata.rst:51
msgid "Transformation Metadata Structure"
msgstr ""

#: ../../../TransformMetadata.rst:53
msgid ""
"Some attributes describe code transformations (unrolling, vectorizing, loop "
"distribution, etc.). They can either be a hint to the optimizer that a "
"transformation might be beneficial, instruction to use a specific option, , "
"or convey a specific request from the user (such as ``#pragma clang loop`` "
"or ``#pragma omp simd``)."
msgstr ""

#: ../../../TransformMetadata.rst:59
msgid ""
"If a transformation is forced but cannot be carried-out for any reason, an "
"optimization-missed warning must be emitted. Semantic information such as a "
"transformation being safe (e.g. ``llvm.mem.parallel_loop_access``) can be "
"unused by the optimizer without generating a warning."
msgstr ""

#: ../../../TransformMetadata.rst:65
msgid ""
"Unless explicitly disabled, any optimization pass may heuristically "
"determine whether a transformation is beneficial and apply it. If metadata "
"for another transformation was specified, applying a different "
"transformation before it might be inadvertent due to being applied on a "
"different loop or the loop not existing anymore. To avoid having to "
"explicitly disable an unknown number of passes, the attribute ``llvm.loop."
"disable_nonforced`` disables all optional, high-level, restructuring "
"transformations."
msgstr ""

#: ../../../TransformMetadata.rst:74
msgid ""
"The following example avoids the loop being altered before being vectorized, "
"for instance being unrolled."
msgstr ""

#: ../../../TransformMetadata.rst:85
msgid ""
"After a transformation is applied, follow-up attributes are set on the "
"transformed and/or new loop(s). This allows additional attributes including "
"followup-transformations to be specified. Specifying multiple "
"transformations in the same metadata node is possible for compatibility "
"reasons, but their execution order is undefined. For instance, when ``llvm."
"loop.vectorize.enable`` and ``llvm.loop.unroll.enable`` are specified at the "
"same time, unrolling may occur either before or after vectorization."
msgstr ""

#: ../../../TransformMetadata.rst:94
msgid ""
"As an example, the following instructs a loop to be vectorized and only then "
"unrolled."
msgstr ""

#: ../../../TransformMetadata.rst:104
msgid ""
"If, and only if, no followup is specified, the pass may add attributes "
"itself. For instance, the vectorizer adds a ``llvm.loop.isvectorized`` "
"attribute and all attributes from the original loop excluding its loop "
"vectorizer attributes. To avoid this, an empty followup attribute can be "
"used, e.g."
msgstr ""

#: ../../../TransformMetadata.rst:113
msgid ""
"The followup attributes of a transformation that cannot be applied will "
"never be added to a loop and are therefore effectively ignored. This means "
"that any followup-transformation in such attributes requires that its prior "
"transformations are applied before the followup-transformation. The user "
"should receive a warning about the first transformation in the "
"transformation chain that could not be applied if it a forced "
"transformation. All following transformations are skipped."
msgstr ""

#: ../../../TransformMetadata.rst:122
msgid "Pass-Specific Transformation Metadata"
msgstr ""

#: ../../../TransformMetadata.rst:124
msgid ""
"Transformation options are specific to each transformation. In the "
"following, we present the model for each LLVM loop optimization pass and the "
"metadata to influence them."
msgstr ""

#: ../../../TransformMetadata.rst:129
msgid "Loop Vectorization and Interleaving"
msgstr ""

#: ../../../TransformMetadata.rst:131
msgid ""
"Loop vectorization and interleaving is interpreted as a single "
"transformation. It is interpreted as forced if ``!{\"llvm.loop.vectorize."
"enable\", i1 true}`` is set."
msgstr ""

#: ../../../TransformMetadata.rst:135
msgid "Assuming the pre-vectorization loop is"
msgstr ""

#: ../../../TransformMetadata.rst:142
msgid ""
"then the code after vectorization will be approximately (assuming an SIMD "
"width of 4):"
msgstr ""

#: ../../../TransformMetadata.rst:155 ../../../TransformMetadata.rst:324
msgid "where ``rtc`` is a generated runtime check."
msgstr ""

#: ../../../TransformMetadata.rst:157
msgid ""
"``llvm.loop.vectorize.followup_vectorized`` will set the attributes for the "
"vectorized loop. If not specified, ``llvm.loop.isvectorized`` is combined "
"with the original loop's attributes to avoid it being vectorized multiple "
"times."
msgstr ""

#: ../../../TransformMetadata.rst:162
msgid ""
"``llvm.loop.vectorize.followup_epilogue`` will set the attributes for the "
"remainder loop. If not specified, it will have the original loop's "
"attributes combined with ``llvm.loop.isvectorized`` and ``llvm.loop.unroll."
"runtime.disable`` (unless the original loop already has unroll metadata)."
msgstr ""

#: ../../../TransformMetadata.rst:168
msgid ""
"The attributes specified by ``llvm.loop.vectorize.followup_all`` are added "
"to both loops."
msgstr ""

#: ../../../TransformMetadata.rst:171
msgid ""
"When using a follow-up attribute, it replaces any automatically deduced "
"attributes for the generated loop in question. Therefore it is recommended "
"to add ``llvm.loop.isvectorized`` to ``llvm.loop.vectorize.followup_all`` "
"which avoids that the loop vectorizer tries to optimize the loops again."
msgstr ""

#: ../../../TransformMetadata.rst:178
msgid "Loop Unrolling"
msgstr ""

#: ../../../TransformMetadata.rst:180
msgid ""
"Unrolling is interpreted as forced any ``!{!\"llvm.loop.unroll.enable\"}`` "
"metadata or option (``llvm.loop.unroll.count``, ``llvm.loop.unroll.full``) "
"is present. Unrolling can be full unrolling, partial unrolling of a loop "
"with constant trip count or runtime unrolling of a loop with a trip count "
"unknown at compile-time."
msgstr ""

#: ../../../TransformMetadata.rst:186
msgid ""
"If the loop has been unrolled fully, there is no followup-loop. For partial/"
"runtime unrolling, the original loop of"
msgstr ""

#: ../../../TransformMetadata.rst:194
msgid "is transformed into (using an unroll factor of 4):"
msgstr ""

#: ../../../TransformMetadata.rst:208
msgid ""
"``llvm.loop.unroll.followup_unrolled`` will set the loop attributes of the "
"unrolled loop. If not specified, the attributes of the original loop without "
"the ``llvm.loop.unroll.*`` attributes are copied and ``llvm.loop.unroll."
"disable`` added to it."
msgstr ""

#: ../../../TransformMetadata.rst:213
msgid ""
"``llvm.loop.unroll.followup_remainder`` defines the attributes of the "
"remainder loop. If not specified the remainder loop will have no attributes. "
"The remainder loop might not be present due to being fully unrolled in which "
"case this attribute has no effect."
msgstr ""

#: ../../../TransformMetadata.rst:218
msgid ""
"Attributes defined in ``llvm.loop.unroll.followup_all`` are added to the "
"unrolled and remainder loops."
msgstr ""

#: ../../../TransformMetadata.rst:221
msgid ""
"To avoid that the partially unrolled loop is unrolled again, it is "
"recommended to add ``llvm.loop.unroll.disable`` to ``llvm.loop.unroll."
"followup_all``. If no follow-up attribute specified for a generated loop, it "
"is added automatically."
msgstr ""

#: ../../../TransformMetadata.rst:227
msgid "Unroll-And-Jam"
msgstr ""

#: ../../../TransformMetadata.rst:229
msgid ""
"Unroll-and-jam uses the following transformation model (here with an unroll "
"factor if 2). Currently, it does not support a fallback version when the "
"transformation is unsafe."
msgstr ""

#: ../../../TransformMetadata.rst:262
msgid ""
"``llvm.loop.unroll_and_jam.followup_outer`` will set the loop attributes of "
"the unrolled outer loop. If not specified, the attributes of the original "
"outer loop without the ``llvm.loop.unroll.*`` attributes are copied and "
"``llvm.loop.unroll.disable`` added to it."
msgstr ""

#: ../../../TransformMetadata.rst:267
msgid ""
"``llvm.loop.unroll_and_jam.followup_inner`` will set the loop attributes of "
"the unrolled inner loop. If not specified, the attributes of the original "
"inner loop are used unchanged."
msgstr ""

#: ../../../TransformMetadata.rst:271
msgid ""
"``llvm.loop.unroll_and_jam.followup_remainder_outer`` sets the loop "
"attributes of the outer remainder loop. If not specified it will not have "
"any attributes. The remainder loop might not be present due to being fully "
"unrolled."
msgstr ""

#: ../../../TransformMetadata.rst:276
msgid ""
"``llvm.loop.unroll_and_jam.followup_remainder_inner`` sets the loop "
"attributes of the inner remainder loop. If not specified it will have the "
"attributes of the original inner loop. It the outer remainder loop is "
"unrolled, the inner remainder loop might be present multiple times."
msgstr ""

#: ../../../TransformMetadata.rst:281
msgid ""
"Attributes defined in ``llvm.loop.unroll_and_jam.followup_all`` are added to "
"all of the aforementioned output loops."
msgstr ""

#: ../../../TransformMetadata.rst:284
msgid ""
"To avoid that the unrolled loop is unrolled again, it is recommended to add "
"``llvm.loop.unroll.disable`` to ``llvm.loop.unroll_and_jam.followup_all``. "
"It suppresses unroll-and-jam as well as an additional inner loop unrolling. "
"If no follow-up attribute specified for a generated loop, it is added "
"automatically."
msgstr ""

#: ../../../TransformMetadata.rst:291
msgid "Loop Distribution"
msgstr ""

#: ../../../TransformMetadata.rst:293
msgid ""
"The LoopDistribution pass tries to separate vectorizable parts of a loop "
"from the non-vectorizable part (which otherwise would make the entire loop "
"non-vectorizable). Conceptually, it transforms a loop such as"
msgstr ""

#: ../../../TransformMetadata.rst:305
msgid "into the following code:"
msgstr ""

#: ../../../TransformMetadata.rst:326
msgid ""
"``llvm.loop.distribute.followup_coincident`` sets the loop attributes of all "
"loops without loop-carried dependencies (i.e. vectorizable loops). There "
"might be more than one such loops. If not defined, the loops will inherit "
"the original loop's attributes."
msgstr ""

#: ../../../TransformMetadata.rst:331
msgid ""
"``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the "
"loop with potentially unsafe dependencies. There should be at most one such "
"loop. If not defined, the loop will inherit the original loop's attributes."
msgstr ""

#: ../../../TransformMetadata.rst:336
msgid ""
"``llvm.loop.distribute.followup_fallback`` defines the loop attributes for "
"the fallback loop, which is a copy of the original loop for when loop "
"versioning is required. If undefined, the fallback loop inherits all "
"attributes from the original loop."
msgstr ""

#: ../../../TransformMetadata.rst:341
msgid ""
"Attributes defined in ``llvm.loop.distribute.followup_all`` are added to all "
"of the aforementioned output loops."
msgstr ""

#: ../../../TransformMetadata.rst:344
msgid ""
"It is recommended to add ``llvm.loop.disable_nonforced`` to ``llvm.loop."
"distribute.followup_fallback``. This avoids that the fallback version (which "
"is likely never executed) is further optimized which would increase the code "
"size."
msgstr ""

#: ../../../TransformMetadata.rst:350
msgid "Versioning LICM"
msgstr ""

#: ../../../TransformMetadata.rst:352
msgid ""
"The pass hoists code out of loops that are only loop-invariant when dynamic "
"conditions apply. For instance, it transforms the loop"
msgstr ""

#: ../../../TransformMetadata.rst:360
msgid "into:"
msgstr ""

#: ../../../TransformMetadata.rst:373
msgid ""
"The runtime condition (``rtc``) checks that the array ``A`` and the element "
"`B[0]` do not alias."
msgstr ""

#: ../../../TransformMetadata.rst:376
msgid "Currently, this transformation does not support followup-attributes."
msgstr ""

#: ../../../TransformMetadata.rst:379
msgid "Loop Interchange"
msgstr ""

#: ../../../TransformMetadata.rst:381
msgid "Currently, the ``LoopInterchange`` pass does not use any metadata."
msgstr ""

#: ../../../TransformMetadata.rst:384
msgid "Ambiguous Transformation Order"
msgstr ""

#: ../../../TransformMetadata.rst:386
msgid ""
"If there multiple transformations defined, the order in which they are "
"executed depends on the order in LLVM's pass pipeline, which is subject to "
"change. The default optimization pipeline (anything higher than ``-O0``) has "
"the following order."
msgstr ""

#: ../../../TransformMetadata.rst:391
msgid "When using the legacy pass manager:"
msgstr ""

#: ../../../TransformMetadata.rst:393 ../../../TransformMetadata.rst:403
msgid "LoopInterchange (if enabled)"
msgstr ""

#: ../../../TransformMetadata.rst:394 ../../../TransformMetadata.rst:404
#: ../../../TransformMetadata.rst:410
msgid "SimpleLoopUnroll/LoopFullUnroll (only performs full unrolling)"
msgstr ""

#: ../../../TransformMetadata.rst:395
msgid "VersioningLICM (if enabled)"
msgstr ""

#: ../../../TransformMetadata.rst:396 ../../../TransformMetadata.rst:411
msgid "LoopDistribute"
msgstr ""

#: ../../../TransformMetadata.rst:397 ../../../TransformMetadata.rst:405
#: ../../../TransformMetadata.rst:412
msgid "LoopVectorizer"
msgstr ""

#: ../../../TransformMetadata.rst:398 ../../../TransformMetadata.rst:413
msgid "LoopUnrollAndJam (if enabled)"
msgstr ""

#: ../../../TransformMetadata.rst:399 ../../../TransformMetadata.rst:406
#: ../../../TransformMetadata.rst:414
msgid "LoopUnroll (partial and runtime unrolling)"
msgstr ""

#: ../../../TransformMetadata.rst:401
msgid "When using the legacy pass manager with LTO:"
msgstr ""

#: ../../../TransformMetadata.rst:408
msgid "When using the new pass manager:"
msgstr ""

#: ../../../TransformMetadata.rst:417
msgid "Leftover Transformations"
msgstr ""

#: ../../../TransformMetadata.rst:419
msgid ""
"Forced transformations that have not been applied after the last "
"transformation pass should be reported to the user. The transformation "
"passes themselves cannot be responsible for this reporting because they "
"might not be in the pipeline, there might be multiple passes able to apply a "
"transformation (e.g. ``LoopInterchange`` and Polly) or a transformation "
"attribute may be 'hidden' inside another passes' followup attribute."
msgstr ""

#: ../../../TransformMetadata.rst:427
msgid ""
"The pass ``-transform-warning`` (``WarnMissedTransformationsPass``) emits "
"such warnings. It should be placed after the last transformation pass."
msgstr ""

#: ../../../TransformMetadata.rst:431
msgid ""
"The current pass pipeline has a fixed order in which transformations passes "
"are executed. A transformation can be in the followup of a pass that is "
"executed later and thus leftover. For instance, a loop nest cannot be "
"distributed and then interchanged with the current pass pipeline. The loop "
"distribution will execute, but there is no loop interchange pass following "
"such that any loop interchange metadata will be ignored. The ``-transform-"
"warning`` should emit a warning in this case."
msgstr ""

#: ../../../TransformMetadata.rst:440
msgid ""
"Future versions of LLVM may fix this by executing transformations using a "
"dynamic ordering."
msgstr ""
