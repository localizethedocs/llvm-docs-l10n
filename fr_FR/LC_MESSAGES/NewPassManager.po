# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../NewPassManager.rst:3
msgid "Using the New Pass Manager"
msgstr ""

#: ../../../NewPassManager.rst:9
msgid "Overview"
msgstr ""

#: ../../../NewPassManager.rst:11
msgid ""
"For an overview of the new pass manager, see the `blog post <https://blog."
"llvm.org/posts/2021-03-26-the-new-pass-manager/>`_."
msgstr ""

#: ../../../NewPassManager.rst:15
msgid ""
"Just Tell Me How To Run The Default Optimization Pipeline With The New Pass "
"Manager"
msgstr ""

#: ../../../NewPassManager.rst:47
msgid ""
"The C API also supports most of this, see ``llvm-c/Transforms/PassBuilder."
"h``."
msgstr ""

#: ../../../NewPassManager.rst:50
msgid "Adding Passes to a Pass Manager"
msgstr ""

#: ../../../NewPassManager.rst:52
msgid ""
"For how to write a new PM pass, see :doc:`this page "
"<WritingAnLLVMNewPMPass>`."
msgstr ""

#: ../../../NewPassManager.rst:54
msgid ""
"To add a pass to a new PM pass manager, the important thing is to match the "
"pass type and the pass manager type. For example, a ``FunctionPassManager`` "
"can only contain function passes:"
msgstr ""

#: ../../../NewPassManager.rst:64
msgid ""
"If you want to add a loop pass that runs on all loops in a function to a "
"``FunctionPassManager``, the loop pass must be wrapped in a function pass "
"adaptor that goes through all the loops in the function and runs the loop "
"pass on each one."
msgstr ""

#: ../../../NewPassManager.rst:75
msgid ""
"The IR hierarchy in terms of the new PM is Module -> (CGSCC ->) Function -> "
"Loop, where going through a CGSCC is optional."
msgstr ""

#: ../../../NewPassManager.rst:102
msgid ""
"A pass manager of a specific IR unit is also a pass of that kind. For "
"example, a ``FunctionPassManager`` is a function pass, meaning it can be "
"added to a ``ModulePassManager``:"
msgstr ""

#: ../../../NewPassManager.rst:116
msgid ""
"Generally you want to group CGSCC/function/loop passes together in a pass "
"manager, as opposed to adding adaptors for each pass to the containing upper "
"level pass manager. For example,"
msgstr ""

#: ../../../NewPassManager.rst:127
msgid ""
"will run ``FunctionPass1`` on each function in a module, then run "
"``FunctionPass2`` on each function in the module. In contrast,"
msgstr ""

#: ../../../NewPassManager.rst:140
msgid ""
"will run ``FunctionPass1`` and ``FunctionPass2`` on the first function in a "
"module, then run both passes on the second function in the module, and so "
"on. This is better for cache locality around LLVM data structures. This "
"similarly applies for the other IR types, and in some cases can even affect "
"the quality of optimization. For example, running all loop passes on a loop "
"may cause a later loop to be able to be optimized more than if each loop "
"pass were run separately."
msgstr ""

#: ../../../NewPassManager.rst:149
msgid "Inserting Passes into Default Pipelines"
msgstr ""

#: ../../../NewPassManager.rst:151
msgid ""
"Rather than manually adding passes to a pass manager, the typical way of "
"creating a pass manager is to use a ``PassBuilder`` and call something like "
"``PassBuilder::buildPerModuleDefaultPipeline()`` which creates a typical "
"pipeline for a given optimization level."
msgstr ""

#: ../../../NewPassManager.rst:156
msgid ""
"Sometimes either frontends or backends will want to inject passes into the "
"pipeline. For example, frontends may want to add instrumentation, and target "
"backends may want to add passes that lower custom intrinsics. For these "
"cases, ``PassBuilder`` exposes callbacks that allow injecting passes into "
"certain parts of the pipeline. For example,"
msgstr ""

#: ../../../NewPassManager.rst:170
msgid ""
"will add ``FooPass`` near the very beginning of the pipeline for pass "
"managers created by that ``PassBuilder``. See the documentation for "
"``PassBuilder`` for the various places that passes can be added."
msgstr ""

#: ../../../NewPassManager.rst:174
msgid ""
"If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it "
"will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the "
"backend to inject passes into the pipeline."
msgstr ""

#: ../../../NewPassManager.rst:178
msgid ""
"Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly "
"sanitizer) passes to various parts of the pipeline. ``AMDGPUTargetMachine::"
"registerPassBuilderCallbacks()`` is an example of a backend adding passes to "
"various parts of the pipeline."
msgstr ""

#: ../../../NewPassManager.rst:183
msgid ""
"Pass plugins can also add passes into default pipelines. Different tools "
"have different ways of loading dynamic pass plugins. For example, ``opt -"
"load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For "
"information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`."
msgstr ""

#: ../../../NewPassManager.rst:189
msgid "Using Analyses"
msgstr ""

#: ../../../NewPassManager.rst:191
msgid ""
"LLVM provides many analyses that passes can use, such as a dominator tree. "
"Calculating these can be expensive, so the new pass manager has "
"infrastructure to cache analyses and reuse them when possible."
msgstr ""

#: ../../../NewPassManager.rst:195
msgid ""
"When a pass runs on some IR, it also receives an analysis manager which it "
"can query for analyses. Querying for an analysis will cause the manager to "
"check if it has already computed the result for the requested IR. If it "
"already has and the result is still valid, it will return that. Otherwise it "
"will construct a new result by calling the analysis's ``run()`` method, "
"cache it, and return it. You can also ask the analysis manager to only "
"return an analysis if it's already cached."
msgstr ""

#: ../../../NewPassManager.rst:203
msgid ""
"The analysis manager only provides analysis results for the same IR type as "
"what the pass runs on. For example, a function pass receives an analysis "
"manager that only provides function-level analyses. This works for many "
"passes which work on a fixed scope. However, some passes want to peek up or "
"down the IR hierarchy. For example, an SCC pass may want to look at function "
"analyses for the functions inside the SCC. Or it may want to look at some "
"immutable global analysis. In these cases, the analysis manager can provide "
"a proxy to an outer or inner level analysis manager. For example, to get a "
"``FunctionAnalysisManager`` from a ``CGSCCAnalysisManager``, you can call"
msgstr ""

#: ../../../NewPassManager.rst:219
msgid ""
"and use ``FAM`` as a typical ``FunctionAnalysisManager`` that a function "
"pass would have access to. To get access to an outer level IR analysis, you "
"can call"
msgstr ""

#: ../../../NewPassManager.rst:229
msgid ""
"Asking for a cached and immutable outer level IR analysis works via "
"``getCachedResult()``, but getting direct access to an outer level IR "
"analysis manager to compute an outer level IR analysis is not allowed. This "
"is for a couple reasons."
msgstr ""

#: ../../../NewPassManager.rst:234
msgid ""
"The first reason is that running analyses across outer level IR in inner "
"level IR passes can result in quadratic compile time behavior. For example, "
"a module analysis often scans every function and allowing function passes to "
"run a module analysis may cause us to scan functions a quadratic number of "
"times. If passes could keep outer level analyses up to date rather than "
"computing them on demand this wouldn't be an issue, but that would be a lot "
"of work to ensure every pass updates all outer level analyses, and so far "
"this hasn't been necessary and there isn't infrastructure for this (aside "
"from function analyses in loop passes as described below). Self-updating "
"analyses that gracefully degrade also handle this problem (e.g. GlobalsAA), "
"but they run into the issue of having to be manually recomputed somewhere in "
"the optimization pipeline if we want precision, and they block potential "
"future concurrency."
msgstr ""

#: ../../../NewPassManager.rst:247
msgid ""
"The second reason is to keep in mind potential future pass concurrency, for "
"example parallelizing function passes over different functions in a CGSCC or "
"module. Since passes can ask for a cached analysis result, allowing passes "
"to trigger outer level analysis computation could result in non-determinism "
"if concurrency was supported. A related limitation is that outer level IR "
"analyses that are used must be immutable, or else they could be invalidated "
"by changes to inner level IR. Outer analyses unused by inner passes can and "
"often will be invalidated by changes to inner level IR. These invalidations "
"happen after the inner pass manager finishes, so accessing mutable analyses "
"would give invalid results."
msgstr ""

#: ../../../NewPassManager.rst:258
msgid ""
"The exception to not being able to access outer level analyses is accessing "
"function analyses in loop passes. Loop passes often use function analyses "
"such as the dominator tree. Loop passes inherently require modifying the "
"function the loop is in, and that includes some function analyses the loop "
"analyses depend on. This discounts future concurrency over separate loops in "
"a function, but that's a tradeoff due to how tightly a loop and its function "
"are coupled. To make sure the function analyses that loop passes use are "
"valid, they are manually updated in the loop passes to ensure that "
"invalidation is not necessary. There is a set of common function analyses "
"that loop passes and analyses have access to which is passed into loop "
"passes as a ``LoopStandardAnalysisResults`` parameter. Other mutable "
"function analyses are not accessible from loop passes."
msgstr ""

#: ../../../NewPassManager.rst:271
msgid ""
"As with any caching mechanism, we need some way to tell analysis managers "
"when results are no longer valid. Much of the analysis manager complexity "
"comes from trying to invalidate as few analysis results as possible to keep "
"compile times as low as possible."
msgstr ""

#: ../../../NewPassManager.rst:276
msgid ""
"There are two ways to deal with potentially invalid analysis results. One is "
"to simply force clear the results. This should generally only be used when "
"the IR that the result is keyed on becomes invalid. For example, a function "
"is deleted, or a CGSCC has become invalid due to call graph changes."
msgstr ""

#: ../../../NewPassManager.rst:281
msgid ""
"The typical way to invalidate analysis results is for a pass to declare what "
"types of analyses it preserves and what types it does not. When transforming "
"IR, a pass either has the option to update analyses alongside the IR "
"transformation, or tell the analysis manager that analyses are no longer "
"valid and should be invalidated. If a pass wants to keep some specific "
"analysis up to date, such as when updating it would be faster than "
"invalidating and recalculating it, the analysis itself may have methods to "
"update it for specific transformations, or there may be helper updaters like "
"``DomTreeUpdater`` for a ``DominatorTree``. Otherwise to mark some analysis "
"as no longer valid, the pass can return a ``PreservedAnalyses`` with the "
"proper analyses invalidated."
msgstr ""

#: ../../../NewPassManager.rst:311
msgid ""
"The pass manager will call the analysis manager's ``invalidate()`` method "
"with the pass's returned ``PreservedAnalyses``. This can be also done "
"manually within the pass:"
msgstr ""

#: ../../../NewPassManager.rst:332
msgid ""
"One thing to note when accessing inner level IR analyses is cached results "
"for deleted IR. If a function is deleted in a module pass, its address is "
"still used as the key for cached analyses. Take care in the pass to either "
"clear the results for that function or not use inner analyses at all."
msgstr ""

#: ../../../NewPassManager.rst:337
msgid ""
"``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner "
"analysis manager proxy which will clear all cached analyses, conservatively "
"assuming that there are invalid addresses used as keys for cached analyses. "
"However, if you'd like to be more selective about which analyses are cached/"
"invalidated, you can mark the analysis manager proxy as preserved, "
"essentially saying that all deleted entries have been taken care of "
"manually. This should only be done with measurable compile time gains as it "
"can be tricky to make sure all the right analyses are invalidated."
msgstr ""

#: ../../../NewPassManager.rst:347
msgid "Implementing Analysis Invalidation"
msgstr ""

#: ../../../NewPassManager.rst:349
msgid ""
"By default, an analysis is invalidated if ``PreservedAnalyses`` says that "
"analyses on the IR unit it runs on are not preserved (see "
"``AnalysisResultModel::invalidate()``). An analysis can implement "
"``invalidate()`` to be more conservative when it comes to invalidation. For "
"example,"
msgstr ""

#: ../../../NewPassManager.rst:366
msgid ""
"says that if the ``PreservedAnalyses`` specifically preserves "
"``FooAnalysis``, or if ``PreservedAnalyses`` preserves all analyses "
"(implicit in ``PAC.preserved()``), or if ``PreservedAnalyses`` preserves all "
"function analyses, or ``PreservedAnalyses`` preserves all analyses that only "
"care about the CFG, the ``FooAnalysisResult`` should not be invalidated."
msgstr ""

#: ../../../NewPassManager.rst:372
msgid ""
"If an analysis is stateless and generally shouldn't be invalidated, use the "
"following:"
msgstr ""

#: ../../../NewPassManager.rst:385
msgid ""
"If an analysis depends on other analyses, those analyses also need to be "
"checked if they are invalidated:"
msgstr ""

#: ../../../NewPassManager.rst:401
msgid ""
"Combining invalidation and analysis manager proxies results in some "
"complexity. For example, when we invalidate all analyses in a module pass, "
"we have to make sure that we also invalidate function analyses accessible "
"via any existing inner proxies. The inner proxy's ``invalidate()`` first "
"checks if the proxy itself should be invalidated. If so, that means the "
"proxy may contain pointers to IR that is no longer valid, meaning that the "
"inner proxy needs to completely clear all relevant analysis results. "
"Otherwise the proxy simply forwards the invalidation to the inner analysis "
"manager."
msgstr ""

#: ../../../NewPassManager.rst:410
msgid ""
"Generally for outer proxies, analysis results from the outer analysis "
"manager should be immutable, so invalidation shouldn't be a concern. "
"However, it is possible for some inner analysis to depend on some outer "
"analysis, and when the outer analysis is invalidated, we need to make sure "
"that dependent inner analyses are also invalidated. This actually happens "
"with alias analysis results. Alias analysis is a function-level analysis, "
"but there are module-level implementations of specific types of alias "
"analysis. Currently ``GlobalsAA`` is the only module-level alias analysis "
"and it generally is not invalidated so this is not so much of a concern. See "
"``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()`` "
"for more details."
msgstr ""

#: ../../../NewPassManager.rst:423
msgid "Invoking ``opt``"
msgstr ""

#: ../../../NewPassManager.rst:431
msgid ""
"The new PM typically requires explicit pass nesting. For example, to run a "
"function pass, then a module pass, we need to wrap the function pass in a "
"module adaptor:"
msgstr ""

#: ../../../NewPassManager.rst:439
msgid ""
"A more complete example, and ``-debug-pass-manager`` to show the execution "
"order:"
msgstr ""

#: ../../../NewPassManager.rst:446
msgid "Improper nesting can lead to error messages such as"
msgstr ""

#: ../../../NewPassManager.rst:453
msgid ""
"The nesting is: module (-> cgscc) -> function -> loop, where the CGSCC "
"nesting is optional."
msgstr ""

#: ../../../NewPassManager.rst:455
msgid "There are a couple of special cases for easier typing:"
msgstr ""

#: ../../../NewPassManager.rst:457
msgid ""
"If the first pass is not a module pass, a pass manager of the first pass is "
"implicitly created"
msgstr ""

#: ../../../NewPassManager.rst:460 ../../../NewPassManager.rst:470
msgid "For example, the following are equivalent"
msgstr ""

#: ../../../NewPassManager.rst:467
msgid ""
"If there is an adaptor for a pass that lets it fit in the previous pass "
"manager, that is implicitly created"
msgstr ""

#: ../../../NewPassManager.rst:477
msgid ""
"For a list of available passes and analyses, including the IR unit (module, "
"CGSCC, function, loop) they operate on, run"
msgstr ""

#: ../../../NewPassManager.rst:484
msgid "or take a look at ``PassRegistry.def``."
msgstr ""

#: ../../../NewPassManager.rst:486
msgid ""
"To make sure an analysis named ``foo`` is available before a pass, add "
"``require<foo>`` to the pass pipeline. This adds a pass that simply requests "
"that the analysis is run. This pass is also subject to proper nesting.  For "
"example, to make sure some function analysis is already computed for all "
"functions before a module pass:"
msgstr ""

#: ../../../NewPassManager.rst:497
msgid "Status of the New and Legacy Pass Managers"
msgstr ""

#: ../../../NewPassManager.rst:499
msgid ""
"LLVM currently contains two pass managers, the legacy PM and the new PM. The "
"optimization pipeline (aka the middle-end) uses the new PM, whereas the "
"backend target-dependent code generation uses the legacy PM."
msgstr ""

#: ../../../NewPassManager.rst:503
msgid ""
"The legacy PM somewhat works with the optimization pipeline, but this is "
"deprecated and there are ongoing efforts to remove its usage."
msgstr ""

#: ../../../NewPassManager.rst:506
msgid ""
"Some IR passes are considered part of the backend codegen pipeline even if "
"they are LLVM IR passes (whereas all MIR passes are codegen passes). This "
"includes anything added via ``TargetPassConfig`` hooks, e.g. "
"``TargetPassConfig::addCodeGenPrepare()``."
msgstr ""

#: ../../../NewPassManager.rst:511
msgid ""
"The ``TargetMachine::adjustPassManager()`` function that was used to extend "
"a legacy PM with passes on a per target basis has been removed. It was "
"mainly used from opt, but since support for using the default pipelines has "
"been removed in opt the function isn't needed any longer. In the new PM such "
"adjustments are done by using ``TargetMachine::"
"registerPassBuilderCallbacks()``."
msgstr ""

#: ../../../NewPassManager.rst:517
msgid ""
"Currently there are efforts to make the codegen pipeline work with the new "
"PM."
msgstr ""
