# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 21\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../Passes.rst:3
msgid "LLVM's Analysis and Transform Passes"
msgstr ""

#: ../../../Passes.rst:14
msgid "Introduction"
msgstr ""

#: ../../../Passes.rst:15
msgid ""
"This document is not updated frequently, and the list of passes is most "
"likely incomplete. It is possible to list passes known by the opt tool using "
"``opt -print-passes``."
msgstr ""

#: ../../../Passes.rst:19
msgid ""
"This document serves as a high level summary of the optimization features "
"that LLVM provides.  Optimizations are implemented as Passes that traverse "
"some portion of a program to either collect information or transform the "
"program. The table below divides the passes that LLVM provides into three "
"categories. Analysis passes compute information that other passes can use or "
"for debugging or program visualization purposes.  Transform passes can use "
"(or invalidate) the analysis passes.  Transform passes all mutate the "
"program in some way. Utility passes provides some utility but don't "
"otherwise fit categorization. For example passes to extract functions to "
"bitcode or write a module to bitcode are neither analysis nor transform "
"passes.  The table of contents above provides a quick summary of each pass "
"and links to the more complete pass description later in the document."
msgstr ""

#: ../../../Passes.rst:33
msgid "Analysis Passes"
msgstr ""

#: ../../../Passes.rst:35
msgid "This section describes the LLVM Analysis Passes."
msgstr ""

#: ../../../Passes.rst:38
msgid "``aa-eval``: Exhaustive Alias Analysis Precision Evaluator"
msgstr ""

#: ../../../Passes.rst:40
msgid ""
"This is a simple N^2 alias analysis accuracy evaluator.  Basically, for each "
"function in the program, it simply queries to see how the alias analysis "
"implementation answers alias queries between each pair of pointers in the "
"function."
msgstr ""

#: ../../../Passes.rst:45
msgid ""
"This is inspired and adapted from code by: Naveen Neelakantam, Francesco "
"Spadini, and Wojciech Stryjewski."
msgstr ""

#: ../../../Passes.rst:49
msgid "``basic-aa``: Basic Alias Analysis (stateless AA impl)"
msgstr ""

#: ../../../Passes.rst:51
msgid ""
"A basic alias analysis pass that implements identities (two different "
"globals cannot alias, etc), but does no stateful analysis."
msgstr ""

#: ../../../Passes.rst:55
msgid "``basiccg``: Basic CallGraph Construction"
msgstr ""

#: ../../../Passes.rst:57 ../../../Passes.rst:225
msgid "Yet to be written."
msgstr ""

#: ../../../Passes.rst:62
msgid "``da``: Dependence Analysis"
msgstr ""

#: ../../../Passes.rst:64
msgid ""
"Dependence analysis framework, which is used to detect dependences in memory "
"accesses."
msgstr ""

#: ../../../Passes.rst:68
msgid "``domfrontier``: Dominance Frontier Construction"
msgstr ""

#: ../../../Passes.rst:70
msgid ""
"This pass is a simple dominator construction algorithm for finding forward "
"dominator frontiers."
msgstr ""

#: ../../../Passes.rst:74
msgid "``domtree``: Dominator Tree Construction"
msgstr ""

#: ../../../Passes.rst:76
msgid ""
"This pass is a simple dominator construction algorithm for finding forward "
"dominators."
msgstr ""

#: ../../../Passes.rst:81
msgid "``dot-callgraph``: Print Call Graph to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:83
msgid ""
"This pass, only available in ``opt``, prints the call graph into a ``.dot`` "
"graph.  This graph can then be processed with the \"dot\" tool to convert it "
"to postscript or some other suitable format."
msgstr ""

#: ../../../Passes.rst:88
msgid "``dot-cfg``: Print CFG of function to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:90
msgid ""
"This pass, only available in ``opt``, prints the control flow graph into a "
"``.dot`` graph.  This graph can then be processed with the :program:`dot` "
"tool to convert it to postscript or some other suitable format. Additionally "
"the ``-cfg-func-name=<substring>`` option can be used to filter the "
"functions that are printed. All functions that contain the specified "
"substring will be printed."
msgstr ""

#: ../../../Passes.rst:98
msgid ""
"``dot-cfg-only``: Print CFG of function to \"dot\" file (with no function "
"bodies)"
msgstr ""

#: ../../../Passes.rst:100
msgid ""
"This pass, only available in ``opt``, prints the control flow graph into a "
"``.dot`` graph, omitting the function bodies.  This graph can then be "
"processed with the :program:`dot` tool to convert it to postscript or some "
"other suitable format. Additionally the ``-cfg-func-name=<substring>`` "
"option can be used to filter the functions that are printed. All functions "
"that contain the specified substring will be printed."
msgstr ""

#: ../../../Passes.rst:109
msgid "``dot-dom``: Print dominance tree of function to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:111
msgid ""
"This pass, only available in ``opt``, prints the dominator tree into a ``."
"dot`` graph.  This graph can then be processed with the :program:`dot` tool "
"to convert it to postscript or some other suitable format."
msgstr ""

#: ../../../Passes.rst:116
msgid ""
"``dot-dom-only``: Print dominance tree of function to \"dot\" file (with no "
"function bodies)"
msgstr ""

#: ../../../Passes.rst:118
msgid ""
"This pass, only available in ``opt``, prints the dominator tree into a ``."
"dot`` graph, omitting the function bodies.  This graph can then be processed "
"with the :program:`dot` tool to convert it to postscript or some other "
"suitable format."
msgstr ""

#: ../../../Passes.rst:123
msgid "``dot-post-dom``: Print postdominance tree of function to \"dot\" file"
msgstr ""

#: ../../../Passes.rst:125
msgid ""
"This pass, only available in ``opt``, prints the post dominator tree into a "
"``.dot`` graph.  This graph can then be processed with the :program:`dot` "
"tool to convert it to postscript or some other suitable format."
msgstr ""

#: ../../../Passes.rst:130
msgid ""
"``dot-post-dom-only``: Print postdominance tree of function to \"dot\" file "
"(with no function bodies)"
msgstr ""

#: ../../../Passes.rst:132
msgid ""
"This pass, only available in ``opt``, prints the post dominator tree into a "
"``.dot`` graph, omitting the function bodies.  This graph can then be "
"processed with the :program:`dot` tool to convert it to postscript or some "
"other suitable format."
msgstr ""

#: ../../../Passes.rst:138
msgid "``globals-aa``: Simple mod/ref analysis for globals"
msgstr ""

#: ../../../Passes.rst:140
msgid ""
"This simple pass provides alias and mod/ref information for global values "
"that do not have their address taken, and keeps track of whether functions "
"read or write memory (are \"pure\").  For this simple (but very common) "
"case, we can provide pretty accurate and useful information."
msgstr ""

#: ../../../Passes.rst:146
msgid "``instcount``: Counts the various types of ``Instruction``\\ s"
msgstr ""

#: ../../../Passes.rst:148
msgid "This pass collects the count of all instructions and reports them."
msgstr ""

#: ../../../Passes.rst:151
msgid "``iv-users``: Induction Variable Users"
msgstr ""

#: ../../../Passes.rst:153
msgid ""
"Bookkeeping for \"interesting\" users of expressions computed from induction "
"variables."
msgstr ""

#: ../../../Passes.rst:157
msgid "``kernel-info``: GPU Kernel Info"
msgstr ""

#: ../../../Passes.rst:159
msgid ""
"Reports various statistics for codes compiled for GPUs.  This pass is :doc:"
"`documented separately<KernelInfo>`."
msgstr ""

#: ../../../Passes.rst:163
msgid "``lazy-value-info``: Lazy Value Information Analysis"
msgstr ""

#: ../../../Passes.rst:165
msgid "Interface for lazy computation of value constraint information."
msgstr ""

#: ../../../Passes.rst:168
msgid "``lint``: Statically lint-checks LLVM IR"
msgstr ""

#: ../../../Passes.rst:170
msgid ""
"This pass statically checks for common and easily-identified constructs "
"which produce undefined or likely unintended behavior in LLVM IR."
msgstr ""

#: ../../../Passes.rst:173
msgid ""
"It is not a guarantee of correctness, in two ways.  First, it isn't "
"comprehensive.  There are checks which could be done statically which are "
"not yet implemented.  Some of these are indicated by TODO comments, but "
"those aren't comprehensive either.  Second, many conditions cannot be "
"checked statically.  This pass does no dynamic instrumentation, so it can't "
"check for all possible problems."
msgstr ""

#: ../../../Passes.rst:180
msgid ""
"Another limitation is that it assumes all code will be executed.  A store "
"through a null pointer in a basic block which is never reached is harmless, "
"but this pass will warn about it anyway."
msgstr ""

#: ../../../Passes.rst:184
msgid ""
"Optimization passes may make conditions that this pass checks for more or "
"less obvious.  If an optimization pass appears to be introducing a warning, "
"it may be that the optimization pass is merely exposing an existing "
"condition in the code."
msgstr ""

#: ../../../Passes.rst:189
msgid ""
"This code may be run before :ref:`instcombine <passes-instcombine>`.  In "
"many cases, instcombine checks for the same kinds of things and turns "
"instructions with undefined behavior into unreachable (or equivalent).  "
"Because of this, this pass makes some effort to look through bitcasts and so "
"on."
msgstr ""

#: ../../../Passes.rst:195
msgid "``loops``: Natural Loop Information"
msgstr ""

#: ../../../Passes.rst:197
msgid ""
"This analysis is used to identify natural loops and determine the loop depth "
"of various nodes of the CFG.  Note that the loops identified may actually be "
"several natural loops that share the same header node... not just a single "
"natural loop."
msgstr ""

#: ../../../Passes.rst:203
msgid "``memdep``: Memory Dependence Analysis"
msgstr ""

#: ../../../Passes.rst:205
msgid ""
"An analysis that determines, for a given memory operation, what preceding "
"memory operations it depends on.  It builds on alias analysis information, "
"and tries to provide a lazy, caching interface to a common kind of alias "
"information query."
msgstr ""

#: ../../../Passes.rst:211
msgid "``print<module-debuginfo>``: Decodes module-level debug info"
msgstr ""

#: ../../../Passes.rst:213
msgid ""
"This pass decodes the debug info metadata in a module and prints it to "
"standard output in a (sufficiently-prepared-) human-readable form."
msgstr ""

#: ../../../Passes.rst:217
msgid "``postdomtree``: Post-Dominator Tree Construction"
msgstr ""

#: ../../../Passes.rst:219
msgid ""
"This pass is a simple post-dominator construction algorithm for finding post-"
"dominators."
msgstr ""

#: ../../../Passes.rst:223
msgid "``print-alias-sets``: Alias Set Printer"
msgstr ""

#: ../../../Passes.rst:228
msgid "``print-callgraph``: Print a call graph"
msgstr ""

#: ../../../Passes.rst:230
msgid ""
"This pass, only available in ``opt``, prints the call graph to standard "
"error in a human-readable form."
msgstr ""

#: ../../../Passes.rst:234
msgid "``print-callgraph-sccs``: Print SCCs of the Call Graph"
msgstr ""

#: ../../../Passes.rst:236
msgid ""
"This pass, only available in ``opt``, prints the SCCs of the call graph to "
"standard error in a human-readable form."
msgstr ""

#: ../../../Passes.rst:240
msgid "``print-cfg-sccs``: Print SCCs of each function CFG"
msgstr ""

#: ../../../Passes.rst:242
msgid ""
"This pass, only available in ``opt``, prints the SCCs of each function CFG "
"to standard error in a human-readable fom."
msgstr ""

#: ../../../Passes.rst:246
msgid "``function(print)``: Print function to stderr"
msgstr ""

#: ../../../Passes.rst:248
msgid ""
"The ``PrintFunctionPass`` class is designed to be pipelined with other "
"``FunctionPasses``, and prints out the functions of the module as they are "
"processed."
msgstr ""

#: ../../../Passes.rst:253
msgid "``module(print)``: Print module to stderr"
msgstr ""

#: ../../../Passes.rst:255
msgid "This pass simply prints out the entire module when it is executed."
msgstr ""

#: ../../../Passes.rst:258
msgid "``regions``: Detect single entry single exit regions"
msgstr ""

#: ../../../Passes.rst:260
msgid ""
"The ``RegionInfo`` pass detects single entry single exit regions in a "
"function, where a region is defined as any subgraph that is connected to the "
"remaining graph at only two spots.  Furthermore, a hierarchical region tree "
"is built."
msgstr ""

#: ../../../Passes.rst:267
msgid "``scalar-evolution``: Scalar Evolution Analysis"
msgstr ""

#: ../../../Passes.rst:269
msgid ""
"The ``ScalarEvolution`` analysis can be used to analyze and categorize "
"scalar expressions in loops.  It specializes in recognizing general "
"induction variables, representing them with the abstract and opaque ``SCEV`` "
"class. Given this analysis, trip counts of loops and other important "
"properties can be obtained."
msgstr ""

#: ../../../Passes.rst:275
msgid ""
"This analysis is primarily useful for induction variable substitution and "
"strength reduction."
msgstr ""

#: ../../../Passes.rst:279
msgid "``scev-aa``: ScalarEvolution-based Alias Analysis"
msgstr ""

#: ../../../Passes.rst:281
msgid ""
"Simple alias analysis implemented in terms of ``ScalarEvolution`` queries."
msgstr ""

#: ../../../Passes.rst:283
msgid ""
"This differs from traditional loop dependence analysis in that it tests for "
"dependencies within a single iteration of a loop, rather than dependencies "
"between different iterations."
msgstr ""

#: ../../../Passes.rst:287
msgid ""
"``ScalarEvolution`` has a more complete understanding of pointer arithmetic "
"than ``BasicAliasAnalysis``' collection of ad-hoc analyses."
msgstr ""

#: ../../../Passes.rst:291
msgid "``stack-safety``: Stack Safety Analysis"
msgstr ""

#: ../../../Passes.rst:293
msgid ""
"The ``StackSafety`` analysis can be used to determine if stack allocated "
"variables can be considered safe from memory access bugs."
msgstr ""

#: ../../../Passes.rst:296
msgid ""
"This analysis' primary purpose is to be used by sanitizers to avoid "
"unnecessary instrumentation of safe variables."
msgstr ""

#: ../../../Passes.rst:300
msgid "Transform Passes"
msgstr ""

#: ../../../Passes.rst:302
msgid "This section describes the LLVM Transform Passes."
msgstr ""

#: ../../../Passes.rst:305
msgid "``adce``: Aggressive Dead Code Elimination"
msgstr ""

#: ../../../Passes.rst:307
msgid ""
"ADCE aggressively tries to eliminate code.  This pass is similar to :ref:"
"`DCE <passes-dce>` but it assumes that values are dead until proven "
"otherwise.  This is similar to :ref:`SCCP <passes-sccp>`, except applied to "
"the liveness of values."
msgstr ""

#: ../../../Passes.rst:313
msgid "``always-inline``: Inliner for ``always_inline`` functions"
msgstr ""

#: ../../../Passes.rst:315
msgid ""
"A custom inliner that handles only functions that are marked as \"always "
"inline\"."
msgstr ""

#: ../../../Passes.rst:319
msgid "``argpromotion``: Promote 'by reference' arguments to scalars"
msgstr ""

#: ../../../Passes.rst:321
msgid ""
"This pass promotes \"by reference\" arguments to be \"by value\" arguments.  "
"In practice, this means looking for internal functions that have pointer "
"arguments.  If it can prove, through the use of alias analysis, that an "
"argument is *only* loaded, then it can pass the value into the function "
"instead of the address of the value.  This can cause recursive "
"simplification of code and lead to the elimination of allocas (especially in "
"C++ template code like the STL)."
msgstr ""

#: ../../../Passes.rst:329
msgid ""
"This pass also handles aggregate arguments that are passed into a function, "
"scalarizing them if the elements of the aggregate are only loaded.  Note "
"that it refuses to scalarize aggregates which would require passing in more "
"than three operands to the function, because passing thousands of operands "
"for a large array or structure is unprofitable!"
msgstr ""

#: ../../../Passes.rst:335
msgid ""
"Note that this transformation could also be done for arguments that are only "
"stored to (returning the value instead), but does not currently.  This case "
"would be best handled when and if LLVM starts supporting multiple return "
"values from functions."
msgstr ""

#: ../../../Passes.rst:341
msgid "``block-placement``: Profile Guided Basic Block Placement"
msgstr ""

#: ../../../Passes.rst:343
msgid ""
"This pass is a very simple profile guided basic block placement algorithm.  "
"The idea is to put frequently executed blocks together at the start of the "
"function and hopefully increase the number of fall-through conditional "
"branches.  If there is no profile information for a particular function, "
"this pass basically orders blocks in depth-first order."
msgstr ""

#: ../../../Passes.rst:350
msgid "``break-crit-edges``: Break critical edges in CFG"
msgstr ""

#: ../../../Passes.rst:352
msgid ""
"Break all of the critical edges in the CFG by inserting a dummy basic block. "
"It may be \"required\" by passes that cannot deal with critical edges.  This "
"transformation obviously invalidates the CFG, but can update forward "
"dominator (set, immediate dominators, tree, and frontier) information."
msgstr ""

#: ../../../Passes.rst:358
msgid "``codegenprepare``: Optimize for code generation"
msgstr ""

#: ../../../Passes.rst:360
msgid ""
"This pass munges the code in the input function to better prepare it for "
"SelectionDAG-based code generation.  This works around limitations in its "
"basic-block-at-a-time approach.  It should eventually be removed."
msgstr ""

#: ../../../Passes.rst:365
msgid "``constmerge``: Merge Duplicate Global Constants"
msgstr ""

#: ../../../Passes.rst:367
msgid ""
"Merges duplicate global constants together into a single constant that is "
"shared.  This is useful because some passes (i.e., TraceValues) insert a lot "
"of string constants into the program, regardless of whether or not an "
"existing string is available."
msgstr ""

#: ../../../Passes.rst:375
msgid "``dce``: Dead Code Elimination"
msgstr ""

#: ../../../Passes.rst:377
msgid ""
"Dead code elimination is similar to dead instruction elimination, but it "
"rechecks instructions that were used by removed instructions to see if they "
"are newly dead."
msgstr ""

#: ../../../Passes.rst:382
msgid "``deadargelim``: Dead Argument Elimination"
msgstr ""

#: ../../../Passes.rst:384
msgid ""
"This pass deletes dead arguments from internal functions.  Dead argument "
"elimination removes arguments which are directly dead, as well as arguments "
"only passed into function calls as dead arguments of other functions.  This "
"pass also deletes dead arguments in a similar way."
msgstr ""

#: ../../../Passes.rst:389
msgid ""
"This pass is often useful as a cleanup pass to run after aggressive "
"interprocedural passes, which add possibly-dead arguments."
msgstr ""

#: ../../../Passes.rst:393
msgid "``dse``: Dead Store Elimination"
msgstr ""

#: ../../../Passes.rst:395
msgid ""
"A trivial dead store elimination that only considers basic-block local "
"redundant stores."
msgstr ""

#: ../../../Passes.rst:401
msgid "``function-attrs``: Deduce function attributes"
msgstr ""

#: ../../../Passes.rst:403
msgid ""
"A simple interprocedural pass which walks the call-graph, looking for "
"functions which do not access or only read non-local memory, and marking "
"them ``readnone``/``readonly``.  In addition, it marks function arguments "
"(of pointer type) \"``nocapture``\" if a call to the function does not "
"create any copies of the pointer value that outlive the call.  This more or "
"less means that the pointer is only dereferenced, and not returned from the "
"function or stored in a global.  This pass is implemented as a bottom-up "
"traversal of the call-graph."
msgstr ""

#: ../../../Passes.rst:413
msgid "``globaldce``: Dead Global Elimination"
msgstr ""

#: ../../../Passes.rst:415
msgid ""
"This transform is designed to eliminate unreachable internal globals from "
"the program.  It uses an aggressive algorithm, searching out globals that "
"are known to be alive.  After it finds all of the globals which are needed, "
"it deletes whatever is left over.  This allows it to delete recursive chunks "
"of the program which are unreachable."
msgstr ""

#: ../../../Passes.rst:422
msgid "``globalopt``: Global Variable Optimizer"
msgstr ""

#: ../../../Passes.rst:424
msgid ""
"This pass transforms simple global variables that never have their address "
"taken.  If obviously true, it marks read/write globals as constant, deletes "
"variables only stored to, etc."
msgstr ""

#: ../../../Passes.rst:429
msgid "``gvn``: Global Value Numbering"
msgstr ""

#: ../../../Passes.rst:431
msgid ""
"This pass performs global value numbering to eliminate fully and partially "
"redundant instructions.  It also performs redundant load elimination."
msgstr ""

#: ../../../Passes.rst:437
msgid "``indvars``: Canonicalize Induction Variables"
msgstr ""

#: ../../../Passes.rst:439
msgid ""
"This transformation analyzes and transforms the induction variables (and "
"computations derived from them) into simpler forms suitable for subsequent "
"analysis and transformation."
msgstr ""

#: ../../../Passes.rst:443
msgid ""
"This transformation makes the following changes to each loop with an "
"identifiable induction variable:"
msgstr ""

#: ../../../Passes.rst:446
msgid ""
"All loops are transformed to have a *single* canonical induction variable "
"which starts at zero and steps by one."
msgstr ""

#: ../../../Passes.rst:448
msgid ""
"The canonical induction variable is guaranteed to be the first PHI node in "
"the loop header block."
msgstr ""

#: ../../../Passes.rst:450
msgid "Any pointer arithmetic recurrences are raised to use array subscripts."
msgstr ""

#: ../../../Passes.rst:452
msgid ""
"If the trip count of a loop is computable, this pass also makes the "
"following changes:"
msgstr ""

#: ../../../Passes.rst:455
msgid ""
"The exit condition for the loop is canonicalized to compare the induction "
"value against the exit value.  This turns loops like:"
msgstr ""

#: ../../../Passes.rst:468
msgid ""
"Any use outside of the loop of an expression derived from the indvar is "
"changed to compute the derived value outside of the loop, eliminating the "
"dependence on the exit value of the induction variable.  If the only purpose "
"of the loop is to compute the exit value of some derived expression, this "
"transformation will make the loop dead."
msgstr ""

#: ../../../Passes.rst:474
msgid ""
"This transformation should be followed by strength reduction after all of "
"the desired loop transformations have been performed.  Additionally, on "
"targets where it is profitable, the loop could be transformed to count down "
"to zero (the \"do loop\" optimization)."
msgstr ""

#: ../../../Passes.rst:480
msgid "``inline``: Function Integration/Inlining"
msgstr ""

#: ../../../Passes.rst:482
msgid "Bottom-up inlining of functions into callees."
msgstr ""

#: ../../../Passes.rst:487
msgid "``instcombine``: Combine redundant instructions"
msgstr ""

#: ../../../Passes.rst:489
msgid ""
"Combine instructions to form fewer, simple instructions.  This pass does not "
"modify the CFG. This pass is where algebraic simplification happens."
msgstr ""

#: ../../../Passes.rst:492
msgid "This pass combines things like:"
msgstr ""

#: ../../../Passes.rst:499
msgid "into:"
msgstr ""

#: ../../../Passes.rst:505
msgid "This is a simple worklist driven algorithm."
msgstr ""

#: ../../../Passes.rst:507
msgid ""
"This pass guarantees that the following canonicalizations are performed on "
"the program:"
msgstr ""

#: ../../../Passes.rst:510
msgid ""
"If a binary operator has a constant operand, it is moved to the right-hand "
"side."
msgstr ""

#: ../../../Passes.rst:512
msgid ""
"Bitwise operators with constant operands are always grouped so that shifts "
"are performed first, then ``or``\\ s, then ``and``\\ s, then ``xor``\\ s."
msgstr ""

#: ../../../Passes.rst:514
msgid ""
"Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to "
"``=`` or ``≠`` if possible."
msgstr ""

#: ../../../Passes.rst:516
msgid ""
"All ``cmp`` instructions on boolean values are replaced with logical "
"operations."
msgstr ""

#: ../../../Passes.rst:518
msgid "``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``"
msgstr ""

#: ../../../Passes.rst:519
msgid ""
"Multiplies with a constant power-of-two argument are transformed into shifts."
msgstr ""

#: ../../../Passes.rst:521
msgid "… etc."
msgstr ""

#: ../../../Passes.rst:523
msgid ""
"This pass can also simplify calls to specific well-known function calls (e."
"g. runtime library functions).  For example, a call ``exit(3)`` that occurs "
"within the ``main()`` function can be transformed into simply ``return 3``. "
"Whether or not library calls are simplified is controlled by the :ref:`-"
"function-attrs <passes-function-attrs>` pass and LLVM's knowledge of library "
"calls on different targets."
msgstr ""

#: ../../../Passes.rst:533
msgid "``aggressive-instcombine``: Combine expression patterns"
msgstr ""

#: ../../../Passes.rst:535
msgid ""
"Combine expression patterns to form expressions with fewer, simple "
"instructions."
msgstr ""

#: ../../../Passes.rst:537
msgid ""
"For example, this pass reduce width of expressions post-dominated by "
"TruncInst into smaller width when applicable."
msgstr ""

#: ../../../Passes.rst:540
msgid ""
"It differs from instcombine pass in that it can modify CFG and contains "
"pattern optimization that requires higher complexity than the O(1), thus, it "
"should run fewer times than instcombine pass."
msgstr ""

#: ../../../Passes.rst:545
msgid "``internalize``: Internalize Global Symbols"
msgstr ""

#: ../../../Passes.rst:547
msgid ""
"This pass loops over all of the functions in the input module, looking for a "
"main function.  If a main function is found, all other functions and all "
"global variables with initializers are marked as internal."
msgstr ""

#: ../../../Passes.rst:552
msgid "``ipsccp``: Interprocedural Sparse Conditional Constant Propagation"
msgstr ""

#: ../../../Passes.rst:554
msgid ""
"An interprocedural variant of :ref:`Sparse Conditional Constant Propagation "
"<passes-sccp>`."
msgstr ""

#: ../../../Passes.rst:558
msgid "``normalize``: Transforms IR into a normal form that's easier to diff"
msgstr ""

#: ../../../Passes.rst:560
msgid ""
"This pass aims to transform LLVM Modules into a normal form by reordering "
"and renaming instructions while preserving the same semantics. The "
"normalizer makes it easier to spot semantic differences while diffing two "
"modules which have undergone two different passes."
msgstr ""

#: ../../../Passes.rst:566
msgid "``jump-threading``: Jump Threading"
msgstr ""

#: ../../../Passes.rst:568
msgid ""
"Jump threading tries to find distinct threads of control flow running "
"through a basic block.  This pass looks at blocks that have multiple "
"predecessors and multiple successors.  If one or more of the predecessors of "
"the block can be proven to always cause a jump to one of the successors, we "
"forward the edge from the predecessor to the successor by duplicating the "
"contents of this block."
msgstr ""

#: ../../../Passes.rst:575
msgid "An example of when this can occur is code like this:"
msgstr ""

#: ../../../Passes.rst:584
msgid ""
"In this case, the unconditional branch at the end of the first if can be "
"revectored to the false side of the second if."
msgstr ""

#: ../../../Passes.rst:590
msgid "``lcssa``: Loop-Closed SSA Form Pass"
msgstr ""

#: ../../../Passes.rst:592
msgid ""
"This pass transforms loops by placing phi nodes at the end of the loops for "
"all values that are live across the loop boundary.  For example, it turns "
"the left into the right code:"
msgstr ""

#: ../../../Passes.rst:607
msgid ""
"This is still valid LLVM; the extra phi nodes are purely redundant, and will "
"be trivially eliminated by ``InstCombine``.  The major benefit of this "
"transformation is that it makes many other loop optimizations, such as "
"``LoopUnswitch``\\ ing, simpler. You can read more in the :ref:`loop "
"terminology section for the LCSSA form <loop-terminology-lcssa>`."
msgstr ""

#: ../../../Passes.rst:616
msgid "``licm``: Loop Invariant Code Motion"
msgstr ""

#: ../../../Passes.rst:618
msgid ""
"This pass performs loop invariant code motion, attempting to remove as much "
"code from the body of a loop as possible.  It does this by either hoisting "
"code into the preheader block, or by sinking code to the exit blocks if it "
"is safe. This pass also promotes must-aliased memory locations in the loop "
"to live in registers, thus hoisting and sinking \"invariant\" loads and "
"stores."
msgstr ""

#: ../../../Passes.rst:624
msgid ""
"Hoisting operations out of loops is a canonicalization transform. It enables "
"and simplifies subsequent optimizations in the middle-end. Rematerialization "
"of hoisted instructions to reduce register pressure is the responsibility of "
"the back-end, which has more accurate information about register pressure "
"and also handles other optimizations than LICM that increase live-ranges."
msgstr ""

#: ../../../Passes.rst:630
msgid "This pass uses alias analysis for two purposes:"
msgstr ""

#: ../../../Passes.rst:632
msgid ""
"Moving loop invariant loads and calls out of loops.  If we can determine "
"that a load or call inside of a loop never aliases anything stored to, we "
"can hoist it or sink it like any other instruction."
msgstr ""

#: ../../../Passes.rst:636
msgid ""
"Scalar Promotion of Memory.  If there is a store instruction inside of the "
"loop, we try to move the store to happen AFTER the loop instead of inside of "
"the loop.  This can only happen if a few conditions are true:"
msgstr ""

#: ../../../Passes.rst:640
msgid "The pointer stored through is loop invariant."
msgstr ""

#: ../../../Passes.rst:641
msgid ""
"There are no stores or loads in the loop which *may* alias the pointer. "
"There are no calls in the loop which mod/ref the pointer."
msgstr ""

#: ../../../Passes.rst:644
msgid ""
"If these conditions are true, we can promote the loads and stores in the "
"loop of the pointer to use a temporary alloca'd variable.  We then use the :"
"ref:`mem2reg <passes-mem2reg>` functionality to construct the appropriate "
"SSA form for the variable."
msgstr ""

#: ../../../Passes.rst:650
msgid "``loop-deletion``: Delete dead loops"
msgstr ""

#: ../../../Passes.rst:652
msgid ""
"This file implements the Dead Loop Deletion Pass.  This pass is responsible "
"for eliminating loops with non-infinite computable trip counts that have no "
"side effects or volatile instructions, and do not contribute to the "
"computation of the function's return value."
msgstr ""

#: ../../../Passes.rst:660
msgid "``loop-extract``: Extract loops into new functions"
msgstr ""

#: ../../../Passes.rst:662
msgid ""
"A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract "
"each top-level loop into its own new function.  If the loop is the *only* "
"loop in a given function, it is not touched.  This is a pass most useful for "
"debugging via bugpoint."
msgstr ""

#: ../../../Passes.rst:668
msgid "``loop-reduce``: Loop Strength Reduction"
msgstr ""

#: ../../../Passes.rst:670
msgid ""
"This pass performs a strength reduction on array references inside loops "
"that have as one or more of their components the loop induction variable.  "
"This is accomplished by creating a new value to hold the initial value of "
"the array access for the first iteration, and then creating a new GEP "
"instruction in the loop to increment the value by the appropriate amount."
msgstr ""

#: ../../../Passes.rst:679
msgid "``loop-rotate``: Rotate Loops"
msgstr ""

#: ../../../Passes.rst:681
msgid ""
"A simple loop rotation transformation.  A summary of it can be found in :ref:"
"`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`."
msgstr ""

#: ../../../Passes.rst:688
msgid "``loop-simplify``: Canonicalize natural loops"
msgstr ""

#: ../../../Passes.rst:690
msgid ""
"This pass performs several transformations to transform natural loops into a "
"simpler form, which makes subsequent analyses and transformations simpler "
"and more effective. A summary of it can be found in :ref:`Loop Terminology, "
"Loop Simplify Form <loop-terminology-loop-simplify>`."
msgstr ""

#: ../../../Passes.rst:695
msgid ""
"Loop pre-header insertion guarantees that there is a single, non-critical "
"entry edge from outside of the loop to the loop header.  This simplifies a "
"number of analyses and transformations, such as :ref:`LICM <passes-licm>`."
msgstr ""

#: ../../../Passes.rst:699
msgid ""
"Loop exit-block insertion guarantees that all exit blocks from the loop "
"(blocks which are outside of the loop that have predecessors inside of the "
"loop) only have predecessors from inside of the loop (and are thus dominated "
"by the loop header).  This simplifies transformations such as store-sinking "
"that are built into LICM."
msgstr ""

#: ../../../Passes.rst:705
msgid "This pass also guarantees that loops will have exactly one backedge."
msgstr ""

#: ../../../Passes.rst:707
msgid ""
"Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up "
"blocks which are split out but end up being unnecessary, so usage of this "
"pass should not pessimize generated code."
msgstr ""

#: ../../../Passes.rst:711
msgid ""
"This pass obviously modifies the CFG, but updates loop information and "
"dominator information."
msgstr ""

#: ../../../Passes.rst:715
msgid "``loop-unroll``: Unroll loops"
msgstr ""

#: ../../../Passes.rst:717
msgid ""
"This pass implements a simple loop unroller.  It works best when loops have "
"been canonicalized by the :ref:`indvars <passes-indvars>` pass, allowing it "
"to determine the trip counts of loops easily."
msgstr ""

#: ../../../Passes.rst:722
msgid "``loop-unroll-and-jam``: Unroll and Jam loops"
msgstr ""

#: ../../../Passes.rst:724
msgid ""
"This pass implements a simple unroll and jam classical loop optimisation "
"pass. It transforms loop from:"
msgstr ""

#: ../../../Passes.rst:737
msgid ""
"Which can be seen as unrolling the outer loop and \"jamming\" (fusing) the "
"inner loops into one. When variables or loads can be shared in the new inner "
"loop, this can lead to significant performance improvements. It uses :ref:"
"`Dependence Analysis <passes-da>` for proving the transformations are safe."
msgstr ""

#: ../../../Passes.rst:743
msgid "``lower-global-dtors``: Lower global destructors"
msgstr ""

#: ../../../Passes.rst:745
msgid ""
"This pass lowers global module destructors (``llvm.global_dtors``) by "
"creating wrapper functions that are registered as global constructors in "
"``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to "
"register their destructor functions."
msgstr ""

#: ../../../Passes.rst:751
msgid "``lower-atomic``: Lower atomic intrinsics to non-atomic form"
msgstr ""

#: ../../../Passes.rst:753
msgid ""
"This pass lowers atomic intrinsics to non-atomic form for use in a known non-"
"preemptible environment."
msgstr ""

#: ../../../Passes.rst:756
msgid ""
"The pass does not verify that the environment is non-preemptible (in general "
"this would require knowledge of the entire call graph of the program "
"including any libraries which may not be available in bitcode form); it "
"simply lowers every atomic intrinsic."
msgstr ""

#: ../../../Passes.rst:762
msgid ""
"``lower-invoke``: Lower invokes to calls, for unwindless code generators"
msgstr ""

#: ../../../Passes.rst:764
msgid ""
"This transformation is designed for use by code generators which do not yet "
"support stack unwinding.  This pass converts ``invoke`` instructions to "
"``call`` instructions, so that any exception-handling ``landingpad`` blocks "
"become dead code (which can be removed by running the ``-simplifycfg`` pass "
"afterwards)."
msgstr ""

#: ../../../Passes.rst:771
msgid "``lower-switch``: Lower ``SwitchInst``\\ s to branches"
msgstr ""

#: ../../../Passes.rst:773
msgid ""
"Rewrites switch instructions with a sequence of branches, which allows "
"targets to get away with not implementing the switch instruction until it is "
"convenient."
msgstr ""

#: ../../../Passes.rst:780
msgid "``mem2reg``: Promote Memory to Register"
msgstr ""

#: ../../../Passes.rst:782
msgid ""
"This file promotes memory references to be register references.  It promotes "
"alloca instructions which only have loads and stores as uses.  An ``alloca`` "
"is transformed by using dominator frontiers to place phi nodes, then "
"traversing the function in depth-first order to rewrite loads and stores as "
"appropriate. This is just the standard SSA construction algorithm to "
"construct \"pruned\" SSA form."
msgstr ""

#: ../../../Passes.rst:790
msgid "``memcpyopt``: MemCpy Optimization"
msgstr ""

#: ../../../Passes.rst:792
msgid ""
"This pass performs various transformations related to eliminating ``memcpy`` "
"calls, or transforming sets of stores into ``memset``\\ s."
msgstr ""

#: ../../../Passes.rst:796
msgid "``mergefunc``: Merge Functions"
msgstr ""

#: ../../../Passes.rst:798
msgid ""
"This pass looks for equivalent functions that are mergeable and folds them."
msgstr ""

#: ../../../Passes.rst:800
msgid ""
"Total-ordering is introduced among the functions set: we define comparison "
"that answers for every two functions which of them is greater. It allows to "
"arrange functions into the binary tree."
msgstr ""

#: ../../../Passes.rst:804
msgid "For every new function we check for equivalent in tree."
msgstr ""

#: ../../../Passes.rst:806
msgid ""
"If equivalent exists we fold such functions. If both functions are "
"overridable, we move the functionality into a new internal function and "
"leave two overridable thunks to it."
msgstr ""

#: ../../../Passes.rst:810
msgid "If there is no equivalent, then we add this function to tree."
msgstr ""

#: ../../../Passes.rst:812
msgid ""
"Lookup routine has O(log(n)) complexity, while whole merging process has "
"complexity of O(n*log(n))."
msgstr ""

#: ../../../Passes.rst:815
msgid "Read :doc:`this <MergeFunctions>` article for more details."
msgstr ""

#: ../../../Passes.rst:820
msgid "``mergereturn``: Unify function exit nodes"
msgstr ""

#: ../../../Passes.rst:822
msgid ""
"Ensure that functions have at most one ``ret`` instruction in them. "
"Additionally, it keeps track of which node is the new exit node of the CFG."
msgstr ""

#: ../../../Passes.rst:826
msgid "``partial-inliner``: Partial Inliner"
msgstr ""

#: ../../../Passes.rst:828
msgid ""
"This pass performs partial inlining, typically by inlining an ``if`` "
"statement that surrounds the body of the function."
msgstr ""

#: ../../../Passes.rst:832
msgid "``reassociate``: Reassociate expressions"
msgstr ""

#: ../../../Passes.rst:834
msgid ""
"This pass reassociates commutative expressions in an order that is designed "
"to promote better constant propagation, GCSE, :ref:`LICM <passes-licm>`, "
"PRE, etc."
msgstr ""

#: ../../../Passes.rst:837
msgid "For example: 4 + (x + 5) ⇒ x + (4 + 5)"
msgstr ""

#: ../../../Passes.rst:839
msgid ""
"In the implementation of this algorithm, constants are assigned rank = 0, "
"function arguments are rank = 1, and other values are assigned ranks "
"corresponding to the reverse post order traversal of current function "
"(starting at 2), which effectively gives values in deep loops higher rank "
"than values not in loops."
msgstr ""

#: ../../../Passes.rst:846
msgid "``rel-lookup-table-converter``: Relative lookup table converter"
msgstr ""

#: ../../../Passes.rst:848
msgid ""
"This pass converts lookup tables to PIC-friendly relative lookup tables."
msgstr ""

#: ../../../Passes.rst:851
msgid "``reg2mem``: Demote all values to stack slots"
msgstr ""

#: ../../../Passes.rst:853
msgid ""
"This file demotes all registers to memory references.  It is intended to be "
"the inverse of :ref:`mem2reg <passes-mem2reg>`.  By converting to ``load`` "
"instructions, the only values live across basic blocks are ``alloca`` "
"instructions and ``load`` instructions before ``phi`` nodes.  It is intended "
"that this should make CFG hacking much easier.  To make later hacking "
"easier, the entry block is split into two, such that all introduced "
"``alloca`` instructions (and nothing else) are in the entry block."
msgstr ""

#: ../../../Passes.rst:862
msgid "``sroa``: Scalar Replacement of Aggregates"
msgstr ""

#: ../../../Passes.rst:864
msgid ""
"The well-known scalar replacement of aggregates transformation.  This "
"transform breaks up ``alloca`` instructions of aggregate type (structure or "
"array) into individual ``alloca`` instructions for each member if possible.  "
"Then, if possible, it transforms the individual ``alloca`` instructions into "
"nice clean scalar SSA form."
msgstr ""

#: ../../../Passes.rst:873
msgid "``sccp``: Sparse Conditional Constant Propagation"
msgstr ""

#: ../../../Passes.rst:875
msgid ""
"Sparse conditional constant propagation and merging, which can be summarized "
"as:"
msgstr ""

#: ../../../Passes.rst:878
msgid "Assumes values are constant unless proven otherwise"
msgstr ""

#: ../../../Passes.rst:879
msgid "Assumes BasicBlocks are dead unless proven otherwise"
msgstr ""

#: ../../../Passes.rst:880
msgid "Proves values to be constant, and replaces them with constants"
msgstr ""

#: ../../../Passes.rst:881
msgid "Proves conditional branches to be unconditional"
msgstr ""

#: ../../../Passes.rst:883
msgid ""
"Note that this pass has a habit of making definitions be dead.  It is a good "
"idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass."
msgstr ""

#: ../../../Passes.rst:889
msgid "``simplifycfg``: Simplify the CFG"
msgstr ""

#: ../../../Passes.rst:891
msgid "Performs dead code elimination and basic block merging.  Specifically:"
msgstr ""

#: ../../../Passes.rst:893
msgid "Removes basic blocks with no predecessors."
msgstr ""

#: ../../../Passes.rst:894
msgid ""
"Merges a basic block into its predecessor if there is only one and the "
"predecessor only has one successor."
msgstr ""

#: ../../../Passes.rst:896
msgid "Eliminates PHI nodes for basic blocks with a single predecessor."
msgstr ""

#: ../../../Passes.rst:897
msgid "Eliminates a basic block that only contains an unconditional branch."
msgstr ""

#: ../../../Passes.rst:900
msgid "``sink``: Code sinking"
msgstr ""

#: ../../../Passes.rst:902
msgid ""
"This pass moves instructions into successor blocks, when possible, so that "
"they aren't executed on paths where their results aren't needed."
msgstr ""

#: ../../../Passes.rst:908
msgid "``simple-loop-unswitch``: Unswitch loops"
msgstr ""

#: ../../../Passes.rst:910
msgid ""
"This pass transforms loops that contain branches on loop-invariant "
"conditions to have multiple loops.  For example, it turns the left into the "
"right code:"
msgstr ""

#: ../../../Passes.rst:922
msgid ""
"This can increase the size of the code exponentially (doubling it every time "
"a loop is unswitched) so we only unswitch if the resultant code will be "
"smaller than a threshold."
msgstr ""

#: ../../../Passes.rst:926
msgid ""
"This pass expects :ref:`LICM <passes-licm>` to be run before it to hoist "
"invariant conditions out of the loop, to make the unswitching opportunity "
"obvious."
msgstr ""

#: ../../../Passes.rst:931
msgid "``strip``: Strip all symbols from a module"
msgstr ""

#: ../../../Passes.rst:933
msgid "Performs code stripping.  This transformation can delete:"
msgstr ""

#: ../../../Passes.rst:935
msgid "names for virtual registers"
msgstr ""

#: ../../../Passes.rst:936
msgid "symbols for internal globals and functions"
msgstr ""

#: ../../../Passes.rst:937
msgid "debug information"
msgstr ""

#: ../../../Passes.rst:939
msgid ""
"Note that this transformation makes code much less readable, so it should "
"only be used in situations where the strip utility would be used, such as "
"reducing code size or making it harder to reverse engineer code."
msgstr ""

#: ../../../Passes.rst:944
msgid "``strip-dead-debug-info``: Strip debug info for unused symbols"
msgstr ""

#: ../../../Passes.rst:946
msgid ""
"Performs code stripping. Similar to strip, but only strips debug info for "
"unused symbols."
msgstr ""

#: ../../../Passes.rst:950
msgid "``strip-dead-prototypes``: Strip Unused Function Prototypes"
msgstr ""

#: ../../../Passes.rst:952
msgid ""
"This pass loops over all of the functions in the input module, looking for "
"dead declarations and removes them.  Dead declarations are declarations of "
"functions for which no implementation is available (i.e., declarations for "
"unused library functions)."
msgstr ""

#: ../../../Passes.rst:957
msgid ""
"``strip-debug-declare``: Strip all ``llvm.dbg.declare`` intrinsics and "
"``#dbg_declare`` records. "
"-------------------------------------------------------------------"
msgstr ""

#: ../../../Passes.rst:961
msgid ""
"Performs code stripping. Similar to strip, but only strips ``llvm.dbg."
"declare`` intrinsics."
msgstr ""

#: ../../../Passes.rst:965
msgid ""
"``strip-nondebug``: Strip all symbols, except dbg symbols, from a module"
msgstr ""

#: ../../../Passes.rst:967
msgid "Performs code stripping. Similar to strip, but dbg info is preserved."
msgstr ""

#: ../../../Passes.rst:970
msgid "``tailcallelim``: Tail Call Elimination"
msgstr ""

#: ../../../Passes.rst:972
msgid ""
"This file transforms calls of the current function (self recursion) followed "
"by a return instruction with a branch to the entry of the function, creating "
"a loop.  This pass also implements the following extensions to the basic "
"algorithm:"
msgstr ""

#: ../../../Passes.rst:977
msgid ""
"Trivial instructions between the call and return do not prevent the "
"transformation from taking place, though currently the analysis cannot "
"support moving any really useful instructions (only dead ones)."
msgstr ""

#: ../../../Passes.rst:980
msgid ""
"This pass transforms functions that are prevented from being tail recursive "
"by an associative expression to use an accumulator variable, thus compiling "
"the typical naive factorial or fib implementation into efficient code."
msgstr ""

#: ../../../Passes.rst:983
msgid ""
"TRE is performed if the function returns void, if the return returns the "
"result returned by the call, or if the function returns a run-time constant "
"on all exits from the function.  It is possible, though unlikely, that the "
"return returns something else (like constant 0), and can still be TRE'd.  It "
"can be TRE'd if *all other* return instructions in the function return the "
"exact same value."
msgstr ""

#: ../../../Passes.rst:989
msgid ""
"If it can prove that callees do not access their caller stack frame, they "
"are marked as eligible for tail call elimination (by the code generator)."
msgstr ""

#: ../../../Passes.rst:993
msgid "Utility Passes"
msgstr ""

#: ../../../Passes.rst:995
msgid "This section describes the LLVM Utility Passes."
msgstr ""

#: ../../../Passes.rst:998
msgid "``deadarghaX0r``: Dead Argument Hacking (BUGPOINT USE ONLY; DO NOT USE)"
msgstr ""

#: ../../../Passes.rst:1000
msgid ""
"Same as dead argument elimination, but deletes arguments to functions which "
"are external.  This is only for use by :doc:`bugpoint <Bugpoint>`."
msgstr ""

#: ../../../Passes.rst:1004
msgid "``extract-blocks``: Extract Basic Blocks From Module (for bugpoint use)"
msgstr ""

#: ../../../Passes.rst:1006
msgid ""
"This pass is used by bugpoint to extract all blocks from the module into "
"their own functions."
msgstr ""

#: ../../../Passes.rst:1010
msgid "``instnamer``: Assign names to anonymous instructions"
msgstr ""

#: ../../../Passes.rst:1012
msgid ""
"This is a little utility pass that gives instructions names, this is mostly "
"useful when diffing the effect of an optimization because deleting an "
"unnamed instruction can change all other instruction numbering, making the "
"diff very noisy."
msgstr ""

#: ../../../Passes.rst:1020
msgid "``verify``: Module Verifier"
msgstr ""

#: ../../../Passes.rst:1022
msgid ""
"Verifies an LLVM IR code.  This is useful to run after an optimization which "
"is undergoing testing.  Note that llvm-as verifies its input before emitting "
"bitcode, and also that malformed bitcode is likely to make LLVM crash.  All "
"language front-ends are therefore encouraged to verify their output before "
"performing optimizing transformations."
msgstr ""

#: ../../../Passes.rst:1028
msgid "Both of a binary operator's parameters are of the same type."
msgstr ""

#: ../../../Passes.rst:1029
msgid ""
"Verify that the indices of mem access instructions match other operands."
msgstr ""

#: ../../../Passes.rst:1030
msgid ""
"Verify that arithmetic and other things are only performed on first-class "
"types.  Verify that shifts and logicals only happen on integrals f.e."
msgstr ""

#: ../../../Passes.rst:1032
msgid "All of the constants in a switch statement are of the correct type."
msgstr ""

#: ../../../Passes.rst:1033
msgid "The code is in valid SSA form."
msgstr ""

#: ../../../Passes.rst:1034
msgid ""
"It is illegal to put a label into any other type (like a structure) or to "
"return one."
msgstr ""

#: ../../../Passes.rst:1036
msgid ""
"Only phi nodes can be self referential: ``%x = add i32 %x``, ``%x`` is "
"invalid."
msgstr ""

#: ../../../Passes.rst:1038
msgid "PHI nodes must have an entry for each predecessor, with no extras."
msgstr ""

#: ../../../Passes.rst:1039
msgid ""
"PHI nodes must be the first thing in a basic block, all grouped together."
msgstr ""

#: ../../../Passes.rst:1040
msgid "PHI nodes must have at least one entry."
msgstr ""

#: ../../../Passes.rst:1041
msgid ""
"All basic blocks should only end with terminator insts, not contain them."
msgstr ""

#: ../../../Passes.rst:1042
msgid "The entry node to a function must not have predecessors."
msgstr ""

#: ../../../Passes.rst:1043
msgid "All Instructions must be embedded into a basic block."
msgstr ""

#: ../../../Passes.rst:1044
msgid "Functions cannot take a void-typed parameter."
msgstr ""

#: ../../../Passes.rst:1045
msgid "Verify that a function's argument list agrees with its declared type."
msgstr ""

#: ../../../Passes.rst:1046
msgid "It is illegal to specify a name for a void value."
msgstr ""

#: ../../../Passes.rst:1047
msgid "It is illegal to have an internal global value with no initializer."
msgstr ""

#: ../../../Passes.rst:1048
msgid ""
"It is illegal to have a ``ret`` instruction that returns a value that does "
"not agree with the function return value type."
msgstr ""

#: ../../../Passes.rst:1050
msgid "Function call argument types match the function prototype."
msgstr ""

#: ../../../Passes.rst:1051
msgid "All other things that are tested by asserts spread about the code."
msgstr ""

#: ../../../Passes.rst:1053
msgid ""
"Note that this does not provide full security verification (like Java), but "
"instead just tries to ensure that code is well-formed."
msgstr ""

#: ../../../Passes.rst:1059
msgid "``view-cfg``: View CFG of function"
msgstr ""

#: ../../../Passes.rst:1061
msgid ""
"Displays the control flow graph using the GraphViz tool. Additionally the ``-"
"cfg-func-name=<substring>`` option can be used to filter the functions that "
"are displayed. All functions that contain the specified substring will be "
"displayed."
msgstr ""

#: ../../../Passes.rst:1067
msgid "``view-cfg-only``: View CFG of function (with no function bodies)"
msgstr ""

#: ../../../Passes.rst:1069
msgid ""
"Displays the control flow graph using the GraphViz tool, but omitting "
"function bodies. Additionally the ``-cfg-func-name=<substring>`` option can "
"be used to filter the functions that are displayed. All functions that "
"contain the specified substring will be displayed."
msgstr ""

#: ../../../Passes.rst:1076
msgid "``view-dom``: View dominance tree of function"
msgstr ""

#: ../../../Passes.rst:1078
msgid "Displays the dominator tree using the GraphViz tool."
msgstr ""

#: ../../../Passes.rst:1081
msgid ""
"``view-dom-only``: View dominance tree of function (with no function bodies)"
msgstr ""

#: ../../../Passes.rst:1083
msgid ""
"Displays the dominator tree using the GraphViz tool, but omitting function "
"bodies."
msgstr ""

#: ../../../Passes.rst:1087
msgid "``view-post-dom``: View postdominance tree of function"
msgstr ""

#: ../../../Passes.rst:1089
msgid "Displays the post dominator tree using the GraphViz tool."
msgstr ""

#: ../../../Passes.rst:1092
msgid ""
"``view-post-dom-only``: View postdominance tree of function (with no "
"function bodies)"
msgstr ""

#: ../../../Passes.rst:1094
msgid ""
"Displays the post dominator tree using the GraphViz tool, but omitting "
"function bodies."
msgstr ""

#: ../../../Passes.rst:1098
msgid "``transform-warning``: Report missed forced transformations"
msgstr ""

#: ../../../Passes.rst:1100
msgid ""
"Emits warnings about not yet applied forced transformations (e.g. from "
"``#pragma omp simd``)."
msgstr ""
