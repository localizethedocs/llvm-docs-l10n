# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../FAQ.rst:3
msgid "Frequently Asked Questions (FAQ)"
msgstr ""

#: ../../../FAQ.rst:10
msgid "License"
msgstr ""

#: ../../../FAQ.rst:13
msgid "Can I modify LLVM source code and redistribute the modified source?"
msgstr ""

#: ../../../FAQ.rst:14
msgid ""
"Yes.  The modified source distribution must retain the copyright notice and "
"follow the conditions listed in the `LLVM license <http://llvm.org/svn/llvm-"
"project/llvm/trunk/LICENSE.TXT>`_."
msgstr ""

#: ../../../FAQ.rst:20
msgid ""
"Can I modify the LLVM source code and redistribute binaries or other tools "
"based on it, without redistributing the source?"
msgstr ""

#: ../../../FAQ.rst:21
msgid ""
"Yes. This is why we distribute LLVM under a less restrictive license than "
"GPL, as explained in the first question above."
msgstr ""

#: ../../../FAQ.rst:26
msgid "Source Code"
msgstr ""

#: ../../../FAQ.rst:29
msgid "In what language is LLVM written?"
msgstr ""

#: ../../../FAQ.rst:30
msgid ""
"All of the LLVM tools and libraries are written in C++ with extensive use of "
"the STL."
msgstr ""

#: ../../../FAQ.rst:35
msgid "How portable is the LLVM source code?"
msgstr ""

#: ../../../FAQ.rst:36
msgid ""
"The LLVM source code should be portable to most modern Unix-like operating "
"systems. LLVM also has excellent support on Windows systems. Most of the "
"code is written in standard C++ with operating system services abstracted to "
"a support library.  The tools required to build and test LLVM have been "
"ported to a plethora of platforms."
msgstr ""

#: ../../../FAQ.rst:44
msgid ""
"What API do I use to store a value to one of the virtual registers in LLVM "
"IR's SSA representation?"
msgstr ""

#: ../../../FAQ.rst:46
msgid ""
"In short: you can't. It's actually kind of a silly question once you grok "
"what's going on. Basically, in code like:"
msgstr ""

#: ../../../FAQ.rst:53
msgid ""
", ``%result`` is just a name given to the ``Value`` of the ``add`` "
"instruction. In other words, ``%result`` *is* the add instruction. The "
"\"assignment\" doesn't explicitly \"store\" anything to any \"virtual "
"register\"; the \"``=``\" is more like the mathematical sense of equality."
msgstr ""

#: ../../../FAQ.rst:58
msgid ""
"Longer explanation: In order to generate a textual representation of the IR, "
"some kind of name has to be given to each instruction so that other "
"instructions can textually reference it. However, the isomorphic in-memory "
"representation that you manipulate from C++ has no such restriction since "
"instructions can simply keep pointers to any other ``Value``'s that they "
"reference. In fact, the names of dummy numbered temporaries like ``%1`` are "
"not explicitly represented in the in-memory representation at all (see "
"``Value::getName()``)."
msgstr ""

#: ../../../FAQ.rst:69
msgid "Source Languages"
msgstr ""

#: ../../../FAQ.rst:72
msgid "What source languages are supported?"
msgstr ""

#: ../../../FAQ.rst:74
msgid ""
"LLVM currently has full support for C and C++ source languages through "
"`Clang <http://clang.llvm.org/>`_. Many other language frontends have been "
"written using LLVM, and an incomplete list is available at `projects with "
"LLVM <http://llvm.org/ProjectsWithLLVM/>`_."
msgstr ""

#: ../../../FAQ.rst:81
msgid ""
"I'd like to write a self-hosting LLVM compiler. How should I interface with "
"the LLVM middle-end optimizers and back-end code generators?"
msgstr ""

#: ../../../FAQ.rst:82
msgid ""
"Your compiler front-end will communicate with LLVM by creating a module in "
"the LLVM intermediate representation (IR) format. Assuming you want to write "
"your language's compiler in the language itself (rather than C++), there are "
"3 major ways to tackle generating LLVM IR from a front-end:"
msgstr ""

#: ../../../FAQ.rst:87
msgid ""
"**Call into the LLVM libraries code using your language's FFI (foreign "
"function interface).**"
msgstr ""

#: ../../../FAQ.rst:90
msgid "*for:* best tracks changes to the LLVM IR, .ll syntax, and .bc format"
msgstr ""

#: ../../../FAQ.rst:92
msgid ""
"*for:* enables running LLVM optimization passes without a emit/parse overhead"
msgstr ""

#: ../../../FAQ.rst:95
msgid "*for:* adapts well to a JIT context"
msgstr ""

#: ../../../FAQ.rst:97
msgid "*against:* lots of ugly glue code to write"
msgstr ""

#: ../../../FAQ.rst:99
msgid "**Emit LLVM assembly from your compiler's native language.**"
msgstr ""

#: ../../../FAQ.rst:101
msgid "*for:* very straightforward to get started"
msgstr ""

#: ../../../FAQ.rst:103
msgid ""
"*against:* the .ll parser is slower than the bitcode reader when interfacing "
"to the middle end"
msgstr ""

#: ../../../FAQ.rst:106 ../../../FAQ.rst:116
msgid "*against:* it may be harder to track changes to the IR"
msgstr ""

#: ../../../FAQ.rst:108
msgid "**Emit LLVM bitcode from your compiler's native language.**"
msgstr ""

#: ../../../FAQ.rst:110
msgid ""
"*for:* can use the more-efficient bitcode reader when interfacing to the "
"middle end"
msgstr ""

#: ../../../FAQ.rst:113
msgid ""
"*against:* you'll have to re-engineer the LLVM IR object model and bitcode "
"writer in your language"
msgstr ""

#: ../../../FAQ.rst:118
msgid ""
"If you go with the first option, the C bindings in include/llvm-c should "
"help a lot, since most languages have strong support for interfacing with C. "
"The most common hurdle with calling C from managed code is interfacing with "
"the garbage collector. The C interface was designed to require very little "
"memory management, and so is straightforward in this regard."
msgstr ""

#: ../../../FAQ.rst:125
msgid ""
"What support is there for a higher level source language constructs for "
"building a compiler?"
msgstr ""

#: ../../../FAQ.rst:126
msgid ""
"Currently, there isn't much. LLVM supports an intermediate representation "
"which is useful for code representation but will not support the high level "
"(abstract syntax tree) representation needed by most compilers. There are no "
"facilities for lexical nor semantic analysis."
msgstr ""

#: ../../../FAQ.rst:133
msgid "I don't understand the ``GetElementPtr`` instruction. Help!"
msgstr ""

#: ../../../FAQ.rst:134
msgid "See `The Often Misunderstood GEP Instruction <GetElementPtr.html>`_."
msgstr ""

#: ../../../FAQ.rst:138
msgid "Using the C and C++ Front Ends"
msgstr ""

#: ../../../FAQ.rst:141
msgid "Can I compile C or C++ code to platform-independent LLVM bitcode?"
msgstr ""

#: ../../../FAQ.rst:142
msgid ""
"No. C and C++ are inherently platform-dependent languages. The most obvious "
"example of this is the preprocessor. A very common way that C code is made "
"portable is by using the preprocessor to include platform-specific code. In "
"practice, information about other platforms is lost after preprocessing, so "
"the result is inherently dependent on the platform that the preprocessing "
"was targeting."
msgstr ""

#: ../../../FAQ.rst:149
msgid ""
"Another example is ``sizeof``. It's common for ``sizeof(long)`` to vary "
"between platforms. In most C front-ends, ``sizeof`` is expanded to a "
"constant immediately, thus hard-wiring a platform-specific detail."
msgstr ""

#: ../../../FAQ.rst:153
msgid ""
"Also, since many platforms define their ABIs in terms of C, and since LLVM "
"is lower-level than C, front-ends currently must emit platform-specific IR "
"in order to have the result conform to the platform ABI."
msgstr ""

#: ../../../FAQ.rst:159
msgid "Questions about code generated by the demo page"
msgstr ""

#: ../../../FAQ.rst:162
msgid ""
"What is this ``llvm.global_ctors`` and ``_GLOBAL__I_a...`` stuff that "
"happens when I ``#include <iostream>``?"
msgstr ""

#: ../../../FAQ.rst:163
msgid ""
"If you ``#include`` the ``<iostream>`` header into a C++ translation unit, "
"the file will probably use the ``std::cin``/``std::cout``/... global "
"objects. However, C++ does not guarantee an order of initialization between "
"static objects in different translation units, so if a static ctor/dtor in "
"your .cpp file used ``std::cout``, for example, the object would not "
"necessarily be automatically initialized before your use."
msgstr ""

#: ../../../FAQ.rst:170
msgid ""
"To make ``std::cout`` and friends work correctly in these scenarios, the STL "
"that we use declares a static object that gets created in every translation "
"unit that includes ``<iostream>``.  This object has a static constructor and "
"destructor that initializes and destroys the global iostream objects before "
"they could possibly be used in the file.  The code that you see in the ``."
"ll`` file corresponds to the constructor and destructor registration code."
msgstr ""

#: ../../../FAQ.rst:177
msgid ""
"If you would like to make it easier to *understand* the LLVM code generated "
"by the compiler in the demo page, consider using ``printf()`` instead of "
"``iostream``\\s to print values."
msgstr ""

#: ../../../FAQ.rst:183
msgid "Where did all of my code go??"
msgstr ""

#: ../../../FAQ.rst:184
msgid ""
"If you are using the LLVM demo page, you may often wonder what happened to "
"all of the code that you typed in.  Remember that the demo script is running "
"the code through the LLVM optimizers, so if your code doesn't actually do "
"anything useful, it might all be deleted."
msgstr ""

#: ../../../FAQ.rst:189
msgid ""
"To prevent this, make sure that the code is actually needed.  For example, "
"if you are computing some expression, return the value from the function "
"instead of leaving it in a local variable.  If you really want to constrain "
"the optimizer, you can read from and assign to ``volatile`` global variables."
msgstr ""

#: ../../../FAQ.rst:196
msgid "What is this \"``undef``\" thing that shows up in my code?"
msgstr ""

#: ../../../FAQ.rst:197
msgid ""
"``undef`` is the LLVM way of representing a value that is not defined.  You "
"can get these if you do not initialize a variable before you use it.  For "
"example, the C function:"
msgstr ""

#: ../../../FAQ.rst:205
msgid ""
"Is compiled to \"``ret i32 undef``\" because \"``i``\" never has a value "
"specified for it."
msgstr ""

#: ../../../FAQ.rst:210
msgid ""
"Why does instcombine + simplifycfg turn a call to a function with a "
"mismatched calling convention into \"unreachable\"? Why not make the "
"verifier reject it?"
msgstr ""

#: ../../../FAQ.rst:211
msgid ""
"This is a common problem run into by authors of front-ends that are using "
"custom calling conventions: you need to make sure to set the right calling "
"convention on both the function and on each call to the function.  For "
"example, this code:"
msgstr ""

#: ../../../FAQ.rst:226
msgid "Is optimized to:"
msgstr ""

#: ../../../FAQ.rst:237
msgid ""
"... with \"``opt -instcombine -simplifycfg``\".  This often bites people "
"because \"all their code disappears\".  Setting the calling convention on "
"the caller and callee is required for indirect calls to work, so people "
"often ask why not make the verifier reject this sort of thing."
msgstr ""

#: ../../../FAQ.rst:242
msgid ""
"The answer is that this code has undefined behavior, but it is not illegal. "
"If we made it illegal, then every transformation that could potentially "
"create this would have to ensure that it doesn't, and there is valid code "
"that can create this sort of construct (in dead code).  The sorts of things "
"that can cause this to happen are fairly contrived, but we still need to "
"accept them. Here's an example:"
msgstr ""

#: ../../../FAQ.rst:269
msgid ""
"In this example, \"test\" always passes ``@foo``/``false`` into ``bar``, "
"which ensures that it is dynamically called with the right calling conv "
"(thus, the code is perfectly well defined).  If you run this through the "
"inliner, you get this (the explicit \"or\" is there so that the inliner "
"doesn't dead code eliminate a bunch of stuff):"
msgstr ""

#: ../../../FAQ.rst:293
msgid ""
"Here you can see that the inlining pass made an undefined call to ``@foo`` "
"with the wrong calling convention.  We really don't want to make the inliner "
"have to know about this sort of thing, so it needs to be valid code.  In "
"this case, dead code elimination can trivially remove the undefined code.  "
"However, if ``%X`` was an input argument to ``@test``, the inliner would "
"produce this:"
msgstr ""

#: ../../../FAQ.rst:317
msgid ""
"The interesting thing about this is that ``%X`` *must* be false for the code "
"to be well-defined, but no amount of dead code elimination will be able to "
"delete the broken call as unreachable.  However, since ``instcombine``/"
"``simplifycfg`` turns the undefined call into unreachable, we end up with a "
"branch on a condition that goes to unreachable: a branch to unreachable can "
"never happen, so \"``-inline -instcombine -simplifycfg``\" is able to "
"produce:"
msgstr ""
