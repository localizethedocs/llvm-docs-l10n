# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/LangImpl06.rst:3
msgid "Kaleidoscope: Extending the Language: User-defined Operators"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:9
msgid "Chapter 6 Introduction"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:11
msgid ""
"Welcome to Chapter 6 of the \"`Implementing a language with LLVM <index."
"html>`_\" tutorial. At this point in our tutorial, we now have a fully "
"functional language that is fairly minimal, but also useful. There is still "
"one big problem with it, however. Our language doesn't have many useful "
"operators (like division, logical negation, or even any comparisons besides "
"less-than)."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:18
msgid ""
"This chapter of the tutorial takes a wild digression into adding user-"
"defined operators to the simple and beautiful Kaleidoscope language. This "
"digression now gives us a simple and ugly language in some ways, but also a "
"powerful one at the same time. One of the great things about creating your "
"own language is that you get to decide what is good or bad. In this tutorial "
"we'll assume that it is okay to use this as a way to show some interesting "
"parsing techniques."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:26
msgid ""
"At the end of this tutorial, we'll run through an example Kaleidoscope "
"application that `renders the Mandelbrot set <#kicking-the-tires>`_. This "
"gives an example of what you can build with Kaleidoscope and its feature set."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:31
msgid "User-defined Operators: the Idea"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:33
msgid ""
"The \"operator overloading\" that we will add to Kaleidoscope is more "
"general than in languages like C++. In C++, you are only allowed to redefine "
"existing operators: you can't programmatically change the grammar, introduce "
"new operators, change precedence levels, etc. In this chapter, we will add "
"this capability to Kaleidoscope, which will let the user round out the set "
"of operators that are supported."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:40
msgid ""
"The point of going into user-defined operators in a tutorial like this is to "
"show the power and flexibility of using a hand-written parser. Thus far, the "
"parser we have been implementing uses recursive descent for most parts of "
"the grammar and operator precedence parsing for the expressions. See "
"`Chapter 2 <LangImpl02.html>`_ for details. By using operator precedence "
"parsing, it is very easy to allow the programmer to introduce new operators "
"into the grammar: the grammar is dynamically extensible as the JIT runs."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:49
msgid ""
"The two specific features we'll add are programmable unary operators (right "
"now, Kaleidoscope has no unary operators at all) as well as binary "
"operators. An example of this is:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:79
msgid ""
"Many languages aspire to being able to implement their standard runtime "
"library in the language itself. In Kaleidoscope, we can implement "
"significant parts of the language in the library!"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:83
msgid ""
"We will break down implementation of these features into two parts: "
"implementing support for user-defined binary operators and adding unary "
"operators."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:88
msgid "User-defined Binary Operators"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:90
msgid ""
"Adding support for user-defined binary operators is pretty simple with our "
"current framework. We'll first add support for the unary/binary keywords:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:115
msgid ""
"This just adds lexer support for the unary and binary keywords, like we did "
"in `previous chapters <LangImpl5.html#lexer-extensions-for-if-then-else>`_. "
"One nice thing about our current AST, is that we represent binary operators "
"with full generalisation by using their ASCII code as the opcode. For our "
"extended operators, we'll use this same representation, so we don't need any "
"new AST or parser support."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:122
msgid ""
"On the other hand, we have to be able to represent the definitions of these "
"new operators, in the \"def binary\\| 5\" part of the function definition. "
"In our grammar so far, the \"name\" for the function definition is parsed as "
"the \"prototype\" production and into the ``PrototypeAST`` AST node. To "
"represent our new user-defined operators as prototypes, we have to extend "
"the ``PrototypeAST`` AST node like this:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:160
msgid ""
"Basically, in addition to knowing a name for the prototype, we now keep "
"track of whether it was an operator, and if it was, what precedence level "
"the operator is at. The precedence is only used for binary operators (as "
"you'll see below, it just doesn't apply for unary operators). Now that we "
"have a way to represent the prototype for a user-defined operator, we need "
"to parse it:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:225
msgid ""
"This is all fairly straightforward parsing code, and we have already seen a "
"lot of similar code in the past. One interesting part about the code above "
"is the couple lines that set up ``FnName`` for binary operators. This builds "
"names like \"binary@\" for a newly defined \"@\" operator. It then takes "
"advantage of the fact that symbol names in the LLVM symbol table are allowed "
"to have any character in them, including embedded nul characters."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:233
msgid ""
"The next interesting thing to add, is codegen support for these binary "
"operators. Given our current structure, this is a simple addition of a "
"default case for our existing binary operator node:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:270
msgid ""
"As you can see above, the new code is actually really simple. It just does a "
"lookup for the appropriate operator in the symbol table and generates a "
"function call to it. Since user-defined operators are just built as normal "
"functions (because the \"prototype\" boils down to a function with the right "
"name) everything falls into place."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:276
msgid "The final piece of code we are missing, is a bit of top-level magic:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:297
msgid ""
"Basically, before codegening a function, if it is a user-defined operator, "
"we register it in the precedence table. This allows the binary operator "
"parsing logic we already have in place to handle it. Since we are working on "
"a fully-general operator precedence parser, this is all we need to do to "
"\"extend the grammar\"."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:303
msgid ""
"Now we have useful user-defined binary operators. This builds a lot on the "
"previous framework we built for other operators. Adding unary operators is a "
"bit more challenging, because we don't have any framework for it yet - lets "
"see what it takes."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:309
msgid "User-defined Unary Operators"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:311
msgid ""
"Since we don't currently support unary operators in the Kaleidoscope "
"language, we'll need to add everything to support them. Above, we added "
"simple support for the 'unary' keyword to the lexer. In addition to that, we "
"need an AST node:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:330
msgid ""
"This AST node is very simple and obvious by now. It directly mirrors the "
"binary operator AST node, except that it only has one child. With this, we "
"need to add the parsing logic. Parsing a unary operator is pretty simple: "
"we'll add a new function to do it:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:353
msgid ""
"The grammar we add is pretty straightforward here. If we see a unary "
"operator when parsing a primary operator, we eat the operator as a prefix "
"and parse the remaining piece as another unary operator. This allows us to "
"handle multiple unary operators (e.g. \"!!x\"). Note that unary operators "
"can't have ambiguous parses like binary operators can, so there is no need "
"for precedence information."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:360
msgid ""
"The problem with this function, is that we need to call ParseUnary from "
"somewhere. To do this, we change previous callers of ParsePrimary to call "
"ParseUnary instead:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:388
msgid ""
"With these two simple changes, we are now able to parse unary operators and "
"build the AST for them. Next up, we need to add parser support for "
"prototypes, to parse the unary operator prototype. We extend the binary "
"operator code above with:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:425
msgid ""
"As with binary operators, we name unary operators with a name that includes "
"the operator character. This assists us at code generation time. Speaking "
"of, the final piece we need to add is codegen support for unary operators. "
"It looks like this:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:444
msgid ""
"This code is similar to, but simpler than, the code for binary operators. It "
"is simpler primarily because it doesn't need to handle any predefined "
"operators."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:449
msgid "Kicking the Tires"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:451
msgid ""
"It is somewhat hard to believe, but with a few simple extensions we've "
"covered in the last chapters, we have grown a real-ish language. With this, "
"we can do a lot of interesting things, including I/O, math, and a bunch of "
"other things. For example, we can now add a nice sequencing operator (printd "
"is defined to print out the specified value and a newline):"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:472
msgid "We can also define a bunch of other \"primitive\" operations, such as:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:515
msgid ""
"Given the previous if/then/else support, we can also define interesting "
"functions for I/O. For example, the following prints out a character whose "
"\"density\" reflects the value passed in: the lower the value, the denser "
"the character:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:540
msgid ""
"Based on these simple primitive operations, we can start to define more "
"interesting things. For example, here's a little function that determines "
"the number of iterations it takes for a certain function in the complex "
"plane to diverge:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:561
msgid ""
"This \"``z = z2 + c``\" function is a beautiful little creature that is the "
"basis for computation of the `Mandelbrot Set <http://en.wikipedia.org/wiki/"
"Mandelbrot_set>`_. Our ``mandelconverge`` function returns the number of "
"iterations that it takes for a complex orbit to escape, saturating to 255. "
"This is not a very useful function by itself, but if you plot its value over "
"a two-dimensional plane, you can see the Mandelbrot set. Given that we are "
"limited to using putchard here, our amazing graphical output is limited, but "
"we can whip together something using the density plotter above:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:588
msgid ""
"Given this, we can try plotting out the mandelbrot set! Lets try it out:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:723
msgid ""
"At this point, you may be starting to realize that Kaleidoscope is a real "
"and powerful language. It may not be self-similar :), but it can be used to "
"plot things that are!"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:727
msgid ""
"With this, we conclude the \"adding user-defined operators\" chapter of the "
"tutorial. We have successfully augmented our language, adding the ability to "
"extend the language in the library, and we have shown how this can be used "
"to build a simple but interesting end-user application in Kaleidoscope. At "
"this point, Kaleidoscope can build a variety of applications that are "
"functional and can call functions with side-effects, but it can't actually "
"define and mutate a variable itself."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:735
msgid ""
"Strikingly, variable mutation is an important feature of some languages, and "
"it is not at all obvious how to `add support for mutable variables "
"<LangImpl07.html>`_ without having to add an \"SSA construction\" phase to "
"your front-end. In the next chapter, we will describe how you can add "
"variable mutation without building SSA in your front-end."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:742
msgid "Full Code Listing"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:744
msgid ""
"Here is the complete code listing for our running example, enhanced with the "
"support for user-defined operators. To build this example, use:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:754
msgid ""
"On some platforms, you will need to specify -rdynamic or -Wl,--export-"
"dynamic when linking. This ensures that symbols defined in the main "
"executable are exported to the dynamic linker and so are available for "
"symbol resolution at run time. This is not needed if you compile your "
"support code into a shared library, although doing that will cause problems "
"on Windows."
msgstr ""

#: ../../../tutorial/LangImpl06.rst:761
msgid "Here is the code:"
msgstr ""

#: ../../../tutorial/LangImpl06.rst:766
msgid ""
"`Next: Extending the language: mutable variables / SSA construction "
"<LangImpl07.html>`_"
msgstr ""
