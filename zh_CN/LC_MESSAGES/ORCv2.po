# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-07 18:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ORCv2.rst:3
msgid "ORC Design and Implementation"
msgstr ""

#: ../../../ORCv2.rst:9
msgid "Introduction"
msgstr ""

#: ../../../ORCv2.rst:11
msgid ""
"This document aims to provide a high-level overview of the design and "
"implementation of the ORC JIT APIs. Except where otherwise stated all "
"discussion refers to the modern ORCv2 APIs (available since LLVM 7). Clients "
"wishing to transition from OrcV1 should see Section :ref:"
"`transitioning_orcv1_to_orcv2`."
msgstr ""

#: ../../../ORCv2.rst:17
msgid "Use-cases"
msgstr ""

#: ../../../ORCv2.rst:19
msgid ""
"ORC provides a modular API for building JIT compilers. There are a number of "
"use cases for such an API. For example:"
msgstr ""

#: ../../../ORCv2.rst:22
msgid ""
"1. The LLVM tutorials use a simple ORC-based JIT class to execute "
"expressions compiled from a toy language: Kaleidoscope."
msgstr ""

#: ../../../ORCv2.rst:25
msgid ""
"2. The LLVM debugger, LLDB, uses a cross-compiling JIT for expression "
"evaluation. In this use case, cross compilation allows expressions compiled "
"in the debugger process to be executed on the debug target process, which "
"may be on a different device/architecture."
msgstr ""

#: ../../../ORCv2.rst:30
msgid ""
"3. In high-performance JITs (e.g. JVMs, Julia) that want to make use of "
"LLVM's optimizations within an existing JIT infrastructure."
msgstr ""

#: ../../../ORCv2.rst:33
msgid "In interpreters and REPLs, e.g. Cling (C++) and the Swift interpreter."
msgstr ""

#: ../../../ORCv2.rst:35
msgid ""
"By adopting a modular, library-based design we aim to make ORC useful in as "
"many of these contexts as possible."
msgstr ""

#: ../../../ORCv2.rst:39
msgid "Features"
msgstr ""

#: ../../../ORCv2.rst:41
msgid "ORC provides the following features:"
msgstr ""

#: ../../../ORCv2.rst:48
msgid "**JIT-linking**"
msgstr ""

#: ../../../ORCv2.rst:44
msgid ""
"ORC provides APIs to link relocatable object files (COFF, ELF, MachO) [1]_ "
"into a target process at runtime. The target process may be the same process "
"that contains the JIT session object and jit-linker, or may be another "
"process (even one running on a different machine or architecture) that "
"communicates with the JIT via RPC."
msgstr ""

#: ../../../ORCv2.rst:52
msgid "**LLVM IR compilation**"
msgstr ""

#: ../../../ORCv2.rst:51
msgid ""
"ORC provides off the shelf components (IRCompileLayer, SimpleCompiler, "
"ConcurrentIRCompiler) that make it easy to add LLVM IR to a JIT'd process."
msgstr ""

#: ../../../ORCv2.rst:59
msgid "**Eager and lazy compilation**"
msgstr ""

#: ../../../ORCv2.rst:55
msgid ""
"By default, ORC will compile symbols as soon as they are looked up in the "
"JIT session object (``ExecutionSession``). Compiling eagerly by default "
"makes it easy to use ORC as an in-memory compiler for an existing JIT "
"(similar to how MCJIT is commonly used). However ORC also provides built-in "
"support for lazy compilation via lazy-reexports (see :ref:`Laziness`)."
msgstr ""

#: ../../../ORCv2.rst:66
msgid "**Support for Custom Compilers and Program Representations**"
msgstr ""

#: ../../../ORCv2.rst:62
msgid ""
"Clients can supply custom compilers for each symbol that they define in "
"their JIT session. ORC will run the user-supplied compiler when the a "
"definition of a symbol is needed. ORC is actually fully language agnostic: "
"LLVM IR is not treated specially, and is supported via the same wrapper "
"mechanism (the ``MaterializationUnit`` class) that is used for custom "
"compilers."
msgstr ""

#: ../../../ORCv2.rst:74
msgid "**Concurrent JIT'd code** and **Concurrent Compilation**"
msgstr ""

#: ../../../ORCv2.rst:69
msgid ""
"JIT'd code may be executed in multiple threads, may spawn new threads, and "
"may re-enter the ORC (e.g. to request lazy compilation) concurrently from "
"multiple threads. Compilers launched my ORC can run concurrently (provided "
"the client sets up an appropriate dispatcher). Built-in dependency tracking "
"ensures that ORC does not release pointers to JIT'd code or data until all "
"dependencies have also been JIT'd and they are safe to call or use."
msgstr ""

#: ../../../ORCv2.rst:77
msgid "**Removable Code**"
msgstr ""

#: ../../../ORCv2.rst:77
msgid "Resources for JIT'd program representations"
msgstr ""

#: ../../../ORCv2.rst:82
msgid "**Orthogonality** and **Composability**"
msgstr ""

#: ../../../ORCv2.rst:80
msgid ""
"Each of the features above can be used independently. It is possible to put "
"ORC components together to make a non-lazy, in-process, single threaded JIT "
"or a lazy, out-of-process, concurrent JIT, or anything in between."
msgstr ""

#: ../../../ORCv2.rst:85
msgid "LLJIT and LLLazyJIT"
msgstr ""

#: ../../../ORCv2.rst:87
msgid ""
"ORC provides two basic JIT classes off-the-shelf. These are useful both as "
"examples of how to assemble ORC components to make a JIT, and as "
"replacements for earlier LLVM JIT APIs (e.g. MCJIT)."
msgstr ""

#: ../../../ORCv2.rst:91
msgid ""
"The LLJIT class uses an IRCompileLayer and RTDyldObjectLinkingLayer to "
"support compilation of LLVM IR and linking of relocatable object files. All "
"operations are performed eagerly on symbol lookup (i.e. a symbol's "
"definition is compiled as soon as you attempt to look up its address). LLJIT "
"is a suitable replacement for MCJIT in most cases (note: some more advanced "
"features, e.g. JITEventListeners are not supported yet)."
msgstr ""

#: ../../../ORCv2.rst:98
msgid ""
"The LLLazyJIT extends LLJIT and adds a CompileOnDemandLayer to enable lazy "
"compilation of LLVM IR. When an LLVM IR module is added via the "
"addLazyIRModule method, function bodies in that module will not be compiled "
"until they are first called. LLLazyJIT aims to provide a replacement of "
"LLVM's original (pre-MCJIT) JIT API."
msgstr ""

#: ../../../ORCv2.rst:104
msgid ""
"LLJIT and LLLazyJIT instances can be created using their respective builder "
"classes: LLJITBuilder and LLazyJITBuilder. For example, assuming you have a "
"module ``M`` loaded on a ThreadSafeContext ``Ctx``:"
msgstr ""

#: ../../../ORCv2.rst:132
msgid ""
"The builder classes provide a number of configuration options that can be "
"specified before the JIT instance is constructed. For example:"
msgstr ""

#: ../../../ORCv2.rst:155
msgid ""
"For users wanting to get started with LLJIT a minimal example program can be "
"found at ``llvm/examples/HowToUseLLJIT``."
msgstr ""

#: ../../../ORCv2.rst:159
msgid "Design Overview"
msgstr ""

#: ../../../ORCv2.rst:161
msgid ""
"ORC's JIT program model aims to emulate the linking and symbol resolution "
"rules used by the static and dynamic linkers. This allows ORC to JIT "
"arbitrary LLVM IR, including IR produced by an ordinary static compiler (e."
"g. clang) that uses constructs like symbol linkage and visibility, and weak "
"[3]_ and common symbol definitions."
msgstr ""

#: ../../../ORCv2.rst:167
msgid ""
"To see how this works, imagine a program ``foo`` which links against a pair "
"of dynamic libraries: ``libA`` and ``libB``. On the command line, building "
"this program might look like:"
msgstr ""

#: ../../../ORCv2.rst:178
msgid ""
"In ORC, this would translate into API calls on a hypothetical "
"CXXCompilingLayer (with error checking omitted for brevity) as:"
msgstr ""

#: ../../../ORCv2.rst:211
msgid ""
"This example tells us nothing about *how* or *when* compilation will happen. "
"That will depend on the implementation of the hypothetical "
"CXXCompilingLayer. The same linker-based symbol resolution rules will apply "
"regardless of that implementation, however. For example, if a1.cpp and a2."
"cpp both define a function \"foo\" then ORCv2 will generate a duplicate "
"definition error. On the other hand, if a1.cpp and b1.cpp both define "
"\"foo\" there is no error (different dynamic libraries may define the same "
"symbol). If main.cpp refers to \"foo\", it should bind to the definition in "
"LibA rather than the one in LibB, since main.cpp is part of the \"main\" "
"dylib, and the main dylib links against LibA before LibB."
msgstr ""

#: ../../../ORCv2.rst:222
msgid ""
"Many JIT clients will have no need for this strict adherence to the usual "
"ahead-of-time linking rules, and should be able to get by just fine by "
"putting all of their code in a single JITDylib. However, clients who want to "
"JIT code for languages/projects that traditionally rely on ahead-of-time "
"linking (e.g. C++) will find that this feature makes life much easier."
msgstr ""

#: ../../../ORCv2.rst:228
msgid ""
"Symbol lookup in ORC serves two other important functions, beyond providing "
"addresses for symbols: (1) It triggers compilation of the symbol(s) searched "
"for (if they have not been compiled already), and (2) it provides the "
"synchronization mechanism for concurrent compilation. The pseudo-code for "
"the lookup process is:"
msgstr ""

#: ../../../ORCv2.rst:242
msgid ""
"In this context a materializer is something that provides a working "
"definition of a symbol upon request. Usually materializers are just wrappers "
"for compilers, but they may also wrap a jit-linker directly (if the program "
"representation backing the definitions is an object file), or may even be a "
"class that writes bits directly into memory (for example, if the definitions "
"are stubs). Materialization is the blanket term for any actions (compiling, "
"linking, splatting bits, registering with runtimes, etc.) that are required "
"to generate a symbol definition that is safe to call or access."
msgstr ""

#: ../../../ORCv2.rst:251
msgid ""
"As each materializer completes its work it notifies the JITDylib, which in "
"turn notifies any query objects that are waiting on the newly materialized "
"definitions. Each query object maintains a count of the number of symbols "
"that it is still waiting on, and once this count reaches zero the query "
"object calls the query handler with a *SymbolMap* (a map of symbol names to "
"addresses) describing the result. If any symbol fails to materialize the "
"query immediately calls the query handler with an error."
msgstr ""

#: ../../../ORCv2.rst:259
msgid ""
"The collected materialization units are sent to the ExecutionSession to be "
"dispatched, and the dispatch behavior can be set by the client. By default "
"each materializer is run on the calling thread. Clients are free to create "
"new threads to run materializers, or to send the work to a work queue for a "
"thread pool (this is what LLJIT/LLLazyJIT do)."
msgstr ""

#: ../../../ORCv2.rst:266
msgid "Top Level APIs"
msgstr ""

#: ../../../ORCv2.rst:268
msgid "Many of ORC's top-level APIs are visible in the example above:"
msgstr ""

#: ../../../ORCv2.rst:270
msgid ""
"*ExecutionSession* represents the JIT'd program and provides context for the "
"JIT: It contains the JITDylibs, error reporting mechanisms, and dispatches "
"the materializers."
msgstr ""

#: ../../../ORCv2.rst:274
msgid "*JITDylibs* provide the symbol tables."
msgstr ""

#: ../../../ORCv2.rst:276
msgid ""
"*Layers* (ObjLinkingLayer and CXXLayer) are wrappers around compilers and "
"allow clients to add uncompiled program representations supported by those "
"compilers to JITDylibs."
msgstr ""

#: ../../../ORCv2.rst:280
msgid ""
"Several other important APIs are used explicitly. JIT clients need not be "
"aware of them, but Layer authors will use them:"
msgstr ""

#: ../../../ORCv2.rst:283
msgid ""
"*MaterializationUnit* - When XXXLayer::add is invoked it wraps the given "
"program representation (in this example, C++ source) in a "
"MaterializationUnit, which is then stored in the JITDylib. "
"MaterializationUnits are responsible for describing the definitions they "
"provide, and for unwrapping the program representation and passing it back "
"to the layer when compilation is required (this ownership shuffle makes "
"writing thread-safe layers easier, since the ownership of the program "
"representation will be passed back on the stack, rather than having to be "
"fished out of a Layer member, which would require synchronization)."
msgstr ""

#: ../../../ORCv2.rst:293
msgid ""
"*MaterializationResponsibility* - When a MaterializationUnit hands a program "
"representation back to the layer it comes with an associated "
"MaterializationResponsibility object. This object tracks the definitions "
"that must be materialized and provides a way to notify the JITDylib once "
"they are either successfully materialized or a failure occurs."
msgstr ""

#: ../../../ORCv2.rst:300
msgid "Absolute Symbols, Aliases, and Reexports"
msgstr ""

#: ../../../ORCv2.rst:302
msgid ""
"ORC makes it easy to define symbols with absolute addresses, or symbols that "
"are simply aliases of other symbols:"
msgstr ""

#: ../../../ORCv2.rst:306
msgid "Absolute Symbols"
msgstr ""

#: ../../../ORCv2.rst:308
msgid ""
"Absolute symbols are symbols that map directly to addresses without "
"requiring further materialization, for example: \"foo\" = 0x1234. One use "
"case for absolute symbols is allowing resolution of process symbols. E.g."
msgstr ""

#: ../../../ORCv2.rst:320
msgid ""
"With this mapping established code added to the JIT can refer to printf "
"symbolically rather than requiring the address of printf to be \"baked in\". "
"This in turn allows cached versions of the JIT'd code (e.g. compiled "
"objects) to be re-used across JIT sessions as the JIT'd code no longer "
"changes, only the absolute symbol definition does."
msgstr ""

#: ../../../ORCv2.rst:326
msgid ""
"For process and library symbols the DynamicLibrarySearchGenerator utility "
"(See :ref:`How to Add Process and Library Symbols to JITDylibs "
"<ProcessAndLibrarySymbols>`) can be used to automatically build absolute "
"symbol mappings for you. However the absoluteSymbols function is still "
"useful for making non-global objects in your JIT visible to JIT'd code. For "
"example, imagine that your JIT standard library needs access to your JIT "
"object to make some calls. We could bake the address of your object into the "
"library, but then it would need to be recompiled for each session:"
msgstr ""

#: ../../../ORCv2.rst:346
msgid "We can turn this into a symbolic reference in the JIT standard library:"
msgstr ""

#: ../../../ORCv2.rst:354
msgid ""
"And then make our JIT object visible to the JIT standard library with an "
"absolute symbol definition when the JIT is started:"
msgstr ""

#: ../../../ORCv2.rst:369
msgid "Aliases and Reexports"
msgstr ""

#: ../../../ORCv2.rst:371
msgid ""
"Aliases and reexports allow you to define new symbols that map to existing "
"symbols. This can be useful for changing linkage relationships between "
"symbols across sessions without having to recompile code. For example, "
"imagine that JIT'd code has access to a log function, ``void log(const "
"char*)`` for which there are two implementations in the JIT standard "
"library: ``log_fast`` and ``log_detailed``. Your JIT can choose which one of "
"these definitions will be used when the ``log`` symbol is referenced by "
"setting up an alias at JIT startup time:"
msgstr ""

#: ../../../ORCv2.rst:394
msgid ""
"The ``symbolAliases`` function allows you to define aliases within a single "
"JITDylib. The ``reexports`` function provides the same functionality, but "
"operates across JITDylib boundaries. E.g."
msgstr ""

#: ../../../ORCv2.rst:409
msgid ""
"The reexports utility can be handy for composing a single JITDylib interface "
"by re-exporting symbols from several other JITDylibs."
msgstr ""

#: ../../../ORCv2.rst:415
msgid "Laziness"
msgstr ""

#: ../../../ORCv2.rst:417
msgid ""
"Laziness in ORC is provided by a utility called \"lazy reexports\". A lazy "
"reexport is similar to a regular reexport or alias: It provides a new name "
"for an existing symbol. Unlike regular reexports however, lookups of lazy "
"reexports do not trigger immediate materialization of the reexported symbol. "
"Instead, they only trigger materialization of a function stub. This function "
"stub is initialized to point at a *lazy call-through*, which provides "
"reentry into the JIT. If the stub is called at runtime then the lazy call-"
"through will look up the reexported symbol (triggering materialization for "
"it if necessary), update the stub (to call directly to the reexported symbol "
"on subsequent calls), and then return via the reexported symbol. By re-using "
"the existing symbol lookup mechanism, lazy reexports inherit the same "
"concurrency guarantees: calls to lazy reexports can be made from multiple "
"threads concurrently, and the reexported symbol can be any state of "
"compilation (uncompiled, already in the process of being compiled, or "
"already compiled) and the call will succeed. This allows laziness to be "
"safely mixed with features like remote compilation, concurrent compilation, "
"concurrent JIT'd code, and speculative compilation."
msgstr ""

#: ../../../ORCv2.rst:434
msgid ""
"There is one other key difference between regular reexports and lazy "
"reexports that some clients must be aware of: The address of a lazy reexport "
"will be *different* from the address of the reexported symbol (whereas a "
"regular reexport is guaranteed to have the same address as the reexported "
"symbol). Clients who care about pointer equality will generally want to use "
"the address of the reexport as the canonical address of the reexported "
"symbol. This will allow the address to be taken without forcing "
"materialization of the reexport."
msgstr ""

#: ../../../ORCv2.rst:442
msgid "Usage example:"
msgstr ""

#: ../../../ORCv2.rst:444
msgid ""
"If JITDylib ``JD`` contains definitions for symbols ``foo_body`` and "
"``bar_body``, we can create lazy entry points ``Foo`` and ``Bar`` in "
"JITDylib ``JD2`` by calling:"
msgstr ""

#: ../../../ORCv2.rst:458
msgid ""
"A full example of how to use lazyReexports with the LLJIT class can be found "
"at ``llvm_project/llvm/examples/LLJITExamples/LLJITWithLazyReexports``."
msgstr ""

#: ../../../ORCv2.rst:462
msgid "Supporting Custom Compilers"
msgstr ""

#: ../../../ORCv2.rst:464
msgid "TBD."
msgstr ""

#: ../../../ORCv2.rst:469
msgid "Transitioning from ORCv1 to ORCv2"
msgstr ""

#: ../../../ORCv2.rst:471
msgid ""
"Since LLVM 7.0, new ORC development work has focused on adding support for "
"concurrent JIT compilation. The new APIs (including new layer interfaces and "
"implementations, and new utilities) that support concurrency are "
"collectively referred to as ORCv2, and the original, non-concurrent layers "
"and utilities are now referred to as ORCv1."
msgstr ""

#: ../../../ORCv2.rst:477
msgid ""
"The majority of the ORCv1 layers and utilities were renamed with a 'Legacy' "
"prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In "
"LLVM 12.0 ORCv1 will be removed entirely."
msgstr ""

#: ../../../ORCv2.rst:481
msgid ""
"Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of "
"the ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be "
"directly substituted. However there are some design differences between "
"ORCv1 and ORCv2 to be aware of:"
msgstr ""

#: ../../../ORCv2.rst:486
msgid ""
"ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules "
"(and other program representations, e.g. Object Files)  are no longer added "
"directly to JIT classes or layers. Instead, they are added to ``JITDylib`` "
"instances *by* layers. The ``JITDylib`` determines *where* the definitions "
"reside, the layers determine *how* the definitions will be compiled. Linkage "
"relationships between ``JITDylibs`` determine how inter-module references "
"are resolved, and symbol resolvers are no longer used. See the section "
"`Design Overview`_ for more details."
msgstr ""

#: ../../../ORCv2.rst:495
msgid ""
"Unless multiple JITDylibs are needed to model linkage relationships, ORCv1 "
"clients should place all code in a single JITDylib. MCJIT clients should use "
"LLJIT (see `LLJIT and LLLazyJIT`_), and can place code in LLJIT's default "
"created main JITDylib (See ``LLJIT::getMainJITDylib()``)."
msgstr ""

#: ../../../ORCv2.rst:501
msgid ""
"All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession "
"manages the string pool, error reporting, synchronization, and symbol lookup."
msgstr ""

#: ../../../ORCv2.rst:505
msgid ""
"ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than "
"string values in order to reduce memory overhead and improve lookup "
"performance. See the subsection `How to manage symbol strings`_."
msgstr ""

#: ../../../ORCv2.rst:509
msgid ""
"IR layers require ThreadSafeModule instances, rather than std::"
"unique_ptr<Module>s. ThreadSafeModule is a wrapper that ensures that Modules "
"that use the same LLVMContext are not accessed concurrently. See `How to use "
"ThreadSafeModule and ThreadSafeContext`_."
msgstr ""

#: ../../../ORCv2.rst:514
msgid ""
"Symbol lookup is no longer handled by layers. Instead, there is a ``lookup`` "
"method on JITDylib that takes a list of JITDylibs to scan."
msgstr ""

#: ../../../ORCv2.rst:525
msgid ""
"Module removal is not yet supported. There is no equivalent of the layer "
"concept removeModule/removeObject methods. Work on resource tracking and "
"removal in ORCv2 is ongoing."
msgstr ""

#: ../../../ORCv2.rst:529
msgid ""
"For code examples and suggestions of how to use the ORCv2 APIs, please see "
"the section `How-tos`_."
msgstr ""

#: ../../../ORCv2.rst:533
msgid "How-tos"
msgstr ""

#: ../../../ORCv2.rst:536
msgid "How to manage symbol strings"
msgstr ""

#: ../../../ORCv2.rst:538
msgid ""
"Symbol strings in ORC are uniqued to improve lookup performance, reduce "
"memory overhead, and allow symbol names to function as efficient keys. To "
"get the unique ``SymbolStringPtr`` for a string value, call the "
"``ExecutionSession::intern`` method:"
msgstr ""

#: ../../../ORCv2.rst:549
msgid ""
"If you wish to perform lookup using the C/IR name of a symbol you will also "
"need to apply the platform linker-mangling before interning the string. On "
"Linux this mangling is a no-op, but on other platforms it usually involves "
"adding a prefix to the string (e.g. '_' on Darwin). The mangling scheme is "
"based on the DataLayout for the target. Given a DataLayout and an "
"ExecutionSession, you can create a MangleAndInterner function object that "
"will perform both jobs for you:"
msgstr ""

#: ../../../ORCv2.rst:569
msgid "How to create JITDylibs and set up linkage relationships"
msgstr ""

#: ../../../ORCv2.rst:571
msgid ""
"In ORC, all symbol definitions reside in JITDylibs. JITDylibs are created by "
"calling the ``ExecutionSession::createJITDylib`` method with a unique name:"
msgstr ""

#: ../../../ORCv2.rst:579
msgid ""
"The JITDylib is owned by the ``ExecutionEngine`` instance and will be freed "
"when it is destroyed."
msgstr ""

#: ../../../ORCv2.rst:583
msgid "How to remove a JITDylib"
msgstr ""

#: ../../../ORCv2.rst:584
msgid ""
"JITDylibs can be removed completely by calling  ``ExecutionSession::"
"removeJITDylib``. Calling that function will close the give JITDylib and "
"clear all the resources held for it. No code can be added to a closed "
"JITDylib."
msgstr ""

#: ../../../ORCv2.rst:588
msgid ""
"Please note that closing a JITDylib won't update any pointers, you are "
"responsible for ensuring that any code/data contained in the JITDylib is no "
"longer in use."
msgstr ""

#: ../../../ORCv2.rst:591
msgid ""
"Also You can use a custom resource tracker to remove individual modules from "
"a JITDylib."
msgstr ""

#: ../../../ORCv2.rst:594
msgid "How to add the support for custom program representation"
msgstr ""

#: ../../../ORCv2.rst:595
msgid ""
"In order to add the support for a custom program representation, a custom "
"``MaterializationUnit`` for the program representation, and a custom "
"``Layer`` are needed. The Layer will have two operations: ``add`` and "
"``emit``. The ``add`` operation takes an instance of your program "
"representation, builds one of your custom ``MaterializationUnits`` to hold "
"it, then adds it to a ``JITDylib``. The emit operation takes a "
"``MaterializationResponsibility`` object and an instance of your program "
"representation and materializes it, usually by compiling it and handing the "
"resulting object off to an ``ObjectLinkingLayer``."
msgstr ""

#: ../../../ORCv2.rst:603
msgid ""
"Your custom ``MaterializationUnit`` will have two operations: "
"``materialize`` and ``discard``. The ``materialize`` function will be called "
"for you when any symbol provided by the unit is looked up, and it should "
"just call the ``emit`` function on your layer, passing in the given "
"``MaterializationResponsibility`` and the wrapped program representation. "
"The ``discard`` function will be called if some weak symbol provided by your "
"unit is not needed (because the JIT found an overriding definition). You can "
"use this to drop your definition early, or just ignore it and let the linker "
"drops the definition later."
msgstr ""

#: ../../../ORCv2.rst:611
msgid "Here is an example of an ASTLayer:"
msgstr ""

#: ../../../ORCv2.rst:672
msgid ""
"Take look at the source code of `Building A JIT's Chapter 4 <tutorial/"
"BuildingAJIT4.html>`_ for a complete example."
msgstr ""

#: ../../../ORCv2.rst:675
msgid "How to use ThreadSafeModule and ThreadSafeContext"
msgstr ""

#: ../../../ORCv2.rst:677
msgid ""
"ThreadSafeModule and ThreadSafeContext are wrappers around Modules and "
"LLVMContexts respectively. A ThreadSafeModule is a pair of a std::"
"unique_ptr<Module> and a (possibly shared) ThreadSafeContext value. A "
"ThreadSafeContext is a pair of a std::unique_ptr<LLVMContext> and a lock. "
"This design serves two purposes: providing a locking scheme and lifetime "
"management for LLVMContexts. The ThreadSafeContext may be locked to prevent "
"accidental concurrent access by two Modules that use the same LLVMContext. "
"The underlying LLVMContext is freed once all ThreadSafeContext values "
"pointing to it are destroyed, allowing the context memory to be reclaimed as "
"soon as the Modules referring to it are destroyed."
msgstr ""

#: ../../../ORCv2.rst:688
msgid ""
"ThreadSafeContexts can be explicitly constructed from a std::"
"unique_ptr<LLVMContext>:"
msgstr ""

#: ../../../ORCv2.rst:695
msgid ""
"ThreadSafeModules can be constructed from a pair of a std::"
"unique_ptr<Module> and a ThreadSafeContext value. ThreadSafeContext values "
"may be shared between multiple ThreadSafeModules:"
msgstr ""

#: ../../../ORCv2.rst:707
msgid ""
"Before using a ThreadSafeContext, clients should ensure that either the "
"context is only accessible on the current thread, or that the context is "
"locked. In the example above (where the context is never locked) we rely on "
"the fact that both ``TSM1`` and ``TSM2``, and TSCtx are all created on one "
"thread. If a context is going to be shared between threads then it must be "
"locked before any accessing or creating any Modules attached to it. E.g."
msgstr ""

#: ../../../ORCv2.rst:732
msgid ""
"To make exclusive access to Modules easier to manage the ThreadSafeModule "
"class provides a convenience function, ``withModuleDo``, that implicitly (1) "
"locks the associated context, (2) runs a given function object, (3) unlocks "
"the context, and (3) returns the result generated by the function object. E."
"g."
msgstr ""

#: ../../../ORCv2.rst:749
msgid ""
"Clients wishing to maximize possibilities for concurrent compilation will "
"want to create every new ThreadSafeModule on a new ThreadSafeContext. For "
"this reason a convenience constructor for ThreadSafeModule is provided that "
"implicitly constructs a new ThreadSafeContext value from a std::"
"unique_ptr<LLVMContext>:"
msgstr ""

#: ../../../ORCv2.rst:764
msgid ""
"Clients who plan to run single-threaded may choose to save memory by loading "
"all modules on the same context:"
msgstr ""

#: ../../../ORCv2.rst:779
msgid "How to Add Process and Library Symbols to the JITDylibs"
msgstr ""

#: ../../../ORCv2.rst:781
msgid ""
"JIT'd code typically needs access to symbols in the host program or in "
"supporting libraries. References to process symbols can be \"baked in\" to "
"code as it is compiled by turning external references into pre-resolved "
"integer constants, however this ties the JIT'd code to the current process's "
"virtual memory layout (meaning that it can not be cached between runs) and "
"makes debugging lower level program representations difficult (as all "
"external references are opaque integer values). A bettor solution is to "
"maintain symbolic external references and let the jit-linker bind them for "
"you at runtime. To allow the JIT linker to find these external definitions "
"their addresses must be added to a JITDylib that the JIT'd definitions link "
"against."
msgstr ""

#: ../../../ORCv2.rst:792
msgid ""
"Adding definitions for external symbols could be done using the "
"absoluteSymbols function:"
msgstr ""

#: ../../../ORCv2.rst:808
msgid ""
"Manually adding absolute symbols for a large or changing interface is "
"cumbersome however, so ORC provides an alternative to generate new "
"definitions on demand: *definition generators*. If a definition generator is "
"attached to a JITDylib, then any unsuccessful lookup on that JITDylib will "
"fall back to calling the definition generator, and the definition generator "
"may choose to generate a new definition for the missing symbols. Of "
"particular use here is the ``DynamicLibrarySearchGenerator`` utility. This "
"can be used to reflect the whole exported symbol set of the process or a "
"specific dynamic library, or a subset of either of these determined by a "
"predicate."
msgstr ""

#: ../../../ORCv2.rst:818
msgid "For example, to load the whole interface of a runtime library:"
msgstr ""

#: ../../../ORCv2.rst:835
msgid "Or, to expose an allowed set of symbols from the main process:"
msgstr ""

#: ../../../ORCv2.rst:860
msgid "Roadmap"
msgstr ""

#: ../../../ORCv2.rst:862
msgid ""
"ORC is still undergoing active development. Some current and future works "
"are listed below."
msgstr ""

#: ../../../ORCv2.rst:866
msgid "Current Work"
msgstr ""

#: ../../../ORCv2.rst:868
msgid ""
"**TargetProcessControl: Improvements to in-tree support for out-of-process "
"execution**"
msgstr ""

#: ../../../ORCv2.rst:871
msgid ""
"The ``TargetProcessControl`` API provides various operations on the JIT "
"target process (the one which will execute the JIT'd code), including memory "
"allocation, memory writes, function execution, and process queries (e.g. for "
"the target triple). By targeting this API new components can be developed "
"which will work equally well for in-process and out-of-process JITing."
msgstr ""

#: ../../../ORCv2.rst:879
msgid "**ORC RPC based TargetProcessControl implementation**"
msgstr ""

#: ../../../ORCv2.rst:881
msgid ""
"An ORC RPC based implementation of the ``TargetProcessControl`` API is "
"currently under development to enable easy out-of-process JITing via file "
"descriptors / sockets."
msgstr ""

#: ../../../ORCv2.rst:885
msgid "**Core State Machine Cleanup**"
msgstr ""

#: ../../../ORCv2.rst:887
msgid ""
"The core ORC state machine is currently implemented between JITDylib and "
"ExecutionSession. Methods are slowly being moved to `ExecutionSession`. This "
"will tidy up the code base, and also allow us to support asynchronous "
"removal of JITDylibs (in practice deleting an associated state object in "
"ExecutionSession and leaving the JITDylib instance in a defunct state until "
"all references to it have been released)."
msgstr ""

#: ../../../ORCv2.rst:895
msgid "Near Future Work"
msgstr ""

#: ../../../ORCv2.rst:897
msgid "**ORC JIT Runtime Libraries**"
msgstr ""

#: ../../../ORCv2.rst:899
msgid ""
"We need a runtime library for JIT'd code. This would include things like TLS "
"registration, reentry functions, registration code for language runtimes (e."
"g. Objective C and Swift) and other JIT specific runtime code. This should "
"be built in a similar manner to compiler-rt (possibly even as part of it)."
msgstr ""

#: ../../../ORCv2.rst:904
msgid "**Remote jit_dlopen / jit_dlclose**"
msgstr ""

#: ../../../ORCv2.rst:906
msgid ""
"To more fully mimic the environment that static programs operate in we would "
"like JIT'd code to be able to \"dlopen\" and \"dlclose\" JITDylibs, running "
"all of their initializers/deinitializers on the current thread. This would "
"require support from the runtime library described above."
msgstr ""

#: ../../../ORCv2.rst:911
msgid "**Debugging support**"
msgstr ""

#: ../../../ORCv2.rst:913
msgid ""
"ORC currently supports the GDBRegistrationListener API when using "
"RuntimeDyld as the underlying JIT linker. We will need a new solution for "
"JITLink based platforms."
msgstr ""

#: ../../../ORCv2.rst:918
msgid "Further Future Work"
msgstr ""

#: ../../../ORCv2.rst:920
msgid "**Speculative Compilation**"
msgstr ""

#: ../../../ORCv2.rst:922
msgid ""
"ORC's support for concurrent compilation allows us to easily enable "
"*speculative* JIT compilation: compilation of code that is not needed yet, "
"but which we have reason to believe will be needed in the future. This can "
"be used to hide compile latency and improve JIT throughput. A proof-of-"
"concept example of speculative compilation with ORC has already been "
"developed (see ``llvm/examples/SpeculativeJIT``). Future work on this is "
"likely to focus on re-using and improving existing profiling support "
"(currently used by PGO) to feed speculation decisions, as well as built-in "
"tools to simplify use of speculative compilation."
msgstr ""

#: ../../../ORCv2.rst:932
msgid ""
"Formats/architectures vary in terms of supported features. MachO and ELF "
"tend to have better support than COFF. Patches very welcome!"
msgstr ""

#: ../../../ORCv2.rst:935
msgid ""
"The ``LazyEmittingLayer``, ``RemoteObjectClientLayer`` and "
"``RemoteObjectServerLayer`` do not have counterparts in the new system. In "
"the case of ``LazyEmittingLayer`` it was simply no longer needed: in ORCv2, "
"deferring compilation until symbols are looked up is the default. The "
"removal of ``RemoteObjectClientLayer`` and ``RemoteObjectServerLayer`` means "
"that JIT stacks can no longer be split across processes, however this "
"functionality appears not to have been used."
msgstr ""

#: ../../../ORCv2.rst:944
msgid ""
"Weak definitions are currently handled correctly within dylibs, but if "
"multiple dylibs provide a weak definition of a symbol then each will end up "
"with its own definition (similar to how weak definitions are handled in "
"Windows DLLs). This will be fixed in the future."
msgstr ""
