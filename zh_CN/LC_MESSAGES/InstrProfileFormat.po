# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2025, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../InstrProfileFormat.rst:3
msgid "Instrumentation Profile Format"
msgstr ""

#: ../../../InstrProfileFormat.rst:10
msgid "Overview"
msgstr ""

#: ../../../InstrProfileFormat.rst:12
msgid ""
"Clang supports two types of profiling via instrumentation [1]_: frontend-"
"based and IR-based, and both could support a variety of use cases [2]_ . "
"This document describes two binary serialization formats (raw and indexed) "
"to store instrumented profiles with a specific emphasis on IRPGO use case, "
"in the sense that when specific header fields and payload sections have "
"different ways of interpretation across use cases, the documentation is "
"based on IRPGO."
msgstr ""

#: ../../../InstrProfileFormat.rst:20
msgid ""
"Frontend-generated profiles are used together with coverage mapping for "
"`source-based code coverage`_. The `coverage mapping format`_ is different "
"from profile format."
msgstr ""

#: ../../../InstrProfileFormat.rst:28
msgid "Raw Profile Format"
msgstr ""

#: ../../../InstrProfileFormat.rst:30
msgid ""
"The raw profile is generated by running the instrumented binary. The raw "
"profile data from an executable or a shared library [3]_ consists of a "
"header and multiple sections, with each section as a memory dump. The raw "
"profile data needs to be reasonably compact and fast to generate."
msgstr ""

#: ../../../InstrProfileFormat.rst:35
msgid ""
"There are no backward or forward version compatibility guarantees for the "
"raw profile format. That is, compilers and tools `require`_ a specific raw "
"profile version to parse the profiles."
msgstr ""

#: ../../../InstrProfileFormat.rst:41
msgid ""
"To feed profiles back into compilers for an optimized build (e.g., via ``-"
"fprofile-use`` for IR instrumentation), a raw profile must to be converted "
"into indexed format."
msgstr ""

#: ../../../InstrProfileFormat.rst:46 ../../../InstrProfileFormat.rst:401
msgid "General Storage Layout"
msgstr ""

#: ../../../InstrProfileFormat.rst:48
msgid ""
"The storage layout of raw profile data format is illustrated below. "
"Basically, when the raw profile is read into an memory buffer, the actual "
"byte offset of a section is inferred from the section's order in the layout "
"and size information of all the sections ahead of it."
msgstr ""

#: ../../../InstrProfileFormat.rst:82
msgid ""
"Sections might be padded to meet specific alignment requirements. For "
"simplicity, header fields and data sections solely for padding purpose are "
"omitted in the data layout graph above and the rest of this document."
msgstr ""

#: ../../../InstrProfileFormat.rst:87 ../../../InstrProfileFormat.rst:444
msgid "Header"
msgstr ""

#: ../../../InstrProfileFormat.rst:97
msgid "``Magic``"
msgstr ""

#: ../../../InstrProfileFormat.rst:90
msgid ""
"Magic number encodes profile format (raw, indexed or text). For the raw "
"format, the magic number also encodes the endianness (big or little) and C "
"pointer size (4 or 8 bytes) of the platform on which the profile is "
"generated."
msgstr ""

#: ../../../InstrProfileFormat.rst:94
msgid ""
"A factory method reads the magic number to construct reader properly and "
"returns error upon unrecognized format. Specifically, the factory method and "
"raw profile reader implementation make sure that a raw profile file could be "
"read back on a platform with the opposite endianness and/or the other C "
"pointer size."
msgstr ""

#: ../../../InstrProfileFormat.rst:102
msgid "``Version``"
msgstr ""

#: ../../../InstrProfileFormat.rst:100
msgid ""
"The lower 32 bits specify the actual version and the most significant 32 "
"bits specify the variant types of the profile. IR-based instrumentation PGO "
"and context-sensitive IR-based instrumentation PGO are two variant types."
msgstr ""

#: ../../../InstrProfileFormat.rst:105
msgid "``BinaryIdsSize``"
msgstr ""

#: ../../../InstrProfileFormat.rst:105
msgid "The byte size of `binary id`_ section."
msgstr ""

#: ../../../InstrProfileFormat.rst:109
msgid "``NumData``"
msgstr ""

#: ../../../InstrProfileFormat.rst:108
msgid ""
"The number of profile metadata. The byte size of `profile metadata`_ section "
"could be computed with this field."
msgstr ""

#: ../../../InstrProfileFormat.rst:113
msgid "``NumCounter``"
msgstr ""

#: ../../../InstrProfileFormat.rst:112
msgid ""
"The number of entries in the profile counter section. The byte size of "
"`counter`_ section could be computed with this field."
msgstr ""

#: ../../../InstrProfileFormat.rst:116 ../../../InstrProfileFormat.rst:251
msgid "``NumBitmapBytes``"
msgstr ""

#: ../../../InstrProfileFormat.rst:116
msgid "The number of bytes in the profile `bitmap`_ section."
msgstr ""

#: ../../../InstrProfileFormat.rst:119
msgid "``NamesSize``"
msgstr ""

#: ../../../InstrProfileFormat.rst:119
msgid "The number of bytes in the name section."
msgstr ""

#: ../../../InstrProfileFormat.rst:136
msgid "``CountersDelta``"
msgstr ""

#: ../../../InstrProfileFormat.rst:124
msgid ""
"This field records the in-memory address difference between the `profile "
"metadata`_ and counter section in the instrumented binary, i.e., "
"``start(__llvm_prf_cnts) - start(__llvm_prf_data)``."
msgstr ""

#: ../../../InstrProfileFormat.rst:127
msgid ""
"It's used jointly with the `CounterPtr`_ field to compute the counter offset "
"relative to ``start(__llvm_prf_cnts)``. Check out calculation-of-counter-"
"offset_ for a visualized explanation."
msgstr ""

#: ../../../InstrProfileFormat.rst:132
msgid ""
"The ``__llvm_prf_data`` object file section might not be loaded into memory "
"when instrumented binary runs or might not get generated in the instrumented "
"binary in the first place. In those cases, ``CountersDelta`` is not used and "
"other mechanisms are used to match counters with instrumented code. See "
"`lightweight instrumentation`_ and `binary profile correlation`_ for "
"examples."
msgstr ""

#: ../../../InstrProfileFormat.rst:147
msgid "``BitmapDelta``"
msgstr ""

#: ../../../InstrProfileFormat.rst:139
msgid ""
"This field records the in-memory address difference between the `profile "
"metadata`_ and bitmap section in the instrumented binary, i.e., "
"``start(__llvm_prf_bits) - start(__llvm_prf_data)``."
msgstr ""

#: ../../../InstrProfileFormat.rst:142
msgid ""
"It's used jointly with the `BitmapPtr`_ to find the bitmap of a profile data "
"record, in a similar way to how counters are referenced as explained by "
"calculation-of-counter-offset_ ."
msgstr ""

#: ../../../InstrProfileFormat.rst:146
msgid ""
"Similar to `CountersDelta`_ field, this field may not be used in non-PGO "
"variants of profiles."
msgstr ""

#: ../../../InstrProfileFormat.rst:151
msgid "``NamesDelta``"
msgstr ""

#: ../../../InstrProfileFormat.rst:150
msgid ""
"Records the in-memory address of name section. Not used except for raw "
"profile reader error checking."
msgstr ""

#: ../../../InstrProfileFormat.rst:155
msgid "``NumVTables``"
msgstr ""

#: ../../../InstrProfileFormat.rst:154
msgid ""
"Records the number of instrumented vtable entries in the binary. Used for "
"`type profiling`_."
msgstr ""

#: ../../../InstrProfileFormat.rst:158
msgid "``VNamesSize``"
msgstr ""

#: ../../../InstrProfileFormat.rst:158
msgid ""
"Records the byte size in the virtual table names section. Used for `type "
"profiling`_."
msgstr ""

#: ../../../InstrProfileFormat.rst:162
msgid "``ValueKindLast``"
msgstr ""

#: ../../../InstrProfileFormat.rst:161
msgid ""
"Records the number of value kinds. Macro `VALUE_PROF_KIND`_ defines the "
"value kinds with a description of the kind."
msgstr ""

#: ../../../InstrProfileFormat.rst:167 ../../../InstrProfileFormat.rst:461
msgid "Payload Sections"
msgstr ""

#: ../../../InstrProfileFormat.rst:170 ../../../InstrProfileFormat.rst:490
msgid "Binary Ids"
msgstr ""

#: ../../../InstrProfileFormat.rst:171
msgid ""
"Stores the binary ids of the instrumented binaries to associate binaries "
"with profiles for source code coverage. See `binary id`_ RFC for the design."
msgstr ""

#: ../../../InstrProfileFormat.rst:177
msgid "Profile Metadata"
msgstr ""

#: ../../../InstrProfileFormat.rst:179
msgid ""
"This section stores the metadata to map counters and value profiles back to "
"instrumented code regions (e.g., LLVM IR for IRPGO)."
msgstr ""

#: ../../../InstrProfileFormat.rst:182
msgid ""
"The in-memory representation of the metadata is `__llvm_profile_data`_. Some "
"fields are used to reference data from other sections in the profile. The "
"fields are documented as follows:"
msgstr ""

#: ../../../InstrProfileFormat.rst:192
msgid "``NameRef``"
msgstr ""

#: ../../../InstrProfileFormat.rst:189
msgid ""
"The MD5 of the function's PGO name. PGO name has the format "
"``[<filepath><delimiter>]<mangled-name>`` where ``<filepath>`` and "
"``<delimiter>`` are provided for local-linkage functions to tell possibly "
"identical functions."
msgstr ""

#: ../../../InstrProfileFormat.rst:198
msgid "``FuncHash``"
msgstr ""

#: ../../../InstrProfileFormat.rst:197
msgid ""
"A checksum of the function's IR, taking control flow graph and instrumented "
"value sites into accounts. See `computeCFGHash`_ for details."
msgstr ""

#: ../../../InstrProfileFormat.rst:208
msgid "``CounterPtr``"
msgstr ""

#: ../../../InstrProfileFormat.rst:205
msgid ""
"The in-memory address difference between profile data and the start of "
"corresponding counters. Counter position is stored this way (as a link-time "
"constant) to reduce instrumented binary size compared with snapshotting the "
"address of symbols directly. See `commit a1532ed`_ for further information."
msgstr ""

#: ../../../InstrProfileFormat.rst:213
msgid ""
"``CounterPtr`` might represent a different value for non-IRPGO use case. For "
"example, for `binary profile correlation`_, it represents the absolute "
"address of counter. When in doubt, check source code."
msgstr ""

#: ../../../InstrProfileFormat.rst:224
msgid "``BitmapPtr``"
msgstr ""

#: ../../../InstrProfileFormat.rst:220
msgid ""
"The in-memory address difference between profile data and the start address "
"of corresponding bitmap."
msgstr ""

#: ../../../InstrProfileFormat.rst:224
msgid ""
"Similar to `CounterPtr`_, this field may represent a different value for non-"
"IRPGO use case."
msgstr ""

#: ../../../InstrProfileFormat.rst:229
msgid "``FunctionPointer``"
msgstr ""

#: ../../../InstrProfileFormat.rst:227
msgid ""
"Records the function address when instrumented binary runs. This is used to "
"map the profiled callee address of indirect calls to the ``NameRef`` during "
"conversion from raw to indexed profiles."
msgstr ""

#: ../../../InstrProfileFormat.rst:241
msgid "``Values``"
msgstr ""

#: ../../../InstrProfileFormat.rst:232
msgid ""
"Represents value profiles in a two dimensional array. The number of elements "
"in the first dimension is the number of instrumented value sites across all "
"kinds. Each element in the first dimension is the head of a linked list, and "
"the each element in the second dimension is linked list element, carrying "
"``<profiled-value, count>`` as payload. This is used by compiler runtime "
"when writing out value profiles."
msgstr ""

#: ../../../InstrProfileFormat.rst:240
msgid ""
"Value profiling is supported by frontend and IR PGO instrumentation, but "
"it's not supported in all cases (e.g., `lightweight instrumentation`_)."
msgstr ""

#: ../../../InstrProfileFormat.rst:244
msgid "``NumCounters``"
msgstr ""

#: ../../../InstrProfileFormat.rst:244
msgid "The number of counters for the instrumented function."
msgstr ""

#: ../../../InstrProfileFormat.rst:248
msgid "``NumValueSites``"
msgstr ""

#: ../../../InstrProfileFormat.rst:247
msgid ""
"This is an array of counters, and each counter represents the number of "
"instrumented sites for a kind of value in the function."
msgstr ""

#: ../../../InstrProfileFormat.rst:251
msgid "The number of bitmap bytes for the function."
msgstr ""

#: ../../../InstrProfileFormat.rst:256
msgid "Profile Counters"
msgstr ""

#: ../../../InstrProfileFormat.rst:258
msgid ""
"For PGO [4]_, the counters within an instrumented function of a specific "
"`FuncHash`_ are stored contiguously and in an order that is consistent with "
"instrumentation points selection."
msgstr ""

#: ../../../InstrProfileFormat.rst:263
msgid ""
"As mentioned above, the recorded counter offset is relative to the profile "
"metadata. So how are function counters located in the raw profile data?"
msgstr ""

#: ../../../InstrProfileFormat.rst:266
msgid ""
"Basically, the profile reader iterates profile metadata (from the `profile "
"metadata`_ section) and makes use of the recorded relative distances, as "
"illustrated below."
msgstr ""

#: ../../../InstrProfileFormat.rst:302
msgid "In the graph,"
msgstr ""

#: ../../../InstrProfileFormat.rst:304
msgid ""
"The profile header records ``CounterDelta`` with the value as "
"``start(__llvm_prf_cnts) - start(__llvm_prf_data)``. We will call it "
"``CounterDeltaInitVal`` below for convenience."
msgstr ""

#: ../../../InstrProfileFormat.rst:306
msgid ""
"For each profile data record ``ProfileDataN``, ``CounterPtr`` is recorded as "
"``start(CounterN) - start(ProfileDataN)``, where ``ProfileDataN`` is the N-"
"th entry in ``__llvm_prf_data``, and ``CounterN`` represents the "
"corresponding profile counters."
msgstr ""

#: ../../../InstrProfileFormat.rst:311
msgid ""
"Each time the reader advances to the next data record, it `updates`_ "
"``CounterDelta`` to minus the size of one ``ProfileData``."
msgstr ""

#: ../../../InstrProfileFormat.rst:316
msgid ""
"For the counter corresponding to the first data record, the byte offset "
"relative to the start of the counter section is calculated as ``CounterPtr1 "
"- CounterDeltaInitVal``. When profile reader advances to the second data "
"record, note ``CounterDelta`` is updated to ``CounterDeltaInitVal - "
"sizeof(ProfileData)``. Thus the byte offset relative to the start of the "
"counter section is calculated as ``CounterPtr2 - (CounterDeltaInitVal - "
"sizeof(ProfileData))``."
msgstr ""

#: ../../../InstrProfileFormat.rst:326
msgid "Bitmap"
msgstr ""

#: ../../../InstrProfileFormat.rst:327
msgid ""
"This section is used for source-based `Modified Condition/Decision "
"Coverage`_ code coverage. Check out `Bitmap RFC`_ for the design."
msgstr ""

#: ../../../InstrProfileFormat.rst:336
msgid "Names"
msgstr ""

#: ../../../InstrProfileFormat.rst:338
msgid ""
"This section contains possibly compressed concatenated string of functions' "
"PGO names. If compressed, zlib library is used."
msgstr ""

#: ../../../InstrProfileFormat.rst:341
msgid ""
"Function names serve as keys in the PGO data hash table when raw profiles "
"are converted into indexed profiles. They are also crucial for ``llvm-"
"profdata`` to show the profiles in a human-readable way."
msgstr ""

#: ../../../InstrProfileFormat.rst:346
msgid "Virtual Table Profile Data"
msgstr ""

#: ../../../InstrProfileFormat.rst:348
msgid ""
"This section is used for `type profiling`_. Each entry corresponds to one "
"virtual table and is defined by the following C++ struct"
msgstr ""

#: ../../../InstrProfileFormat.rst:362
msgid ""
"At profile use time, the compiler looks up a profiled address in the sorted "
"vtable address ranges and maps the address to a specific vtable through "
"hashed name."
msgstr ""

#: ../../../InstrProfileFormat.rst:366 ../../../InstrProfileFormat.rst:499
msgid "Virtual Table Names"
msgstr ""

#: ../../../InstrProfileFormat.rst:368
msgid ""
"This section is similar to `function names`_ section above, except it "
"contains the PGO names of profiled virtual tables. It's a standalone section "
"such that raw profile readers could directly find each name set by accessing "
"the corresponding profile data section."
msgstr ""

#: ../../../InstrProfileFormat.rst:373
msgid ""
"This section is stored in raw profiles such that `llvm-profdata` could show "
"the profiles in a human-readable way."
msgstr ""

#: ../../../InstrProfileFormat.rst:377
msgid "Value Profile Data"
msgstr ""

#: ../../../InstrProfileFormat.rst:379
msgid "This section contains the profile data for value profiling."
msgstr ""

#: ../../../InstrProfileFormat.rst:381
msgid ""
"The value profiles corresponding to a profile metadata are serialized "
"contiguously as one record, and value profile records are stored in the same "
"order as the respective profile data, such that a raw profile reader "
"`advances`_ the pointer to profile data and the pointer to value profile "
"records simultaneously [5]_ to find value profiles for a per function, per "
"`FuncHash`_ profile data."
msgstr ""

#: ../../../InstrProfileFormat.rst:390
msgid "Indexed Profile Format"
msgstr ""

#: ../../../InstrProfileFormat.rst:392
msgid ""
"Indexed profiles are generated from ``llvm-profdata``. In the indexed "
"profiles, function data are organized as on-disk hash table such that "
"compilers can look up profile data for functions in an IR module."
msgstr ""

#: ../../../InstrProfileFormat.rst:396
msgid ""
"Compilers and tools must retain backward compatibility with indexed "
"profiles. That is, a tool or a compiler built at newer versions of code must "
"understand profiles generated by older tools or compilers."
msgstr ""

#: ../../../InstrProfileFormat.rst:403
msgid ""
"The ASCII art depicts the general storage layout of indexed profiles. "
"Specifically, the indexed profile header describes the byte offset of "
"individual payload sections."
msgstr ""

#: ../../../InstrProfileFormat.rst:440
msgid ""
"Profile summary section is at the beginning of payload. It's right after the "
"header so its position is implicitly known after reading the header."
msgstr ""

#: ../../../InstrProfileFormat.rst:446
msgid ""
"The `Header struct`_ is the source of truth and struct fields should explain "
"what's in the header. At a high level, `*Offset` fields record section byte "
"offsets, which are used by readers to locate interesting sections and skip "
"uninteresting ones."
msgstr ""

#: ../../../InstrProfileFormat.rst:453
msgid ""
"To maintain backward compatibility of the indexed profiles, existing fields "
"shouldn't be deleted from struct definition; the field order shouldn't be "
"modified. New fields should be appended."
msgstr ""

#: ../../../InstrProfileFormat.rst:464
msgid "(CS) Profile Summary"
msgstr ""

#: ../../../InstrProfileFormat.rst:465
msgid ""
"This section is right after profile header. It stores the serialized profile "
"summary. For context-sensitive IR-based instrumentation PGO, this section "
"stores an additional profile summary corresponding to the context-sensitive "
"profiles."
msgstr ""

#: ../../../InstrProfileFormat.rst:472
msgid "Function data"
msgstr ""

#: ../../../InstrProfileFormat.rst:473
msgid ""
"This section stores functions and their profiling data as an on-disk hash "
"table. Profile data for functions with the same name are grouped together "
"and share one hash table entry (the functions may come from different shared "
"libraries for instance). The profile data for them are organized as a "
"sequence of key-value pair where the key is `FuncHash`_, and the value is "
"profiled information (represented by `InstrProfRecord`_) for the function."
msgstr ""

#: ../../../InstrProfileFormat.rst:483
msgid "MemProf Profile data"
msgstr ""

#: ../../../InstrProfileFormat.rst:484
msgid ""
"This section stores function's memory profiling data. See `MemProf binary "
"serialization format RFC`_ for the design."
msgstr ""

#: ../../../InstrProfileFormat.rst:491
msgid ""
"The section is used to carry on `binary id`_ information from raw profiles."
msgstr ""

#: ../../../InstrProfileFormat.rst:494
msgid "Temporal Profile Traces"
msgstr ""

#: ../../../InstrProfileFormat.rst:495
msgid ""
"The section is used to carry on temporal profile information from raw "
"profiles. See `temporal profiling`_ for the design."
msgstr ""

#: ../../../InstrProfileFormat.rst:500
msgid ""
"This section is used to store the names of vtables from raw profile in the "
"indexed profile."
msgstr ""

#: ../../../InstrProfileFormat.rst:503
msgid ""
"Unlike function names which are stored as keys of `function data`_ hash "
"table, vtable names need to be stored in a standalone section in indexed "
"profiles. This way, `llvm-profdata` could show the profiled vtable "
"information in a human-readable way."
msgstr ""

#: ../../../InstrProfileFormat.rst:509
msgid "Profile Data Usage"
msgstr ""

#: ../../../InstrProfileFormat.rst:511
msgid ""
"``llvm-profdata`` is the command line tool to display and process "
"instrumentation- based profile data. For supported usages, check out `llvm-"
"profdata documentation <https://llvm.org/docs/CommandGuide/llvm-profdata."
"html>`_."
msgstr ""

#: ../../../InstrProfileFormat.rst:514
msgid ""
"For usage, see https://clang.llvm.org/docs/UsersManual.html#profiling-with-"
"instrumentation"
msgstr ""

#: ../../../InstrProfileFormat.rst:515
msgid ""
"For example, IR-based instrumentation supports `lightweight "
"instrumentation`_ and `temporal profiling`_. Frontend instrumentation could "
"support `single-byte counters`_."
msgstr ""

#: ../../../InstrProfileFormat.rst:517
msgid ""
"A raw profile file could contain the concatenation of multiple raw profiles, "
"for example, from an executable and its shared libraries. Raw profile reader "
"could parse all raw profiles from the file correctly."
msgstr ""

#: ../../../InstrProfileFormat.rst:520
msgid ""
"The counter section is used by a few variant types (like temporal profiling) "
"and might have different semantics there."
msgstr ""

#: ../../../InstrProfileFormat.rst:522
msgid ""
"The step size of data pointer is the ``sizeof(ProfileData)``, and the step "
"size of value profile pointer is calculated based on the number of collected "
"values."
msgstr ""
